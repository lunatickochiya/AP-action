From a38a65bbe0b7212a3a1340cdbd83c797ed99a8ea Mon Sep 17 00:00:00 2001
From: Sean Khan <datapronix@protonmail.com>
Date: Fri, 7 Feb 2025 10:58:23 -0500
Subject: [PATCH 2/2] ath11k_nss: revert parts of NSS patches to align with
 upstream

These changes revert parts of QCom's NSS patches to bring it closer to upstream Linux.

* The structure of `hal_wbm_release_ring` is restored
* `changed` in ath11k_mac_op_nss_bss_info_changed() is set back to u64
* `ath11k_mac_op_update_vif_offload()` returns void as in mainline.
* Reverted `ath10k_update_vif_offload()` to return void.

Ideally the original patches would be updated to avoid introducing these changes in the first place
but since there are a number of patches in the series, they too will need to be updated.

Signed-off-by: Sean Khan <datapronix@protonmail.com>
---
 .../199-004-ath10k-fixup-nss-compile.patch    | 19 -----
 .../999-921-ath11k-Revert-headers.patch       | 71 +++++++++++++++++++
 .../999-921-mac80211-Revert-headers.patch     | 31 ++++++++
 3 files changed, 102 insertions(+), 19 deletions(-)
 delete mode 100644 package/kernel/mac80211/patches/nss/ath10k/199-004-ath10k-fixup-nss-compile.patch
 create mode 100644 package/kernel/mac80211/patches/nss/ath11k/999-921-ath11k-Revert-headers.patch
 create mode 100644 package/kernel/mac80211/patches/nss/subsys/999-921-mac80211-Revert-headers.patch

diff --git a/package/kernel/mac80211/patches/nss/ath10k/199-004-ath10k-fixup-nss-compile.patch b/package/kernel/mac80211/patches/nss/ath10k/199-004-ath10k-fixup-nss-compile.patch
deleted file mode 100644
index 5e8c5f08ad..0000000000
--- a/package/kernel/mac80211/patches/nss/ath10k/199-004-ath10k-fixup-nss-compile.patch
+++ /dev/null
@@ -1,19 +0,0 @@
---- a/drivers/net/wireless/ath/ath10k/mac.c
-+++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -5527,7 +5527,7 @@ static int ath10k_mac_set_txbf_conf(stru
- 					 ar->wmi.vdev_param->txbf, value);
- }
- 
--static void ath10k_update_vif_offload(struct ieee80211_hw *hw,
-+static int ath10k_update_vif_offload(struct ieee80211_hw *hw,
- 				      struct ieee80211_vif *vif)
- {
- 	struct ath10k_vif *arvif = (void *)vif->drv_priv;
-@@ -5549,6 +5549,7 @@ static void ath10k_update_vif_offload(st
- 		ath10k_warn(ar, "failed to set vdev %i TX encapsulation: %d\n",
- 			    arvif->vdev_id, ret);
- 	}
-+	return ret;
- }
- 
- /*
diff --git a/package/kernel/mac80211/patches/nss/ath11k/999-921-ath11k-Revert-headers.patch b/package/kernel/mac80211/patches/nss/ath11k/999-921-ath11k-Revert-headers.patch
new file mode 100644
index 0000000000..857a55f203
--- /dev/null
+++ b/package/kernel/mac80211/patches/nss/ath11k/999-921-ath11k-Revert-headers.patch
@@ -0,0 +1,71 @@
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -851,7 +851,7 @@ void ath11k_dp_tx_completion_handler(str
+ 	struct dp_tx_ring *tx_ring = &dp->tx_ring[ring_id];
+ 	int valid_entries;
+ 	enum hal_wbm_rel_src_module buf_rel_source;
+-	u32 *desc;
++	struct hal_wbm_release_ring *desc;
+ 	u32 msdu_id, desc_id;
+ 	u8 mac_id;
+ 	struct hal_wbm_release_ring *tx_status;
+@@ -869,8 +869,9 @@ void ath11k_dp_tx_completion_handler(str
+ 
+ 	ath11k_hal_srng_dst_invalidate_entry(ab, status_ring, valid_entries);
+ 
+-	while ((desc = ath11k_hal_srng_dst_get_next_cache_entry(ab, status_ring))) {
+-		if (!ath11k_dp_tx_completion_valid((struct hal_wbm_release_ring *)desc))
++	while ((desc = (struct hal_wbm_release_ring *)
++				ath11k_hal_srng_dst_get_next_cache_entry(ab, status_ring))) {
++		if (!ath11k_dp_tx_completion_valid(desc))
+ 			continue;
+ 
+ 		memcpy(&tx_ring->tx_status[count],
+--- a/drivers/net/wireless/ath/ath11k/mac.c
++++ b/drivers/net/wireless/ath/ath11k/mac.c
+@@ -3546,7 +3546,7 @@ static bool ath11k_mac_supports_station_
+ 
+ static void ath11k_mac_op_nss_bss_info_changed(struct ieee80211_hw *hw,
+ 					   struct ieee80211_vif *vif,
+-					   u32 changed)
++					   u64 changed)
+ {
+ 	struct ath11k *ar = hw->priv;
+ 	struct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);
+@@ -6842,7 +6842,7 @@ static int ath11k_mac_setup_vdev_create_
+ 	return 0;
+ }
+ 
+-static int ath11k_mac_op_update_vif_offload(struct ieee80211_hw *hw,
++static void ath11k_mac_op_update_vif_offload(struct ieee80211_hw *hw,
+ 					     struct ieee80211_vif *vif)
+ {
+ 	struct ath11k *ar = hw->priv;
+@@ -6852,7 +6852,7 @@ static int ath11k_mac_op_update_vif_offl
+ 	int ret;
+ 
+ 	if (ab->nss.enabled && vif->type == NL80211_IFTYPE_AP_VLAN)
+-		return 0;
++		return;
+ 
+ 	param_id = WMI_VDEV_PARAM_TX_ENCAP_TYPE;
+ 	if (ath11k_frame_mode != ATH11K_HW_TXRX_ETHERNET ||
+@@ -6891,8 +6891,6 @@ static int ath11k_mac_op_update_vif_offl
+ 			    arvif->vdev_id, ret);
+ 		vif->offload_flags &= ~IEEE80211_OFFLOAD_DECAP_ENABLED;
+ 	}
+-
+-	return ret;
+ }
+ 
+ static bool ath11k_mac_vif_ap_active_any(struct ath11k_base *ab)
+@@ -7223,8 +7221,7 @@ static int ath11k_mac_op_add_interface(s
+ 		goto err_vdev_del;
+ 	}
+ 
+-	if (ath11k_mac_op_update_vif_offload(hw, vif))
+-		goto err_vdev_del;
++	ath11k_mac_op_update_vif_offload(hw, vif);
+ 
+ 	if (vif->offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
+ 		param_value = ATH11K_HW_TXRX_ETHERNET;
diff --git a/package/kernel/mac80211/patches/nss/subsys/999-921-mac80211-Revert-headers.patch b/package/kernel/mac80211/patches/nss/subsys/999-921-mac80211-Revert-headers.patch
new file mode 100644
index 0000000000..8c838f7511
--- /dev/null
+++ b/package/kernel/mac80211/patches/nss/subsys/999-921-mac80211-Revert-headers.patch
@@ -0,0 +1,31 @@
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -4549,7 +4549,7 @@ struct ieee80211_ops {
+ 				  u64 changed);
+ 	void (*nss_bss_info_changed)(struct ieee80211_hw *hw,
+ 				     struct ieee80211_vif *vif,
+-				     u32 changed);
++				     u64 changed);
+ 	int (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+ 			struct ieee80211_bss_conf *link_conf);
+ 	void (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+@@ -4859,7 +4859,7 @@ struct ieee80211_ops {
+ 	int (*reset_tid_config)(struct ieee80211_hw *hw,
+ 				struct ieee80211_vif *vif,
+ 				struct ieee80211_sta *sta, u8 tids);
+-	int (*update_vif_offload)(struct ieee80211_hw *hw,
++	void (*update_vif_offload)(struct ieee80211_hw *hw,
+ 				   struct ieee80211_vif *vif);
+ 	void (*sta_set_4addr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+ 			      struct ieee80211_sta *sta, bool enabled);
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -2767,7 +2767,7 @@ static int ieee80211_change_bss(struct w
+ 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+ 	struct ieee80211_link_data *link;
+ 	struct ieee80211_supported_band *sband;
+-	u32 changed = 0, nss_changed = 0;
++	u64 changed = 0, nss_changed = 0;
+ 
+ 	link = ieee80211_link_or_deflink(sdata, params->link_id, true);
+ 	if (IS_ERR(link))
-- 
2.34.1

