From 580129ff6597b6232a0551629ca28bceebebbd04 Mon Sep 17 00:00:00 2001
From: sfiction <sfiction.r@gmail.com>
Date: Wed, 5 Feb 2025 23:11:05 +0800
Subject: [PATCH] feature: support fallback dns server. feat(dns_rules): place
 data in pointer feat(dns_rules): memory pool feat(dns_rules): treat
 dns_rule_flags as member feat(dns_rules): reduce memory usage of domain rule
 feat(dns_rules): separate `dns_domain_rule`
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

add test for domain rules
feat: move constants to a new header
chore(dns_conf): Remove unused code

1. Remove trailing whitespaces
2. Add list member mark
3. Modify log message
perf(libart): dynamically switch search mode
perf(libart): speed up full partial compare

1. Callers of prefix_mismatch() dont care result larger than
   n->partial_len.
2. Finding any child from art_node48 should be faster than finding the
   minimum.
perf(libart): art_substring_walk avoid dup call

Avoid checking again when the leaf matches.

Stop traversing when current inner node is also a leaf and isn't a
prefix of given string.
feat: 新增 strlcpy
feat: 优化 Makefile
chore: 完善 init.d
perf(libart): modify struct layout

1. Reorder art_node fields to reudce struct size.
2. Make use of 4 bytes padding size in the tail of `art_leaf`.

layout
fix(libart): fix art_iter_prefix enter deeper

In the old version of `art_iter_prefix`, if the `partial` matches the first
character, `partial_len` will always be added to `depth`, even when `partial`
is not fully matched.

See also https://github.com/armon/libart/issues/40.
chore(libart): add extern C & remove i386 support

1. remove trailing whitespace
feature: support fallback dns server.
---
 .gitignore                      |   1 +
 etc/init.d/smartdns             |   9 +-
 etc/smartdns/smartdns.conf      |   1 +
 src/Makefile                    |  12 +-
 src/common.h                    |  84 ++++++
 src/dns.h                       |  17 +-
 src/dns_client.c                |  14 +
 src/dns_client.h                |   1 +
 src/dns_conf.c                  | 268 +++++--------------
 src/dns_conf.h                  | 213 +--------------
 src/dns_rules.c                 | 448 ++++++++++++++++++++++++++++++++
 src/dns_rules.h                 | 205 +++++++++++++++
 src/dns_server.c                |  83 +++---
 src/include/art.h               |  16 +-
 src/include/stringutil.h        |   8 +-
 src/lib/art.c                   | 225 +++++++---------
 src/smartdns.c                  |   1 +
 src/stringutil.c                |  53 ++++
 src/tlog.c                      |  23 +-
 src/util.h                      |   1 +
 test/cases/test-domain-rules.cc |  61 +++++
 test/cases/test-server.cc       |  60 ++++-
 22 files changed, 1173 insertions(+), 631 deletions(-)
 create mode 100644 src/common.h
 create mode 100644 src/dns_rules.c
 create mode 100644 src/dns_rules.h
 create mode 100644 src/stringutil.c
 create mode 100644 test/cases/test-domain-rules.cc

diff --git a/.gitignore b/.gitignore
index 1126d70..fd742fe 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,6 @@
 .vscode
 *.o
+*.d
 *.a
 *.pem
 .DS_Store
diff --git a/etc/init.d/smartdns b/etc/init.d/smartdns
index 67cda8f..420d6ae 100644
--- a/etc/init.d/smartdns
+++ b/etc/init.d/smartdns
@@ -17,8 +17,8 @@
 
 ### BEGIN INIT INFO
 # Provides:        smartdns
-# Required-Start:  $network 
-# Required-Stop:   $network 
+# Required-Start:  $network
+# Required-Stop:   $network
 # Default-Start:   2 3 4 5
 # Default-Stop:
 # Short-Description: Start smartdns server
@@ -37,7 +37,7 @@ test -x $SMARTDNS || exit 5
 
 case $1 in
 	start)
-		$SMARTDNS "$SMART_DNS_OPTS" -R
+		LD_LIBRARY_PATH=/usr/local/gcc-14.2.0/lib64:$LD_LIBRARY_PATH $SMARTDNS "$SMART_DNS_OPTS" -R
 		while true; do
 			if [ -e "$PIDFILE" ]; then
 				break;
@@ -74,11 +74,12 @@ case $1 in
 		LOOP=1
 		while true; do
 			if [ ! -d "/proc/$PID" ]; then
+				rm "$PIDFILE"
 				break;
 			fi
 
 			if [ $LOOP -gt 12 ]; then
-				kill -9 "$PID"
+				kill -9 "$PID" && rm "$PIDFILE"
 				break;
 			fi
 			LOOP=$((LOOP+1))
diff --git a/etc/smartdns/smartdns.conf b/etc/smartdns/smartdns.conf
index 3c3d2b4..25d5b0f 100644
--- a/etc/smartdns/smartdns.conf
+++ b/etc/smartdns/smartdns.conf
@@ -219,6 +219,7 @@ log-level info
 #   -subnet [ip/subnet]: set edns client subnet.
 #   -host-ip [ip]: set dns server host ip.
 #   -interface [interface]: set dns server interface.
+#   -fallback: set as fallback dns server.
 # server 8.8.8.8 -blacklist-ip -check-edns -group g1 -group g2
 # server tls://dns.google:853 
 # server https://dns.google/dns-query
diff --git a/src/Makefile b/src/Makefile
index 95fd546..01f2b57 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -14,9 +14,10 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-BIN=smartdns 
+BIN=smartdns
 OBJS_LIB=$(patsubst %.c,%.o,$(wildcard lib/*.c))
 OBJS_MAIN=$(patsubst %.c,%.o,$(wildcard *.c))
+OBJS_HEADER=$(patsubst %.c,%.d,$(wildcard *.c))
 OBJS=$(OBJS_MAIN) $(OBJS_LIB)
 
 # cflags
@@ -26,6 +27,8 @@ ifndef CFLAGS
  else
   CFLAGS = -O2
  endif
+ CFLAGS += -Werror
+ CFLAGS += -MMD
  CFLAGS +=-Wall -Wstrict-prototypes -fno-omit-frame-pointer -Wstrict-aliasing -funwind-tables -Wmissing-prototypes -Wshadow -Wextra -Wno-unused-parameter -Wno-implicit-fallthrough
 endif
 
@@ -57,7 +60,7 @@ ifdef COMMIT_VERION
  override CFLAGS += -DCOMMIT_VERION='"$(shell git describe --tags --always --dirty)"'
 endif
 
-CXXFLAGS=-O2 -g -Wall -std=c++11 
+CXXFLAGS=-O2 -g -Wall -std=c++11
 override CXXFLAGS +=-Iinclude
 
 ifeq ($(STATIC), yes)
@@ -67,6 +70,8 @@ else
  override LDFLAGS += -lssl -lcrypto -lpthread -ldl -lm -rdynamic
 endif
 
+-include $(OBJS_HEADER)
+
 .PHONY: all clean
 
 all: $(BIN)
@@ -74,6 +79,9 @@ all: $(BIN)
 $(BIN) : $(OBJS)
 	$(CC) $(OBJS) -o $@ $(LDFLAGS)
 
+%.o: %.c
+	$(CC) $(CFLAGS) -MMD -MP -c $< -o $@
+
 clang-tidy:
 	clang-tidy -p=. $(OBJS_MAIN:.o=.c) -- $(CFLAGS)
 
diff --git a/src/common.h b/src/common.h
new file mode 100644
index 0000000..94817a3
--- /dev/null
+++ b/src/common.h
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ * Copyright (C) 2018-2024 Ruilin Peng (Nick) <pymumu@gmail.com>.
+ *
+ * smartdns is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * smartdns is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _SMARTDNS_COMMON_H
+#define _SMARTDNS_COMMON_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// from dns
+#define DNS_RR_A_LEN 4
+#define DNS_RR_AAAA_LEN 16
+#define DNS_MAX_CNAME_LEN 256
+#define DNS_MAX_OPT_LEN 256
+#define DNS_IN_PACKSIZE (512 * 8)
+#define DNS_PACKSIZE (512 * 16)
+#define DNS_DEFAULT_PACKET_SIZE 512
+#define DNS_MAX_ALPN_LEN 32
+#define DNS_MAX_ECH_LEN 512
+
+#define DNS_OPT_FLAG_DO 0x8000
+
+#define DNS_ADDR_FAMILY_IP 1
+#define DNS_ADDR_FAMILY_IPV6 2
+
+// from dns_conf
+#define DNS_MAX_BIND_IP 32
+#define DNS_MAX_SERVERS 64
+#define DNS_MAX_SERVER_NAME_LEN 128
+#define DNS_MAX_PTR_LEN 128
+#define DNS_MAX_IPSET_NAMELEN 32
+#define DNS_MAX_NFTSET_FAMILYLEN 8
+#define DNS_MAX_NFTSET_NAMELEN 256
+#define DNS_GROUP_NAME_LEN 32
+
+#define PROXY_NAME_LEN 32
+#define PROXY_MAX_SERVERS 128
+
+#define DNS_NAX_GROUP_NUMBER 16
+#define DNS_MAX_IPLEN 64
+#define DNS_PROXY_MAX_LEN 128
+#define DNS_CONF_USERNAME_LEN 32
+#define DNS_MAX_SPKI_LEN 64
+#define DNS_MAX_URL_LEN 256
+#define DNS_MAX_PATH 1024
+#define DEFAULT_DNS_PORT 53
+#define DEFAULT_DNS_TLS_PORT 853
+#define DEFAULT_DNS_HTTPS_PORT 443
+#define DNS_MAX_CONF_CNAME_LEN 256
+#define MAX_QTYPE_NUM 65535
+#define DNS_MAX_REPLY_IP_NUM 8
+#define DNS_MAX_QUERY_LIMIT 65535
+#define DNS_DEFAULT_CHECKPOINT_TIME (3600 * 24)
+#define DNS_MAX_SERVE_EXPIRED_TIME (3600 * 24 * 365)
+#define MAX_INTERFACE_LEN 16
+
+#define SMARTDNS_CONF_FILE "/etc/smartdns/smartdns.conf"
+#define SMARTDNS_LOG_FILE "/var/log/smartdns/smartdns.log"
+#define SMARTDNS_AUDIT_FILE "/var/log/smartdns/smartdns-audit.log"
+#define SMARTDNS_CACHE_FILE "/var/cache/smartdns/smartdns.cache"
+#define SMARTDNS_TMP_CACHE_FILE "/tmp/smartdns.cache"
+#define SMARTDNS_DEBUG_DIR "/tmp/smartdns"
+#define DNS_RESOLV_FILE "/etc/resolv.conf"
+
+#ifdef __cplusplus
+}
+#endif
+#endif // !_SMART_DNS_COMMON_H
\ No newline at end of file
diff --git a/src/dns.h b/src/dns.h
index 30bd240..b345e31 100644
--- a/src/dns.h
+++ b/src/dns.h
@@ -19,25 +19,12 @@
 #ifndef _DNS_HEAD_H
 #define _DNS_HEAD_H
 
+#include "common.h"
+
 #ifdef __cplusplus
 extern "C" {
 #endif /*__cplusplus */
 
-#define DNS_RR_A_LEN 4
-#define DNS_RR_AAAA_LEN 16
-#define DNS_MAX_CNAME_LEN 256
-#define DNS_MAX_OPT_LEN 256
-#define DNS_IN_PACKSIZE (512 * 8)
-#define DNS_PACKSIZE (512 * 16)
-#define DNS_DEFAULT_PACKET_SIZE 512
-#define DNS_MAX_ALPN_LEN 32
-#define DNS_MAX_ECH_LEN 512
-
-#define DNS_OPT_FLAG_DO 0x8000
-
-#define DNS_ADDR_FAMILY_IP 1
-#define DNS_ADDR_FAMILY_IPV6 2
-
 /*
 DNS parameters:
 https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml
diff --git a/src/dns_client.c b/src/dns_client.c
index f8a2fa4..80f81d2 100644
--- a/src/dns_client.c
+++ b/src/dns_client.c
@@ -3861,10 +3861,24 @@ static int _dns_client_send_packet(struct dns_query_struct *query, void *packet,
 			prohibit_time = 5;
 		}
 
+		/* fallback group exists, use fallback group */
+		if (atomic_read(&query->retry_count) == 1) {
+			struct dns_server_group *fallback_server_group = _dns_client_get_group("fallback");
+			if (fallback_server_group != NULL) {
+				query->server_group = fallback_server_group;
+			}
+		}
+
 		pthread_mutex_lock(&client.server_list_lock);
 		list_for_each_entry_safe(group_member, tmp, &query->server_group->head, list)
 		{
 			server_info = group_member->server;
+
+			/* skip fallback server for first query */
+			if (server_info->flags.fallback && atomic_read(&query->retry_count) == DNS_QUERY_RETRY && i == 0) {
+				continue;
+			}
+
 			if (server_info->prohibit) {
 				if (server_info->is_already_prohibit == 0) {
 					server_info->is_already_prohibit = 1;
diff --git a/src/dns_client.h b/src/dns_client.h
index 383c335..730240d 100644
--- a/src/dns_client.h
+++ b/src/dns_client.h
@@ -143,6 +143,7 @@ struct client_dns_server_flags {
 	long long set_mark;
 	int tcp_keepalive;
 	int drop_packet_latency_ms;
+	int fallback;
 
 	char proxyname[DNS_MAX_CNAME_LEN];
 	char ifname[DNS_SERVER_IFNAME_LEN];
diff --git a/src/dns_conf.c b/src/dns_conf.c
index 74fd770..c20ab0b 100644
--- a/src/dns_conf.c
+++ b/src/dns_conf.c
@@ -181,7 +181,6 @@ static int _conf_ptr_add(const char *hostname, const char *ip, int is_dynamic);
 static int _conf_client_subnet(char *subnet, struct dns_edns_client_subnet *ipv4_ecs,
 							   struct dns_edns_client_subnet *ipv6_ecs);
 static int _conf_domain_rule_address(char *domain, const char *domain_address);
-static struct dns_domain_rule *_config_domain_rule_get(const char *domain);
 typedef int (*set_rule_add_func)(const char *value, void *priv);
 static int _config_ip_rule_set_each(const char *ip_set, set_rule_add_func callback, void *priv);
 static struct dns_conf_group *_config_rule_group_get(const char *group_name);
@@ -285,87 +284,6 @@ static __attribute__((unused)) int _dns_conf_group_enum(int value, int *data)
 	return 0;
 }
 
-static void *_new_dns_rule_ext(enum domain_rule domain_rule, int ext_size)
-{
-	struct dns_rule *rule;
-	int size = 0;
-
-	if (domain_rule >= DOMAIN_RULE_MAX) {
-		return NULL;
-	}
-
-	switch (domain_rule) {
-	case DOMAIN_RULE_FLAGS:
-		size = sizeof(struct dns_rule_flags);
-		break;
-	case DOMAIN_RULE_ADDRESS_IPV4:
-		size = sizeof(struct dns_rule_address_IPV4);
-		break;
-	case DOMAIN_RULE_ADDRESS_IPV6:
-		size = sizeof(struct dns_rule_address_IPV6);
-		break;
-	case DOMAIN_RULE_IPSET:
-	case DOMAIN_RULE_IPSET_IPV4:
-	case DOMAIN_RULE_IPSET_IPV6:
-		size = sizeof(struct dns_ipset_rule);
-		break;
-	case DOMAIN_RULE_NFTSET_IP:
-	case DOMAIN_RULE_NFTSET_IP6:
-		size = sizeof(struct dns_nftset_rule);
-		break;
-	case DOMAIN_RULE_NAMESERVER:
-		size = sizeof(struct dns_nameserver_rule);
-		break;
-	case DOMAIN_RULE_GROUP:
-		size = sizeof(struct dns_group_rule);
-		break;
-	case DOMAIN_RULE_CHECKSPEED:
-		size = sizeof(struct dns_domain_check_orders);
-		break;
-	case DOMAIN_RULE_RESPONSE_MODE:
-		size = sizeof(struct dns_response_mode_rule);
-		break;
-	case DOMAIN_RULE_CNAME:
-		size = sizeof(struct dns_cname_rule);
-		break;
-	case DOMAIN_RULE_HTTPS:
-		size = sizeof(struct dns_https_record_rule);
-		break;
-	case DOMAIN_RULE_TTL:
-		size = sizeof(struct dns_ttl_rule);
-		break;
-	default:
-		return NULL;
-	}
-
-	size += ext_size;
-	rule = malloc(size);
-	if (!rule) {
-		return NULL;
-	}
-	memset(rule, 0, size);
-	rule->rule = domain_rule;
-	atomic_set(&rule->refcnt, 1);
-	return rule;
-}
-
-static void *_new_dns_rule(enum domain_rule domain_rule)
-{
-	return _new_dns_rule_ext(domain_rule, 0);
-}
-
-static void _dns_rule_get(struct dns_rule *rule)
-{
-	atomic_inc(&rule->refcnt);
-}
-
-static void _dns_rule_put(struct dns_rule *rule)
-{
-	if (atomic_dec_and_test(&rule->refcnt)) {
-		free(rule);
-	}
-}
-
 static void _dns_iplist_ip_address_add(struct dns_iplist_ip_addresses *iplist, unsigned char addr[], int addr_len)
 {
 	iplist->ipaddr = realloc(iplist->ipaddr, (iplist->ipaddr_num + 1) * sizeof(struct dns_iplist_ip_address));
@@ -523,22 +441,6 @@ static void _config_group_table_destroy(void)
 	}
 }
 
-struct dns_proxy_names *dns_server_get_proxy_nams(const char *proxyname)
-{
-	uint32_t key = 0;
-	struct dns_proxy_names *proxy = NULL;
-
-	key = hash_string(proxyname);
-	hash_for_each_possible(dns_proxy_table.proxy, proxy, node, key)
-	{
-		if (strncmp(proxy->proxy_name, proxyname, DNS_GROUP_NAME_LEN) == 0) {
-			return proxy;
-		}
-	}
-
-	return NULL;
-}
-
 static struct dns_conf_group *_config_current_rule_group(void)
 {
 	if (dns_conf_current_group_info == NULL) {
@@ -930,7 +832,7 @@ static int _config_server(int argc, char *argv[], dns_server_type_t type, int de
 #ifdef FEATURE_CHECK_EDNS
 		/* experimental feature */
 		{"check-edns", no_argument, NULL, 251},   /* check edns */
-#endif 
+#endif
 		{"whitelist-ip", no_argument, NULL, 252}, /* filtering with whitelist-ip */
 		{"blacklist-ip", no_argument, NULL, 253}, /* filtering with blacklist-ip */
 		{"set-mark", required_argument, NULL, 254}, /* set mark */
@@ -943,6 +845,7 @@ static int _config_server(int argc, char *argv[], dns_server_type_t type, int de
 		{"tls-host-verify", required_argument, NULL, 262 }, /* verify tls hostname */
 		{"tcp-keepalive", required_argument, NULL, 263}, /* tcp keepalive */
 		{"subnet-all-query-types", no_argument, NULL, 264}, /* send subnent for all query types.*/
+		{"fallback", no_argument, NULL, 265}, /* fallback */
 		{NULL, no_argument, NULL, 0}
 	};
 	/* clang-format on */
@@ -1114,6 +1017,10 @@ static int _config_server(int argc, char *argv[], dns_server_type_t type, int de
 			server->subnet_all_query_types = 1;
 			break;
 		}
+		case 265: {
+			server->fallback = 1;
+			break;
+		}
 		default:
 			if (optind > optind_last) {
 				tlog(TLOG_WARN, "unknown server option: %s at '%s:%d'.", argv[optind - 1], conf_get_conf_file(),
@@ -1213,31 +1120,10 @@ static int _config_update_bootstrap_dns_rule(void)
 	return 0;
 }
 
-static int _config_domain_rule_free(struct dns_domain_rule *domain_rule)
-{
-	int i = 0;
-
-	if (domain_rule == NULL) {
-		return 0;
-	}
-
-	for (i = 0; i < DOMAIN_RULE_MAX; i++) {
-		if (domain_rule->rules[i] == NULL) {
-			continue;
-		}
-
-		_dns_rule_put(domain_rule->rules[i]);
-		domain_rule->rules[i] = NULL;
-	}
-
-	free(domain_rule);
-	return 0;
-}
-
 static int _config_domain_iter_free(void *data, const unsigned char *key, uint32_t key_len, void *value)
 {
 	struct dns_domain_rule *domain_rule = value;
-	return _config_domain_rule_free(domain_rule);
+	return domain_rule_free(domain_rule);
 }
 
 static struct dns_conf_group *_config_rule_group_get(const char *group_name)
@@ -1323,6 +1209,7 @@ static void _config_rule_group_remove(struct dns_conf_group *rule_group)
 
 static void _config_rule_group_destroy(void)
 {
+	return;
 	struct dns_conf_group *group;
 	struct hlist_node *tmp = NULL;
 	unsigned long i = 0;
@@ -1482,23 +1369,11 @@ static int _config_setup_domain_key(const char *domain, char *domain_key, int do
 	return 0;
 }
 
-static __attribute__((unused)) struct dns_domain_rule *_config_domain_rule_get(const char *domain)
-{
-	char domain_key[DNS_MAX_CONF_CNAME_LEN];
-	int len = 0;
-
-	if (_config_setup_domain_key(domain, domain_key, sizeof(domain_key), &len, NULL, NULL) != 0) {
-		return NULL;
-	}
-
-	return art_search(&_config_current_rule_group()->domain_rule.tree, (unsigned char *)domain_key, len);
-}
-
 static int _config_domain_rule_add(const char *domain, enum domain_rule type, void *rule)
 {
 	struct dns_domain_rule *domain_rule = NULL;
-	struct dns_domain_rule *old_domain_rule = NULL;
-	struct dns_domain_rule *add_domain_rule = NULL;
+	struct dns_domain_rule add_domain_rule;
+	int need_insert = 0;
 
 	char domain_key[DNS_MAX_CONF_CNAME_LEN];
 	int len = 0;
@@ -1523,43 +1398,35 @@ static int _config_domain_rule_add(const char *domain, enum domain_rule type, vo
 	}
 
 	/* Get existing or create domain rule */
-	domain_rule = art_search(&_config_current_rule_group()->domain_rule.tree, (unsigned char *)domain_key, len);
+	domain_rule = (struct dns_domain_rule *)art_search(&_config_current_rule_group()->domain_rule.tree,
+													   (unsigned char *)domain_key, len);
 	if (domain_rule == NULL) {
-		add_domain_rule = malloc(sizeof(*add_domain_rule));
-		if (add_domain_rule == NULL) {
-			goto errout;
-		}
-		memset(add_domain_rule, 0, sizeof(*add_domain_rule));
-		domain_rule = add_domain_rule;
+		domain_rule_init(&add_domain_rule);
+		domain_rule = &add_domain_rule;
+		need_insert = 1;
 	}
 
-	/* add new rule to domain */
-	if (domain_rule->rules[type]) {
-		_dns_rule_put(domain_rule->rules[type]);
-		domain_rule->rules[type] = NULL;
+	if (domain_rule_set_data(domain_rule, sub_rule_only, root_rule_only)) {
+		goto errout;
 	}
 
-	domain_rule->rules[type] = rule;
-	domain_rule->sub_rule_only = sub_rule_only;
-	domain_rule->root_rule_only = root_rule_only;
-	_dns_rule_get(rule);
+	/* add new rule to domain */
+	if (domain_rule_set(domain_rule, type, rule)) {
+		goto errout;
+	}
 
 	/* update domain rule */
-	if (add_domain_rule) {
-		old_domain_rule = art_insert(&_config_current_rule_group()->domain_rule.tree, (unsigned char *)domain_key, len,
-									 add_domain_rule);
-		if (old_domain_rule) {
-			_config_domain_rule_free(old_domain_rule);
-		}
+	if (need_insert) {
+		art_insert(&_config_current_rule_group()->domain_rule.tree, (unsigned char *)domain_key, len, domain_rule->ptr);
 	}
 
 	return 0;
 errout:
-	if (add_domain_rule) {
-		free(add_domain_rule);
+	if (need_insert) {
+		domain_rule_free(domain_rule);
 	}
 
-	tlog(TLOG_ERROR, "add domain %s rule failed", domain);
+	tlog(TLOG_ERROR, "add domain %s rule %d failed", domain, type);
 	return -1;
 }
 
@@ -1587,7 +1454,7 @@ static int _config_domain_rule_delete(const char *domain)
 	/* delete existing rules */
 	void *rule = art_delete(&_config_current_rule_group()->domain_rule.tree, (unsigned char *)domain_key, len);
 	if (rule) {
-		_config_domain_rule_free(rule);
+		domain_rule_free((void *)&rule);
 	}
 
 	return 0;
@@ -1596,19 +1463,18 @@ errout:
 	return -1;
 }
 
-static int _config_domain_rule_flag_set(const char *domain, unsigned int flag, unsigned int is_clear);
+static int _config_domain_rule_flag_set(const char *domain, unsigned int flag, unsigned int);
 static int _config_domain_rule_flag_callback(const char *domain, void *priv)
 {
 	struct dns_set_rule_flags_callback_args *args = (struct dns_set_rule_flags_callback_args *)priv;
 	return _config_domain_rule_flag_set(domain, args->flags, args->is_clear_flag);
 }
 
-static int _config_domain_rule_flag_set(const char *domain, unsigned int flag, unsigned int is_clear)
+static int _config_domain_rule_flag_set(const char *domain, unsigned int flag, unsigned int)
 {
 	struct dns_domain_rule *domain_rule = NULL;
-	struct dns_domain_rule *old_domain_rule = NULL;
-	struct dns_domain_rule *add_domain_rule = NULL;
-	struct dns_rule_flags *rule_flags = NULL;
+	struct dns_domain_rule add_domain_rule;
+	int need_insert = 0;
 
 	char domain_key[DNS_MAX_CONF_CNAME_LEN];
 	int len = 0;
@@ -1618,7 +1484,6 @@ static int _config_domain_rule_flag_set(const char *domain, unsigned int flag, u
 	if (strncmp(domain, "domain-set:", sizeof("domain-set:") - 1) == 0) {
 		struct dns_set_rule_flags_callback_args args;
 		args.flags = flag;
-		args.is_clear_flag = is_clear;
 		return _config_domain_rule_set_each(domain + sizeof("domain-set:") - 1, _config_domain_rule_flag_callback,
 											&args);
 	}
@@ -1628,50 +1493,35 @@ static int _config_domain_rule_flag_set(const char *domain, unsigned int flag, u
 	}
 
 	/* Get existing or create domain rule */
-	domain_rule = art_search(&_config_current_rule_group()->domain_rule.tree, (unsigned char *)domain_key, len);
+	domain_rule = (struct dns_domain_rule *)art_search(&_config_current_rule_group()->domain_rule.tree,
+													   (unsigned char *)domain_key, len);
 	if (domain_rule == NULL) {
-		add_domain_rule = malloc(sizeof(*add_domain_rule));
-		if (add_domain_rule == NULL) {
-			goto errout;
-		}
-		memset(add_domain_rule, 0, sizeof(*add_domain_rule));
-		domain_rule = add_domain_rule;
+		domain_rule_init(&add_domain_rule);
+		domain_rule = &add_domain_rule;
+		need_insert = 1;
 	}
 
-	/* add new rule to domain */
-	if (domain_rule->rules[DOMAIN_RULE_FLAGS] == NULL) {
-		rule_flags = _new_dns_rule(DOMAIN_RULE_FLAGS);
-		rule_flags->flags = 0;
-		domain_rule->rules[DOMAIN_RULE_FLAGS] = (struct dns_rule *)rule_flags;
+	if (domain_rule_set_data(domain_rule, sub_rule_only, root_rule_only)) {
+		goto errout;
 	}
 
-	domain_rule->sub_rule_only = sub_rule_only;
-	domain_rule->root_rule_only = root_rule_only;
-
-	rule_flags = (struct dns_rule_flags *)domain_rule->rules[DOMAIN_RULE_FLAGS];
-	if (is_clear == false) {
-		rule_flags->flags |= flag;
-	} else {
-		rule_flags->flags &= ~flag;
+	/* add new rule to domain */
+	if (domain_rule_set_flag(domain_rule, flag)) {
+		goto errout;
 	}
-	rule_flags->is_flag_set |= flag;
 
 	/* update domain rule */
-	if (add_domain_rule) {
-		old_domain_rule = art_insert(&_config_current_rule_group()->domain_rule.tree, (unsigned char *)domain_key, len,
-									 add_domain_rule);
-		if (old_domain_rule) {
-			_config_domain_rule_free(old_domain_rule);
-		}
+	if (need_insert) {
+		art_insert(&_config_current_rule_group()->domain_rule.tree, (unsigned char *)domain_key, len, domain_rule->ptr);
 	}
 
 	return 0;
 errout:
-	if (add_domain_rule) {
-		free(add_domain_rule);
+	if (need_insert) {
+		domain_rule_free(domain_rule);
 	}
 
-	tlog(TLOG_ERROR, "add domain %s rule failed", domain);
+	tlog(TLOG_ERROR, "flag set domain %s rule failed", domain);
 	return 0;
 }
 
@@ -3047,13 +2897,13 @@ static int _config_bind_ip(int argc, char *argv[], DNS_BIND_TYPE type)
 	/* clang-format off */
 	static struct option long_options[] = {
 		{"group", required_argument, NULL, 'g'}, /* add to group */
-		{"no-rule-addr", no_argument, NULL, 'A'},   
-		{"no-rule-nameserver", no_argument, NULL, 'N'},   
-		{"no-rule-ipset", no_argument, NULL, 'I'},   
-		{"no-rule-sni-proxy", no_argument, NULL, 'P'},   
+		{"no-rule-addr", no_argument, NULL, 'A'},
+		{"no-rule-nameserver", no_argument, NULL, 'N'},
+		{"no-rule-ipset", no_argument, NULL, 'I'},
+		{"no-rule-sni-proxy", no_argument, NULL, 'P'},
 		{"no-rule-soa", no_argument, NULL, 'O'},
-		{"no-speed-check", no_argument, NULL, 'S'},  
-		{"no-cache", no_argument, NULL, 'C'},  
+		{"no-speed-check", no_argument, NULL, 'S'},
+		{"no-cache", no_argument, NULL, 'C'},
 		{"no-dualstack-selection", no_argument, NULL, 'D'},
 		{"no-ip-alias", no_argument, NULL, 'a'},
 		{"force-aaaa-soa", no_argument, NULL, 'F'},
@@ -3413,7 +3263,7 @@ static int _config_proxy_server(void *data, int argc, char *argv[])
 
 	/* clang-format off */
 	static struct option long_options[] = {
-		{"name", required_argument, NULL, 'n'}, 
+		{"name", required_argument, NULL, 'n'},
 		{"use-domain", no_argument, NULL, 'd'},
 		{NULL, no_argument, NULL, 0}
 	};
@@ -5630,13 +5480,13 @@ static int _config_client_rules(void *data, int argc, char *argv[])
 	/* clang-format off */
 	static struct option long_options[] = {
 		{"group", required_argument, NULL, 'g'},
-		{"no-rule-addr", no_argument, NULL, 'A'},   
-		{"no-rule-nameserver", no_argument, NULL, 'N'},   
-		{"no-rule-ipset", no_argument, NULL, 'I'},   
-		{"no-rule-sni-proxy", no_argument, NULL, 'P'},   
+		{"no-rule-addr", no_argument, NULL, 'A'},
+		{"no-rule-nameserver", no_argument, NULL, 'N'},
+		{"no-rule-ipset", no_argument, NULL, 'I'},
+		{"no-rule-sni-proxy", no_argument, NULL, 'P'},
 		{"no-rule-soa", no_argument, NULL, 'O'},
-		{"no-speed-check", no_argument, NULL, 'S'},  
-		{"no-cache", no_argument, NULL, 'C'},  
+		{"no-speed-check", no_argument, NULL, 'S'},
+		{"no-cache", no_argument, NULL, 'C'},
 		{"no-dualstack-selection", no_argument, NULL, 'D'},
 		{"no-ip-alias", no_argument, NULL, 'a'},
 		{"force-aaaa-soa", no_argument, NULL, 'F'},
diff --git a/src/dns_conf.h b/src/dns_conf.h
index c3706f8..3b362fb 100644
--- a/src/dns_conf.h
+++ b/src/dns_conf.h
@@ -21,9 +21,11 @@
 
 #include "art.h"
 #include "atomic.h"
+#include "common.h"
 #include "conf.h"
 #include "dns.h"
 #include "dns_client.h"
+#include "dns_rules.h"
 #include "hash.h"
 #include "hashtable.h"
 #include "list.h"
@@ -34,63 +36,6 @@
 extern "C" {
 #endif
 
-#define DNS_MAX_BIND_IP 32
-#define DNS_MAX_SERVERS 64
-#define DNS_MAX_SERVER_NAME_LEN 128
-#define DNS_MAX_PTR_LEN 128
-#define DNS_MAX_IPSET_NAMELEN 32
-#define DNS_MAX_NFTSET_FAMILYLEN 8
-#define DNS_MAX_NFTSET_NAMELEN 256
-#define DNS_GROUP_NAME_LEN 32
-
-#define PROXY_NAME_LEN 32
-#define PROXY_MAX_SERVERS 128
-
-#define DNS_NAX_GROUP_NUMBER 16
-#define DNS_MAX_IPLEN 64
-#define DNS_PROXY_MAX_LEN 128
-#define DNS_CONF_USERNAME_LEN 32
-#define DNS_MAX_SPKI_LEN 64
-#define DNS_MAX_URL_LEN 256
-#define DNS_MAX_PATH 1024
-#define DEFAULT_DNS_PORT 53
-#define DEFAULT_DNS_TLS_PORT 853
-#define DEFAULT_DNS_HTTPS_PORT 443
-#define DNS_MAX_CONF_CNAME_LEN 256
-#define MAX_QTYPE_NUM 65535
-#define DNS_MAX_REPLY_IP_NUM 8
-#define DNS_MAX_QUERY_LIMIT 65535
-#define DNS_DEFAULT_CHECKPOINT_TIME (3600 * 24)
-#define DNS_MAX_SERVE_EXPIRED_TIME (3600 * 24 * 365)
-#define MAX_INTERFACE_LEN 16
-
-#define SMARTDNS_CONF_FILE "/etc/smartdns/smartdns.conf"
-#define SMARTDNS_LOG_FILE "/var/log/smartdns/smartdns.log"
-#define SMARTDNS_AUDIT_FILE "/var/log/smartdns/smartdns-audit.log"
-#define SMARTDNS_CACHE_FILE "/var/cache/smartdns/smartdns.cache"
-#define SMARTDNS_TMP_CACHE_FILE "/tmp/smartdns.cache"
-#define SMARTDNS_DEBUG_DIR "/tmp/smartdns"
-#define DNS_RESOLV_FILE "/etc/resolv.conf"
-
-enum domain_rule {
-	DOMAIN_RULE_FLAGS = 0,
-	DOMAIN_RULE_ADDRESS_IPV4,
-	DOMAIN_RULE_ADDRESS_IPV6,
-	DOMAIN_RULE_IPSET,
-	DOMAIN_RULE_IPSET_IPV4,
-	DOMAIN_RULE_IPSET_IPV6,
-	DOMAIN_RULE_NFTSET_IP,
-	DOMAIN_RULE_NFTSET_IP6,
-	DOMAIN_RULE_NAMESERVER,
-	DOMAIN_RULE_GROUP,
-	DOMAIN_RULE_CHECKSPEED,
-	DOMAIN_RULE_RESPONSE_MODE,
-	DOMAIN_RULE_CNAME,
-	DOMAIN_RULE_HTTPS,
-	DOMAIN_RULE_TTL,
-	DOMAIN_RULE_MAX,
-};
-
 enum ip_rule {
 	IP_RULE_FLAGS = 0,
 	IP_RULE_ALIAS = 1,
@@ -110,37 +55,6 @@ typedef enum {
 	DNS_BIND_TYPE_HTTPS,
 } DNS_BIND_TYPE;
 
-typedef enum {
-	DOMAIN_CHECK_NONE = 0,
-	DOMAIN_CHECK_ICMP = 1,
-	DOMAIN_CHECK_TCP = 2,
-	DOMAIN_CHECK_NUM = 3,
-} DOMAIN_CHECK_TYPE;
-
-#define DOMAIN_FLAG_ADDR_SOA (1 << 0)
-#define DOMAIN_FLAG_ADDR_IPV4_SOA (1 << 1)
-#define DOMAIN_FLAG_ADDR_IPV6_SOA (1 << 2)
-#define DOMAIN_FLAG_ADDR_IGN (1 << 3)
-#define DOMAIN_FLAG_ADDR_IPV4_IGN (1 << 4)
-#define DOMAIN_FLAG_ADDR_IPV6_IGN (1 << 5)
-#define DOMAIN_FLAG_IPSET_IGN (1 << 6)
-#define DOMAIN_FLAG_IPSET_IPV4_IGN (1 << 7)
-#define DOMAIN_FLAG_IPSET_IPV6_IGN (1 << 8)
-#define DOMAIN_FLAG_NAMESERVER_IGNORE (1 << 9)
-#define DOMAIN_FLAG_DUALSTACK_SELECT (1 << 10)
-#define DOMAIN_FLAG_SMARTDNS_DOMAIN (1 << 11)
-#define DOMAIN_FLAG_NFTSET_INET_IGN (1 << 12)
-#define DOMAIN_FLAG_NFTSET_IP_IGN (1 << 13)
-#define DOMAIN_FLAG_NFTSET_IP6_IGN (1 << 14)
-#define DOMAIN_FLAG_NO_SERVE_EXPIRED (1 << 15)
-#define DOMAIN_FLAG_CNAME_IGN (1 << 16)
-#define DOMAIN_FLAG_NO_CACHE (1 << 17)
-#define DOMAIN_FLAG_NO_IPALIAS (1 << 18)
-#define DOMAIN_FLAG_GROUP_IGNORE (1 << 19)
-#define DOMAIN_FLAG_ENABLE_CACHE (1 << 20)
-#define DOMAIN_FLAG_ADDR_HTTPS_SOA (1 << 21)
-#define DOMAIN_FLAG_ADDR_HTTPS_IGN (1 << 22)
-
 #define IP_RULE_FLAG_BLACKLIST (1 << 0)
 #define IP_RULE_FLAG_WHITELIST (1 << 1)
 #define IP_RULE_FLAG_BOGUS (1 << 2)
@@ -167,45 +81,11 @@ typedef enum {
 #define BIND_FLAG_NO_RULES (1 << 15)
 #define BIND_FLAG_ACL (1 << 16)
 
-enum response_mode_type {
-	DNS_RESPONSE_MODE_FIRST_PING_IP = 0,
-	DNS_RESPONSE_MODE_FASTEST_IP,
-	DNS_RESPONSE_MODE_FASTEST_RESPONSE,
-};
-
-struct dns_rule {
-	atomic_t refcnt;
-	enum domain_rule rule;
-};
-
-struct dns_rule_flags {
-	struct dns_rule head;
-	unsigned int flags;
-	unsigned int is_flag_set;
-};
-
-struct dns_rule_address_IPV4 {
-	struct dns_rule head;
-	char addr_num;
-	unsigned char ipv4_addr[][DNS_RR_A_LEN];
-};
-
-struct dns_rule_address_IPV6 {
-	struct dns_rule head;
-	char addr_num;
-	unsigned char ipv6_addr[][DNS_RR_AAAA_LEN];
-};
-
 struct dns_ipset_name {
 	struct hlist_node node;
 	char ipsetname[DNS_MAX_IPSET_NAMELEN];
 };
 
-struct dns_ipset_rule {
-	struct dns_rule head;
-	const char *ipsetname;
-};
-
 struct dns_ipset_names {
 	char inet_enable;
 	char ipv4_enable;
@@ -217,18 +97,6 @@ struct dns_ipset_names {
 extern struct dns_ipset_names dns_conf_ipset_no_speed;
 extern struct dns_ipset_names dns_conf_ipset;
 
-struct dns_cname_rule {
-	struct dns_rule head;
-	char cname[DNS_MAX_CNAME_LEN];
-};
-
-struct dns_ttl_rule {
-	struct dns_rule head;
-	int ttl;
-	int ttl_max;
-	int ttl_min;
-};
-
 struct dns_nftset_name {
 	struct hlist_node node;
 	char nftfamilyname[DNS_MAX_NFTSET_FAMILYLEN];
@@ -236,13 +104,6 @@ struct dns_nftset_name {
 	char nftsetname[DNS_MAX_NFTSET_NAMELEN];
 };
 
-struct dns_nftset_rule {
-	struct dns_rule head;
-	const char *familyname;
-	const char *nfttablename;
-	const char *nftsetname;
-};
-
 struct dns_nftset_names {
 	char inet_enable;
 	char ip_enable;
@@ -254,22 +115,6 @@ struct dns_nftset_names {
 extern struct dns_nftset_names dns_conf_nftset_no_speed;
 extern struct dns_nftset_names dns_conf_nftset;
 
-struct dns_domain_rule {
-	unsigned char sub_rule_only : 1;
-	unsigned char root_rule_only : 1;
-	struct dns_rule *rules[DOMAIN_RULE_MAX];
-};
-
-struct dns_nameserver_rule {
-	struct dns_rule head;
-	const char *group_name;
-};
-
-struct dns_group_rule {
-	struct dns_rule head;
-	const char *group_name;
-};
-
 struct dns_server_groups {
 	struct hlist_node node;
 	char group_name[DNS_GROUP_NAME_LEN];
@@ -277,49 +122,9 @@ struct dns_server_groups {
 	struct dns_servers *servers[DNS_MAX_SERVERS];
 };
 
-struct dns_domain_check_order {
-	DOMAIN_CHECK_TYPE type;
-	unsigned short tcp_port;
-};
-
-struct dns_domain_check_orders {
-	struct dns_rule head;
-	struct dns_domain_check_order orders[DOMAIN_CHECK_NUM];
-};
-
-struct dns_response_mode_rule {
-	struct dns_rule head;
-	enum response_mode_type mode;
-};
-
-struct dns_https_record {
-	int enable;
-	char target[DNS_MAX_CNAME_LEN];
-	int priority;
-	char alpn[DNS_MAX_ALPN_LEN];
-	int alpn_len;
-	int port;
-	unsigned char ech[DNS_MAX_ECH_LEN];
-	int ech_len;
-	int has_ipv4;
-	unsigned char ipv4_addr[DNS_RR_A_LEN];
-	int has_ipv6;
-	unsigned char ipv6_addr[DNS_RR_AAAA_LEN];
-};
-
-struct dns_https_filter {
-	int no_ipv4hint;
-	int no_ipv6hint;
-};
-
-struct dns_https_record_rule {
-	struct dns_rule head;
-	struct dns_https_record record;
-	struct dns_https_filter filter;
-};
-
 struct dns_group_table {
 	DECLARE_HASHTABLE(group, 8);
+	struct dns_server_groups _[0];
 };
 extern struct dns_group_table dns_group_table;
 
@@ -364,10 +169,12 @@ struct dns_proxy_names {
 	struct hlist_node node;
 	char proxy_name[PROXY_NAME_LEN];
 	struct list_head server_list;
+	struct dns_proxy_servers* _[0];
 };
 
 struct dns_proxy_table {
 	DECLARE_HASHTABLE(proxy, 4);
+	struct dns_proxy_names _[0];
 };
 extern struct dns_proxy_table dns_proxy_table;
 
@@ -387,6 +194,7 @@ struct dns_servers {
 	long long set_mark;
 	unsigned int drop_packet_latency_ms;
 	int tcp_keepalive;
+	int fallback;
 	int subnet_all_query_types;
 	char skip_check_cert;
 	char spki[DNS_MAX_SPKI_LEN];
@@ -678,10 +486,6 @@ extern int dns_conf_server_num;
 
 extern char dns_conf_exist_bootstrap_dns;
 
-/* proxy servers */
-extern struct dns_proxy_servers dns_conf_proxy_servers[PROXY_MAX_SERVERS];
-extern int dns_conf_proxy_server_num;
-
 extern int dns_conf_log_level;
 extern char dns_conf_log_file[DNS_MAX_PATH];
 extern size_t dns_conf_log_size;
@@ -701,9 +505,6 @@ extern struct dns_domain_check_orders dns_conf_default_check_orders;
 extern int dns_conf_has_icmp_check;
 extern int dns_conf_has_tcp_check;
 
-extern struct dns_server_groups dns_conf_server_groups[DNS_NAX_GROUP_NUMBER];
-extern int dns_conf_server_group_num;
-
 extern int dns_conf_audit_enable;
 extern int dns_conf_audit_log_SOA;
 extern int dns_conf_audit_syslog;
@@ -746,8 +547,6 @@ int dns_server_load_conf(const char *file);
 
 int dns_server_check_update_hosts(void);
 
-struct dns_proxy_names *dns_server_get_proxy_nams(const char *proxyname);
-
 struct dns_srv_records *dns_server_get_srv_record(const char *domain);
 
 struct dns_conf_group *dns_server_get_rule_group(const char *group_name);
diff --git a/src/dns_rules.c b/src/dns_rules.c
new file mode 100644
index 0000000..2656c65
--- /dev/null
+++ b/src/dns_rules.c
@@ -0,0 +1,448 @@
+/*************************************************************************
+ *
+ * Copyright (C) 2018-2024 Ruilin Peng (Nick) <pymumu@gmail.com>.
+ *
+ * smartdns is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * smartdns is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "stddef.h"
+#include "stdlib.h"
+#include "string.h"
+
+#include "dns_rules.h"
+#include "tlog.h"
+
+void *_new_dns_rule_ext(enum domain_rule domain_rule, int ext_size)
+{
+	struct dns_rule *rule;
+	int size = 0;
+
+	switch (domain_rule) {
+	case DOMAIN_RULE_ADDRESS_IPV4:
+		size = sizeof(struct dns_rule_address_IPV4);
+		break;
+	case DOMAIN_RULE_ADDRESS_IPV6:
+		size = sizeof(struct dns_rule_address_IPV6);
+		break;
+	case DOMAIN_RULE_IPSET:
+	case DOMAIN_RULE_IPSET_IPV4:
+	case DOMAIN_RULE_IPSET_IPV6:
+		size = sizeof(struct dns_ipset_rule);
+		break;
+	case DOMAIN_RULE_NFTSET_IP:
+	case DOMAIN_RULE_NFTSET_IP6:
+		size = sizeof(struct dns_nftset_rule);
+		break;
+	case DOMAIN_RULE_NAMESERVER:
+		size = sizeof(struct dns_nameserver_rule);
+		break;
+	case DOMAIN_RULE_GROUP:
+		size = sizeof(struct dns_group_rule);
+		break;
+	case DOMAIN_RULE_CHECKSPEED:
+		size = sizeof(struct dns_domain_check_orders);
+		break;
+	case DOMAIN_RULE_RESPONSE_MODE:
+		size = sizeof(struct dns_response_mode_rule);
+		break;
+	case DOMAIN_RULE_CNAME:
+		size = sizeof(struct dns_cname_rule);
+		break;
+	case DOMAIN_RULE_HTTPS:
+		size = sizeof(struct dns_https_record_rule);
+		break;
+	case DOMAIN_RULE_TTL:
+		size = sizeof(struct dns_ttl_rule);
+		break;
+	default:
+		return NULL;
+	}
+
+	size += ext_size;
+	rule = malloc(size);
+	if (!rule) {
+		return NULL;
+	}
+	memset(rule, 0, size);
+	rule->rule = domain_rule;
+	atomic_set(&rule->refcnt, 1);
+	return rule;
+}
+
+void *_new_dns_rule(enum domain_rule domain_rule)
+{
+	return _new_dns_rule_ext(domain_rule, 0);
+}
+
+static void _dns_rule_get(struct dns_rule *rule)
+{
+	atomic_inc(&rule->refcnt);
+}
+
+void _dns_rule_put(struct dns_rule *rule)
+{
+	if (atomic_dec_and_test(&rule->refcnt)) {
+		free(rule);
+	}
+}
+
+#define IS_RAW(x) ((uintptr_t)(x->ptr) & 1)
+
+struct raw_domain_rule {
+	uint32_t lowest : 1;
+	uint32_t sub_rule_only : 1;
+	uint32_t root_rule_only : 1;
+	uint32_t flags : 29;
+};
+
+enum layout_type {
+	DOMAIN_RULE_LAYOUT_ARRAY = 1,
+	DOMAIN_RULE_LAYOUT_POINTER = 2,
+};
+
+#define INNER_ARRAY_SIZE 1
+
+struct _domain_rule {
+	unsigned char sub_rule_only : 1;
+	unsigned char root_rule_only : 1;
+
+	unsigned char layout_type : 2;
+	uint8_t capacity;
+	uint16_t bitmap;
+	uint32_t flags;
+	union {
+		struct dns_rule *arr[INNER_ARRAY_SIZE];
+		struct dns_rule **ptr;
+	} rules;
+};
+
+struct _domain_rule *domain_rules;
+static uint32_t buffer_index;
+
+#define PAGE_SIZE ((1 << 22) - (1 << 5))
+#define PAGE_NUM (PAGE_SIZE / sizeof(struct _domain_rule))
+
+int domain_rule_init(struct dns_domain_rule *wrapper)
+{
+	struct raw_domain_rule *raw = (struct raw_domain_rule *)wrapper;
+
+	if (wrapper == NULL) {
+		return -1;
+	}
+
+	raw->lowest = 1;
+	raw->sub_rule_only = 0;
+	raw->root_rule_only = 0;
+	raw->flags = 0;
+
+	return 0;
+}
+
+static struct _domain_rule *_domain_rule_new(uint8_t)
+{
+	struct _domain_rule *domain_rule;
+
+	if (domain_rules == NULL || buffer_index >= PAGE_NUM) {
+		domain_rules = malloc(PAGE_SIZE);
+		if (domain_rules == NULL) {
+			return NULL;
+		}
+		buffer_index = 0;
+	}
+
+	domain_rule = &domain_rules[buffer_index++];
+
+	domain_rule->layout_type = DOMAIN_RULE_LAYOUT_ARRAY;
+	domain_rule->capacity = INNER_ARRAY_SIZE;
+	domain_rule->bitmap = 0;
+
+	return domain_rule;
+}
+
+static struct dns_rule **_domain_rule_rules(struct dns_domain_rule *wrapper)
+{
+	struct _domain_rule *domain_rule;
+
+	if (wrapper == NULL || IS_RAW(wrapper)) {
+		return NULL;
+	}
+
+	domain_rule = wrapper->ptr;
+	if (domain_rule == NULL) {
+		return NULL;
+	}
+
+	switch (domain_rule->layout_type) {
+	case DOMAIN_RULE_LAYOUT_ARRAY:
+		return domain_rule->rules.arr;
+	case DOMAIN_RULE_LAYOUT_POINTER:
+		return domain_rule->rules.ptr;
+	default:
+		tlog(TLOG_ERROR, "unexpected domain rule layout %d", domain_rule->layout_type);
+		return NULL;
+	}
+}
+
+static struct dns_rule **_domain_rule_access(struct dns_domain_rule *wrapper, enum domain_rule type, int insert)
+{
+	struct dns_rule **rules = _domain_rule_rules(wrapper);
+	struct _domain_rule *domain_rule;
+	int i, size;
+	int new_capacity;
+	struct dns_rule **new_rules;
+
+	if (rules == NULL || type < 0 || type >= DOMAIN_RULE_MAX) {
+		return NULL;
+	}
+
+	domain_rule = wrapper->ptr;
+	if (domain_rule == NULL) {
+		return NULL;
+	}
+
+	i = __builtin_popcount(domain_rule->bitmap & ((1u << type) - 1));
+	if ((domain_rule->bitmap >> type) & 1) {
+		return &rules[i];
+	}
+
+	if (!insert) {
+		return NULL;
+	}
+
+	size = __builtin_popcount(domain_rule->bitmap);
+	if (size < domain_rule->capacity) {
+		memmove(rules + i + 1, rules + i, (size - i) * sizeof(void *));
+		rules[i] = NULL;
+		domain_rule->bitmap |= 1 << type;
+		return &rules[i];
+	} else {
+		new_capacity = domain_rule->capacity * 2;
+		if (new_capacity > DOMAIN_RULE_MAX) {
+			new_capacity = DOMAIN_RULE_MAX;
+		}
+		new_rules = (struct dns_rule **)malloc(new_capacity * sizeof(void *));
+		if (new_rules == NULL) {
+			return NULL;
+		}
+
+		memcpy(new_rules, rules, i * sizeof(void *));
+		memcpy(new_rules + i + 1, rules + i, (size - i) * sizeof(void *));
+		new_rules[i] = NULL;
+		if (domain_rule->layout_type == DOMAIN_RULE_LAYOUT_POINTER) {
+			free(rules);
+		}
+		domain_rule->layout_type = DOMAIN_RULE_LAYOUT_POINTER;
+		domain_rule->capacity = new_capacity;
+		domain_rule->bitmap |= 1 << type;
+		domain_rule->rules.ptr = new_rules;
+		return &new_rules[i];
+	}
+}
+
+int domain_rule_free(struct dns_domain_rule *wrapper)
+{
+	struct dns_rule **rules = _domain_rule_rules(wrapper);
+	struct _domain_rule *domain_rule;
+	int type, i;
+
+	if (IS_RAW(wrapper)) {
+		return 0;
+	}
+
+	domain_rule = wrapper->ptr;
+
+	if (rules != NULL) {
+		for (type = 0, i = 0; type < DOMAIN_RULE_MAX; ++type) {
+			if (((domain_rule->bitmap >> type) & 1) == 0) {
+				continue;
+			}
+
+			if (rules[i] != NULL) {
+				_dns_rule_put(rules[i]);
+			}
+
+			++i;
+		}
+	}
+
+	if (domain_rule->layout_type == DOMAIN_RULE_LAYOUT_POINTER) {
+		free(rules);
+	}
+
+	return 0;
+}
+
+int domain_rule_get_data(struct dns_domain_rule *wrapper, int *sub_rule_only, int *root_rule_only)
+{
+	struct _domain_rule *domain_rule;
+
+	if (wrapper == NULL) {
+		return -1;
+	}
+
+	if (IS_RAW(wrapper)) {
+		*sub_rule_only = ((struct raw_domain_rule *)wrapper)->sub_rule_only;
+		*root_rule_only = ((struct raw_domain_rule *)wrapper)->root_rule_only;
+		return 0;
+	}
+
+	domain_rule = wrapper->ptr;
+	if (domain_rule == NULL) {
+		return -1;
+	}
+
+	*sub_rule_only = domain_rule->sub_rule_only;
+	*root_rule_only = domain_rule->root_rule_only;
+
+	return 0;
+}
+
+int domain_rule_set_data(struct dns_domain_rule *wrapper, int sub_rule_only, int root_rule_only)
+{
+	struct _domain_rule *domain_rule;
+
+	if (wrapper == NULL) {
+		return -1;
+	}
+
+	if (IS_RAW(wrapper)) {
+		((struct raw_domain_rule *)wrapper)->sub_rule_only = sub_rule_only;
+		((struct raw_domain_rule *)wrapper)->root_rule_only = root_rule_only;
+		return 0;
+	}
+
+	domain_rule = wrapper->ptr;
+	if (domain_rule == NULL) {
+		return -1;
+	}
+
+	domain_rule->sub_rule_only = sub_rule_only;
+	domain_rule->root_rule_only = root_rule_only;
+
+	return 0;
+}
+
+int domain_rule_get_flags(struct dns_domain_rule *wrapper, unsigned int *flags)
+{
+	struct _domain_rule *domain_rule;
+
+	if (wrapper == NULL) {
+		return -1;
+	}
+
+	if (IS_RAW(wrapper)) {
+		*flags = ((struct raw_domain_rule *)wrapper)->flags;
+		return 0;
+	}
+
+	domain_rule = wrapper->ptr;
+	if (domain_rule == NULL) {
+		return -1;
+	}
+
+	*flags = domain_rule->flags;
+	return 0;
+}
+
+int domain_rule_set_flag(struct dns_domain_rule *wrapper, unsigned int flag)
+{
+	struct _domain_rule *domain_rule;
+	uint32_t flags;
+
+	if (wrapper == NULL) {
+		return -1;
+	}
+
+	if (domain_rule_get_flags(wrapper, &flags)) {
+		return -1;
+	}
+
+	flags |= flag;
+	if (flag & DOMAIN_FLAG_DUALSTACK_SELECT) {
+		flags &= ~DOMAIN_FLAG_NO_DUALSTACK_SELECT;
+	} else if (flag & DOMAIN_FLAG_NO_DUALSTACK_SELECT) {
+		flags &= ~DOMAIN_FLAG_DUALSTACK_SELECT;
+	}
+
+	if (IS_RAW(wrapper)) {
+		((struct raw_domain_rule *)wrapper)->flags = flags;
+	} else {
+		domain_rule = wrapper->ptr;
+		domain_rule->flags = flags;
+	}
+
+	return 0;
+}
+
+struct dns_rule *domain_rule_get(struct dns_domain_rule *wrapper, enum domain_rule type)
+{
+	struct _domain_rule *domain_rule;
+	struct dns_rule **ptr_rule;
+
+	if (wrapper == NULL || IS_RAW(wrapper)) {
+		return NULL;
+	}
+
+	domain_rule = wrapper->ptr;
+	if (domain_rule == NULL) {
+		return NULL;
+	}
+
+	ptr_rule = _domain_rule_access(wrapper, type, 0);
+	if (ptr_rule == NULL) {
+		return NULL;
+	}
+
+	return *ptr_rule;
+}
+
+int domain_rule_set(struct dns_domain_rule *wrapper, enum domain_rule type, struct dns_rule *rule)
+{
+	struct _domain_rule *domain_rule;
+	struct raw_domain_rule *raw;
+	struct dns_rule **ptr_rule;
+
+	if (wrapper == NULL) {
+		return -1;
+	}
+
+	if (IS_RAW(wrapper)) {
+		domain_rule = _domain_rule_new(1);
+		raw = (struct raw_domain_rule *)wrapper;
+		domain_rule->sub_rule_only = raw->sub_rule_only;
+		domain_rule->root_rule_only = raw->root_rule_only;
+		domain_rule->flags = raw->flags;
+		wrapper->ptr = domain_rule;
+	}
+
+	domain_rule = wrapper->ptr;
+	if (domain_rule == NULL) {
+		return -1;
+	}
+
+	ptr_rule = _domain_rule_access(wrapper, type, 1);
+	if (ptr_rule == NULL) {
+		return -1;
+	}
+
+	if (*ptr_rule) {
+		_dns_rule_put(*ptr_rule);
+		*ptr_rule = NULL;
+	}
+
+	*ptr_rule = rule;
+	_dns_rule_get(rule);
+
+	return 0;
+}
\ No newline at end of file
diff --git a/src/dns_rules.h b/src/dns_rules.h
new file mode 100644
index 0000000..56c1313
--- /dev/null
+++ b/src/dns_rules.h
@@ -0,0 +1,205 @@
+/*************************************************************************
+ *
+ * Copyright (C) 2018-2024 Ruilin Peng (Nick) <pymumu@gmail.com>.
+ *
+ * smartdns is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * smartdns is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _DNS_RULES
+#define _DNS_RULES
+
+#include <stdint.h>
+
+#include "atomic.h"
+#include "common.h"
+#include "list.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum domain_rule {
+	DOMAIN_RULE_ADDRESS_IPV4 = 0,
+	DOMAIN_RULE_ADDRESS_IPV6,
+	DOMAIN_RULE_IPSET,
+	DOMAIN_RULE_IPSET_IPV4,
+	DOMAIN_RULE_IPSET_IPV6,
+	DOMAIN_RULE_NFTSET_IP,
+	DOMAIN_RULE_NFTSET_IP6,
+	DOMAIN_RULE_NAMESERVER,
+	DOMAIN_RULE_GROUP,
+	DOMAIN_RULE_CHECKSPEED,
+	DOMAIN_RULE_RESPONSE_MODE,
+	DOMAIN_RULE_CNAME,
+	DOMAIN_RULE_HTTPS,
+	DOMAIN_RULE_TTL,
+	DOMAIN_RULE_MAX,
+};
+
+struct dns_rule {
+	atomic_t refcnt;
+	enum domain_rule rule;
+};
+
+#define DOMAIN_FLAG_ADDR_SOA (1 << 0)
+#define DOMAIN_FLAG_ADDR_IPV4_SOA (1 << 1)
+#define DOMAIN_FLAG_ADDR_IPV6_SOA (1 << 2)
+#define DOMAIN_FLAG_ADDR_IGN (1 << 3)
+#define DOMAIN_FLAG_ADDR_IPV4_IGN (1 << 4)
+#define DOMAIN_FLAG_ADDR_IPV6_IGN (1 << 5)
+#define DOMAIN_FLAG_IPSET_IGN (1 << 6)
+#define DOMAIN_FLAG_IPSET_IPV4_IGN (1 << 7)
+#define DOMAIN_FLAG_IPSET_IPV6_IGN (1 << 8)
+#define DOMAIN_FLAG_NAMESERVER_IGNORE (1 << 9)
+#define DOMAIN_FLAG_DUALSTACK_SELECT (1 << 10)
+#define DOMAIN_FLAG_SMARTDNS_DOMAIN (1 << 11)
+#define DOMAIN_FLAG_NFTSET_INET_IGN (1 << 12)
+#define DOMAIN_FLAG_NFTSET_IP_IGN (1 << 13)
+#define DOMAIN_FLAG_NFTSET_IP6_IGN (1 << 14)
+#define DOMAIN_FLAG_NO_SERVE_EXPIRED (1 << 15)
+#define DOMAIN_FLAG_CNAME_IGN (1 << 16)
+#define DOMAIN_FLAG_NO_CACHE (1 << 17)
+#define DOMAIN_FLAG_NO_IPALIAS (1 << 18)
+#define DOMAIN_FLAG_GROUP_IGNORE (1 << 19)
+#define DOMAIN_FLAG_ENABLE_CACHE (1 << 20)
+#define DOMAIN_FLAG_ADDR_HTTPS_SOA (1 << 21)
+#define DOMAIN_FLAG_ADDR_HTTPS_IGN (1 << 22)
+#define DOMAIN_FLAG_NO_DUALSTACK_SELECT (1 << 23)
+
+struct dns_rule_address_IPV4 {
+	struct dns_rule head;
+	char addr_num;
+	unsigned char ipv4_addr[][DNS_RR_A_LEN];
+};
+
+struct dns_rule_address_IPV6 {
+	struct dns_rule head;
+	char addr_num;
+	unsigned char ipv6_addr[][DNS_RR_AAAA_LEN];
+};
+
+struct dns_ipset_rule {
+	struct dns_rule head;
+	const char *ipsetname;
+};
+
+struct dns_nftset_rule {
+	struct dns_rule head;
+	const char *familyname;
+	const char *nfttablename;
+	const char *nftsetname;
+};
+
+struct dns_nameserver_rule {
+	struct dns_rule head;
+	const char *group_name;
+};
+
+struct dns_group_rule {
+	struct dns_rule head;
+	const char *group_name;
+};
+
+typedef enum {
+	DOMAIN_CHECK_NONE = 0,
+	DOMAIN_CHECK_ICMP = 1,
+	DOMAIN_CHECK_TCP = 2,
+	DOMAIN_CHECK_NUM = 3,
+} DOMAIN_CHECK_TYPE;
+
+struct dns_domain_check_order {
+	DOMAIN_CHECK_TYPE type;
+	unsigned short tcp_port;
+};
+
+struct dns_domain_check_orders {
+	struct dns_rule head;
+	struct dns_domain_check_order orders[DOMAIN_CHECK_NUM];
+};
+
+enum response_mode_type {
+	DNS_RESPONSE_MODE_FIRST_PING_IP = 0,
+	DNS_RESPONSE_MODE_FASTEST_IP,
+	DNS_RESPONSE_MODE_FASTEST_RESPONSE,
+};
+
+struct dns_response_mode_rule {
+	struct dns_rule head;
+	enum response_mode_type mode;
+};
+
+struct dns_cname_rule {
+	struct dns_rule head;
+	char cname[DNS_MAX_CNAME_LEN];
+};
+
+struct dns_https_record {
+	int enable;
+	char target[DNS_MAX_CNAME_LEN];
+	int priority;
+	char alpn[DNS_MAX_ALPN_LEN];
+	int alpn_len;
+	int port;
+	unsigned char ech[DNS_MAX_ECH_LEN];
+	int ech_len;
+	int has_ipv4;
+	unsigned char ipv4_addr[DNS_RR_A_LEN];
+	int has_ipv6;
+	unsigned char ipv6_addr[DNS_RR_AAAA_LEN];
+};
+
+struct dns_https_filter {
+	int no_ipv4hint;
+	int no_ipv6hint;
+};
+
+struct dns_https_record_rule {
+	struct dns_rule head;
+	struct dns_https_record record;
+	struct dns_https_filter filter;
+};
+
+struct dns_ttl_rule {
+	struct dns_rule head;
+	int ttl;
+	int ttl_max;
+	int ttl_min;
+};
+
+void *_new_dns_rule_ext(enum domain_rule domain_rule, int ext_size);
+void *_new_dns_rule(enum domain_rule domain_rule);
+void _dns_rule_put(struct dns_rule *rule);
+
+struct dns_domain_rule {
+	void *ptr;
+};
+
+// struct dns_domain_rule *domain_rule_new(uint8_t capacity);
+int domain_rule_init(struct dns_domain_rule *domain_rule);
+int domain_rule_free(struct dns_domain_rule *domain_rule);
+// ensures users can't directly modify `struct dns_domain_rule`
+int domain_rule_get_data(struct dns_domain_rule *domain_rule, int *sub_rule_only, int *root_rule_only);
+int domain_rule_set_data(struct dns_domain_rule *domain_rule, int sub_rule_only, int root_rule_only);
+int domain_rule_get_flags(struct dns_domain_rule *domain_rule, unsigned int *flags);
+int domain_rule_set_flag(struct dns_domain_rule *domain_rule, unsigned int flag);
+/**
+ * Get rule without allocation.
+ */
+struct dns_rule *domain_rule_get(struct dns_domain_rule *domain_rule, enum domain_rule type);
+int domain_rule_set(struct dns_domain_rule *domain_rule, enum domain_rule type, struct dns_rule *rule);
+
+#ifdef __cplusplus
+}
+#endif
+#endif // !_DNS_RULES
\ No newline at end of file
diff --git a/src/dns_server.c b/src/dns_server.c
index 66fa190..b9f2ce9 100644
--- a/src/dns_server.c
+++ b/src/dns_server.c
@@ -260,6 +260,10 @@ struct dns_request_pending_list {
 };
 
 struct dns_request_domain_rule {
+	struct _dns_rule_flags {
+		unsigned int flags;
+	} rule_flags;
+	int rule_flags_is_sub_rule;
 	struct dns_rule *rules[DOMAIN_RULE_MAX];
 	int is_sub_rule[DOMAIN_RULE_MAX];
 };
@@ -589,13 +593,22 @@ static void *_dns_server_get_dns_rule_ext(struct dns_request_domain_rule *domain
 	return domain_rule->rules[rule];
 }
 
-static int _dns_server_is_dns_rule_extract_match_ext(struct dns_request_domain_rule *domain_rule, enum domain_rule rule)
+static int _dns_server_is_domain_rule_flags_extract_match_ext(struct dns_request_domain_rule *domain_rule)
 {
-	if (rule >= DOMAIN_RULE_MAX || domain_rule == NULL) {
+	if (domain_rule == NULL) {
 		return 0;
 	}
 
-	return domain_rule->is_sub_rule[rule] == 0;
+	return domain_rule->rule_flags_is_sub_rule == 0;
+}
+
+static void *_dns_server_get_domain_rule_flags(struct dns_request *request)
+{
+	if (request == NULL) {
+		return NULL;
+	}
+
+	return &request->domain_rule.rule_flags;
 }
 
 static void *_dns_server_get_dns_rule(struct dns_request *request, enum domain_rule rule)
@@ -607,13 +620,13 @@ static void *_dns_server_get_dns_rule(struct dns_request *request, enum domain_r
 	return _dns_server_get_dns_rule_ext(&request->domain_rule, rule);
 }
 
-static int _dns_server_is_dns_rule_extract_match(struct dns_request *request, enum domain_rule rule)
+static int _dns_server_is_domain_rule_flags_extract_match(struct dns_request *request)
 {
 	if (request == NULL) {
 		return 0;
 	}
 
-	return _dns_server_is_dns_rule_extract_match_ext(&request->domain_rule, rule);
+	return _dns_server_is_domain_rule_flags_extract_match_ext(&request->domain_rule);
 }
 
 static int _dns_server_is_dns64_request(struct dns_request *request)
@@ -635,7 +648,7 @@ static int _dns_server_is_dns64_request(struct dns_request *request)
 
 static void _dns_server_set_dualstack_selection(struct dns_request *request)
 {
-	struct dns_rule_flags *rule_flag = NULL;
+	struct _dns_rule_flags *rule_flag = NULL;
 
 	if (request->dualstack_selection_query || is_ipv6_ready == 0) {
 		request->dualstack_selection = 0;
@@ -648,14 +661,14 @@ static void _dns_server_set_dualstack_selection(struct dns_request *request)
 		return;
 	}
 
-	rule_flag = _dns_server_get_dns_rule(request, DOMAIN_RULE_FLAGS);
+	rule_flag = _dns_server_get_domain_rule_flags(request);
 	if (rule_flag) {
 		if (rule_flag->flags & DOMAIN_FLAG_DUALSTACK_SELECT) {
 			request->dualstack_selection = 1;
 			return;
 		}
 
-		if (rule_flag->is_flag_set & DOMAIN_FLAG_DUALSTACK_SELECT) {
+		if (rule_flag->flags & DOMAIN_FLAG_NO_DUALSTACK_SELECT) {
 			request->dualstack_selection = 0;
 			return;
 		}
@@ -671,7 +684,7 @@ static void _dns_server_set_dualstack_selection(struct dns_request *request)
 
 static int _dns_server_is_return_soa_qtype(struct dns_request *request, dns_type_t qtype)
 {
-	struct dns_rule_flags *rule_flag = NULL;
+	struct _dns_rule_flags *rule_flag = NULL;
 	unsigned int flags = 0;
 
 	if (_dns_server_has_bind_flag(request, BIND_FLAG_NO_RULE_SOA) == 0) {
@@ -683,7 +696,7 @@ static int _dns_server_is_return_soa_qtype(struct dns_request *request, dns_type
 		return 0;
 	}
 
-	rule_flag = _dns_server_get_dns_rule(request, DOMAIN_RULE_FLAGS);
+	rule_flag = _dns_server_get_domain_rule_flags(request);
 	if (rule_flag) {
 		flags = rule_flag->flags;
 		if (flags & DOMAIN_FLAG_ADDR_SOA) {
@@ -2073,7 +2086,7 @@ static int _dns_server_setup_ipset_nftset_packet(struct dns_server_post_context
 	struct dns_ipset_rule *ipset_rule_v6 = NULL;
 	struct dns_nftset_rule *nftset_ip = NULL;
 	struct dns_nftset_rule *nftset_ip6 = NULL;
-	struct dns_rule_flags *rule_flags = NULL;
+	struct _dns_rule_flags *rule_flags = NULL;
 	int check_no_speed_rule = 0;
 
 	if (_dns_server_has_bind_flag(request, BIND_FLAG_NO_RULE_IPSET) == 0) {
@@ -2095,7 +2108,7 @@ static int _dns_server_setup_ipset_nftset_packet(struct dns_server_post_context
 	conf = request->conf;
 
 	/* check ipset rule */
-	rule_flags = _dns_server_get_dns_rule(request, DOMAIN_RULE_FLAGS);
+	rule_flags = _dns_server_get_domain_rule_flags(request);
 	if (!rule_flags || (rule_flags->flags & DOMAIN_FLAG_IPSET_IGN) == 0) {
 		ipset_rule = _dns_server_get_dns_rule(request, DOMAIN_RULE_IPSET);
 		if (ipset_rule == NULL) {
@@ -5282,7 +5295,7 @@ static void _dns_server_log_rule(const char *domain, enum domain_rule rule_type,
 
 static void _dns_server_update_rule_by_flags(struct dns_request_domain_rule *request_domain_rule)
 {
-	struct dns_rule_flags *rule_flag = (struct dns_rule_flags *)request_domain_rule->rules[0];
+	struct _dns_rule_flags *rule_flag = &request_domain_rule->rule_flags;
 	unsigned int flags = 0;
 
 	if (rule_flag == NULL) {
@@ -5336,20 +5349,27 @@ static int _dns_server_get_rules(unsigned char *key, uint32_t key_len, int is_su
 {
 	struct rule_walk_args *walk_args = arg;
 	struct dns_request_domain_rule *request_domain_rule = walk_args->args;
-	struct dns_domain_rule *domain_rule = value;
+	struct dns_domain_rule _domain_rule;
+	struct dns_domain_rule *domain_rule = &_domain_rule;
+	struct dns_rule *rule;
+	int sub_rule_only = 0;
+	int root_rule_only = 0;
 	int i = 0;
-	if (domain_rule == NULL) {
+	if (value == NULL) {
 		return 0;
 	}
 
-	if (domain_rule->sub_rule_only != domain_rule->root_rule_only) {
+	domain_rule->ptr = value;
+	// always success when domain_rule is not NULL
+	domain_rule_get_data(domain_rule, &sub_rule_only, &root_rule_only);
+	if (sub_rule_only != root_rule_only) {
 		/* only subkey rule */
-		if (domain_rule->sub_rule_only == 1 && is_subkey == 0) {
+		if (sub_rule_only == 1 && is_subkey == 0) {
 			return 0;
 		}
 
 		/* only root key rule */
-		if (domain_rule->root_rule_only == 1 && is_subkey == 1) {
+		if (root_rule_only == 1 && is_subkey == 1) {
 			return 0;
 		}
 	}
@@ -5360,15 +5380,18 @@ static int _dns_server_get_rules(unsigned char *key, uint32_t key_len, int is_su
 		i = 0;
 	}
 
+	domain_rule_get_flags(domain_rule, &request_domain_rule->rule_flags.flags);
+	request_domain_rule->rule_flags_is_sub_rule = is_subkey;
 	for (; i < DOMAIN_RULE_MAX; i++) {
-		if (domain_rule->rules[i] == NULL) {
+		rule = domain_rule_get(domain_rule, i);
+		if (rule == NULL) {
 			if (walk_args->rule_index >= 0) {
 				break;
 			}
 			continue;
 		}
 
-		request_domain_rule->rules[i] = domain_rule->rules[i];
+		request_domain_rule->rules[i] = rule;
 		request_domain_rule->is_sub_rule[i] = is_subkey;
 		walk_args->key[i] = key;
 		walk_args->key_len[i] = key_len;
@@ -5500,12 +5523,12 @@ static int _dns_server_pre_process_server_flags(struct dns_request *request)
 
 static int _dns_server_pre_process_rule_flags(struct dns_request *request)
 {
-	struct dns_rule_flags *rule_flag = NULL;
+	struct _dns_rule_flags *rule_flag = NULL;
 	unsigned int flags = 0;
 	int rcode = DNS_RC_NOERROR;
 
 	/* get domain rule flag */
-	rule_flag = _dns_server_get_dns_rule(request, DOMAIN_RULE_FLAGS);
+	rule_flag = _dns_server_get_domain_rule_flags(request);
 	if (rule_flag != NULL) {
 		flags = rule_flag->flags;
 	}
@@ -5854,7 +5877,7 @@ static DNS_CHILD_POST_RESULT _dns_server_process_cname_callback(struct dns_reque
 static int _dns_server_process_cname_pre(struct dns_request *request)
 {
 	struct dns_cname_rule *cname = NULL;
-	struct dns_rule_flags *rule_flag = NULL;
+	struct _dns_rule_flags *rule_flag = NULL;
 	struct dns_request_domain_rule domain_rule;
 
 	if (_dns_server_has_bind_flag(request, BIND_FLAG_NO_RULE_CNAME) == 0) {
@@ -5866,7 +5889,7 @@ static int _dns_server_process_cname_pre(struct dns_request *request)
 	}
 
 	/* get domain rule flag */
-	rule_flag = _dns_server_get_dns_rule(request, DOMAIN_RULE_FLAGS);
+	rule_flag = _dns_server_get_domain_rule_flags(request);
 	if (rule_flag != NULL) {
 		if (rule_flag->flags & DOMAIN_FLAG_CNAME_IGN) {
 			return 0;
@@ -5898,7 +5921,7 @@ static int _dns_server_process_cname(struct dns_request *request)
 	struct dns_cname_rule *cname = NULL;
 	const char *child_group_name = NULL;
 	int ret = 0;
-	struct dns_rule_flags *rule_flag = NULL;
+	struct _dns_rule_flags *rule_flag = NULL;
 
 	if (_dns_server_has_bind_flag(request, BIND_FLAG_NO_RULE_CNAME) == 0) {
 		return 0;
@@ -5909,7 +5932,7 @@ static int _dns_server_process_cname(struct dns_request *request)
 	}
 
 	/* get domain rule flag */
-	rule_flag = _dns_server_get_dns_rule(request, DOMAIN_RULE_FLAGS);
+	rule_flag = _dns_server_get_domain_rule_flags(request);
 	if (rule_flag != NULL) {
 		if (rule_flag->flags & DOMAIN_FLAG_CNAME_IGN) {
 			return 0;
@@ -6539,16 +6562,16 @@ static void _dns_server_request_set_callback(struct dns_request *request, dns_re
 
 static int _dns_server_process_smartdns_domain(struct dns_request *request)
 {
-	struct dns_rule_flags *rule_flag = NULL;
+	struct _dns_rule_flags *rule_flag = NULL;
 	unsigned int flags = 0;
 
 	/* get domain rule flag */
-	rule_flag = _dns_server_get_dns_rule(request, DOMAIN_RULE_FLAGS);
+	rule_flag = _dns_server_get_domain_rule_flags(request);
 	if (rule_flag == NULL) {
 		return -1;
 	}
 
-	if (_dns_server_is_dns_rule_extract_match(request, DOMAIN_RULE_FLAGS) == 0) {
+	if (_dns_server_is_domain_rule_flags_extract_match(request) == 0) {
 		return -1;
 	}
 
@@ -6815,7 +6838,7 @@ static int _dns_server_query_dualstack(struct dns_request *request)
 	ret = _dns_server_do_query(request_dualstack, 0);
 	if (ret != 0) {
 		request->request_wait--;
-		tlog(TLOG_ERROR, "do query %s type %d failed.\n", request->domain, qtype);
+		tlog(TLOG_DEBUG, "do query %s type %d failed.\n", request->domain, qtype);
 		goto errout;
 	}
 
diff --git a/src/include/art.h b/src/include/art.h
index 4bcbeb0..943b62b 100644
--- a/src/include/art.h
+++ b/src/include/art.h
@@ -57,9 +57,9 @@ typedef int(*art_callback)(void *data, const unsigned char *key, uint32_t key_le
  * of all the various node sizes
  */
 typedef struct {
+    uint32_t partial_len;
     uint8_t type;
     uint8_t num_children;
-    uint32_t partial_len;
     unsigned char partial[MAX_PREFIX_LEN];
 } art_node;
 
@@ -106,7 +106,7 @@ typedef struct {
 typedef struct {
     void *value;
     uint32_t key_len;
-    unsigned char key[0];
+    unsigned char key[4];
 } art_leaf;
 
 /**
@@ -181,20 +181,10 @@ void* art_delete(art_tree *t, const unsigned char *key, int key_len);
  * @arg key The key
  * @arg key_len The length of the key
  * @return NULL if the item was not found, otherwise
- * the value pointer is returned.
+ * the pointer to value is returned.
  */
 void* art_search(const art_tree *t, const unsigned char *key, int key_len);
 
-/**
- * Searches substring for a value in the ART tree
- * @arg t The tree
- * @arg str The key
- * @arg str_len The length of the key
- * @return NULL if the item was not found, otherwise
- * the value pointer is returned.
- */
-void *art_substring(const art_tree *t, const unsigned char *str, int str_len, unsigned char *key, int *key_len);
-
 /**
  * Wakk substring for a value in the ART tree
  * @arg t The tree
diff --git a/src/include/stringutil.h b/src/include/stringutil.h
index 97dbb6f..edf07b8 100644
--- a/src/include/stringutil.h
+++ b/src/include/stringutil.h
@@ -22,7 +22,7 @@
 #include <stddef.h>
 #include <string.h>
 
-static inline char *safe_strncpy(char *dest, const char *src, size_t n) 
+static inline char *safe_strncpy(char *dest, const char *src, size_t n)
 {
 	if (src == NULL) {
 		dest[0] = '\0';
@@ -32,7 +32,7 @@ static inline char *safe_strncpy(char *dest, const char *src, size_t n)
 	if (n <= 0) {
 		return NULL;
 	}
-	
+
 #if __GNUC__  > 7
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wstringop-truncation"
@@ -47,5 +47,7 @@ static inline char *safe_strncpy(char *dest, const char *src, size_t n)
 	return ret;
 }
 
+size_t
+strlcpy(char *dst, const char *src, size_t siz);
 
-#endif
+#endif
\ No newline at end of file
diff --git a/src/lib/art.c b/src/lib/art.c
index 327a8a5..1269363 100644
--- a/src/lib/art.c
+++ b/src/lib/art.c
@@ -24,6 +24,10 @@ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #include <stdlib.h>
 #include <string.h>
 #include <strings.h>
@@ -31,13 +35,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <assert.h>
 #include "art.h"
 
-// #ifdef __i386__
-//     #include <emmintrin.h>
-// #else
 #ifdef __amd64__
     #include <emmintrin.h>
 #endif
-// #endif
+
+// compare the full partial (compressed inner path)
+#define BEHAVE_PESSIMISTIC 0
+// skip partial
+#define BEHAVE_OPTIMISTIC 1
 
 /**
  * Macros to manipulate pointer tags
@@ -124,8 +129,8 @@ static void destroy_node(art_node *n) {
         case NODE48:
             p.p3 = (art_node48*)n;
             for (i=0;i<256;i++) {
-                idx = ((art_node48*)n)->keys[i]; 
-                if (!idx) continue; 
+                idx = p.p3->keys[i];
+                if (!idx) continue;
                 destroy_node(p.p3->children[idx-1]);
             }
             break;
@@ -188,17 +193,6 @@ static art_node** find_child(art_node *n, unsigned char c) {
             p.p2 = (art_node16*)n;
 
             // support non-86 architectures
-
-            // #ifdef __i386__
-            //     // Compare the key to all 16 stored keys
-            //     __m128i cmp;
-            //     cmp = _mm_cmpeq_epi8(_mm_set1_epi8(c),
-            //             _mm_loadu_si128((__m128i*)p.p2->keys));
-                
-            //     // Use a mask to ignore children that don't exist
-            //     mask = (1 << n->num_children) - 1;
-            //     bitfield = _mm_movemask_epi8(cmp) & mask;
-            // #else
             #ifdef __amd64__
                 // Compare the key to all 16 stored keys
                 __m128i cmp;
@@ -220,7 +214,6 @@ static art_node** find_child(art_node *n, unsigned char c) {
                 mask = (1 << n->num_children) - 1;
                 bitfield &= mask;
             #endif
-            // #endif
 
             /*
              * If we have a match (any bit set) then we can
@@ -295,13 +288,14 @@ void* art_search(const art_tree *t, const unsigned char *key, int key_len) {
     art_node **child;
     art_node *n = t->root;
     int prefix_len, depth = 0;
+    int behave = BEHAVE_PESSIMISTIC;
     while (n) {
         // Might be a leaf
         if (IS_LEAF(n)) {
             n = (art_node*)LEAF_RAW(n);
             // Check if the expanded path matches
-            if (!leaf_matches((art_leaf*)n, key, key_len, depth)) {
-                return ((art_leaf*)n)->value;
+            if (!leaf_matches((art_leaf*)n, key, key_len, behave == BEHAVE_PESSIMISTIC ? depth : 0)) {
+                return (void *)&((art_leaf*)n)->value;
             }
             return NULL;
         }
@@ -311,6 +305,9 @@ void* art_search(const art_tree *t, const unsigned char *key, int key_len) {
             prefix_len = check_prefix(n, key, key_len, depth);
             if (prefix_len != min(MAX_PREFIX_LEN, n->partial_len))
                 return NULL;
+            if (n->partial_len > MAX_PREFIX_LEN) {
+                behave = BEHAVE_OPTIMISTIC;
+            }
             depth = depth + n->partial_len;
         }
 
@@ -374,6 +371,32 @@ static art_leaf* maximum(const art_node *n) {
     }
 }
 
+// Find any leaf to get full partial
+static art_leaf* any_leaf(const art_node *n) {
+    // Handle base cases
+    if (!n) return NULL;
+    if (IS_LEAF(n)) return LEAF_RAW(n);
+
+    int idx;
+    switch (n->type) {
+        case NODE4:
+            return any_leaf(((const art_node4*)n)->children[0]);
+        case NODE16:
+            return any_leaf(((const art_node16*)n)->children[0]);
+        case NODE48:
+            idx=0;
+            // children[c] resets to null in `remove_child48`
+            while (!((const art_node48*)n)->children[idx]) idx++;
+            return any_leaf(((const art_node48*)n)->children[idx]);
+        case NODE256:
+            idx=0;
+            while (!((const art_node256*)n)->children[idx]) idx++;
+            return any_leaf(((const art_node256*)n)->children[idx]);
+        default:
+            abort();
+    }
+}
+
 /**
  * Returns the minimum valued leaf
  */
@@ -389,11 +412,12 @@ art_leaf* art_maximum(art_tree *t) {
 }
 
 static art_leaf* make_leaf(const unsigned char *key, int key_len, void *value) {
-    art_leaf *l = (art_leaf*)calloc(1, sizeof(art_leaf)+key_len+1);
+    int flexible_size = key_len + 1 <= 4 ? 0 : key_len + 1 - 4;
+    art_leaf *l = (art_leaf*)calloc(1, sizeof(art_leaf) + flexible_size);
     if (l == NULL) {
 		return NULL;
 	}
-    
+
     l->value = value;
     l->key_len = key_len;
     memcpy(l->key, key, key_len);
@@ -447,18 +471,8 @@ static void add_child48(art_node48 *n, art_node **ref, unsigned char c, void *ch
 static void add_child16(art_node16 *n, art_node **ref, unsigned char c, void *child) {
     if (n->n.num_children < 16) {
         unsigned mask = (1 << n->n.num_children) - 1;
-        
-        // support non-x86 architectures
-        // #ifdef __i386__
-        //     __m128i cmp;
-
-        //     // Compare the key to all 16 stored keys
-        //     cmp = _mm_cmplt_epi8(_mm_set1_epi8(c),
-        //             _mm_loadu_si128((__m128i*)n->keys));
 
-        //     // Use a mask to ignore children that don't exist
-        //     unsigned bitfield = _mm_movemask_epi8(cmp) & mask;
-        // #else
+        // support non-x86 architectures
         #ifdef __amd64__
             __m128i cmp;
 
@@ -478,9 +492,8 @@ static void add_child16(art_node16 *n, art_node **ref, unsigned char c, void *ch
             }
 
             // Use a mask to ignore children that don't exist
-            bitfield &= mask;    
+            bitfield &= mask;
         #endif
-        // #endif
 
         // Check if less than any
         unsigned idx;
@@ -562,9 +575,10 @@ static void add_child(art_node *n, art_node **ref, unsigned char c, void *child)
 }
 
 /**
- * Calculates the index at which the prefixes mismatch
+ * Calculates the longest common prefix of partial and key.
+ * Similar to check_prefix, but check the full partial.
  */
-static int prefix_mismatch(const art_node *n, const unsigned char *key, int key_len, int depth) {
+static int partial_match(const art_node *n, const unsigned char *key, int key_len, int depth) {
     int max_cmp = min(min(MAX_PREFIX_LEN, n->partial_len), key_len - depth);
     int idx;
     for (idx=0; idx < max_cmp; idx++) {
@@ -572,11 +586,16 @@ static int prefix_mismatch(const art_node *n, const unsigned char *key, int key_
             return idx;
     }
 
+    // If the key is fully matched we can avoid finding a leaf
+    if (depth + idx == key_len) {
+        return idx;
+    }
+
     // If the prefix is short we can avoid finding a leaf
     if (n->partial_len > MAX_PREFIX_LEN) {
         // Prefix is longer than what we've checked, find a leaf
-        art_leaf *l = minimum(n);
-        max_cmp = min(l->key_len, key_len)- depth;
+        art_leaf *l = any_leaf(n);
+        max_cmp = min(n->partial_len, key_len - depth);
         for (; idx < max_cmp; idx++) {
             if (l->key[idx+depth] != key[depth+idx])
                 return idx;
@@ -624,7 +643,7 @@ static void* recursive_insert(art_node *n, art_node **ref, const unsigned char *
     // Check if given node has a prefix
     if (n->partial_len) {
         // Determine if the prefixes differ, since we need to split
-        int prefix_diff = prefix_mismatch(n, key, key_len, depth);
+        int prefix_diff = partial_match(n, key, key_len, depth);
         if ((uint32_t)prefix_diff >= n->partial_len) {
             depth += n->partial_len;
             goto RECURSE_SEARCH;
@@ -972,20 +991,14 @@ int art_iter_prefix(art_tree *t, const unsigned char *key, int key_len, art_call
 
         // Bail if the prefix does not match
         if (n->partial_len) {
-            prefix_len = prefix_mismatch(n, key, key_len, depth);
-
-            // Guard if the mis-match is longer than the MAX_PREFIX_LEN
-            if ((uint32_t)prefix_len > n->partial_len) {
-                prefix_len = n->partial_len;
-            }
-
-            // If there is no match, search is terminated
-            if (!prefix_len) {
-                return 0;
+            prefix_len = partial_match(n, key, key_len, depth);
 
             // If we've matched the prefix, iterate on this node
-            } else if (depth + prefix_len == key_len) {
+            if (depth + prefix_len == key_len) {
                 return recursive_iter(n, cb, data);
+            // If there is a mismatch, search is terminated
+            } else if ((uint32_t)prefix_len < n->partial_len) {
+                return 0;
             }
 
             // if there is a full match, go deeper
@@ -1000,95 +1013,34 @@ int art_iter_prefix(art_tree *t, const unsigned char *key, int key_len, art_call
     return 0;
 }
 
-static int str_prefix_matches(const art_leaf *n, const unsigned char *str, int str_len) {
-    // Fail if the key length is too short
+/*
+ * Similar to leaf_prefix_matches, but checks if the leaf key is a prefix of
+ * the given string.
+ */
+static int str_prefix_matches(const art_leaf *n, const unsigned char *str, int str_len, int depth) {
+    // Fail if the str length is too short
     if (n->key_len > (uint32_t)str_len) return 1;
 
     // Compare the keys
-    return memcmp(str, n->key, n->key_len);
-}
-
-static void art_copy_key(art_leaf *leaf, unsigned char *key, int *key_len)
-{
-	int len;
-
-    if (key == NULL || key_len == NULL) {
-		return;
-	}
-
-	len = (int)leaf->key_len > *key_len ? *key_len : (int)leaf->key_len;
-	memcpy(key, leaf->key, len);
-	*key_len = len;
-}
-
-void *art_substring(const art_tree *t, const unsigned char *str, int str_len, unsigned char *key, int *key_len)
-{
-    art_node **child;
-    art_node *n = t->root;
-    art_node *m;    
-    art_leaf *found = NULL;
-    int prefix_len, depth = 0;
-
-    while (n) {
-        // Might be a leaf
-        if (IS_LEAF(n)) {
-            n = (art_node*)LEAF_RAW(n);
-            // Check if the expanded path matches
-            if (!str_prefix_matches((art_leaf*)n, str, str_len)) {
-                found = (art_leaf*)n;
-			}
-            break;
-        }
-
-        // Check if current is leaf
-    	child = find_child(n, 0);
-    	m = (child) ? *child : NULL;
-    	if (m && IS_LEAF(m)) {
-            m = (art_node*)LEAF_RAW(m);
-            // Check if the expanded path matches
-            if (!str_prefix_matches((art_leaf*)m, str, str_len)) {
-                found = (art_leaf*)m;
-            }
-    	}
-
-        // Bail if the prefix does not match
-        if (n->partial_len) {
-            prefix_len = check_prefix(n, str, str_len, depth);
-            if (prefix_len != min(MAX_PREFIX_LEN, n->partial_len))
-                break;
-            depth = depth + n->partial_len;
-        }
-
-        // Recursively search
-        child = find_child(n, str[depth]);
-        n = (child) ? *child : NULL;
-        depth++;
-    }
-
-    if (found == NULL) {
-        return NULL;
-    }
-
-    art_copy_key(found, key, key_len);
-
-    return found->value;
+    return memcmp(str + depth, n->key + depth, n->key_len - depth);
 }
 
 void art_substring_walk(const art_tree *t, const unsigned char *str, int str_len, walk_func func, void *arg)
 {
     art_node **child;
     art_node *n = t->root;
-    art_node *m;    
+    art_node *m;
     art_leaf *found = NULL;
     int prefix_len, depth = 0;
 	int stop_search = 0;
+    int behave = BEHAVE_PESSIMISTIC;
 
 	while (n && stop_search == 0) {
         // Might be a leaf
         if (IS_LEAF(n)) {
             n = (art_node*)LEAF_RAW(n);
             // Check if the expanded path matches
-            if (!str_prefix_matches((art_leaf*)n, str, str_len)) {
+            if (!str_prefix_matches((art_leaf*)n, str, str_len, behave == BEHAVE_PESSIMISTIC ? depth : 0)) {
                 found = (art_leaf*)n;
 				func(found->key, found->key_len, found->key_len != (uint32_t)str_len, found->value, arg);
 			}
@@ -1101,29 +1053,36 @@ void art_substring_walk(const art_tree *t, const unsigned char *str, int str_len
     	if (m && IS_LEAF(m)) {
             m = (art_node*)LEAF_RAW(m);
             // Check if the expanded path matches
-            if (!str_prefix_matches((art_leaf*)m, str, str_len)) {
+            if (!str_prefix_matches((art_leaf*)m, str, str_len, behave == BEHAVE_PESSIMISTIC ? depth : 0)) {
                 found = (art_leaf*)m;
                 stop_search = func(found->key, found->key_len, found->key_len != (uint32_t)str_len, found->value, arg);
+                // avoid calling this leaf again
+                if (found->key_len == (uint32_t)str_len) {
+                    break;
+                }
+                behave = BEHAVE_PESSIMISTIC;
+            } else {
+                break;
             }
-    	}
-
-        // Bail if the prefix does not match
-        if (n->partial_len) {
+            // Bail if the prefix does not match
+    	} else if (n->partial_len) {
             prefix_len = check_prefix(n, str, str_len, depth);
             if (prefix_len != min(MAX_PREFIX_LEN, n->partial_len))
                 break;
-            depth = depth + n->partial_len;
+            if (n->partial_len > MAX_PREFIX_LEN) {
+                behave = BEHAVE_OPTIMISTIC;
+            }
         }
+        // It's possible that the new_depth > str_len
+        depth = depth + n->partial_len;
 
         // Recursively search
         child = find_child(n, str[depth]);
         n = (child) ? *child : NULL;
         depth++;
     }
+}
 
-    if (found == NULL) {
-        return ;
-    }
-
-    return ;
+#ifdef __cplusplus
 }
+#endif
\ No newline at end of file
diff --git a/src/smartdns.c b/src/smartdns.c
index bfc0474..05b8741 100644
--- a/src/smartdns.c
+++ b/src/smartdns.c
@@ -234,6 +234,7 @@ static int _smartdns_prepare_server_flags(struct client_dns_server_flags *flags,
 	flags->drop_packet_latency_ms = server->drop_packet_latency_ms;
 	flags->tcp_keepalive = server->tcp_keepalive;
 	flags->subnet_all_query_types = server->subnet_all_query_types;
+	flags->fallback = server->fallback;
 	safe_strncpy(flags->proxyname, server->proxyname, sizeof(flags->proxyname));
 	safe_strncpy(flags->ifname, server->ifname, sizeof(flags->ifname));
 	if (server->ipv4_ecs.enable) {
diff --git a/src/stringutil.c b/src/stringutil.c
new file mode 100644
index 0000000..ff49ccb
--- /dev/null
+++ b/src/stringutil.c
@@ -0,0 +1,53 @@
+/*	$OpenBSD: strlcpy.c,v 1.10 2005/08/08 08:05:37 espie Exp $	*/
+
+/*
+ * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/types.h>
+#include <string.h>
+
+#include "stringutil.h"
+
+/*
+ * Copy src to string dst of size siz.  At most siz-1 characters
+ * will be copied.  Always NUL terminates (unless siz == 0).
+ * Returns strlen(src); if retval >= siz, truncation occurred.
+ */
+size_t
+strlcpy(char *dst, const char *src, size_t siz)
+{
+	char *d = dst;
+	const char *s = src;
+	size_t n = siz;
+
+	/* Copy as many bytes as will fit */
+	if (n != 0 && --n != 0) {
+		do {
+			if ((*d++ = *s++) == 0)
+				break;
+		} while (--n != 0);
+	}
+
+	/* Not enough room in dst, add NUL and traverse rest of src */
+	if (n == 0) {
+		if (siz != 0)
+			*d = '\0';		/* NUL-terminate dst */
+		while (*s++)
+			;
+	}
+
+	return(s - src - 1);	/* count does not include NUL */
+}
\ No newline at end of file
diff --git a/src/tlog.c b/src/tlog.c
index db88af4..07b3f59 100644
--- a/src/tlog.c
+++ b/src/tlog.c
@@ -7,6 +7,7 @@
 #define _GNU_SOURCE
 #endif
 #include "tlog.h"
+#include "stringutil.h"
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -201,8 +202,7 @@ static int _tlog_mkdir(const char *path)
         path++;
     }
 
-    strncpy(path_c, path, sizeof(path_c) - 1);
-    path_c[sizeof(path_c) - 1] = '\0';
+    strlcpy(path_c, path, sizeof(path_c));
     len = strnlen(path_c, sizeof(path_c) - 1);
     path_c[len] = '/';
     path_c[len + 1] = '\0';
@@ -671,7 +671,7 @@ int tlog_stdout_with_color(tlog_level level, const char *buff, int bufflen)
         fprintf(stdout, "%s", buff);
     }
 
-    return bufflen;    
+    return bufflen;
 }
 
 static int _tlog_early_print(struct tlog_info_inter *info_inter, const char *format, va_list ap)
@@ -891,8 +891,7 @@ static int _tlog_get_oldest_callback(const char *path, struct dirent *entry, voi
 
     if (oldestlog->mtime == 0 || oldestlog->mtime > sb.st_mtime) {
         oldestlog->mtime = sb.st_mtime;
-        strncpy(oldestlog->name, entry->d_name, sizeof(oldestlog->name));
-        oldestlog->name[sizeof(oldestlog->name) - 1] = '\0';
+        strlcpy(oldestlog->name, entry->d_name, sizeof(oldestlog->name));
         return 0;
     }
 
@@ -1205,14 +1204,10 @@ static void _tlog_get_log_name_dir(struct tlog_log *log)
     }
 
     pthread_mutex_lock(&tlog.lock);
-    strncpy(log_file, log->pending_logfile, sizeof(log_file) - 1);
-    log_file[sizeof(log_file) - 1] = '\0';
-    strncpy(log->logdir, dirname(log_file), sizeof(log->logdir) - 1);
-    log->logdir[sizeof(log->logdir) - 1] = '\0';
-    strncpy(log_file, log->pending_logfile, PATH_MAX);
-    log_file[sizeof(log_file) - 1] = '\0';
-    strncpy(log->logname, basename(log_file), sizeof(log->logname) - 1);
-    log->logname[sizeof(log->logname) - 1] = '\0';
+    strlcpy(log_file, log->pending_logfile, sizeof(log_file));
+    strlcpy(log->logdir, dirname(log_file), sizeof(log->logdir));
+    strlcpy(log_file, log->pending_logfile, sizeof(log_file));
+    strlcpy(log->logname, basename(log_file), sizeof(log->logname));
     pthread_mutex_unlock(&tlog.lock);
 }
 
@@ -1530,7 +1525,7 @@ static void _tlog_write_one_segment_log(struct tlog_log *log, char *buff, int bu
         if (segment_head->magic != TLOG_SEGMENT_MAGIC) {
             return;
         }
-        
+
         _tlog_write_output_func(log, segment_head->data, segment_head->len - 1);
         write_len += segment_head->len + sizeof(*segment_head);
         segment_head = (struct tlog_segment_head *)(buff + write_len);
diff --git a/src/util.h b/src/util.h
index 8e33d97..ab9cb91 100644
--- a/src/util.h
+++ b/src/util.h
@@ -19,6 +19,7 @@
 #ifndef SMART_DNS_UTIL_H
 #define SMART_DNS_UTIL_H
 
+#include "common.h"
 #include "stringutil.h"
 #include <netdb.h>
 #include <time.h>
diff --git a/test/cases/test-domain-rules.cc b/test/cases/test-domain-rules.cc
new file mode 100644
index 0000000..488a3e3
--- /dev/null
+++ b/test/cases/test-domain-rules.cc
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * Copyright (C) 2018-2024 Ruilin Peng (Nick) <pymumu@gmail.com>.
+ *
+ * smartdns is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * smartdns is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "dns_rules.h"
+#include "gtest/gtest.h"
+
+#include <map>
+
+class DomainRules : public ::testing::Test
+{
+  protected:
+	virtual void SetUp() {}
+	virtual void TearDown() {}
+};
+
+TEST_F(DomainRules, order)
+{
+	struct dns_domain_rule _domain_rule;
+	struct dns_domain_rule *domain_rule = &_domain_rule;
+	domain_rule_init(domain_rule);
+	ASSERT_NE(domain_rule, nullptr);
+
+	std::map<int, struct dns_rule *> rules;
+	domain_rule_set_flag(domain_rule, DOMAIN_FLAG_ADDR_SOA);
+	for (int i = 0; i < DOMAIN_RULE_MAX; ++i) {
+		struct dns_rule *rule = (struct dns_rule *)_new_dns_rule((enum domain_rule)i);
+		EXPECT_NE(rule, nullptr);
+		rules[i] = rule;
+		EXPECT_EQ(domain_rule_set(domain_rule, (enum domain_rule)i, rule), 0);
+	}
+
+	unsigned int flags;
+	EXPECT_EQ(domain_rule_get_flags(domain_rule, &flags), 0);
+	EXPECT_EQ(flags, DOMAIN_FLAG_ADDR_SOA);
+	for (int i = 1; i < DOMAIN_RULE_MAX; ++i) {
+		EXPECT_EQ(domain_rule_get(domain_rule, (enum domain_rule)i), rules[i]);
+	}
+
+	domain_rule_set_flag(domain_rule, DOMAIN_FLAG_DUALSTACK_SELECT);
+	EXPECT_EQ(domain_rule_get_flags(domain_rule, &flags), 0);
+	EXPECT_EQ(flags, DOMAIN_FLAG_ADDR_SOA | DOMAIN_FLAG_DUALSTACK_SELECT);
+	domain_rule_set_flag(domain_rule, DOMAIN_FLAG_NO_DUALSTACK_SELECT);
+	EXPECT_EQ(domain_rule_get_flags(domain_rule, &flags), 0);
+	EXPECT_EQ(flags, DOMAIN_FLAG_ADDR_SOA | DOMAIN_FLAG_NO_DUALSTACK_SELECT);
+	EXPECT_EQ(domain_rule_free(domain_rule), 0);
+}
diff --git a/test/cases/test-server.cc b/test/cases/test-server.cc
index d8fd75f..1437325 100644
--- a/test/cases/test-server.cc
+++ b/test/cases/test-server.cc
@@ -272,4 +272,62 @@ dualstack-ip-selection no
 	ASSERT_EQ(client.GetAnswerNum(), 0);
 	EXPECT_EQ(client.GetStatus(), "REFUSED");
 	EXPECT_LT(client.GetQueryTime(), 100);
-}
\ No newline at end of file
+}
+
+TEST_F(Server, fallback)
+{
+	smartdns::MockServer server_upstream;
+	smartdns::Server server;
+
+	server_upstream.Start("udp://0.0.0.0:61053", [](struct smartdns::ServerRequestContext *request) {
+		if (request->qtype != DNS_T_A) {
+			return smartdns::SERVER_REQUEST_SOA;
+		}
+		smartdns::MockServer::AddIP(request, request->domain.c_str(), "1.2.3.4", 611);
+		return smartdns::SERVER_REQUEST_OK;
+	});
+
+	server.MockPing(PING_TYPE_ICMP, "2001::", 128, 10000);
+	server.Start(R"""(bind [::]:60053
+bind-tcp [::]:60053
+server 127.0.0.1:61053 -fallback
+server 127.0.0.1:61054
+)""");
+	smartdns::Client client;
+	ASSERT_TRUE(client.Query("a.com", 60053));
+	std::cout << client.GetResult() << std::endl;
+	ASSERT_EQ(client.GetAnswerNum(), 1);
+	EXPECT_GE(client.GetQueryTime(), 1000);
+	EXPECT_EQ(client.GetStatus(), "NOERROR");
+	EXPECT_EQ(client.GetAnswer()[0].GetName(), "a.com");
+	EXPECT_EQ(client.GetAnswer()[0].GetData(), "1.2.3.4");
+}
+
+TEST_F(Server, fallback_group)
+{
+	smartdns::MockServer server_upstream;
+	smartdns::Server server;
+
+	server_upstream.Start("udp://0.0.0.0:61053", [](struct smartdns::ServerRequestContext *request) {
+		if (request->qtype != DNS_T_A) {
+			return smartdns::SERVER_REQUEST_SOA;
+		}
+		smartdns::MockServer::AddIP(request, request->domain.c_str(), "1.2.3.4", 611);
+		return smartdns::SERVER_REQUEST_OK;
+	});
+
+	server.MockPing(PING_TYPE_ICMP, "2001::", 128, 10000);
+	server.Start(R"""(bind [::]:60053
+bind-tcp [::]:60053
+server 127.0.0.1:61053 -e -group fallback
+server 127.0.0.1:61054
+)""");
+	smartdns::Client client;
+	ASSERT_TRUE(client.Query("a.com", 60053));
+	std::cout << client.GetResult() << std::endl;
+	ASSERT_EQ(client.GetAnswerNum(), 1);
+	EXPECT_GE(client.GetQueryTime(), 1000);
+	EXPECT_EQ(client.GetStatus(), "NOERROR");
+	EXPECT_EQ(client.GetAnswer()[0].GetName(), "a.com");
+	EXPECT_EQ(client.GetAnswer()[0].GetData(), "1.2.3.4");
+}
-- 
2.34.1

