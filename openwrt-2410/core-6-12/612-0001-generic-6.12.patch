From c264f545d38cf29c983045f18575a0289a71bc5f Mon Sep 17 00:00:00 2001
From: Daniel Golle <daniel@makrotopia.org>
Date: Thu, 8 May 2025 03:01:07 +0100
Subject: [PATCH 1/4] generic: 6.12 The MediaTek Ethernet PHY drivers are going
 to be used by multiple targets (airoha, mediatek, ramips). Add generic
 backports of changes required for recently added Ethernet PHYs.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Daniel Golle <daniel@makrotopia.org>
generic: 6.12: mtk_eth_soc: adapt downstream SerDes patch

While it will hopefully be replaced soon by an upstream solution for
now we keep the downstream SerDes PCS implementation for MT7988A.
In order to make it work with upstream mt7988a.dtsi we have to
compensate for the changed start address of topmisc which was
moved from 0x11d10000 to 0x11d10084 to accomodate a future power
domain controller located at 0x11d10000~0x11d10080.
Hence we need to change TOP_MISC_NETSYS_PCS_MUX from 0x84 to 0x0, so
the Ethernet path/mux selection can work with upstream mt7988a.dtsi.

Signed-off-by: Daniel Golle <daniel@makrotopia.org>
generic: 6.12: fix patch adding EEE-support to mtk_eth_soc

Upstream now uses struct ethtool_keee instead of struct ethtool_eee
as parameter to EEE-related functions. Follow that change and modify
the patch accordingly.

Signed-off-by: Daniel Golle <daniel@makrotopia.org>
generic: net: phy: rtl8261n: fix build with Linux 6.12

Mark functions which aren't exported as static to fix build with
Linux 6.12.

Signed-off-by: Daniel Golle <daniel@makrotopia.org>
generic: import rtl8261n patches from mediatek

RTL8261N is used on some Airoha and Realtek devices. Move the driver
from Mediatek to generic so it can be used everywhere.

Signed-off-by: Andrew LaMarche <andrewjlamarche@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18163
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>

# Conflicts:
#	target/linux/siflower/patches-6.6/019-net-phy-add-support-for-Siflower-SF23P1211-SF23P1240.patch
generic: 6.12: add hack patch for transition to new partition bindings

Commit fa0f130764 ("generic: 6.12: update block NVMEM driver") switched
to the upstream DT bindings for block partitions.

Bring back the old/legacy downstream way to assign the OF node to a
block device or partition in order to allow sharing a single DTS for
both, Linux 6.6 (which exclusively uses the old/legacy binding) and
Linux 6.12 (which will now support both, new/upstream binding and the
old/legacy binding).

Once we drop Linux 6.6 and all boards have been converted to the new
binding we can drop this patch.

Signed-off-by: Daniel Golle <daniel@makrotopia.org>
generic: 6.12: add missing Kconfig symbol

Augmented symbol CONFIG_SND_SOC_MT8365 was missing, add it.

Signed-off-by: Daniel Golle <daniel@makrotopia.org>
ath10k-ct:sync with main 20250518

Signed-off-by: lunatickochiya <125438787@qq.com>
mt76:sync with main 20250518

Signed-off-by: lunatickochiya <125438787@qq.com>
Revertmac80211 makefile  "Auxiliary commit to revert individual files from
02102798883007afa3d28056fd588e4681f64155
mac80211:sync with main 20250518
qca-nss-dp: update for 6.12 compatibility
qca-ssdk: update for 6.12 compatibility
rtl8812au-ct: fix netdevice notifier call warning

rtw_ndev_notifier_call should ignore network devices created by other drivers, and it does so,
but when CONFIG_WIRELESS_EXT=n, it does not behave as expected.

Signed-off-by: Liangbin Lian <jjm2473@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18801
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
apm821xx: replace kmod-usb3 with kmod-usb-xhci-pci-renesas

The dependency of kmod-usb3 and kmod-usb-xhci-pci-renesas have
been reversed. Now we need to select kmod-usb-xhci-pci-renesas
instead of kmod-usb3.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18768
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
kernel: modules: update dependency for kmod-usb-xhci-pci-renesas

Now kmod-usb-xhci-pci-renesas is depend on kmod-usb3 on both
6.6 and 6.12 kernels. Also remove the hidden flag so that users
can select it from menuconfig. Fix the following error:

Package kmod-usb-xhci-pci-renesas is missing dependencies for the following libraries:
xhci-pci.ko

Link: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=25f51b76f90f10f9bf2fbc05fc51cf685da7ccad
Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18768
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
generic: fix disable common USB quirks patch

Remove modifications for codes guarded by CONFIG_USB_PCI_AMD.
This kernel symbol is only visible on desktop level platform,
e.g. x86. They are not sensitive to firmware image size. This
patch also fixes function redefinition build errors:

drivers/usb/host/pci-quirks.c:621:6: error: redefinition of 'usb_asmedia_modifyflowcontrol'
  621 | void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev)
      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from drivers/usb/host/pci-quirks.c:22:
drivers/usb/host/pci-quirks.h:49:20: note: previous definition of 'usb_asmedia_modifyflowcontrol' with type 'void(struct pci_dev *)'
   49 | static inline void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev) {}
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fixes: be6753dda00c ("generic: 6.12: manually rebuild pending patches")
Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18637
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
qca-ssdk: use OpenWrt GIT repo as upstream

Instead of having to deal with patch files, lets use the newly made
OpenWrt GIT repo as the SSDK upstream[1].

All existing patches have been applied to the same source commit, so
there should be no intended changes.

[1] https://github.com/openwrt/qca-ssdk.git

Signed-off-by: Robert Marko <robimarko@gmail.com>
nat46: bump to latest git HEAD 2025-04-23

This new version introduces many compilation error fixes for
the upcoming 6.12 kernel. Changelogs:

04923c5 "Fix build failures observed so far" - take three.
b4263cc "Fix build failures observed so far" - take two.
de595b4 Fix build failures observed so far
1c0066a Zero checksum handling for UDP4->UDP6
b42c37d Fix crash when viewing nat46 kernel module config
3a9f630 nat46-module: fix modpost warning
88b91ca gha: use checkout@v4 action instead of checkout@v2
84ba13a gha: enable github action on push/PR
f367088 fix the compilation error
03c14bf gha: clean-up the yaml definition
d964921 Create c-compile.yml
cb69317  "Add network namespace awareness to nat46" - take two.
8302f42 Revert "Add network namespace awareness to nat46"
91b8e68 Add network namespace awareness to nat46

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
generic: 6.12: add CONFIG_IDPF

CONFIG_IDPF is Intel(R) Infrastructure Data Path Function Support and it
should be disabled by default, if needed it can be packaged as a kmod.

Disable to prevent spreading out through target configs.

Signed-off-by: Robert Marko <robimarko@gmail.com>
generic: 6.12: add CONFIG_HISILICON_ERRATUM_162100801

Noticed that CONFIG_HISILICON_ERRATUM_162100801 was being added to
qualcommax 6.12 config.

Since we dont support any Hisilicon chips, disable it in generic config
before it starts spreading in target configs.

Signed-off-by: Robert Marko <robimarko@gmail.com>
firmware: add package for Intel VPU/NPU firmware

Intel NPU device is an AI inference accelerator integrated with Intel
client CPUs, starting from Intel Core Ultra generation of CPUs
(formerly known as Meteor Lake). It enables energy-efficient execution
of artificial neural network tasks.

The full device name is Neural Processing Unit, but the Linux kernel
driver uses the older name - Versatile Processing Unit (VPU).

This package is for NPU/VPU firmware.

Details in https://github.com/intel/linux-npu-driver

Intel VPU firmware is now part of linux-firmware.

The current FW file names in linux-firmware do not match intel vpu
driver, create links to fix it

details in
https://github.com/torvalds/linux/blob/master/drivers/accel/ivpu/ivpu_fw.c

Signed-off-by: Joe Zheng <joe.zheng@intel.com>
Link: https://github.com/openwrt/openwrt/pull/17904
Signed-off-by: Robert Marko <robimarko@gmail.com>
generic: 6.12: add missing symbols

Add missing symbols found during moving sifiveu and d1 to 6.12.

Signed-off-by: Zoltan HERPAI <wigyori@uid0.hu>
generic: config-filter: filter out CONFIG_PAHOLE_HAS_LANG_EXCLUDE

CONFIG_PAHOLE_HAS_LANG_EXCLUDE is set depending on the pahole version
present, so it must be filtered out.

Signed-off-by: Robert Marko <robimarko@gmail.com>
kernel: mtk_bmt: counteracting calloc-transposed-args compiler warning

For kernel 6.12 there is a warning causing an error:
drivers/mtd/nand/mtk_bmt_v2.c: In function 'mtk_bmt_get_mapping_mask':
drivers/mtd/nand/mtk_bmt_v2.c:307:31: error: 'kmalloc_array_noprof' sizes specified with 'sizeof' in the earlier argument and not in the later argument [-Werror=calloc-transposed-args]
  307 |         used = kcalloc(sizeof(unsigned long), BIT_WORD(bmtd.bmt_blk_idx) + 1, GFP_KERNEL);
      |                               ^~~~~~~~

Swapping the arguments solves the problem.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18701
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-adsl-mei: fix missing-prototypes warnings

* Mark some functions as static.
* Add missing prototypes.

This patch fixes the following build warnings:

/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-adsl-mei-danube/ltq-adsl-mei/drv_mei_cpe.c:1182:1: error: no previous prototype for 'makeCMV' [-Werror=missing-prototypes]
 1182 | makeCMV (u8 opcode, u8 group, u16 address, u16 index, int size, u16 * data, u16 *CMVMSG)
      | ^~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-adsl-mei-danube/ltq-adsl-mei/drv_mei_cpe.c:1855:1: error: no previous prototype for 'DSL_BSP_ATMLedCBUnregister' [-Werror=missing-prototypes]
 1855 | DSL_BSP_ATMLedCBUnregister (int (*ifx_adsl_ledcallback) (void))
      | ^~~~~~~~~~~~~~~~~~~~~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-adsl-mei-danube/ltq-adsl-mei/drv_mei_cpe.c:2448:1: error: no previous prototype for 'IFX_MEI_Ioctls' [-Werror=missing-prototypes]
 2448 | IFX_MEI_Ioctls (DSL_DEV_Device_t * pDev, int from_kernel, unsigned int command, unsigned long lon)
      | ^~~~~~~~~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-adsl-mei-danube/ltq-adsl-mei/drv_mei_cpe.c:2699:5: error: no previous prototype for 'ifx_mei_atm_led_blink' [-Werror=missing-prototypes]
 2699 | int ifx_mei_atm_led_blink(void)
      |     ^~~~~~~~~~~~~~~~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-adsl-mei-danube/ltq-adsl-mei/drv_mei_cpe.c:2705:5: error: no previous prototype for 'ifx_mei_atm_showtime_check' [-Werror=missing-prototypes]
 2705 | int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-adsl-mei: fix 'inline' declaration warning

Adjust the 'inline' declaration order to fix the build warning:

/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-adsl-mei-danube/ltq-adsl-mei/drv_mei_cpe.c:188:1: error: 'inline' is not at beginning of declaration [-Werror=old-style-declaration]
  188 | static void inline MEI_MASK_AND_ACK_IRQ(int x)
      | ^~~~~~

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>

fix inline declaration warning

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-adsl: silence missing-prototypes warnings

There are a lot of missing-prototypes warnings, It's not worth to
fix them one by one. Let us just ignore them.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-adsl: add missing header platform_device.h

Fix incomplete type error by including the correct header.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vdsl-vr9-mei: fix missing prototypes warnings

* Mark some functions as static.
* Add missing prototypes.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vdsl-vr9-mei: fix ignored-qualifiers build warnings

These functions return the register memory addresses. Usually
they are fixed values, hence I think it's safe to remove the
qualifier "volatile".

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vdsl-vr9-mei: convert platform driver .remove to .remove_new

Convert .remove to .remove_new so that it can be compatible with
both 6.6 and 6.12 kernels.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vdsl-vr9: fix missing-prototypes warnings

* Mark some functions as static.
* Include function prototypes header file.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vmmc: fix 'inline' declaration warning

Adjust the 'inline' declaration order to fix the build warning.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vmmc: fix unknown type name errors

Include missing header "drv_vmmc_api.h" to fix the compilation errors.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vmmc: fix macro definition conflicts

Add LANTIQ prefix to workaround the build warnings.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vmmc: silence missing-prototypes warnings

There are a lot of missing-prototypes warnings, It's not worth to
fix them one by one.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vmmc: fix ignored-qualifiers warning

NULL and fixed addresses are constant, const qualifier are useless.

/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/mps/drv_mps_vmmc_ar9.c:47:1: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
   47 | const void (*ifx_bsp_basic_mps_decrypt)(unsigned int addr, int n) = NULL;
      | ^~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/mps/drv_mps_vmmc_ar9.c:246:49: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
  246 |                    ifx_bsp_basic_mps_decrypt = (const void (*)(unsigned int, int))0xbf0017c4;
      |                                                 ^~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/mps/drv_mps_vmmc_ar9.c:249:49: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
  249 |                    ifx_bsp_basic_mps_decrypt = (const void (*)(unsigned int, int))0xbf001ea4;
      |                                                 ^~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/mps/drv_mps_vmmc_ar9.c:252:49: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
  252 |                    ifx_bsp_basic_mps_decrypt = (const void (*)(unsigned int, int))0xbf001f38;
      |                                                 ^~~~~

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-ptm: adsl: fix 6.12 kernel build errors on lantiq/xway

Fix incomplete type error by including the correct header.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-ptm: vdsl: fix 6.12 kernel build errors on lantiq/xrx200

Add missing header to fix the build errors on 6.12 kernel.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-ptm: fix missing-prototypes warning

Mark cgu_get_pp32_clock() as static.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-deu: fix 6.12 kernel build warnings on lantiq/xway

This patch fixes the following build warnings by adding
missing prototypes:

/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-deu-danube/ltq-deu/ifxmips_deu_danube.c:100:5: error: no previous prototype for 'input_swap' [-Werror=missing-prototypes]
  100 | u32 input_swap(u32 input)
      |     ^~~~~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-deu-ar9/ltq-deu/ifxmips_deu_ar9.c:91:5: error: no previous prototype for 'input_swap' [-Werror=missing-prototypes]
   91 | u32 input_swap(u32 input)
      |     ^~~~~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-deu-ar9/ltq-deu/ifxmips_deu_ar9.c:131:6: error: no previous prototype for 'chip_version' [-Werror=missing-prototypes]
  131 | void chip_version(void)
      |      ^~~~~~~~~~~~

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-deu: fix 6.12 kernel build warnings on lantiq/xrx200

This patch fixes various missing-prototypes build warnings by:

* Mark some functions as static.
* Add missing prototypes.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-atm: fix missing-prototypes warnings for lantiq/ase

This patch fixes various missing-prototypes build warnings on
6.12 kernel.

/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_ase/ltq-atm-ase/ltq-atm/ifxmips_atm_amazon_se.c:257:13: error: no previous prototype for 'ase_fw_ver' [-Werror=missing-prototypes]
  257 | extern void ase_fw_ver(unsigned int *major, unsigned int *minor)
      |             ^~~~~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_ase/ltq-atm-ase/ltq-atm/ifxmips_atm_amazon_se.c:266:5: error: no previous prototype for 'ase_init' [-Werror=missing-prototypes]
  266 | int ase_init(struct platform_device *pdev)
      |     ^~~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_ase/ltq-atm-ase/ltq-atm/ifxmips_atm_amazon_se.c:283:6: error: no previous prototype for 'ase_shutdown' [-Werror=missing-prototypes]
  283 | void ase_shutdown(void)
      |      ^~~~~~~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_ase/ltq-atm-ase/ltq-atm/ifxmips_atm_amazon_se.c:297:5: error: no previous prototype for 'ase_start' [-Werror=missing-prototypes]
  297 | int ase_start(int pp32)
      |     ^~~~~~~~~
/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_ase/ltq-atm-ase/ltq-atm/ifxmips_atm_amazon_se.c:323:6: error: no previous prototype for 'ase_stop' [-Werror=missing-prototypes]
  323 | void ase_stop(int pp32)
      |      ^~~~~~~~

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-atm: fix build warnings on lantiq/xway

Mark some functions as static to fix various missing-prototypes
build warnings on 6.12 kernel.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-atm: add missing header mod_devicetable.h

fix undefined type error:

/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/ltq-atm-vr9/ltq-atm/ltq_atm.c:1776:43: error: invalid use of undefined type 'const struct of_device_id'
 1776 |         ops = (struct ltq_atm_ops *) match->data;
      |                                           ^~

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-atm: apply local patch to the source files

This package is maintained by the OpenWrt local repository. There
is no need to modify it with the patch file. Just apply all patches
to the source files.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-tapi: fix missing-prototypes build warnings

Mark some functions as static.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
vrx518_tc: fix missing-prototypes build warnings

* Mark some functions as static.
* Include function prototypes header file.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vdsl-vr11: fix missing-prototypes build warnings

* Mark some functions as static.
* Include function prototypes header file.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vdsl-vr11-mei: fix ignored-qualifiers build warnings

These functions return the register memory addresses. Usually
they are fixed values, hence I think it's safe to remove the
qualifier "volatile".

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vdsl-vr11-mei: improve compatibility with the 6.12 kernel.

Convert .remove to .remove_new so that it can be compatible with
both 6.6 and 6.12 kernels.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-vdsl-vr11-mei: fix missing-prototypes build warnings

Add prototype definition for exported function ifx_mei_atm_led_blink().

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
ltq-ifxos: fix missing-prototypes build warning

Add prototype definition for exported function IFX_Var_Fifo_getRoom().

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
vrx518_ep: fix macro redefined build error on 6.12 kernel

Add LANTIQ prefix to avoid name conflicts.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
vrx518_ep: fix compilation error with kernel 6.12

PCI_IRQ_LEGACY was renamed to PCI_IRQ_INTX for kernel 6.10. Fix
compilation error:

/home/db/owrt/build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/linux-ipq40xx_generic/vrx518_ep-2.1.0/ep.c:469:69: error: 'PCI_IRQ_LEGACY' undeclared (first use in this function); did you mean 'NR_IRQS_LEGACY'?
  469 |         err = pci_alloc_irq_vectors(pdev, nvec, nvec, PCI_IRQ_MSI | PCI_IRQ_LEGACY);
      |                                                                     ^~~~~~~~~~~~~~
      |                                                                     NR_IRQS_LEGACY

Signed-off-by: Andre Heider <a.heider@gmail.com>
Co-authored-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18744
Signed-off-by: Robert Marko <robimarko@gmail.com>
kernel: bump 6.12 to 6.12.28

Changelog: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.12.28

Removed upstreamed:
        generic/pending-6.12/691-net-ipv6-fix-UDPv6-GSO-segmentation-with-NAT.patch[1]

Manually rebased:
        generic/pending-6.12/737-net-ethernet-mtk_eth_soc-add-paths-and-SerDes-modes-.patch[2]
        generic/hack-6.12/781-usb-net-rndis-support-asr.patch[3]

1. https://web.git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=6effe1c0fa823d9923f3b77547f201a5bab6c1e5
2. https://web.git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=aea3ca60fafbdf0da5c930ff2f4105587deb6753
3. https://web.git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=222b6685efe0d8c1cdb078a67bbe806f56d18f94

All other patches automatically rebased.

Build system: x86/64
Build-tested: x86/64
Run-tested: x86/64

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18756
Signed-off-by: Robert Marko <robimarko@gmail.com>
generic: 6.12: add CONFIG_EC_LENOVO_YOGA_C630

CONFIG_EC_LENOVO_YOGA_C630 popped up while doing 6.12 for qualcommax.

Signed-off-by: Robert Marko <robimarko@gmail.com>
kernel: add missing Kconfig symbols

Found when building rockchip target (with kernel 6.12).

Signed-off-by: Tianling Shen <cnsztl@immortalwrt.org>
Link: https://github.com/openwrt/openwrt/pull/18685
Signed-off-by: Robert Marko <robimarko@gmail.com>
linux: remove of_match_ptr from OF only drivers

There's no need for it. Kernel update to 6.12 found that it now needs
linux/of.h explicitly included.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18763
Signed-off-by: Robert Marko <robimarko@gmail.com>
kernel: modules: video: package DRM VRAM helper

bcm27xx DRM packages depend on it.

Signed-off-by: Álvaro Fernández Rojas <noltari@gmail.com>
kernel: add KERNEL_ARM64_CONTPTE

When KERNEL_TRANSPARENT_HUGEPAGE is enabled, build fails due to
missing KERNEL_ARM64_CONTPTE.

Signed-off-by: Álvaro Fernández Rojas <noltari@gmail.com>
generic: config-filter: filter out CONFIG_RUSTC_SUPPORTS_* symbols

CONFIG_RUSTC_SUPPORTS_* is set based on rustc presence and version,
so we need to filter it out.

Signed-off-by: Robert Marko <robimarko@gmail.com>
kernel: modules: fs: add missing backslash

Commit 7db0748b7b ("kernel: modules: split package fs-fscache") modified
the KCONFIG section of KernelPackage/fs-netfs but missed to add a
backslash to escape a linebreak. Add it now.

Fixes: 7db0748b7b ("kernel: modules: split package fs-fscache")
Signed-off-by: Daniel Golle <daniel@makrotopia.org>
kernel: modules: split package fs-fscache

The module kmod-fs-fscache was merged into kmod-fs-netfs since
6.12 LTS kernel[1]. Therefore, we have to split fs-cachefiles
into a separate package. This patch also removed some outdated
config symbols that have already been removed in 5.15 kernel:

CONFIG_FSCACHE_OBJECT_LIST [2]
CONFIG_{FSCACHE,CACHEFILES}_HISTOGRAM [3]

[1] https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=915cd30cdea8811cddd8f59e57dd9dd0a814b76c
[2] https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-5.15.y&id=58f386a73f16cea1f78e8466cc5c402eb7f6fcf8
[3] https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-5.15.y&id=6ae9bd8bb037b7c422bafde746f2338a716f6058
Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18661
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
kernel: modules: update dependency for kmod-tpm

Remove unneeded dependencies asn1 codec and oid.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18661
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
kernel: modules: adjust the object files of kmod-fb

kmod-fb no longer depends on fb_io_fops.ko since 6.8 kernel.

Link: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.8.y&id=8813e86f6d82a7931446c3cbc5d596f77d0f1ba6
Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18661
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
generic: 6.12: add new config symbols

Add new config symbols to 6.12 kernel config and move common symbols from x86.

Signed-off-by: Álvaro Fernández Rojas <noltari@gmail.com>
generic: 6.12: add Qualcomm PBS symbol

Qualcomm PBS symbols popped up during 6.12 work.

Signed-off-by: Robert Marko <robimarko@gmail.com>
generic: 6.12: add Qualcomm PM8916 symbols

Qualcomm PM8916 PMIC symbols popped up while doing 6.12 for qualcommax.

Signed-off-by: Robert Marko <robimarko@gmail.com>
spi: spi-qpic-snand: update driver with latest patches from upstream

Updating the spi-qpic-snand driver with the latest patches sent
upstream and remove custom patches.
These patches add error handling fixes, use of right read location in
read ops, removal of unused variable, ability to read user config and
nand chip requirements, and support for 8bits ECC strength.

Tested on: Gl.iNet GL-B3000 & Linksys MR5500, MX2000, MX5500, SPNMX56

Signed-off-by: George Moussalem <george.moussalem@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18723
Signed-off-by: Robert Marko <robimarko@gmail.com>
kernel: bump 6.12 to 6.12.27

Changelog: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.12.27

No patches update required.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18728
Signed-off-by: Robert Marko <robimarko@gmail.com>
generic: 6.12: update block NVMEM driver

Update block NVMEM driver based on backported OF partition support.

Note the different MMC card DT binding compared to the previous
downstream solution: Instead of having a 'partitions' subnode inside
a 'block' node, the 'partitions' node now resides directly under the
node representing the card.

In order to make references to the 'boot0' or 'boot1' hw partitions
you will have to define 'partitions-boot0' or 'partitions-boot1', and
move the NVMEM layout into a partition (you may, of course, use
'fixed-partitions' for that, and cover the whole device, if needed).

See also https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/devicetree/bindings/mmc/mmc-card.yaml?h=v6.13

Signed-off-by: Daniel Golle <daniel@makrotopia.org>
generic: 6.12: update fitblk driver for Linux 6.12

Update the uImage.FIT filesystem subimage block driver for use
with Linux 6.12.

Signed-off-by: Daniel Golle <daniel@makrotopia.org>
ramips: update drivers to be compatible with kernel 6.12

Update drivers to be compatible with kernel 6.12:
 - change deprecate function strlcpy to strscpy
 - fix kernel warning "no previous prototype", by static declaration
 - add missing of.h headers

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18711
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
generic: fix MIPS -mno-long-calls patchset for 6.12 kernel

It seems that we need to override all execmem alloc/free callbacks,
not just for module. This is the default patch behavior in the 6.6
kernel. Fix the warning when the module is loaded:

root@OpenWrt:~# insmod mtd-rw i_want_a_brick=1
[ 1404.954813] mtd-rw: mtd0: setting writeable flag
[ 1404.959643] mtd-rw: mtd5: setting writeable flag
[ 1404.966396] ------------[ cut here ]------------
[ 1404.971119] WARNING: CPU: 0 PID: 8 at mm/vmalloc.c:3361 vfree+0x1ac/0x2c4
[ 1404.978146] Trying to vfree() nonexistent vm area (74cc6c73)
[ 1404.983901] Modules linked in: mtd_rw(O) ath9k(O) ath9k_common(O)...
[ 1405.043696] CPU: 0 UID: 0 PID: 8 Comm: kworker/0:1 Tainted: G        W  O       6.12.25 #0
[ 1405.052118] Tainted: [W]=WARN, [O]=OOT_MODULE
[ 1405.056536] Hardware name:
[ 1405.061222] Workqueue: events do_free_init
[ 1405.065408] Stack : 807865d8 80850000 81823f80 81857df8 00000000 00000d21 81823fd0 800ca130
[ 1405.073924]         81839e48 807865d8 808d20bf 807865d8 81857d1c 00000001 81857ce8 4951640f
[ 1405.082434]         00000000 00000000 807865d8 81857bf8 ffffefff 00000000 ffffffea 00000b5d
[ 1405.090944]         81857c04 00000b5d 808537b0 ffffffff 00000001 00000000 807865d8 81857df8
[ 1405.099453]         00000000 00000d21 81823fd0 8085119c 00000018 803f4828 00000000 80a00000
[ 1405.107963]         ...
[ 1405.110454] Call Trace:
[ 1405.112935] [<80066910>] show_stack+0x28/0xf0
[ 1405.117392] [<8069f340>] dump_stack_lvl+0x48/0x7c
[ 1405.122186] [<80084ab8>] __warn+0x9c/0x118
[ 1405.126357] [<80084bc0>] warn_slowpath_fmt+0x8c/0xac
[ 1405.131399] [<801f02ec>] vfree+0x1ac/0x2c4
[ 1405.135570] [<800dde54>] do_free_init+0x50/0x84
[ 1405.140172] [<8009f4a0>] process_one_work+0x1b0/0x3dc
[ 1405.145312] [<800a022c>] worker_thread+0x308/0x478
[ 1405.150178] [<800a81c0>] kthread+0xf4/0x11c
[ 1405.154455] [<80061b58>] ret_from_kernel_thread+0x14/0x1c
[ 1405.159938]
[ 1405.161772] ---[ end trace 0000000000000000 ]---

Fixes: a9c0f28951fd ("generic: 6.12: move MIPS reloc patch from pending to hack and rework")
Ref: https://lore.kernel.org/all/20240505160628.2323363-1-rppt@kernel.org/
Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Tested-by: Tony Ambardar <itugrok@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18721
Signed-off-by: Robert Marko <robimarko@gmail.com>
generic: 6.12: sync Realtek PHY patches with upstream

- Fix order of patches (3d483a10327f was merged before 34d5a86ff7bb).
- Reorganize patch numbers now that < 6.12 patches are no longer needed.

Signed-off-by: Álvaro Fernández Rojas <noltari@gmail.com>
kernel: bluetooth: btmtk: update dependencies for 6.12

With kernel 6.11 several mtk usb functions were moved from btusb to
btmtk, adding a usb core depdendency to btmtk (if enabled).

Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
kernel: kmod-btmtk: Extract btmtk.ko into own package

btmtk.ko is used by btusb.ko and btmtkuart.ko, add it into an own
package and make both packages depend on it.

Fixes: 1c42a0be3619 ("kernel: modules: bluetooth: separating UART and USB drivers")
Link: https://github.com/openwrt/openwrt/pull/18110
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
kernel: modules: bluetooth: separating UART and USB drivers

Not all devices need Bluetooth UART and USB drivers to be installed together. Three separate drivers have been created:
- kmod-bluetooth
- kmod-hci-uart
- kmod-btusb

Signed-off-by: Paweł Owoc <frut3k7@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/15118
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
kernel: modules: bluetooth: creating a new Bluetooth menu

Move Bluetooth modules to new Bluetooth menu from Other menu.

Signed-off-by: Paweł Owoc <frut3k7@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/15118
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
generic: 6.12: backport hwmon_ops static visibility

This patch was added on linux v6.13 in order to avoid simple is_visible
functions on hwmon drivers.
See https://github.com/torvalds/linux/commit/79bc0af904db647979c735563299c9b0d820e432

Signed-off-by: Álvaro Fernández Rojas <noltari@gmail.com>
generic: 6.12: sync r8169 patches with upstream

Upstream e2015942e90a couldn't be backported to 6.6 because the following
symbols were missing:
- disable_work
- disable_work_sync
- enable_work
See https://github.com/torvalds/linux/commit/e2015942e90a021151a5751776f35830ba063be7

Upstream 34e5ededf4b8 couldn't be backported to 6.6 because the following
symbol was missing:
- pcim_iomap_region
See https://github.com/torvalds/linux/commit/34e5ededf4b8ad4c9e58f0cab8596e26c8fa59a2

Reorganize patch numbers now that < 6.12 patches are no longer needed.

The following patches still differ from upstream:
- e340bff27e63
  phy_set_eee_broken symbol is missing in 6.12
  https://github.com/torvalds/linux/commit/e340bff27e63

The following patches can't be backported to 6.12 due to missing symbols:
- 5e7a74b6a357
  phy_disable_eee_mode symbol is missing in 6.12
  https://github.com/torvalds/linux/commit/5e7a74b6a357

Signed-off-by: Álvaro Fernández Rojas <noltari@gmail.com>
kernel: iio: iio-core: update dependencies for 6.12

With kernel 6.11 iio-core gained a dependency to DMA_SHARED_BUFFER,
so add the appropriate dependency.

Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
kernel: bump 6.12 to 6.12.26

Changelog: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.12.26

All patches automatically rebased.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18695
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
ramips: i2s: use devm for debugfs seqfile

Avoids some pointless boilerplate.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18675
Signed-off-by: Robert Marko <robimarko@gmail.com>
ramips: i2s: replace spaces with tabs

This seems to be some manual patch editing or rebasing bug.

Found with grep ' '.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18675
Signed-off-by: Robert Marko <robimarko@gmail.com>
rtl8812au-ct: fix build issue on 6.12 kernel

Update USB shutdown callback for the 6.12 kernel. A sprintf
overlaps issue is also fixed in this patch. Unfortunately,
there are dozens of missing-prototypes warnings so it's hard
to fix them one by one. Let's just silence them.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18637
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
kernel: trelay: fix build warning on 6.12 kernel

Make trelay_handle_frame() static to fix the build warning:

/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/trelay/trelay.c:38:21: error: no previous prototype for 'trelay_handle_frame' [-Werror=missing-prototypes]
   38 | rx_handler_result_t trelay_handle_frame(struct sk_buff **pskb)
      |                     ^~~~~~~~~~~~~~~~~~~

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18637
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
qualcommax: backport unmerged ipq60xx pwm support

Because of the dt-bindings error, these patches have not
been merged yet, and the driver part is fine.

Signed-off-by: Chukun Pan <amadeus@jmu.edu.cn>
Link: https://github.com/openwrt/openwrt/pull/14950
Signed-off-by: Robert Marko <robimarko@gmail.com>
qualcommax: remoteproc: use remove_new

Easy compability fix for kernel 6.12.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18660
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
qualcommax: pwm: use remove_new

Easy compability fix for kernel 6.12.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18660
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
qualcommax: add ipq50xx target

Introduce support for the Qualcomm IPQ50xx SoC.
This series adds support for the following components:
- minimal boot support: GCC/pinctrl/watchdog/CPUFreq/SDI (upstreamed)
- USB2 (upstreamed)
- Thermal/Tsens
- PCIe gen2 1&2-lane PHY and controller
- PWM and PWM LED
- QPIC SPI NAND controller
- CMN PLL Block (provider of fixed rate clocks to GCC/ethernet/more.)
- Ethernet: IPQ5018 Internal GE PHY (1 gbps)
- Remoteproc MPD driver for IPQ5018 (2.4G) & QCN6122 (5/6G) Wifi

Co-developed-by: Ziyang Huang <hzyitc@outlook.com>
Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
Signed-off-by: George Moussalem <george.moussalem@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/17182
Signed-off-by: Robert Marko <robimarko@gmail.com>
airoha: pwm: use devm

Removes the need for a remove function in platform_device.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18660
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
ipq40xx: ipqess: use remove_new

Easy compability fix for kernel 6.12.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18660
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
ipq40xx: qca8k: use remove_new

Easy compability fix for kernel 6.12.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18660
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
layerscape: ppfe: use remove_new

Easy compability fix for kernel 6.12.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18660
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
ramips: pwm: use remove_new

Easy way to add compatibility for kernel 6.12.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18660
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
ramips: mt7621-i2c: use remove_new

Easy compability fix for kernel 6.12.

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18660
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
ramips: eip93: use remove_new

Compatibility fix for kernel 6.12

Signed-off-by: Rosen Penev <rosenp@gmail.com>
Link: https://github.com/openwrt/openwrt/pull/18660
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: add KERNEL_STACKDEPOT_MAX_FRAMES

When KERNEL_SLUB_DEBUG is enabled, build fails due to the
KERNEL_STACKDEPOT_MAX_FRAMES missing. Add it.

Signed-off-by: Stijn Tintel <stijn@linux-ipv6.be>
Link: https://github.com/openwrt/openwrt/pull/18676
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: fix KERNEL_PROBE_EVENTS_BTF_ARGS

We no longer support kernels < 6.6, so drop the dependency. This fixes a
missing symbol with 6.12 when KERNEL_DEBUG_INFO_BTF and
KERNEL_KPROBE_EVENTS are enabled.

Signed-off-by: Stijn Tintel <stijn@linux-ipv6.be>
Link: https://github.com/openwrt/openwrt/pull/18676
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
config: add new TRANSPARENT_HUGEPAGE choice for 6.12 kernel

Kernel 6.12 has a new selection for TRANSPARENT_HUGEPAGE.
Add them here to avoid missing symbols.

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=683ec99f12f4c386c23bed7f6a8ef44db5a4999a

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18663
Signed-off-by: Robert Marko <robimarko@gmail.com>
generic: add more missing Kconfig symbols for 6.12 kernel

These symbols were found when adding 6.12 kernel support for the
ath79 target.

Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
Link: https://github.com/openwrt/openwrt/pull/18653
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel/drm-ttm-helper: 6.12: fix missing dependency

Add missing depends kmod-drm-kms-helper.

Package kmod-drm-ttm-helper is missing dependencies for the following libraries:
drm_kms_helper.ko
fb_sys_fops.ko
syscopyarea.ko
sysfillrect.ko
sysimgblt.ko

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel/backlight: 6.12: fix missing dependency

Add missing depends kmod-fb.

Package kmod-backlight is missing dependencies for the following libraries:
fb.ko

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: filter out compiler RUSTC opts from config

These get dynamically set, not relevant for targets.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: fortify: Hide run-time copy size from value range tracking

Fix compilation warning treated as an error:
./include/linux/fortify-string.h:114:33: error: '__builtin_memcpy' reading between 65 and 536870904 bytes from a region of size 64 [-Werror=stringop-overread]
  114 | #define __underlying_memcpy     __builtin_memcpy
      |                                 ^
./include/linux/fortify-string.h:633:9: note: in expansion of macro '__underlying_memcpy'
  633 |         __underlying_##op(p, q, __fortify_size);                        \
      |         ^~~~~~~~~~~~~
./include/linux/fortify-string.h:678:26: note: in expansion of macro '__fortify_memcpy_chk'
  678 | #define memcpy(p, q, s)  __fortify_memcpy_chk(p, q, s,                  \
      |                          ^~~~~~~~~~~~~~~~~~~~
./include/linux/bitmap.h:259:17: note: in expansion of macro 'memcpy'
  259 |                 memcpy(dst, src, len);
      |                 ^~~~~~
kernel/padata.c: In function '__padata_set_cpumasks':
kernel/padata.c:735:48: note: source object 'pcpumask' of size [0, 64]
  735 |                                  cpumask_var_t pcpumask,
      |                                  ~~~~~~~~~~~~~~^~~~~~~~

Link: https://web.git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?id=239d87327dcd361b0098038995f8908f3296864f
Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel/hwmon-sch5627: 6.12: fix missing dependency

Add missing depends kmod-regmap-core.

Package kmod-hwmon-sch5627 is missing dependencies for the following libraries:
regmap-core.ko

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=a54fe61639d9f3b6765fee32edda7cfceb6d705a

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel/hwmon-lm92: 6.12: fix missing dependency

Add missing depends kmod-regmap-core.

Package kmod-hwmon-lm92 is missing dependencies for the following libraries:
regmap-core.ko

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=1359590a5c48d1d28cd11808178931f146a539e2

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel/hwmon-core: 6.12: fix missing dependency

Add missing depends kmod-i2c-core.

Package kmod-hwmon-core is missing dependencies for the following libraries:
i2c-core.ko

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
generic: mtdsplit: include appropriate header for kernel 6.12

In kernel 6.12 asm/unaligned.h was moved to linux/unaligned.h[1]
The patch points to the appropriate header depending on the kernel version.

1. https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=5f60d5f6bbc12e782fac78110b0ee62698f3b576

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
package/zram: update for kernel 6.12

Updated for compatibility with kernels 6.6 and 6.12.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
package/fs-fscache: update for kernel 6.12

Update KCONFIG and FILES for kernel 6.12 compatibility

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: 6.12: add snd hda scodec component module

Add snd hda scodec component module

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=fd895a74dc1dca31f4ce7786b36812fda6727477

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
package/fs-ntfs: disable for kernel 6.12

Disabled due to removal from kernel 6.12.

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=7ffa8f3d30236e0ab897c30bdb01224ff1fe1c89

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel/lan743x: 6.12: fix missing dependency

Add missing depends kmod-phylink.

Package kmod-lan743x is missing dependencies for the following libraries:
phylink.ko

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=a5f199a8d8a03512199a9e7cdd4d8ea06c943295

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: modules: i40e,ice,iavf: support for kernel 6.12

Add Common Intel Ethernet library (libeth) and Intel Ethernet library (libie).
Add CONFIG_ICE_HWMON setting.

Ref:
 - https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=306ec721d043bbe5e818d59fbb37c28d999b5d8b
 - https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=4da71a77fc3be1fcb680c8d78e1a1fb8017905ad

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
ath79: convert driver to .remove_new

Convert driver to .remove_new in preparation for kernel 6.12 support.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18535
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
bmips: convert driver to .remove_new

Convert driver to .remove_new in preparation for kernel 6.12 support.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18535
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
mediatek: convert driver to .remove_new

Convert driver to .remove_new in preparation for kernel 6.12 support.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18535
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
ramips: convert driver to .remove_new

Convert driver to .remove_new in preparation for kernel 6.12 support.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/18535
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
ubootenv-nvram: convert driver to .remove_new

Convert driver to .remove_new in preparation for kernel 6.12 support.

Link: https://github.com/openwrt/openwrt/pull/18454
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
gpio-button-hotplug: convert to .remove_new

Convert package to .remove_new in preparation for kernel 6.12 support.

Link: https://github.com/openwrt/openwrt/pull/18454
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
generic: convert driver to .remove_new

Convert driver to .remove_new in preparation for kernel 6.12 support.

Link: https://github.com/openwrt/openwrt/pull/18454
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: modules: add Intel ICE support

Add support for the Intel E800 series of cards, with switchdev
support enabled for lower CPU usage.

Signed-off-by: Stephen Howell <howels@allthatwemight.be>
Link: https://github.com/openwrt/openwrt/pull/17564
Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
kernel/iio-bmp280: 6.12: fix missing dependency

Add missing depends kmod-industrialio-triggered-buffer.

Package kmod-iio-bmp280 is missing dependencies for the following libraries:
industrialio-triggered-buffer.ko

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=80cd23f43ddce3bfa0389ab65a442d3dc8de4b4f

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel/i2c-i801: 6.12: fix missing dependency

Add missing depends kmod-i2c-mux.

Package kmod-i2c-i801 is missing dependencies for the following libraries:
i2c-mux.ko

Ref: https://web.git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=9c535237245e4bf21758604277279b8ead58a724

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel/hwmon-max6697: 6.12: fix missing dependency

Add missing depends kmod-regmap-i2c.

ERROR: modpost: "__regmap_init_i2c" [drivers/hwmon/max6697.ko] undefined!

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=3a2a8cc3fe24ec48a3d222f5b9db68a3404ffab3

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel/9pnet: 6.12: fix missing dependency

Add missing depends kmod-fs-netfs.

Package kmod-9pnet is missing dependencies for the following libraries:
netfs.ko

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=5fb70e7275a61dd404f684370e1add7fe0ebe9c5

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: adjust kmod-phy-aquantia dependencies for v6.12 kernel

Driver moved to different CRC library in v6.12

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=6c8e2407100e4ff1db86e4af65b74be7895031a2

Signed-off-by: Mantas Pucka <mantas@8devices.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
config: add new options for 6.12 kernel

Since kernel v6.12 couple more options were added to
CGROUP section. Add them here to avoid missing symbols.

Signed-off-by: Mantas Pucka <mantas@8devices.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
generic: 6.12: remove outdated kernel symbols

Symbols that no longer exist in 6.12 were removed by a script [1].

[1] https://github.com/openwrt/openwrt/pull/15324

Co-authored-by: Mantas Pucka <mantas@8devices.com>
Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
generic: 6.12: add missing symbols

These symbols only become visible when some packages or kernel debug
options get enabled. Move them to generic.

Co-authored-by: Mantas Pucka <mantas@8devices.com>
Co-authored-by: Mathew McBride <matt@traverse.com.au>
Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: add new kmod and update kmod-tpm

Create a crypto-lib-aescfb package needed for new deps for kmod-tpm.

Package kmod-tpm is missing dependencies for the following libraries:
ecdh_generic.ko
kpp.ko
libaescfb.ko

Co-authored-by: John Audia <therealgraysky@proton.me>
Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
kernel: update dependency of kmod-i2c-piix4

Add missing depends kmod-i2c-smbus.

Package kmod-i2c-piix4 is missing dependencies for the following libraries:
i2c-smbus.ko

Ref: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=de4f2f52f93257433c9029ba2b4044cd9f029b21

Signed-off-by: John Audia <therealgraysky@proton.me>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
pcs-xpcs: 6.12: fix missing dependency

Add missing depends kmod-mdio-devres.

Package kmod-pcs-xpcs is missing dependencies for the following libraries:
mdio_devres.ko

Ref: https://web.git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=f6bb3e9d98c2e8d70587d5ddaf9426ef30d7865c

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Link: https://github.com/openwrt/openwrt/pull/16547
Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
generic:add 6.12 from a2063ec9

Signed-off-by: lunatickochiya <125438787@qq.com>
---
 config/Config-kernel.in                       |   46 +-
 package/firmware/linux-firmware/intel.mk      |   12 +
 package/kernel/ath10k-ct/Makefile             |   12 +-
 .../ath10k-ct/patches/001-patch-version.patch |   11 -
 ...h10k-6.10-remove-unsupported-feature.patch |    6 +-
 ...t-compatible-with-the-old-LTS-kernel.patch |   22 +
 ...ath10k-Use-iommu_paging_domain_alloc.patch |   28 +
 ...ssing-prototypes-warnings-on-6.12-ke.patch |   79 +
 .../ath10k-ct/patches/010-api_update.patch    |   42 -
 ...LED-and-GPIO-controlling-support-for.patch |  616 --
 ...02-ath10k-use-tpt-trigger-by-default.patch |   20 +-
 ...e-warning-caused-by-unsupported-retr.patch |   34 -
 ...e-noisy-log-caused-by-flushing-queue.patch |    6 +-
 .../300-fix-fortify-checking-error.patch      |    4 +-
 ...0-0010-ath10k-limit-htt-rx-ring-size.patch |    4 +-
 ...60-0011-ath10k-limit-pci-buffer-size.patch |    4 +-
 ...k-always-use-mac80211-loss-detection.patch |    8 +-
 .../src/gpio-button-hotplug.c                 |    8 +-
 .../lantiq/ltq-adsl-mei/src/drv_mei_cpe.c     |    6 +-
 .../ltq-adsl-mei/src/ifxmips_mei_interface.h  |    3 +
 ...add-missing-header-platform_device.h.patch |   25 +
 ...-silence-missing-prototypes-warnings.patch |   32 +
 ...100-ltq_atm-fix-compillation-warning.patch |   12 -
 .../ltq-atm/src/ifxmips_atm_amazon_se.c       |   10 +-
 .../lantiq/ltq-atm/src/ifxmips_atm_ar9.c      |   10 +-
 .../lantiq/ltq-atm/src/ifxmips_atm_danube.c   |    4 +-
 package/kernel/lantiq/ltq-atm/src/ltq_atm.c   |    4 +-
 .../kernel/lantiq/ltq-deu/src/ifxmips_aes.c   |   64 +-
 .../kernel/lantiq/ltq-deu/src/ifxmips_des.c   |   34 +-
 .../lantiq/ltq-deu/src/ifxmips_deu_ar9.h      |    3 +
 .../lantiq/ltq-deu/src/ifxmips_deu_danube.h   |    2 +
 .../lantiq/ltq-deu/src/ifxmips_deu_vr9.h      |    3 +
 ...g-prototype-for-IFX_Var_Fifo_getRoom.patch |   26 +
 .../102-fix-missing-prototypes-warning.patch  |   26 +
 ...add-missing-header-mod_devicetable.h.patch |   26 +
 ...add-missing-header-mod_devicetable.h.patch |   25 +
 .../616-fix-missing-prototypes-warnings.patch |   56 +
 ...-prototype-for-ifx_mei_atm_led_blink.patch |   24 +
 ...atform-driver-.remove-to-.remove_new.patch |   43 +
 ...fix-ignored-qualifiers-build-warning.patch |   50 +
 .../301-fix-missing-prototypes-warnings.patch |  172 +
 .../ltq-vdsl-vr9-mei/patches/100-compat.patch |   11 +-
 ...atform-driver-.remove-to-.remove_new.patch |   41 +
 ...ix-ignored-qualifiers-build-warnings.patch |   38 +
 .../407-fix-missing-prototypes-warnings.patch |   53 +
 .../303-fix-missing-prototypes-warning.patch  |  100 +
 ...21-ignore-missing-prototypes-warning.patch |   29 +
 .../lantiq/ltq-vmmc/patches/500-ar9_vr9.patch |    8 +-
 ...o-definition-conflicts-on-6.12-kerne.patch |  143 +
 .../607-fix-unknown-type-name-errors.patch    |   28 +
 ...e-is-not-at-beginning-of-declaration.patch |   26 +
 .../lantiq/vrx518_ep/patches/100-compat.patch |   22 +-
 ...o-definition-conflicts-on-6.12-kerne.patch |   34 +
 ...-allow-larger-mtu-to-support-rfc4638.patch |    6 +-
 .../300-fix-missing-prototypes-warnings.patch |   66 +
 package/kernel/linux/modules/bluetooth.mk     |  165 +
 package/kernel/linux/modules/crypto.mk        |   11 +
 package/kernel/linux/modules/fs.mk            |   41 +-
 package/kernel/linux/modules/hwmon.mk         |    7 +-
 package/kernel/linux/modules/i2c.mk           |    6 +-
 package/kernel/linux/modules/iio.mk           |    3 +-
 package/kernel/linux/modules/netdevices.mk    |   61 +-
 package/kernel/linux/modules/netsupport.mk    |    1 +
 package/kernel/linux/modules/other.mk         |  161 +-
 package/kernel/linux/modules/sound.mk         |   16 +-
 package/kernel/linux/modules/usb.mk           |    7 +-
 package/kernel/linux/modules/video.mk         |   23 +-
 .../930-ath10k_add_tpt_led_trigger.patch      |    4 +-
 ...75-ath10k-use-tpt-trigger-by-default.patch |    2 +-
 ...k-always-use-mac80211-loss-detection.patch |    2 +-
 ...ort-setting-bdf-addr-and-caldb-addr-.patch |   62 +
 ...apped-ce-accessing-issue-on-64bit-OS.patch |  153 +
 ...ifi-ath11k-add-hw-params-for-QCN6122.patch |  115 +
 ...wifi-ath11k-add-hal-regs-for-QCN6122.patch |  114 +
 ...-ath11k-add-hw-ring-mask-for-QCN6122.patch |   74 +
 ...k-update-hif_and-pci_ops-for-QCN6122.patch |  102 +
 ...h11k-add-multipd-support-for-QCN6122.patch |  110 +
 ...fi-ath11k-add-QCN6122-device-support.patch |   55 +
 ...11k-Support-to-assign-m3-dump-memory.patch |   31 +
 ...-wifi-ath11k-poll-reo-status-ipq5018.patch |  164 +
 ...-and-handle-country-code-for-WCN7850.patch |   18 +-
 ...etch-regdb.bin-file-from-board-2.bin.patch |   67 +
 ...i-ath12k-fix-handling-of-6-GHz-rules.patch |  140 +
 ...k-limit-WMI_SCAN_CHAN_LIST_CMDID-arg.patch |  153 +
 ...k-fix-5GHz-operation-on-wideband-QCN.patch |  137 +
 ...k-push-HE-MU-MIMO-params-to-hardware.patch |  469 +
 ...-push-EHT-MU-MIMO-params-to-hardware.patch |  222 +
 ...HE-MCS-mapper-to-a-separate-function.patch |  162 +
 ...and-tx-mcs-maps-for-supported-HE-mcs.patch |  186 +
 ...X-MCS-rate-configurations-in-HE-mode.patch |  141 +
 ...ort-for-setting-fixed-HE-rate-GI-LTF.patch | 1095 +++
 ...7-wifi-ath12k-clean-up-80P80-support.patch |  254 +
 ...2k-add-support-for-160-MHz-bandwidth.patch |  399 +
 ...ed-NSS-bandwidth-support-for-160-MHz.patch |  191 +
 .../341-wifi-ath9k-obtain-system-gpios.patch  |  273 +
 ...erpret-requested-txpower-in-EIRP-dom.patch |    4 +-
 ...power-reduction-for-US-regulatory-do.patch |    2 +-
 ...se-devm-for-irq-and-ioremap-resource.patch |   50 +
 .../patches/ath9k/513-ath9k_add_pci_ids.patch |    2 +-
 .../ath9k/531-ath9k_extra_platform_leds.patch |   64 -
 .../ath9k/542-ath9k_debugfs_diag.patch        |    4 +-
 .../ath9k/547-ath9k_led_defstate_fix.patch    |    2 +-
 .../ath9k/548-ath9k_enable_gpio_chip.patch    |  125 +-
 .../ath9k/549-ath9k_enable_gpio_buttons.patch |  130 -
 .../mac80211/patches/ath9k/550-ath9k-of.patch |  155 +
 .../ath9k/551-ath9k_ubnt_uap_plus_hsr.patch   |    7 +-
 .../patches/ath9k/552-ath9k-ahb_of.patch      |  276 +-
 .../ath9k/553-ath9k_of_gpio_mask.patch        |   25 -
 ...-fix-linux-acpi_amd_wbrf.h-inclusion.patch |   32 +
 ...port-fix-unaligned.h-header-location.patch |   26 +
 .../patches/build/140-trace_backport.patch    |  419 +-
 ...-genlmsg_multicast_allns-upstream-ba.patch |    2 +-
 ...support-for-loading-EEPROM-from-user.patch |   30 +-
 ...t-support-for-external-LNA-on-MT7620.patch |    2 +-
 ...7-rt2x00-change-remove-to-remove_new.patch |   42 +
 ...ll-rate_control_rate_update-for-link.patch |  548 ++
 ...s-net_device-to-.set_monitor_channel.patch |    2 +-
 ...-not-offer-a-mesh-path-if-forwarding.patch |   56 +
 package/kernel/mt76/Makefile                  |    6 +-
 ...t-platform-driver-.remove-to-.remove.patch |   98 +
 package/kernel/nat46/Makefile                 |    6 +-
 package/kernel/qca-nss-dp/Makefile            |    8 +-
 ...dp-Drop-_nocache-variants-of-ioremap.patch |   48 -
 ...port-newer-kernels-time-stamping-API.patch |   47 -
 .../0003-EDMA-Fix-NAPI-packet-counting.patch  |   31 -
 ...-Use-NAPI_POLL_WEIGHT-as-NAPI-weight.patch |   41 -
 ...s-dp-adapt-to-netif_napi_add-changes.patch |   46 -
 ...a-phy-handle-property-to-connect-to-.patch |  183 -
 ...s-dp-edma-v1-use-NAPI-GRO-by-default.patch |   56 -
 ...p-allow-setting-netdev-name-from-DTS.patch |   50 -
 ...009-nss-dp-switchdev-fix-FDB-roaming.patch |  111 -
 ...w_reset-logic-to-permit-rmmod-and-in.patch |   43 -
 ...-correctly-unregister-notifier-on-dp.patch |   59 -
 ...s_dp_main-swap-dp_exit-function-call.patch |   35 -
 ...-unregister_netdev-first-in-dp_remov.patch |   35 -
 ...phy_detach-instead-of-disconnect-in-.patch |   26 -
 ...a_disable_port-in-edma_cleanup-subse.patch |   37 -
 package/kernel/qca-ssdk/Makefile              |   26 +-
 ...enable-invoking-fdb-del-function-for.patch |   30 -
 ...004-SSDK-set-OF-node-for-the-SFP-PHY.patch |   94 -
 ...-selecting-PCS-channel-for-PORT3-on-.patch |  135 -
 ...l_phy-add-support-for-AQR114C-B0-PHY.patch |   33 -
 .../patches/200-allow-parallel-build.patch    |   50 -
 package/kernel/rtl8812au-ct/Makefile          |    3 +-
 .../patches/005-fix-netdevice-notifier.patch  |   37 +
 ...10-fix-usb_driver-.shutdown-callback.patch |   47 +
 ...-overlaps-destination-object-warning.patch |   28 +
 ...nkid-linux-version-code-conditionals.patch |    2 +-
 .../rtl8812au-ct/patches/100-api_update.patch |    2 +-
 package/kernel/trelay/src/trelay.c            |    2 +-
 .../ubootenv-nvram/src/ubootenv-nvram.c       |    5 +-
 ...wm-airoha-Add-support-for-EN7581-SoC.patch |   16 +-
 target/linux/apm821xx/image/nand.mk           |    2 +-
 .../apm821xx/nand/profiles/00-default.mk      |    2 +-
 .../ath79/files/drivers/mfd/rb4xx-cpld.c      |    2 +-
 .../files/drivers/mtd/nand/raw/ar934x_nand.c  |    6 +-
 .../files/drivers/mtd/nand/raw/nand_rb4xx.c   |    6 +-
 .../files/drivers/mtd/nand/raw/rb91x_nand.c   |    6 +-
 .../atheros/ag71xx/ag71xx_legacy_mdio.c       |    5 +-
 .../net/ethernet/atheros/ag71xx/ag71xx_main.c |    8 +-
 .../311-MIPS-pci-ar71xx-convert-to-OF.patch   |    2 +-
 .../313-MIPS-pci-ar724x-convert-to-OF.patch   |    2 +-
 .../net/ethernet/broadcom/bcm6348-enet.c      |   10 +-
 .../net/ethernet/broadcom/bcm6368-enetsw.c    |    8 +-
 ...rt-for-defining-read-only-partitions.patch |   53 +
 ...3-03-block-introduce-add_disk_fwnode.patch |   94 +
 ...-partitions-fwnode-if-found-in-mmc-c.patch |  104 +
 ...rt-for-partition-table-defined-in-OF.patch |  200 +
 ...d-add-support-for-FORESEE-F35SQA001G.patch |   38 +
 ...wnand-qcom-cleanup-qcom_nandc-driver.patch | 1013 +++
 ...d-qcom-Add-qcom-prefix-to-common-api.patch |  880 ++
 ...14-mtd-nand-Add-qpic_common-API-file.patch | 2436 ++++++
 ...nand-qcom-use-FIELD_PREP-and-GENMASK.patch |  198 +
 ...-fix-broken-config-in-qcom_param_pag.patch |   64 +
 ...-Fix-build-issue-on-x86-architecture.patch |   77 +
 ...-driver-for-QCOM-SPI-NAND-flash-Inte.patch | 1737 ++++
 ...nd-Fix-ECC_CFG_ECC_DISABLE-shift-in-.patch |   28 +
 ...nd-avoid-memleak-in-qcom_spi_ecc_ini.patch |   35 +
 ...ND-should-be-tristate-and-depend-on-.patch |   49 +
 ...ate-errors-from-qcom_spi_block_erase.patch |   36 +
 ...ND_READ_LOCATION_2-register-handling.patch |   35 +
 ...nd-use-kmalloc-for-OOB-buffer-alloca.patch |   29 +
 ...-wlen-member-of-struct-qpic_spi_nand.patch |   30 +
 ...phy-mediatek-ge-soc-Fix-coding-style.patch |   88 +
 ...-ge-soc-Shrink-line-wrapping-to-80-c.patch |  271 +
 ...-ge-soc-Propagate-error-code-correct.patch |   40 +
 ...-Re-organize-MediaTek-ethernet-phy-d.patch | 3565 ++++++++
 ...-Move-LED-helper-functions-into-mtk-.patch |  774 ++
 ...-Improve-readability-of-mtk-phy-lib..patch |   72 +
 ...-Integrate-read-write-page-helper-fu.patch |  153 +
 ...ek-add-MT7530-MT7531-s-PHY-ID-macros.patch |   56 +
 ...t-phy-Constify-struct-mdio_device_id.patch |  700 ++
 ...tek-Change-to-more-meaningful-macros.patch |  146 +
 ...-Add-token-ring-access-helper-functi.patch |  448 +
 ...-Add-token-ring-set-bit-operation-su.patch |   73 +
 ...-Add-token-ring-clear-bit-operation-.patch |  122 +
 ...-Move-some-macros-to-phy-lib-for-lat.patch |   45 +
 ...-permit-to-compile-test-GE-SOC-PHY-d.patch |   37 +
 ...atek-add-Airoha-PHY-ID-to-SoC-driver.patch |  129 +
 ...-init-val-in-.phy_led_polarity_set-f.patch |   40 +
 ...et-ethernet-mediatek-add-EEE-support.patch |  157 +
 ...ginal-workaround-for-RTL8125-broken-.patch |   33 +
 ...TSO-on-selected-chip-versions-per-de.patch |   52 +
 ...plement-additional-ethtool-stats-ops.patch |  130 +
 ...169-don-t-take-RTNL-lock-in-rtl_task.patch |   50 +
 ...-custom-flag-with-disable_work-et-al.patch |   94 +
 ...icated-messages-if-loading-firmware-.patch |   41 +
 ...9-remove-rtl_dash_loop_wait_high-low.patch |   82 +
 ...-EEE-at-2.5G-per-default-on-RTL8125B.patch |   28 +
 ...v6.13-r8169-add-support-for-RTL8125D.patch |  143 +
 ...istent-indenting-in-rtl8169_get_eth_.patch |   30 +
 ...TL8125-EEE-config-with-vendor-driver.patch |   49 +
 ...125-RTL8126-PHY-config-with-vendor-d.patch |   46 +
 ...TL8126-EEE-config-with-vendor-driver.patch |   25 +
 ...itialization-of-RSS-registers-on-RTL.patch |   38 +
 ...leftover-locks-after-reverted-change.patch |  113 +
 ...6.13-r8169-improve-__rtl8169_set_wol.patch |  108 +
 ...13-r8169-improve-rtl_set_d3_pll_down.patch |   44 +
 ..._PHY-handling-with-r8125-r8126-vendo.patch |   29 +
 ...-r8169_mod_reg8_cond-to-simplify-rtl.patch |  117 +
 ...r-driver-2.5G-5G-EEE-advertisement-c.patch |   82 +
 ...sed-flag-RTL_FLAG_TASK_RESET_NO_QUEU.patch |   35 +
 ...9-remove-support-for-chip-version-11.patch |  114 +
 ...adjust-version-numbering-for-RTL8126.patch |  257 +
 ...r8169-add-support-for-RTL8125D-rev.b.patch |   90 +
 ...8169-add-support-for-RTL8125BP-rev.b.patch |  184 +
 ...ig-option-for-LED-support-user-visib.patch |   28 +
 ....15-r8169-don-t-scan-PHY-addresses-0.patch |   26 +
 ...9-add-support-for-Intel-Killer-E5000.patch |   25 +
 ...5-ops-for-MDIO_MMD_VENDOR2-registers.patch |   67 +
 ...ax-jumbo-packet-size-on-RTL8125-RTL8.patch |   40 +
 ...way-from-deprecated-pcim_iomap_table.patch |   35 +
 ...8168H-RTL8168EP-RTL8168FP-ASPM-suppo.patch |   27 +
 ...r8169-disable-RTL8126-ZRX-DC-timeout.patch |   60 +
 ...read-duplex-and-gbit-master-from-PHY.patch |  106 +
 ...change-order-of-calls-in-C22-read_st.patch |   53 +
 ...clear-1000Base-T-link-partner-advert.patch |   30 +
 ...merge-the-drivers-for-internal-NBase.patch |  136 +
 ...hy-realtek-add-RTL8125D-internal-PHY.patch |   29 +
 ...add-support-for-reading-MDIO_MMD_VEN.patch |   47 +
 ...clear-1000Base-T-lpa-if-link-is-down.patch |   52 +
 ...clear-master_slave_state-if-link-is-.patch |   35 +
 ...phy-realtek-always-clear-NBase-T-lpa.patch |   42 +
 ...ltek-PHY-driver-to-its-own-subdirect.patch | 3247 +++++++
 ...add-hwmon-support-for-temp-sensor-on.patch |  173 +
 ...HWMON-support-for-standalone-version.patch |   64 +
 ...make-HWMON-support-a-user-visible-Kc.patch |   35 +
 ...y-realtek-use-string-choices-helpers.patch |   54 +
 ...improve-mmd-register-access-for-inte.patch |  134 +
 ...switch-from-paged-to-MMD-ops-in-rtl8.patch |   52 +
 ...ltek-add-helper-RTL822X_VND2_C22_REG.patch |   48 +
 ...add-defines-for-shadowed-c45-standar.patch |  113 +
 ...net-phy-realtek-disable-PHY-mode-EEE.patch |   54 +
 ...an-tag-insertion-stripping-by-defaul.patch |   32 +
 ...-visibility-member-to-struct-hwmon_o.patch |   88 +
 ...tia-allow-forcing-order-of-MDI-pairs.patch |  107 +
 ...-fix-return-value-check-in-aqr107_co.patch |   31 +
 ...rt-active-high-property-for-PHY-LEDs.patch |   53 +
 ...-correctly-describe-LED-polarity-ove.patch |  108 +
 ...et-phy-mxl-gpy-add-basic-LED-support.patch |  332 +
 ...add-missing-support-for-TRIGGER_NETD.patch |   28 +
 ...-gpy-correctly-describe-LED-polarity.patch |   58 +
 ...-intel-xway-add-support-for-PHY-LEDs.patch |  379 +
 ...-regmap-Use-generic-request-free-ops.patch |   30 +
 ...et-dsa-mv88e6xxx-Support-LED-control.patch | 1250 +++
 ...-copy-size-from-value-range-tracking.patch |  155 +
 target/linux/generic/config-6.12              | 7680 +++++++++++++++++
 target/linux/generic/config-6.6               |    1 +
 target/linux/generic/config-filter            |    4 +
 .../drivers/mtd/mtdsplit/mtdsplit_lzma.c      |    5 +
 .../files/drivers/mtd/nand/mtk_bmt_v2.c       |    2 +-
 .../generic/files/drivers/net/phy/adm6996.c   |    6 +-
 .../files/drivers/net/phy/b53/b53_mmap.c      |    6 +-
 .../files/drivers/net/phy/b53/b53_srab.c      |    6 +-
 .../files}/drivers/net/phy/rtl8261n/Kconfig   |    0
 .../files}/drivers/net/phy/rtl8261n/Makefile  |    0
 .../phy/rtl8261n/construct/conf_rtl8261n_c.c  |    0
 .../phy/rtl8261n/construct/conf_rtl8264b.c    |    0
 .../files}/drivers/net/phy/rtl8261n/error.h   |    0
 .../drivers/net/phy/rtl8261n/phy_patch.c      |    0
 .../drivers/net/phy/rtl8261n/phy_patch.h      |    0
 .../net/phy/rtl8261n/phy_rtl826xb_patch.c     |   16 +-
 .../net/phy/rtl8261n/phy_rtl826xb_patch.h     |    0
 .../drivers/net/phy/rtl8261n/rtk_osal.c       |    1 +
 .../drivers/net/phy/rtl8261n/rtk_osal.h       |    0
 .../files}/drivers/net/phy/rtl8261n/rtk_phy.c |    0
 .../drivers/net/phy/rtl8261n/rtk_phylib.c     |    0
 .../drivers/net/phy/rtl8261n/rtk_phylib.h     |    0
 .../drivers/net/phy/rtl8261n/rtk_phylib_def.h |    0
 .../net/phy/rtl8261n/rtk_phylib_rtl826xb.c    |    0
 .../net/phy/rtl8261n/rtk_phylib_rtl826xb.h    |    0
 .../files}/drivers/net/phy/rtl8261n/type.h    |    0
 .../generic/files/drivers/net/phy/rtl8366rb.c |    6 +-
 .../generic/files/drivers/net/phy/rtl8366s.c  |    6 +-
 .../generic/files/drivers/net/phy/rtl8367.c   |    6 +-
 .../generic/files/drivers/net/phy/rtl8367b.c  |    6 +-
 .../hack-6.12/200-tools_portability.patch     |  176 +
 .../generic/hack-6.12/204-module_strip.patch  |  201 +
 ...-abort-configuration-on-unset-symbol.patch |   41 +
 .../210-darwin_scripts_include.patch          | 3053 +++++++
 .../211-darwin-uuid-typedef-clash.patch       |   22 +
 .../hack-6.12/214-spidev_h_portability.patch  |   24 +
 .../hack-6.12/230-openwrt_lzma_options.patch  |   38 +
 .../hack-6.12/250-netfilter_depends.patch     |   27 +
 .../linux/generic/hack-6.12/251-kconfig.patch |  157 +
 .../generic/hack-6.12/253-ksmbd-config.patch  |   32 +
 .../hack-6.12/259-regmap_dynamic.patch        |  156 +
 .../260-crypto_test_dependencies.patch        |   54 +
 .../hack-6.12/261-lib-arc4-unhide.patch       |   24 +
 .../generic/hack-6.12/280-rfkill-stubs.patch  |   84 +
 ...cache-use-more-efficient-cache-blast.patch |   64 +
 ...lare-custom-execmem-alloc-free-funct.patch |   62 +
 ...ng-calls-with-mno-long-calls-if-poss.patch |  396 +
 ...rans-call-add-disks-after-mtd-device.patch |  112 +
 ...upport-OpenWrt-s-MTD_ROOTFS_ROOT_DEV.patch |   24 +
 ...ers-add-nvmem-support-to-cmdlinepart.patch |  120 +
 .../hack-6.12/430-mtk-bmt-support.patch       |   33 +
 ...ACY-block-partitions-populate-fwnode.patch |  130 +
 ...0-net-enable-fraglist-GRO-by-default.patch |   24 +
 ...y-to-free-deferred-skbs-while-waitin.patch |   45 +
 ...lter-connmark-introduce-set-dscpmark.patch |  231 +
 ...-netfilter-add-xt_FLOWOFFLOAD-target.patch |  812 ++
 .../hack-6.12/651-wireless_mesh_header.patch  |   24 +
 .../hack-6.12/660-fq_codel_defaults.patch     |   27 +
 ...t-size-the-hashtable-more-adequately.patch |   25 +
 .../700-swconfig_switch_drivers.patch         |  131 +
 ...-dsa-mv88e6xxx-disable-ATU-violation.patch |   21 +
 .../721-net-add-packet-mangeling.patch        |  159 +
 ...hy-aquantia-enable-AQR112-and-AQR412.patch |  117 +
 ...aquantia-fix-system-side-protocol-mi.patch |   34 +
 ...ntia-add-PHY_IDs-for-AQR112-variants.patch |   63 +
 ..._eth_soc-add-hw-dump-for-forced-rese.patch |  115 +
 .../735-net-phy-realtek-rtl8261n.patch        |   21 +
 ...mtk-lynxi-workaround-2500BaseX-no-an.patch |   64 +
 ...-r8152-add-LED-configuration-from-OF.patch |   74 +
 ...et-add-RTL8152-binding-documentation.patch |   54 +
 ...k-ge-add-LED-configuration-interface.patch |   72 +
 .../hack-6.12/773-bgmac-add-srab-switch.patch |   98 +
 .../780-usb-net-MeigLink_modem_support.patch  |   70 +
 .../781-usb-net-rndis-support-asr.patch       |   69 +
 .../800-GPIO-add-named-gpio-exports.patch     |  172 +
 .../810-bcma-ssb-fallback-sprom.patch         |  182 +
 .../hack-6.12/901-debloat_sock_diag.patch     |  181 +
 .../generic/hack-6.12/902-debloat_proc.patch  |  419 +
 .../hack-6.12/904-debloat_dma_buf.patch       |  105 +
 .../hack-6.12/910-kobject_uevent.patch        |   35 +
 .../911-kobject_add_broadcast_uevent.patch    |   76 +
 .../hack-6.12/920-device_tree_cmdline.patch   |   21 +
 ...vert-driver-core-Set-fw_devlink-on-b.patch |   30 +
 .../735-net-phy-realtek-rtl8261n.patch        |    4 +-
 target/linux/generic/kernel-6.12              |    2 +
 ...include-asm-rwonce.h-for-kernel-code.patch |   29 +
 ...s-negative-stack-offsets-on-stack-tr.patch |   57 +
 .../103-kbuild-export-SUBARCH.patch           |   21 +
 ..._wdt-Add-support-for-specifying-WDI-.patch |   75 +
 ...ame2-and-add-RENAME_WHITEOUT-support.patch |   81 +
 ...41-jffs2-add-RENAME_EXCHANGE-support.patch |   73 +
 .../142-jffs2-add-splice-ops.patch            |   20 +
 ...ge_allow_receiption_on_disabled_port.patch |   45 +
 ...t-send-arp-replies-if-src-and-target.patch |   37 +
 ...-rs5c372-support_alarms_up_to_1_week.patch |   94 +
 ...he_alarm_to_be_used_as_wakeup_source.patch |   71 +
 ...-fix-boot-hang-with-HAVE_LD_DEAD_COD.patch |   79 +
 .../203-kallsyms_uncompressed.patch           |  183 +
 .../205-backtrace_module_info.patch           |   41 +
 ...e-filenames-from-deps_initramfs-list.patch |   30 +
 .../270-platform-mikrotik-build-bits.patch    |   31 +
 .../300-mips_expose_boot_raw.patch            |   40 +
 ...rriers-between-dcache-icache-flushes.patch |   71 +
 .../302-mips_no_branch_likely.patch           |   22 +
 .../pending-6.12/308-mips32r2_tune.patch      |   22 +
 .../310-arm_module_unresolved_weak_sym.patch  |   22 +
 ...t-command-line-parameters-from-users.patch |  282 +
 .../332-arc-add-OWRTDTB-section.patch         |   84 +
 ...able-unaligned-access-in-kernel-mode.patch |   24 +
 ...ernel-XZ-compression-option-on-PPC_8.patch |   25 +
 ...el-fix-detect_memory_region-function.patch |   74 +
 .../400-mtd-mtdsplit-support.patch            |  328 +
 ...er-NVMEM-devices-for-partitions-with.patch |   48 +
 ...support-for-minor-aligned-partitions.patch |  245 +
 ...te-user-chip-specific-ECC-properties.patch |  174 +
 ...mmon-add-defines-for-ECC_MODE-values.patch |   70 +
 ...-add-support-for-8-bits-ECC-strength.patch |  388 +
 .../pending-6.12/420-mtd-redboot_space.patch  |   41 +
 ...30-mtd-add-myloader-partition-parser.patch |  229 +
 ...check-for-bad-blocks-when-calculatin.patch |   68 +
 ...bcm47xxpart-detect-T_Meter-partition.patch |   37 +
 ...mtd-add-routerbootpart-parser-config.patch |   38 +
 ...lock-allow-setting-partition-of_node.patch |  123 +
 ...-of-assign-Device-Tree-node-to-parti.patch |   25 +
 ...artitions-efi-apply-Linux-code-style.patch |  498 ++
 ...llow-assigning-partition-Device-Tree.patch |   75 +
 ...-block-add-support-for-notifications.patch |  164 +
 ...ck-add-new-genhd-flag-GENHD_FL_NVMEM.patch |   29 +
 ...nvmem-implement-block-NVMEM-provider.patch |  250 +
 .../457-mmc-block-set-GENHD_FL_NVMEM.patch    |   22 +
 ...mtd-cfi_cmdset_0002-no-erase_suspend.patch |   25 +
 ...et_0002-add-buffer-write-cmd-timeout.patch |   17 +
 ...25p80-mx-disable-software-protection.patch |   18 +
 .../476-mtd-spi-nor-add-eon-en25q128.patch    |   22 +
 .../477-mtd-spi-nor-add-eon-en25qx128a.patch  |   24 +
 .../479-mtd-spi-nor-add-xtx-xt25f128b.patch   |   84 +
 ...r-add-support-for-Gigadevice-GD25D05.patch |   25 +
 .../482-mtd-spi-nor-add-gd25q512.patch        |   25 +
 .../484-mtd-spi-nor-add-esmt-f25l16pa.patch   |   27 +
 .../485-mtd-spi-nor-add-xmc-xm25qh128c.patch  |   27 +
 ...nd-Add-support-for-Etron-EM73D044VCx.patch |  170 +
 .../488-mtd-spi-nor-add-xmc-xm25qh64c.patch   |   25 +
 ...mtd-device-named-ubi-or-data-on-boot.patch |  104 +
 ...to-create-ubiblock-device-for-rootfs.patch |   77 +
 ...ting-ubi0-rootfs-in-init-do_mounts.c.patch |   54 +
 ...ROOT_DEV-to-ubiblock-rootfs-if-unset.patch |   34 +
 .../494-mtd-ubi-add-EOF-marker-support.patch  |   60 +
 ...-add-bindings-for-mtd-concat-devices.patch |   52 +
 ...cat-add-dt-driver-for-concat-devices.patch |  215 +
 ...i-nor-locking-support-for-MX25L6405D.patch |   32 +
 ...i-nor-disable-16-bit-sr-for-macronix.patch |   30 +
 .../500-fs_cdrom_dependencies.patch           |   52 +
 ...add-uImage.FIT-subimage-block-driver.patch |  757 ++
 ...ass-device-lookup-for-dev-fit-rootfs.patch |   25 +
 .../530-jffs2_make_lzma_available.patch       | 5190 +++++++++++
 .../pending-6.12/532-jffs2_eofdetect.patch    |   65 +
 .../600-netfilter_conntrack_flush.patch       |   90 +
 ...etfilter_match_bypass_default_checks.patch |  110 +
 ...netfilter_match_bypass_default_table.patch |  106 +
 ...netfilter_match_reduce_memory_access.patch |   22 +
 .../pending-6.12/630-packet_socket_type.patch |  138 +
 ...fix-switchdev-host-mdb-entry-updates.patch |   42 +
 ...hdev-Don-t-drop-packets-between-port.patch |   38 +
 ...ly-receive-all-multicast-packets-if-.patch |   24 +
 .../pending-6.12/655-increase_skb_pad.patch   |   20 +
 ...Add-support-for-MAP-E-FMRs-mesh-mode.patch |  511 ++
 ...ng-with-source-address-failed-policy.patch |  263 +
 ...nes-for-_POLICY_FAILED-until-all-cod.patch |   50 +
 ..._F_GSO_FRAGLIST-from-NETIF_F_GSO_SOF.patch |  129 +
 ...83-of_net-add-mac-address-to-of-tree.patch |   75 +
 ...d-missing-check-for-TCP-fraglist-GRO.patch |   26 +
 ...ow_offload-handle-netdevice-events-f.patch |  106 +
 ...les-ignore-EOPNOTSUPP-on-flowtable-d.patch |   29 +
 ...net-mtk_eth_soc-enable-threaded-NAPI.patch |   21 +
 ...detach-callback-to-struct-phy_driver.patch |   38 +
 ...a-tag_mtk-add-padding-for-tx-packets.patch |   28 +
 ...e-host_interfaces-when-attaching-PHY.patch |   57 +
 ...d-knob-for-filtering-rx-tx-BPDU-pack.patch |  174 +
 ...-qca8k-implement-lag_fdb_add-del-ops.patch |   86 +
 ...a8k-enable-flooding-to-both-CPU-port.patch |   37 +
 ...k-add-support-for-port_change_master.patch |  158 +
 ...enable-assisted-learning-on-CPU-port.patch |   57 +
 ...-use-genphy_soft_reset-for-2.5G-PHYs.patch |   81 +
 ...sable-SGMII-in-band-AN-for-2-5G-PHYs.patch |   63 +
 ...make-sure-paged-read-is-protected-by.patch |   35 +
 .../720-04-net-phy-realtek-setup-aldps.patch  |   42 +
 ...tek-detect-early-version-of-RTL8221B.patch |   52 +
 ...ealtek-support-interrupt-of-RTL8221B.patch |  102 +
 ...ealtek-mark-existing-MMDs-as-present.patch |   27 +
 ...hy-realtek-work-around-broken-serdes.patch |   58 +
 ...t-phy-realtek-disable-MDIO-broadcast.patch |   27 +
 ..._eth_soc-reset-all-TX-queues-on-DMA-.patch |   49 +
 ...0211_ptr-even-with-no-CFG82111-suppo.patch |   59 +
 ..._eth_soc-compile-out-netsys-v2-code-.patch |   44 +
 ..._eth_soc-work-around-issue-with-send.patch |  102 +
 ...rnet-mtk_eth_soc-set-NETIF_F_ALL_TSO.patch |   21 +
 ...ernet-mtk_eth_soc-use-napi_build_skb.patch |   30 +
 ...-mediatek-enlarge-DMA-reserve-buffer.patch |   44 +
 ..._eth_soc-improve-keeping-track-of-of.patch |  334 +
 ...iatek-fix-ppe-flow-accounting-for-L2.patch |  343 +
 ..._eth_soc-add-paths-and-SerDes-modes-.patch |  890 ++
 ...th_soc-reduce-rx-ring-size-for-older.patch |  104 +
 ..._eth_soc-do-not-enable-page-pool-sta.patch |   43 +
 ...y-mediatek-xfi-tphy-add-new-bindings.patch |  136 +
 ...lynxi-add-platform-driver-for-MT7988.patch |  369 +
 ...pcs-add-bindings-for-MediaTek-USXGMI.patch |   81 +
 ...-add-driver-for-MediaTek-USXGMII-PCS.patch |  545 ++
 ...et-phy-motorcomm-Add-missing-include.patch |   22 +
 ...broadcom-update-dependency-condition.patch |   35 +
 ...-missing-linux-if_ether.h-for-ETH_AL.patch |   61 +
 ...-bus-mhi-core-add-SBL-state-callback.patch |   48 +
 ...Fix-DMA-allocations-on-57766-devices.patch |   31 +
 ...ice-struct-copy-its-DMA-params-to-th.patch |   73 +
 ...pio-cascade-add-generic-GPIO-cascade.patch |  217 +
 ...e-old-opp-to-config_clks-on-_set_opp.patch |  108 +
 ...env-align-endianness-of-crc32-values.patch |   45 +
 ...-support-mac-base-fixed-layout-cells.patch |  124 +
 ...e-generalize-mac-base-cells-handling.patch |  248 +
 ...uts-add-support-for-ascii-env-driver.patch |  204 +
 ...-ascii-env-handle-CRLF-while-parsing.patch |   58 +
 .../810-pci_disable_common_quirks.patch       |   62 +
 .../811-pci_disable_usb_common_quirks.patch   |   63 +
 .../pending-6.12/834-ledtrig-libata.patch     |  145 +
 ...40-hwrng-bcm2835-set-quality-to-1000.patch |   26 +
 ...e-main-irq_chip-structure-a-static-d.patch |  102 +
 ...890-usb-serial-add-support-for-CH348.patch |  783 ++
 ...ings-leds-Add-LED1202-LED-Controller.patch |  181 +
 .../892-leds-Add-LED1202-I2C-driver.patch     |  513 ++
 ...st1202-Fix-NULL-pointer-access-error.patch |   70 +
 ...x-fix-qca9530-and-qca9550-mdio-probe.patch |   25 +
 .../pending-6.12/920-mangle_bootargs.patch    |   71 +
 ...introduce-the-Qualcomm-IPQESS-driver.patch |    8 +-
 ...-add-IPQ4019-built-in-switch-support.patch |   10 +-
 ...iq-wifi-and-ethernet-eeprom-handling.patch |    2 +-
 .../701-staging-add-fsl_ppfe-driver.patch     |   11 +-
 .../files/drivers/net/phy/rtk/rtl8367s_mdio.c |    6 +-
 target/linux/mediatek/modules.mk              |    2 +-
 target/linux/mediatek/mt7622/config-6.6       |    1 -
 target/linux/mediatek/mt7623/config-6.6       |    1 -
 target/linux/mediatek/mt7629/config-6.6       |    1 -
 .../500-gsw-rtl8367s-mt7622-support.patch     |    6 +-
 target/linux/qualcommax/Makefile              |    2 +-
 .../arch/arm64/boot/dts/qcom/ipq5018-ess.dtsi |  116 +
 target/linux/qualcommax/image/ipq50xx.mk      |    0
 .../linux/qualcommax/ipq50xx/config-default   |   26 +
 target/linux/qualcommax/ipq50xx/target.mk     |    7 +
 .../linux/qualcommax/ipq60xx/config-default   |    3 +
 ...-arm64-dts-qcom-ipq5018-add-watchdog.patch |   31 +
 ...support-indicating-SDI-default-state.patch |   41 +
 ...are-qcom-scm-disable-SDI-if-required.patch |   83 +
 ...qcom-scm-document-IPQ5018-compatible.patch |   25 +
 ...-indicate-that-SDI-shoud-be-disabled.patch |   26 +
 ...-phy-qcom-m31-Add-IPQ5018-compatible.patch |   28 +
 ...atible-phy-init-sequence-for-IPQ5018.patch |   89 +
 ...ings-usb-dwc3-Add-IPQ5018-compatible.patch |   41 +
 ...s-qcom-ipq5018-Add-USB-related-nodes.patch |   86 +
 ...qcom-ipq5018-add-QUP1-SPI-controller.patch |   56 +
 ...k-qcom-a53pll-add-IPQ5018-compatible.patch |   25 +
 ...apss-ipq-pll-add-support-for-IPQ5018.patch |   62 +
 ...m-ipq5018-enable-the-CPUFreq-support.patch |   98 +
 ...add-few-more-reserved-memory-regions.patch |   66 +
 ...-ops-for-IPQ5018-to-fix-boot-failure.patch |   83 +
 ...pss-ipq-pll-fix-PLL-rate-for-IPQ5018.patch |   32 +
 ...com-ipq6018-add-NSS-reserved-memory.patch} |    2 +-
 ...rm64-dts-qcom-ipq6018-add-SDHCI-node.patch |    2 +-
 ...-arm64-dts-qcom-ipq6018-add-pwm-node.patch |   45 +
 ...-dt-bindings-pwm-add-IPQ6018-binding.patch |   60 +
 ...river-for-qualcomm-ipq6018-pwm-block.patch |  334 +
 ...r-Add-simple-mfd-support-for-IPQ6018.patch |  148 +
 ...indings-nvmem-add-IPQ5018-compatible.patch |   22 +
 ...al-qcom-tsens-Add-ipq5018-compatible.patch |   26 +
 ...com-add-new-feat-for-soc-without-rpm.patch |   45 +
 ...-tsens-add-support-for-IPQ5018-tsens.patch |  118 +
 ...0154-dts-qcom-IPQ5018-add-tsens-node.patch |  200 +
 ...com-uniphy-pcie-Document-PCIe-uniphy.patch |   85 +
 ...om-Introduce-PCIe-UNIPHY-28LP-driver.patch |  332 +
 ...m-uniphy-pcie-add-IPQ5018-compatible.patch |   25 +
 ...hy-pcie-28lp-add-support-for-IPQ5018.patch |   77 +
 ...dt-bindings-PCI-qcom-Add-IPQ5018-SoC.patch |   78 +
 ...161-PCI-qcom-add-support-for-IPQ5018.patch |   77 +
 ...-qcom-IPQ5018-add-PCIe-related-nodes.patch |  216 +
 ...mfd-qcom-tcsr-add-IPQ5018-compatible.patch |   18 +
 ...arm64-dts-qcom-IPQ5018-add-TCSR-node.patch |   22 +
 ...018-enable-the-download-mode-support.patch |   19 +
 ...-bindings-pwm-add-IPQ5018-compatible.patch |   22 +
 ...nctrl-qcom-IPQ5018-update-pwm-groups.patch |   65 +
 ...-arm64-dts-qcom-ipq5018-Add-PWM-node.patch |   27 +
 ...64-dts-qcom-ipq5018-Add-crypto-nodes.patch |   41 +
 ...arm64-dts-qcom-ipq5018-Add-PRNG-node.patch |   25 +
 ...dts-qcom-ipq5018-Add-QUP1-UART2-node.patch |   27 +
 ...4-dts-qcom-ipq5018-Add-QUP3-I2C-node.patch |   32 +
 ...ndings-Introduce-qcom-spi-qpic-snand.patch |   97 +
 ...wnand-qcom-cleanup-qcom_nandc-driver.patch |  983 +++
 ...d-qcom-Add-qcom-prefix-to-common-api.patch |  874 ++
 ...04-mtd-nand-Add-qpic_common-API-file.patch | 2418 ++++++
 ...nand-qcom-use-FIELD_PREP-and-GENMASK.patch |  191 +
 ...er-for-QCOM-SPI-NAND-flash-Interface.patch | 1729 ++++
 ...-spi-spi-qpic-fix-compilation-issues.patch |   45 +
 ...0411-spi-spi-qpic-snand-support-BCH8.patch |   53 +
 ...and-qpic-only-support-max-4-bytes-ID.patch |   25 +
 ...4-dts-qcom-ipq5018-Add-SPI-nand-node.patch |   52 +
 ...pq5018-Add-more-nand-compatible-for-.patch |   23 +
 ...k-qcom-Add-CMN-PLL-clock-controller-.patch |  113 +
 ...-PLL-clock-controller-driver-for-IPQ.patch |  288 +
 ...clk-qcom-cmn-pll-add-IPQ5018-support.patch |   78 +
 ...s-qcom-ipq5018-Add-ethernet-cmn-node.patch |   45 +
 ...ntroduce-IPQ5018-internal-PHY-driver.patch |  184 +
 ...arm64-dts-qcom-ipq5018-add-mdio-node.patch |   43 +
 ...m64-dts-qcom-ipq5018-add-ge_phy-node.patch |   45 +
 ...enable-configuration-of-DAC-settings.patch |  111 +
 ...add-IPQ5018-initvals-and-CDT-feature.patch |  108 +
 ...remove-the-unsupported-clk-combinati.patch |   35 +
 ...-phy-rx-and-tx-clk-providers-by-name.patch |   62 +
 ...always-enable-SGMII-auto-negotiation.patch |   30 +
 ...sa-qca8k-support-PHY-to-PHY-CPU-link.patch |   49 +
 ...c-qcom-Add-support-for-multipd-model.patch |  202 +
 ...m-ipq5332-add-support-to-pass-metada.patch |   43 +
 ...m-ipq5332-add-msa-lock-unlock-suppor.patch |  126 +
 ...-q6v5-Add-multipd-interrupts-support.patch |  148 +
 ...Add-Hexagon-based-multipd-rproc-driv.patch |  899 ++
 ...mpd-split-q6_wcss-to-rootpd-and-user.patch |  321 +
 ...q6v5_mpd-fix-incorrent-use-of-rproc-.patch |  206 +
 .../0811-firmware-qcom_scm-support-MPD.patch  |  128 +
 ...0812-soc-qcom-mdt_loader-support-MPD.patch |  199 +
 ...moteproc-qcom_q6v5_mpd-enable-clocks.patch |   38 +
 ...teproc-qcom_q6v5_mpd-support-ipq5018.patch |  111 +
 ...-add-support-for-passing-v1-bootargs.patch |  163 +
 ...64-dts-qcom-ipq5018-add-wifi-support.patch |  241 +
 ...8-add-tz_apps-reserved-memory-region.patch |   22 +
 ...arm64-dts-qcom-ipq6018-add-wifi-node.patch |    2 +-
 ...07-soc-qcom-fix-smp2p-ack-on-ipq6018.patch |    2 +-
 ...pq6018-assign-QDSS_AT-clock-to-wifi-.patch |    2 +-
 .../files/drivers/dma/mediatek/hsdma-mt7621.c |    6 +-
 .../ramips/files/drivers/dma/ralink-gdma.c    |    6 +-
 .../files/drivers/mmc/host/mtk-mmc/sd.c       |    6 +-
 .../files/drivers/mtd/nand/raw/mt7621_nand.c  |    6 +-
 .../drivers/net/ethernet/ralink/esw_rt3050.c  |    7 +-
 .../drivers/net/ethernet/ralink/ethtool.c     |    7 +-
 .../drivers/net/ethernet/ralink/gsw_mt7620.c  |    7 +-
 .../drivers/net/ethernet/ralink/mt7530.c      |    3 +-
 .../drivers/net/ethernet/ralink/mtk_eth_soc.c |    6 +-
 .../835-asoc-add-mt7620-support.patch         |   54 +-
 .../845-pwm-add-mediatek-support.patch        |    8 +-
 .../860-ramips-add-eip93-driver.patch         |    8 +-
 .../realtek/patches-6.6/720-add-rtl-phy.patch |   10 +-
 target/linux/rockchip/armv8/config-6.6        |    1 +
 612 files changed, 83001 insertions(+), 3135 deletions(-)
 delete mode 100644 package/kernel/ath10k-ct/patches/001-patch-version.patch
 create mode 100644 package/kernel/ath10k-ct/patches/003-ath10k-ct-make-it-compatible-with-the-old-LTS-kernel.patch
 create mode 100644 package/kernel/ath10k-ct/patches/004-Revert-wifi-ath10k-Use-iommu_paging_domain_alloc.patch
 create mode 100644 package/kernel/ath10k-ct/patches/005-ath10k-ct-fix-missing-prototypes-warnings-on-6.12-ke.patch
 delete mode 100644 package/kernel/ath10k-ct/patches/010-api_update.patch
 delete mode 100644 package/kernel/ath10k-ct/patches/201-wifi-ath10k-add-LED-and-GPIO-controlling-support-for.patch
 delete mode 100644 package/kernel/ath10k-ct/patches/205-ath10k-ct-silence-warning-caused-by-unsupported-retr.patch
 create mode 100644 package/kernel/lantiq/ltq-adsl/patches/411-add-missing-header-platform_device.h.patch
 create mode 100644 package/kernel/lantiq/ltq-adsl/patches/412-silence-missing-prototypes-warnings.patch
 delete mode 100644 package/kernel/lantiq/ltq-atm/patches/100-ltq_atm-fix-compillation-warning.patch
 create mode 100644 package/kernel/lantiq/ltq-ifxos/patches/101-add-missing-prototype-for-IFX_Var_Fifo_getRoom.patch
 create mode 100644 package/kernel/lantiq/ltq-ptm/patches/102-fix-missing-prototypes-warning.patch
 create mode 100644 package/kernel/lantiq/ltq-ptm/patches/103-add-missing-header-mod_devicetable.h.patch
 create mode 100644 package/kernel/lantiq/ltq-ptm/patches/104-add-missing-header-mod_devicetable.h.patch
 create mode 100644 package/kernel/lantiq/ltq-tapi/patches/616-fix-missing-prototypes-warnings.patch
 create mode 100644 package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/132-add-missing-prototype-for-ifx_mei_atm_led_blink.patch
 create mode 100644 package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/133-convert-platform-driver-.remove-to-.remove_new.patch
 create mode 100644 package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/134-fix-ignored-qualifiers-build-warning.patch
 create mode 100644 package/kernel/lantiq/ltq-vdsl-vr11/patches/301-fix-missing-prototypes-warnings.patch
 create mode 100644 package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/405-convert-platform-driver-.remove-to-.remove_new.patch
 create mode 100644 package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/406-fix-ignored-qualifiers-build-warnings.patch
 create mode 100644 package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/407-fix-missing-prototypes-warnings.patch
 create mode 100644 package/kernel/lantiq/ltq-vdsl-vr9/patches/303-fix-missing-prototypes-warning.patch
 create mode 100644 package/kernel/lantiq/ltq-vmmc/patches/021-ignore-missing-prototypes-warning.patch
 create mode 100644 package/kernel/lantiq/ltq-vmmc/patches/606-fix-version-macro-definition-conflicts-on-6.12-kerne.patch
 create mode 100644 package/kernel/lantiq/ltq-vmmc/patches/607-fix-unknown-type-name-errors.patch
 create mode 100644 package/kernel/lantiq/ltq-vmmc/patches/608-fix-inline-is-not-at-beginning-of-declaration.patch
 create mode 100644 package/kernel/lantiq/vrx518_ep/patches/101-Fix-version-macro-definition-conflicts-on-6.12-kerne.patch
 create mode 100644 package/kernel/lantiq/vrx518_tc/patches/300-fix-missing-prototypes-warnings.patch
 create mode 100644 package/kernel/linux/modules/bluetooth.mk
 create mode 100644 package/kernel/mac80211/patches/ath11k/201-wifi-ath11k-Support-setting-bdf-addr-and-caldb-addr-.patch
 create mode 100644 package/kernel/mac80211/patches/ath11k/910-ath11k-fix-remapped-ce-accessing-issue-on-64bit-OS.patch
 create mode 100644 package/kernel/mac80211/patches/ath11k/920-wifi-ath11k-add-hw-params-for-QCN6122.patch
 create mode 100644 package/kernel/mac80211/patches/ath11k/921-wifi-ath11k-add-hal-regs-for-QCN6122.patch
 create mode 100644 package/kernel/mac80211/patches/ath11k/922-wifi-ath11k-add-hw-ring-mask-for-QCN6122.patch
 create mode 100644 package/kernel/mac80211/patches/ath11k/923-wifi-ath11k-update-hif_and-pci_ops-for-QCN6122.patch
 create mode 100644 package/kernel/mac80211/patches/ath11k/924-wifi-ath11k-add-multipd-support-for-QCN6122.patch
 create mode 100644 package/kernel/mac80211/patches/ath11k/925-wifi-ath11k-add-QCN6122-device-support.patch
 create mode 100644 package/kernel/mac80211/patches/ath11k/931-wifi-ath11k-Support-to-assign-m3-dump-memory.patch
 create mode 100644 package/kernel/mac80211/patches/ath11k/932-wifi-ath11k-poll-reo-status-ipq5018.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/002-wifi-ath12k-Fetch-regdb.bin-file-from-board-2.bin.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/003-wifi-ath12k-fix-handling-of-6-GHz-rules.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/102-wifi-ath12k-limit-WMI_SCAN_CHAN_LIST_CMDID-arg.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/103-wifi-ath12k-fix-5GHz-operation-on-wideband-QCN.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/104-1-wifi-ath12k-push-HE-MU-MIMO-params-to-hardware.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/104-2-wifi-ath12k-push-EHT-MU-MIMO-params-to-hardware.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/104-3-wifi-ath12k-move-HE-MCS-mapper-to-a-separate-function.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/104-4-wifi-ath12k-generate-rx-and-tx-mcs-maps-for-supported-HE-mcs.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/104-5-wifi-ath12k-fix-TX-and-RX-MCS-rate-configurations-in-HE-mode.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/104-6-wifi-ath12k-add-support-for-setting-fixed-HE-rate-GI-LTF.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/104-7-wifi-ath12k-clean-up-80P80-support.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/104-8-wifi-ath12k-add-support-for-160-MHz-bandwidth.patch
 create mode 100644 package/kernel/mac80211/patches/ath12k/104-9-wifi-ath12k-add-extended-NSS-bandwidth-support-for-160-MHz.patch
 create mode 100644 package/kernel/mac80211/patches/ath9k/341-wifi-ath9k-obtain-system-gpios.patch
 create mode 100644 package/kernel/mac80211/patches/ath9k/509-ath9k-use-devm-for-irq-and-ioremap-resource.patch
 delete mode 100644 package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch
 delete mode 100644 package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch
 create mode 100644 package/kernel/mac80211/patches/ath9k/550-ath9k-of.patch
 delete mode 100644 package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch
 create mode 100644 package/kernel/mac80211/patches/build/110-backport-include-fix-linux-acpi_amd_wbrf.h-inclusion.patch
 create mode 100644 package/kernel/mac80211/patches/build/120-backport-fix-unaligned.h-header-location.patch
 create mode 100644 package/kernel/mac80211/patches/rt2x00/997-rt2x00-change-remove-to-remove_new.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/306-wifi-mac80211-call-rate_control_rate_update-for-link.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/400-v6.16-wifi-mac80211-do-not-offer-a-mesh-path-if-forwarding.patch
 create mode 100644 package/kernel/mt76/patches/001-wifi-mt76-convert-platform-driver-.remove-to-.remove.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0001-nss-dp-Drop-_nocache-variants-of-ioremap.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0002-edma_tx_rx-support-newer-kernels-time-stamping-API.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0003-EDMA-Fix-NAPI-packet-counting.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0004-EDMA-Use-NAPI_POLL_WEIGHT-as-NAPI-weight.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0005-nss-dp-adapt-to-netif_napi_add-changes.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0006-nss_dp_main-Use-a-phy-handle-property-to-connect-to-.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0007-nss-dp-edma-v1-use-NAPI-GRO-by-default.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0008-nss-dp-allow-setting-netdev-name-from-DTS.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0009-nss-dp-switchdev-fix-FDB-roaming.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0011-01-edma_v1-rework-hw_reset-logic-to-permit-rmmod-and-in.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0011-02-nss_dp_switchdev-correctly-unregister-notifier-on-dp.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0011-03-nss_dp_main-swap-dp_exit-function-call.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0011-04-nss_dp_main-call-unregister_netdev-first-in-dp_remov.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0011-05-nss_dp_main-use-phy_detach-instead-of-disconnect-in-.patch
 delete mode 100644 package/kernel/qca-nss-dp/patches/0011-06-edma_v1-skip-edma_disable_port-in-edma_cleanup-subse.patch
 delete mode 100644 package/kernel/qca-ssdk/patches/0003-Revert-qca-ssdk-enable-invoking-fdb-del-function-for.patch
 delete mode 100644 package/kernel/qca-ssdk/patches/0004-SSDK-set-OF-node-for-the-SFP-PHY.patch
 delete mode 100644 package/kernel/qca-ssdk/patches/102-qca-ssdk-support-selecting-PCS-channel-for-PORT3-on-.patch
 delete mode 100644 package/kernel/qca-ssdk/patches/103-hsl_phy-add-support-for-AQR114C-B0-PHY.patch
 delete mode 100644 package/kernel/qca-ssdk/patches/200-allow-parallel-build.patch
 create mode 100644 package/kernel/rtl8812au-ct/patches/005-fix-netdevice-notifier.patch
 create mode 100644 package/kernel/rtl8812au-ct/patches/010-fix-usb_driver-.shutdown-callback.patch
 create mode 100644 package/kernel/rtl8812au-ct/patches/011-fix-sprintf-overlaps-destination-object-warning.patch
 create mode 100644 target/linux/generic/backport-6.12/410-v6.13-01-block-add-support-for-defining-read-only-partitions.patch
 create mode 100644 target/linux/generic/backport-6.12/410-v6.13-03-block-introduce-add_disk_fwnode.patch
 create mode 100644 target/linux/generic/backport-6.12/410-v6.13-04-mmc-block-attach-partitions-fwnode-if-found-in-mmc-c.patch
 create mode 100644 target/linux/generic/backport-6.12/410-v6.13-05-block-add-support-for-partition-table-defined-in-OF.patch
 create mode 100644 target/linux/generic/backport-6.12/412-v6.14-mtd-spinand-add-support-for-FORESEE-F35SQA001G.patch
 create mode 100644 target/linux/generic/backport-6.12/413-01-v6.14-mtd-rawnand-qcom-cleanup-qcom_nandc-driver.patch
 create mode 100644 target/linux/generic/backport-6.12/413-02-v6.14-mtd-rawnand-qcom-Add-qcom-prefix-to-common-api.patch
 create mode 100644 target/linux/generic/backport-6.12/413-03-v6.14-mtd-nand-Add-qpic_common-API-file.patch
 create mode 100644 target/linux/generic/backport-6.12/413-04-v6.14-mtd-rawnand-qcom-use-FIELD_PREP-and-GENMASK.patch
 create mode 100644 target/linux/generic/backport-6.12/414-v6.14-mtd-rawnand-qcom-fix-broken-config-in-qcom_param_pag.patch
 create mode 100644 target/linux/generic/backport-6.12/415-v6.14-mtd-rawnand-qcom-Fix-build-issue-on-x86-architecture.patch
 create mode 100644 target/linux/generic/backport-6.12/416-v6.15-01-spi-spi-qpic-add-driver-for-QCOM-SPI-NAND-flash-Inte.patch
 create mode 100644 target/linux/generic/backport-6.12/416-v6.15-02-spi-spi-qpic-snand-Fix-ECC_CFG_ECC_DISABLE-shift-in-.patch
 create mode 100644 target/linux/generic/backport-6.12/416-v6.15-03-spi-spi-qpic-snand-avoid-memleak-in-qcom_spi_ecc_ini.patch
 create mode 100644 target/linux/generic/backport-6.12/416-v6.15-04-spi-SPI_QPIC_SNAND-should-be-tristate-and-depend-on-.patch
 create mode 100644 target/linux/generic/backport-6.12/416-v6.15-05-spi-spi-qpic-snand-propagate-errors-from-qcom_spi_block_erase.patch
 create mode 100644 target/linux/generic/backport-6.12/416-v6.15-06-spi-spi-qpic-snand-fix-NAND_READ_LOCATION_2-register-handling.patch
 create mode 100644 target/linux/generic/backport-6.12/416-v6.15-07-spi-spi-qpic-snand-use-kmalloc-for-OOB-buffer-alloca.patch
 create mode 100644 target/linux/generic/backport-6.12/416-v6.16-08-spi-spi-qpic-snand-remove-unused-wlen-member-of-struct-qpic_spi_nand.patch
 create mode 100644 target/linux/generic/backport-6.12/720-v6.13-net-phy-mediatek-ge-soc-Fix-coding-style.patch
 create mode 100644 target/linux/generic/backport-6.12/721-v6.13-net-phy-mediatek-ge-soc-Shrink-line-wrapping-to-80-c.patch
 create mode 100644 target/linux/generic/backport-6.12/722-v6.13-net-phy-mediatek-ge-soc-Propagate-error-code-correct.patch
 create mode 100644 target/linux/generic/backport-6.12/723-v6.13-net-phy-mediatek-Re-organize-MediaTek-ethernet-phy-d.patch
 create mode 100644 target/linux/generic/backport-6.12/724-v6.13-net-phy-mediatek-Move-LED-helper-functions-into-mtk-.patch
 create mode 100644 target/linux/generic/backport-6.12/725-v6.13-net-phy-mediatek-Improve-readability-of-mtk-phy-lib..patch
 create mode 100644 target/linux/generic/backport-6.12/726-v6.13-net-phy-mediatek-Integrate-read-write-page-helper-fu.patch
 create mode 100644 target/linux/generic/backport-6.12/727-v6.13-net-phy-mediatek-add-MT7530-MT7531-s-PHY-ID-macros.patch
 create mode 100644 target/linux/generic/backport-6.12/728-v6.14-net-phy-Constify-struct-mdio_device_id.patch
 create mode 100644 target/linux/generic/backport-6.12/729-v6.15-net-phy-mediatek-Change-to-more-meaningful-macros.patch
 create mode 100644 target/linux/generic/backport-6.12/730-v6.15-net-phy-mediatek-Add-token-ring-access-helper-functi.patch
 create mode 100644 target/linux/generic/backport-6.12/731-v6.15-net-phy-mediatek-Add-token-ring-set-bit-operation-su.patch
 create mode 100644 target/linux/generic/backport-6.12/732-v6.15-net-phy-mediatek-Add-token-ring-clear-bit-operation-.patch
 create mode 100644 target/linux/generic/backport-6.12/733-v6.15-net-phy-mediatek-Move-some-macros-to-phy-lib-for-lat.patch
 create mode 100644 target/linux/generic/backport-6.12/735-v6.16-net-phy-mediatek-permit-to-compile-test-GE-SOC-PHY-d.patch
 create mode 100644 target/linux/generic/backport-6.12/736-v6.16-net-phy-mediatek-add-Airoha-PHY-ID-to-SoC-driver.patch
 create mode 100644 target/linux/generic/backport-6.12/737-v6.16-net-phy-mediatek-init-val-in-.phy_led_polarity_set-f.patch
 create mode 100644 target/linux/generic/backport-6.12/753-v6.15-net-ethernet-mediatek-add-EEE-support.patch
 create mode 100644 target/linux/generic/backport-6.12/780-01-v6.13-r8169-remove-original-workaround-for-RTL8125-broken-.patch
 create mode 100644 target/linux/generic/backport-6.12/780-02-v6.13-r8169-enable-SG-TSO-on-selected-chip-versions-per-de.patch
 create mode 100644 target/linux/generic/backport-6.12/780-03-v6.13-r8169-implement-additional-ethtool-stats-ops.patch
 create mode 100644 target/linux/generic/backport-6.12/780-04-v6.13-r8169-don-t-take-RTNL-lock-in-rtl_task.patch
 create mode 100644 target/linux/generic/backport-6.12/780-05-v6.13-replace-custom-flag-with-disable_work-et-al.patch
 create mode 100644 target/linux/generic/backport-6.12/780-06-v6.13-r8169-avoid-duplicated-messages-if-loading-firmware-.patch
 create mode 100644 target/linux/generic/backport-6.12/780-07-v6.13-r8169-remove-rtl_dash_loop_wait_high-low.patch
 create mode 100644 target/linux/generic/backport-6.12/780-08-v6.13-r8169-enable-EEE-at-2.5G-per-default-on-RTL8125B.patch
 create mode 100644 target/linux/generic/backport-6.12/780-09-v6.13-r8169-add-support-for-RTL8125D.patch
 create mode 100644 target/linux/generic/backport-6.12/780-10-v6.13-r8169-fix-inconsistent-indenting-in-rtl8169_get_eth_.patch
 create mode 100644 target/linux/generic/backport-6.12/780-11-v6.13-r8169-align-RTL8125-EEE-config-with-vendor-driver.patch
 create mode 100644 target/linux/generic/backport-6.12/780-12-v6.13-r8169-align-RTL8125-RTL8126-PHY-config-with-vendor-d.patch
 create mode 100644 target/linux/generic/backport-6.12/780-13-v6.13-r8169-align-RTL8126-EEE-config-with-vendor-driver.patch
 create mode 100644 target/linux/generic/backport-6.12/780-14-v6.13-r8169-improve-initialization-of-RSS-registers-on-RTL.patch
 create mode 100644 target/linux/generic/backport-6.12/780-15-v6.13-r8169-remove-leftover-locks-after-reverted-change.patch
 create mode 100644 target/linux/generic/backport-6.12/780-16-v6.13-r8169-improve-__rtl8169_set_wol.patch
 create mode 100644 target/linux/generic/backport-6.12/780-17-v6.13-r8169-improve-rtl_set_d3_pll_down.patch
 create mode 100644 target/linux/generic/backport-6.12/780-18-v6.13-r8169-align-WAKE_PHY-handling-with-r8125-r8126-vendo.patch
 create mode 100644 target/linux/generic/backport-6.12/780-19-v6.13-r8169-use-helper-r8169_mod_reg8_cond-to-simplify-rtl.patch
 create mode 100644 target/linux/generic/backport-6.12/780-20-v6.13-r8169-copy-vendor-driver-2.5G-5G-EEE-advertisement-c.patch
 create mode 100644 target/linux/generic/backport-6.12/780-21-v6.14-r8169-remove-unused-flag-RTL_FLAG_TASK_RESET_NO_QUEU.patch
 create mode 100644 target/linux/generic/backport-6.12/780-22-v6.14-r8169-remove-support-for-chip-version-11.patch
 create mode 100644 target/linux/generic/backport-6.12/780-23-v6.14-r8169-adjust-version-numbering-for-RTL8126.patch
 create mode 100644 target/linux/generic/backport-6.12/780-24-v6.14-r8169-add-support-for-RTL8125D-rev.b.patch
 create mode 100644 target/linux/generic/backport-6.12/780-25-v6.14-r8169-add-support-for-RTL8125BP-rev.b.patch
 create mode 100644 target/linux/generic/backport-6.12/780-26-v6.15-r8169-make-Kconfig-option-for-LED-support-user-visib.patch
 create mode 100644 target/linux/generic/backport-6.12/780-27-v6.15-r8169-don-t-scan-PHY-addresses-0.patch
 create mode 100644 target/linux/generic/backport-6.12/780-28-v6.15-r8169-add-support-for-Intel-Killer-E5000.patch
 create mode 100644 target/linux/generic/backport-6.12/780-29-v6.15-r8169-add-PHY-c45-ops-for-MDIO_MMD_VENDOR2-registers.patch
 create mode 100644 target/linux/generic/backport-6.12/780-30-v6.15-r8169-increase-max-jumbo-packet-size-on-RTL8125-RTL8.patch
 create mode 100644 target/linux/generic/backport-6.12/780-31-v6.15-r8169-switch-away-from-deprecated-pcim_iomap_table.patch
 create mode 100644 target/linux/generic/backport-6.12/780-32-v6.15-r8169-enable-RTL8168H-RTL8168EP-RTL8168FP-ASPM-suppo.patch
 create mode 100644 target/linux/generic/backport-6.12/780-33-v6.15-r8169-disable-RTL8126-ZRX-DC-timeout.patch
 create mode 100644 target/linux/generic/backport-6.12/781-01-v6.13-net-phy-realtek-read-duplex-and-gbit-master-from-PHY.patch
 create mode 100644 target/linux/generic/backport-6.12/781-02-v6.13-net-phy-realtek-change-order-of-calls-in-C22-read_st.patch
 create mode 100644 target/linux/generic/backport-6.12/781-03-v6.13-net-phy-realtek-clear-1000Base-T-link-partner-advert.patch
 create mode 100644 target/linux/generic/backport-6.12/781-04-v6.13-net-phy-realtek-merge-the-drivers-for-internal-NBase.patch
 create mode 100644 target/linux/generic/backport-6.12/781-05-v6.13-net-phy-realtek-add-RTL8125D-internal-PHY.patch
 create mode 100644 target/linux/generic/backport-6.12/781-06-v6.14-net-phy-realtek-add-support-for-reading-MDIO_MMD_VEN.patch
 create mode 100644 target/linux/generic/backport-6.12/781-07-v6.14-net-phy-realtek-clear-1000Base-T-lpa-if-link-is-down.patch
 create mode 100644 target/linux/generic/backport-6.12/781-08-v6.14-net-phy-realtek-clear-master_slave_state-if-link-is-.patch
 create mode 100644 target/linux/generic/backport-6.12/781-09-v6.14-net-phy-realtek-always-clear-NBase-T-lpa.patch
 create mode 100644 target/linux/generic/backport-6.12/781-10-v6.14-net-phy-move-realtek-PHY-driver-to-its-own-subdirect.patch
 create mode 100644 target/linux/generic/backport-6.12/781-11-v6.14-net-phy-realtek-add-hwmon-support-for-temp-sensor-on.patch
 create mode 100644 target/linux/generic/backport-6.12/781-12-v6.14-net-phy-realtek-HWMON-support-for-standalone-version.patch
 create mode 100644 target/linux/generic/backport-6.12/781-13-v6.15-net-phy-realtek-make-HWMON-support-a-user-visible-Kc.patch
 create mode 100644 target/linux/generic/backport-6.12/781-14-v6.15-net-phy-realtek-use-string-choices-helpers.patch
 create mode 100644 target/linux/generic/backport-6.12/781-15-v6.15-net-phy-realtek-improve-mmd-register-access-for-inte.patch
 create mode 100644 target/linux/generic/backport-6.12/781-16-v6.15-net-phy-realtek-switch-from-paged-to-MMD-ops-in-rtl8.patch
 create mode 100644 target/linux/generic/backport-6.12/781-17-v6.15-net-phy-realtek-add-helper-RTL822X_VND2_C22_REG.patch
 create mode 100644 target/linux/generic/backport-6.12/781-18-v6.15-net-phy-realtek-add-defines-for-shadowed-c45-standar.patch
 create mode 100644 target/linux/generic/backport-6.12/781-19-v6.15-net-phy-realtek-disable-PHY-mode-EEE.patch
 create mode 100644 target/linux/generic/backport-6.12/792-v6.16-igc-enable-HW-vlan-tag-insertion-stripping-by-defaul.patch
 create mode 100644 target/linux/generic/backport-6.12/800-v6.13-hwmon-Add-static-visibility-member-to-struct-hwmon_o.patch
 create mode 100644 target/linux/generic/backport-6.12/839-v6.13-net-phy-aquantia-allow-forcing-order-of-MDI-pairs.patch
 create mode 100644 target/linux/generic/backport-6.12/840-v6.13-net-phy-aquantia-fix-return-value-check-in-aqr107_co.patch
 create mode 100644 target/linux/generic/backport-6.12/841-v6.13-net-phy-support-active-high-property-for-PHY-LEDs.patch
 create mode 100644 target/linux/generic/backport-6.12/842-v6.13-net-phy-aquantia-correctly-describe-LED-polarity-ove.patch
 create mode 100644 target/linux/generic/backport-6.12/843-v6.13-net-phy-mxl-gpy-add-basic-LED-support.patch
 create mode 100644 target/linux/generic/backport-6.12/844-v6.13-net-phy-mxl-gpy-add-missing-support-for-TRIGGER_NETD.patch
 create mode 100644 target/linux/generic/backport-6.12/845-v6.13-net-phy-mxl-gpy-correctly-describe-LED-polarity.patch
 create mode 100644 target/linux/generic/backport-6.12/846-v6.13-net-phy-intel-xway-add-support-for-PHY-LEDs.patch
 create mode 100644 target/linux/generic/backport-6.12/880-v6.14-gpio-regmap-Use-generic-request-free-ops.patch
 create mode 100644 target/linux/generic/backport-6.12/901-v6.13-net-dsa-mv88e6xxx-Support-LED-control.patch
 create mode 100644 target/linux/generic/backport-6.12/902-v6.13-fortify-Hide-run-time-copy-size-from-value-range-tracking.patch
 create mode 100644 target/linux/generic/config-6.12
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/Kconfig (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/Makefile (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/construct/conf_rtl8261n_c.c (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/construct/conf_rtl8264b.c (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/error.h (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/phy_patch.c (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/phy_patch.h (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.c (99%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.h (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/rtk_osal.c (98%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/rtk_osal.h (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/rtk_phy.c (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/rtk_phylib.c (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/rtk_phylib.h (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/rtk_phylib_def.h (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.c (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.h (100%)
 rename target/linux/{mediatek/files-6.6 => generic/files}/drivers/net/phy/rtl8261n/type.h (100%)
 create mode 100644 target/linux/generic/hack-6.12/200-tools_portability.patch
 create mode 100644 target/linux/generic/hack-6.12/204-module_strip.patch
 create mode 100644 target/linux/generic/hack-6.12/205-kconfig-abort-configuration-on-unset-symbol.patch
 create mode 100644 target/linux/generic/hack-6.12/210-darwin_scripts_include.patch
 create mode 100644 target/linux/generic/hack-6.12/211-darwin-uuid-typedef-clash.patch
 create mode 100644 target/linux/generic/hack-6.12/214-spidev_h_portability.patch
 create mode 100644 target/linux/generic/hack-6.12/230-openwrt_lzma_options.patch
 create mode 100644 target/linux/generic/hack-6.12/250-netfilter_depends.patch
 create mode 100644 target/linux/generic/hack-6.12/251-kconfig.patch
 create mode 100644 target/linux/generic/hack-6.12/253-ksmbd-config.patch
 create mode 100644 target/linux/generic/hack-6.12/259-regmap_dynamic.patch
 create mode 100644 target/linux/generic/hack-6.12/260-crypto_test_dependencies.patch
 create mode 100644 target/linux/generic/hack-6.12/261-lib-arc4-unhide.patch
 create mode 100644 target/linux/generic/hack-6.12/280-rfkill-stubs.patch
 create mode 100644 target/linux/generic/hack-6.12/300-MIPS-r4k_cache-use-more-efficient-cache-blast.patch
 create mode 100644 target/linux/generic/hack-6.12/301-01-mm-permit-to-declare-custom-execmem-alloc-free-funct.patch
 create mode 100644 target/linux/generic/hack-6.12/301-02-mips-replace-mlong-calls-with-mno-long-calls-if-poss.patch
 create mode 100644 target/linux/generic/hack-6.12/402-mtd-blktrans-call-add-disks-after-mtd-device.patch
 create mode 100644 target/linux/generic/hack-6.12/420-mtd-support-OpenWrt-s-MTD_ROOTFS_ROOT_DEV.patch
 create mode 100644 target/linux/generic/hack-6.12/421-drivers-mtd-parsers-add-nvmem-support-to-cmdlinepart.patch
 create mode 100644 target/linux/generic/hack-6.12/430-mtk-bmt-support.patch
 create mode 100644 target/linux/generic/hack-6.12/499-LEGACY-block-partitions-populate-fwnode.patch
 create mode 100644 target/linux/generic/hack-6.12/600-net-enable-fraglist-GRO-by-default.patch
 create mode 100644 target/linux/generic/hack-6.12/610-net-page_pool-try-to-free-deferred-skbs-while-waitin.patch
 create mode 100644 target/linux/generic/hack-6.12/645-netfilter-connmark-introduce-set-dscpmark.patch
 create mode 100644 target/linux/generic/hack-6.12/650-netfilter-add-xt_FLOWOFFLOAD-target.patch
 create mode 100644 target/linux/generic/hack-6.12/651-wireless_mesh_header.patch
 create mode 100644 target/linux/generic/hack-6.12/660-fq_codel_defaults.patch
 create mode 100644 target/linux/generic/hack-6.12/661-kernel-ct-size-the-hashtable-more-adequately.patch
 create mode 100644 target/linux/generic/hack-6.12/700-swconfig_switch_drivers.patch
 create mode 100644 target/linux/generic/hack-6.12/711-net-dsa-mv88e6xxx-disable-ATU-violation.patch
 create mode 100644 target/linux/generic/hack-6.12/721-net-add-packet-mangeling.patch
 create mode 100644 target/linux/generic/hack-6.12/722-net-phy-aquantia-enable-AQR112-and-AQR412.patch
 create mode 100644 target/linux/generic/hack-6.12/723-net-phy-aquantia-fix-system-side-protocol-mi.patch
 create mode 100644 target/linux/generic/hack-6.12/725-net-phy-aquantia-add-PHY_IDs-for-AQR112-variants.patch
 create mode 100644 target/linux/generic/hack-6.12/730-net-ethernet-mtk_eth_soc-add-hw-dump-for-forced-rese.patch
 create mode 100644 target/linux/generic/hack-6.12/735-net-phy-realtek-rtl8261n.patch
 create mode 100644 target/linux/generic/hack-6.12/750-net-pcs-mtk-lynxi-workaround-2500BaseX-no-an.patch
 create mode 100644 target/linux/generic/hack-6.12/760-net-usb-r8152-add-LED-configuration-from-OF.patch
 create mode 100644 target/linux/generic/hack-6.12/761-dt-bindings-net-add-RTL8152-binding-documentation.patch
 create mode 100644 target/linux/generic/hack-6.12/766-net-phy-mediatek-ge-add-LED-configuration-interface.patch
 create mode 100644 target/linux/generic/hack-6.12/773-bgmac-add-srab-switch.patch
 create mode 100644 target/linux/generic/hack-6.12/780-usb-net-MeigLink_modem_support.patch
 create mode 100644 target/linux/generic/hack-6.12/781-usb-net-rndis-support-asr.patch
 create mode 100644 target/linux/generic/hack-6.12/800-GPIO-add-named-gpio-exports.patch
 create mode 100644 target/linux/generic/hack-6.12/810-bcma-ssb-fallback-sprom.patch
 create mode 100644 target/linux/generic/hack-6.12/901-debloat_sock_diag.patch
 create mode 100644 target/linux/generic/hack-6.12/902-debloat_proc.patch
 create mode 100644 target/linux/generic/hack-6.12/904-debloat_dma_buf.patch
 create mode 100644 target/linux/generic/hack-6.12/910-kobject_uevent.patch
 create mode 100644 target/linux/generic/hack-6.12/911-kobject_add_broadcast_uevent.patch
 create mode 100644 target/linux/generic/hack-6.12/920-device_tree_cmdline.patch
 create mode 100644 target/linux/generic/hack-6.12/930-Revert-Revert-Revert-driver-core-Set-fw_devlink-on-b.patch
 rename target/linux/{mediatek/patches-6.6 => generic/hack-6.6}/735-net-phy-realtek-rtl8261n.patch (87%)
 create mode 100644 target/linux/generic/kernel-6.12
 create mode 100644 target/linux/generic/pending-6.12/100-compiler.h-only-include-asm-rwonce.h-for-kernel-code.patch
 create mode 100644 target/linux/generic/pending-6.12/102-MIPS-only-process-negative-stack-offsets-on-stack-tr.patch
 create mode 100644 target/linux/generic/pending-6.12/103-kbuild-export-SUBARCH.patch
 create mode 100644 target/linux/generic/pending-6.12/111-watchdog-max63xx_wdt-Add-support-for-specifying-WDI-.patch
 create mode 100644 target/linux/generic/pending-6.12/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch
 create mode 100644 target/linux/generic/pending-6.12/141-jffs2-add-RENAME_EXCHANGE-support.patch
 create mode 100644 target/linux/generic/pending-6.12/142-jffs2-add-splice-ops.patch
 create mode 100644 target/linux/generic/pending-6.12/150-bridge_allow_receiption_on_disabled_port.patch
 create mode 100644 target/linux/generic/pending-6.12/151-net-bridge-do-not-send-arp-replies-if-src-and-target.patch
 create mode 100644 target/linux/generic/pending-6.12/190-rtc-rs5c372-support_alarms_up_to_1_week.patch
 create mode 100644 target/linux/generic/pending-6.12/191-rtc-rs5c372-let_the_alarm_to_be_used_as_wakeup_source.patch
 create mode 100644 target/linux/generic/pending-6.12/200-ARM-9404-1-arm32-fix-boot-hang-with-HAVE_LD_DEAD_COD.patch
 create mode 100644 target/linux/generic/pending-6.12/203-kallsyms_uncompressed.patch
 create mode 100644 target/linux/generic/pending-6.12/205-backtrace_module_info.patch
 create mode 100644 target/linux/generic/pending-6.12/240-remove-unsane-filenames-from-deps_initramfs-list.patch
 create mode 100644 target/linux/generic/pending-6.12/270-platform-mikrotik-build-bits.patch
 create mode 100644 target/linux/generic/pending-6.12/300-mips_expose_boot_raw.patch
 create mode 100644 target/linux/generic/pending-6.12/301-MIPS-Add-barriers-between-dcache-icache-flushes.patch
 create mode 100644 target/linux/generic/pending-6.12/302-mips_no_branch_likely.patch
 create mode 100644 target/linux/generic/pending-6.12/308-mips32r2_tune.patch
 create mode 100644 target/linux/generic/pending-6.12/310-arm_module_unresolved_weak_sym.patch
 create mode 100644 target/linux/generic/pending-6.12/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch
 create mode 100644 target/linux/generic/pending-6.12/332-arc-add-OWRTDTB-section.patch
 create mode 100644 target/linux/generic/pending-6.12/333-arc-enable-unaligned-access-in-kernel-mode.patch
 create mode 100644 target/linux/generic/pending-6.12/342-powerpc-Enable-kernel-XZ-compression-option-on-PPC_8.patch
 create mode 100644 target/linux/generic/pending-6.12/350-mips-kernel-fix-detect_memory_region-function.patch
 create mode 100644 target/linux/generic/pending-6.12/400-mtd-mtdsplit-support.patch
 create mode 100644 target/linux/generic/pending-6.12/401-mtd-don-t-register-NVMEM-devices-for-partitions-with.patch
 create mode 100644 target/linux/generic/pending-6.12/402-mtd-spi-nor-write-support-for-minor-aligned-partitions.patch
 create mode 100644 target/linux/generic/pending-6.12/416-09-next-spi-spi-qpic-snand-validate-user-chip-specific-ECC-properties.patch
 create mode 100644 target/linux/generic/pending-6.12/416-10-next-1-2-mtd-nand-qpic-common-add-defines-for-ECC_MODE-values.patch
 create mode 100644 target/linux/generic/pending-6.12/416-11-next-2-2-spi-spi-qpic-snand-add-support-for-8-bits-ECC-strength.patch
 create mode 100644 target/linux/generic/pending-6.12/420-mtd-redboot_space.patch
 create mode 100644 target/linux/generic/pending-6.12/430-mtd-add-myloader-partition-parser.patch
 create mode 100644 target/linux/generic/pending-6.12/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch
 create mode 100644 target/linux/generic/pending-6.12/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch
 create mode 100644 target/linux/generic/pending-6.12/435-mtd-add-routerbootpart-parser-config.patch
 create mode 100644 target/linux/generic/pending-6.12/450-block-allow-setting-partition-of_node.patch
 create mode 100644 target/linux/generic/pending-6.12/451-block-partitions-of-assign-Device-Tree-node-to-parti.patch
 create mode 100644 target/linux/generic/pending-6.12/452-partitions-efi-apply-Linux-code-style.patch
 create mode 100644 target/linux/generic/pending-6.12/453-partitions-efi-allow-assigning-partition-Device-Tree.patch
 create mode 100644 target/linux/generic/pending-6.12/454-block-add-support-for-notifications.patch
 create mode 100644 target/linux/generic/pending-6.12/455-block-add-new-genhd-flag-GENHD_FL_NVMEM.patch
 create mode 100644 target/linux/generic/pending-6.12/456-nvmem-implement-block-NVMEM-provider.patch
 create mode 100644 target/linux/generic/pending-6.12/457-mmc-block-set-GENHD_FL_NVMEM.patch
 create mode 100644 target/linux/generic/pending-6.12/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch
 create mode 100644 target/linux/generic/pending-6.12/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch
 create mode 100644 target/linux/generic/pending-6.12/465-m25p80-mx-disable-software-protection.patch
 create mode 100644 target/linux/generic/pending-6.12/476-mtd-spi-nor-add-eon-en25q128.patch
 create mode 100644 target/linux/generic/pending-6.12/477-mtd-spi-nor-add-eon-en25qx128a.patch
 create mode 100644 target/linux/generic/pending-6.12/479-mtd-spi-nor-add-xtx-xt25f128b.patch
 create mode 100644 target/linux/generic/pending-6.12/481-mtd-spi-nor-add-support-for-Gigadevice-GD25D05.patch
 create mode 100644 target/linux/generic/pending-6.12/482-mtd-spi-nor-add-gd25q512.patch
 create mode 100644 target/linux/generic/pending-6.12/484-mtd-spi-nor-add-esmt-f25l16pa.patch
 create mode 100644 target/linux/generic/pending-6.12/485-mtd-spi-nor-add-xmc-xm25qh128c.patch
 create mode 100644 target/linux/generic/pending-6.12/487-mtd-spinand-Add-support-for-Etron-EM73D044VCx.patch
 create mode 100644 target/linux/generic/pending-6.12/488-mtd-spi-nor-add-xmc-xm25qh64c.patch
 create mode 100644 target/linux/generic/pending-6.12/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch
 create mode 100644 target/linux/generic/pending-6.12/491-ubi-auto-create-ubiblock-device-for-rootfs.patch
 create mode 100644 target/linux/generic/pending-6.12/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch
 create mode 100644 target/linux/generic/pending-6.12/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch
 create mode 100644 target/linux/generic/pending-6.12/494-mtd-ubi-add-EOF-marker-support.patch
 create mode 100644 target/linux/generic/pending-6.12/496-dt-bindings-add-bindings-for-mtd-concat-devices.patch
 create mode 100644 target/linux/generic/pending-6.12/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch
 create mode 100644 target/linux/generic/pending-6.12/498-mtd-spi-nor-locking-support-for-MX25L6405D.patch
 create mode 100644 target/linux/generic/pending-6.12/499-mtd-spi-nor-disable-16-bit-sr-for-macronix.patch
 create mode 100644 target/linux/generic/pending-6.12/500-fs_cdrom_dependencies.patch
 create mode 100644 target/linux/generic/pending-6.12/510-block-add-uImage.FIT-subimage-block-driver.patch
 create mode 100644 target/linux/generic/pending-6.12/511-init-bypass-device-lookup-for-dev-fit-rootfs.patch
 create mode 100644 target/linux/generic/pending-6.12/530-jffs2_make_lzma_available.patch
 create mode 100644 target/linux/generic/pending-6.12/532-jffs2_eofdetect.patch
 create mode 100644 target/linux/generic/pending-6.12/600-netfilter_conntrack_flush.patch
 create mode 100644 target/linux/generic/pending-6.12/610-netfilter_match_bypass_default_checks.patch
 create mode 100644 target/linux/generic/pending-6.12/611-netfilter_match_bypass_default_table.patch
 create mode 100644 target/linux/generic/pending-6.12/612-netfilter_match_reduce_memory_access.patch
 create mode 100644 target/linux/generic/pending-6.12/630-packet_socket_type.patch
 create mode 100644 target/linux/generic/pending-6.12/640-net-bridge-fix-switchdev-host-mdb-entry-updates.patch
 create mode 100644 target/linux/generic/pending-6.12/641-net-bridge-switchdev-Don-t-drop-packets-between-port.patch
 create mode 100644 target/linux/generic/pending-6.12/642-net-bridge-locally-receive-all-multicast-packets-if-.patch
 create mode 100644 target/linux/generic/pending-6.12/655-increase_skb_pad.patch
 create mode 100644 target/linux/generic/pending-6.12/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch
 create mode 100644 target/linux/generic/pending-6.12/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
 create mode 100644 target/linux/generic/pending-6.12/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch
 create mode 100644 target/linux/generic/pending-6.12/681-net-remove-NETIF_F_GSO_FRAGLIST-from-NETIF_F_GSO_SOF.patch
 create mode 100644 target/linux/generic/pending-6.12/683-of_net-add-mac-address-to-of-tree.patch
 create mode 100644 target/linux/generic/pending-6.12/690-net-add-missing-check-for-TCP-fraglist-GRO.patch
 create mode 100644 target/linux/generic/pending-6.12/700-netfilter-nft_flow_offload-handle-netdevice-events-f.patch
 create mode 100644 target/linux/generic/pending-6.12/701-netfilter-nf_tables-ignore-EOPNOTSUPP-on-flowtable-d.patch
 create mode 100644 target/linux/generic/pending-6.12/702-net-ethernet-mtk_eth_soc-enable-threaded-NAPI.patch
 create mode 100644 target/linux/generic/pending-6.12/703-phy-add-detach-callback-to-struct-phy_driver.patch
 create mode 100644 target/linux/generic/pending-6.12/705-net-dsa-tag_mtk-add-padding-for-tx-packets.patch
 create mode 100644 target/linux/generic/pending-6.12/706-net-phy-populate-host_interfaces-when-attaching-PHY.patch
 create mode 100644 target/linux/generic/pending-6.12/710-bridge-add-knob-for-filtering-rx-tx-BPDU-pack.patch
 create mode 100644 target/linux/generic/pending-6.12/711-01-net-dsa-qca8k-implement-lag_fdb_add-del-ops.patch
 create mode 100644 target/linux/generic/pending-6.12/711-02-net-dsa-qca8k-enable-flooding-to-both-CPU-port.patch
 create mode 100644 target/linux/generic/pending-6.12/711-03-net-dsa-qca8k-add-support-for-port_change_master.patch
 create mode 100644 target/linux/generic/pending-6.12/712-net-dsa-qca8k-enable-assisted-learning-on-CPU-port.patch
 create mode 100644 target/linux/generic/pending-6.12/720-01-net-phy-realtek-use-genphy_soft_reset-for-2.5G-PHYs.patch
 create mode 100644 target/linux/generic/pending-6.12/720-02-net-phy-realtek-disable-SGMII-in-band-AN-for-2-5G-PHYs.patch
 create mode 100644 target/linux/generic/pending-6.12/720-03-net-phy-realtek-make-sure-paged-read-is-protected-by.patch
 create mode 100644 target/linux/generic/pending-6.12/720-04-net-phy-realtek-setup-aldps.patch
 create mode 100644 target/linux/generic/pending-6.12/720-05-net-phy-realtek-detect-early-version-of-RTL8221B.patch
 create mode 100644 target/linux/generic/pending-6.12/720-06-net-phy-realtek-support-interrupt-of-RTL8221B.patch
 create mode 100644 target/linux/generic/pending-6.12/720-07-net-phy-realtek-mark-existing-MMDs-as-present.patch
 create mode 100644 target/linux/generic/pending-6.12/720-08-net-phy-realtek-work-around-broken-serdes.patch
 create mode 100644 target/linux/generic/pending-6.12/720-09-net-phy-realtek-disable-MDIO-broadcast.patch
 create mode 100644 target/linux/generic/pending-6.12/730-net-ethernet-mtk_eth_soc-reset-all-TX-queues-on-DMA-.patch
 create mode 100644 target/linux/generic/pending-6.12/731-net-permit-ieee80211_ptr-even-with-no-CFG82111-suppo.patch
 create mode 100644 target/linux/generic/pending-6.12/732-00-net-ethernet-mtk_eth_soc-compile-out-netsys-v2-code-.patch
 create mode 100644 target/linux/generic/pending-6.12/732-01-net-ethernet-mtk_eth_soc-work-around-issue-with-send.patch
 create mode 100644 target/linux/generic/pending-6.12/732-02-net-ethernet-mtk_eth_soc-set-NETIF_F_ALL_TSO.patch
 create mode 100644 target/linux/generic/pending-6.12/733-01-net-ethernet-mtk_eth_soc-use-napi_build_skb.patch
 create mode 100644 target/linux/generic/pending-6.12/734-net-ethernet-mediatek-enlarge-DMA-reserve-buffer.patch
 create mode 100644 target/linux/generic/pending-6.12/736-03-net-ethernet-mtk_eth_soc-improve-keeping-track-of-of.patch
 create mode 100644 target/linux/generic/pending-6.12/736-04-net-ethernet-mediatek-fix-ppe-flow-accounting-for-L2.patch
 create mode 100644 target/linux/generic/pending-6.12/737-net-ethernet-mtk_eth_soc-add-paths-and-SerDes-modes-.patch
 create mode 100644 target/linux/generic/pending-6.12/738-01-net-ethernet-mtk_eth_soc-reduce-rx-ring-size-for-older.patch
 create mode 100644 target/linux/generic/pending-6.12/738-02-net-ethernet-mtk_eth_soc-do-not-enable-page-pool-sta.patch
 create mode 100644 target/linux/generic/pending-6.12/739-01-dt-bindings-phy-mediatek-xfi-tphy-add-new-bindings.patch
 create mode 100644 target/linux/generic/pending-6.12/739-03-net-pcs-pcs-mtk-lynxi-add-platform-driver-for-MT7988.patch
 create mode 100644 target/linux/generic/pending-6.12/739-04-dt-bindings-net-pcs-add-bindings-for-MediaTek-USXGMI.patch
 create mode 100644 target/linux/generic/pending-6.12/739-05-net-pcs-add-driver-for-MediaTek-USXGMII-PCS.patch
 create mode 100644 target/linux/generic/pending-6.12/740-net-phy-motorcomm-Add-missing-include.patch
 create mode 100644 target/linux/generic/pending-6.12/741-net-phy-broadcom-update-dependency-condition.patch
 create mode 100644 target/linux/generic/pending-6.12/780-ARM-kirkwood-add-missing-linux-if_ether.h-for-ETH_AL.patch
 create mode 100644 target/linux/generic/pending-6.12/790-bus-mhi-core-add-SBL-state-callback.patch
 create mode 100644 target/linux/generic/pending-6.12/791-tg3-Fix-DMA-allocations-on-57766-devices.patch
 create mode 100644 target/linux/generic/pending-6.12/800-bcma-get-SoC-device-struct-copy-its-DMA-params-to-th.patch
 create mode 100644 target/linux/generic/pending-6.12/801-gpio-gpio-cascade-add-generic-GPIO-cascade.patch
 create mode 100644 target/linux/generic/pending-6.12/802-OPP-Provide-old-opp-to-config_clks-on-_set_opp.patch
 create mode 100644 target/linux/generic/pending-6.12/802-nvmem-u-boot-env-align-endianness-of-crc32-values.patch
 create mode 100644 target/linux/generic/pending-6.12/804-nvmem-core-support-mac-base-fixed-layout-cells.patch
 create mode 100644 target/linux/generic/pending-6.12/809-01-nvmem-core-generalize-mac-base-cells-handling.patch
 create mode 100644 target/linux/generic/pending-6.12/809-02-nvmem-layouts-add-support-for-ascii-env-driver.patch
 create mode 100644 target/linux/generic/pending-6.12/809-03-nvmem-layouts-ascii-env-handle-CRLF-while-parsing.patch
 create mode 100644 target/linux/generic/pending-6.12/810-pci_disable_common_quirks.patch
 create mode 100644 target/linux/generic/pending-6.12/811-pci_disable_usb_common_quirks.patch
 create mode 100644 target/linux/generic/pending-6.12/834-ledtrig-libata.patch
 create mode 100644 target/linux/generic/pending-6.12/840-hwrng-bcm2835-set-quality-to-1000.patch
 create mode 100644 target/linux/generic/pending-6.12/850-0023-PCI-aardvark-Make-main-irq_chip-structure-a-static-d.patch
 create mode 100644 target/linux/generic/pending-6.12/890-usb-serial-add-support-for-CH348.patch
 create mode 100644 target/linux/generic/pending-6.12/891-dt-bindings-leds-Add-LED1202-LED-Controller.patch
 create mode 100644 target/linux/generic/pending-6.12/892-leds-Add-LED1202-I2C-driver.patch
 create mode 100644 target/linux/generic/pending-6.12/893-leds_st1202-Fix-NULL-pointer-access-error.patch
 create mode 100644 target/linux/generic/pending-6.12/900-net-ag71xx-fix-qca9530-and-qca9550-mdio-probe.patch
 create mode 100644 target/linux/generic/pending-6.12/920-mangle_bootargs.patch
 create mode 100644 target/linux/qualcommax/files/arch/arm64/boot/dts/qcom/ipq5018-ess.dtsi
 create mode 100644 target/linux/qualcommax/image/ipq50xx.mk
 create mode 100644 target/linux/qualcommax/ipq50xx/config-default
 create mode 100644 target/linux/qualcommax/ipq50xx/target.mk
 create mode 100644 target/linux/qualcommax/patches-6.6/0065-v6.7-arm64-dts-qcom-ipq5018-add-watchdog.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0066-v6.7-dt-bindings-firmware-qcom-scm-support-indicating-SDI-default-state.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0067-v6.7-firmware-qcom-scm-disable-SDI-if-required.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0068-v6.7-dt-bindings-qcom-scm-document-IPQ5018-compatible.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0069-v6.7-arm64-dts-qcom-IPQ5018-indicate-that-SDI-shoud-be-disabled.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0070-v6.7-dt-bindings-phy-qcom-m31-Add-IPQ5018-compatible.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0071-v6.7-phy-qcom-m31-Add-compatible-phy-init-sequence-for-IPQ5018.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0072-v6.7-dt-bindings-usb-dwc3-Add-IPQ5018-compatible.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0073-v6.8-arm64-dts-qcom-ipq5018-Add-USB-related-nodes.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0074-v6.8-arm64-dts-qcom-ipq5018-add-QUP1-SPI-controller.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0075-v6.8-dt-bindings-clock-qcom-a53pll-add-IPQ5018-compatible.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0076-v6.8-clk-qcom-apss-ipq-pll-add-support-for-IPQ5018.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0077-v6.8-arm64-dts-qcom-ipq5018-enable-the-CPUFreq-support.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0078-v6.8-arm64-dts-qcom-ipq5018-add-few-more-reserved-memory-regions.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0080-v6.10-clk-qcom-apss-ipq-pll-use-stromer-ops-for-IPQ5018-to-fix-boot-failure.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0081-v6.10-clk-qcom-apss-ipq-pll-fix-PLL-rate-for-IPQ5018.patch
 rename target/linux/qualcommax/patches-6.6/{0140-arm64-dts-qcom-ipq6018-add-NSS-reserved-memory.patch => 0135-arm64-dts-qcom-ipq6018-add-NSS-reserved-memory.patch} (97%)
 create mode 100644 target/linux/qualcommax/patches-6.6/0138-arm64-dts-qcom-ipq6018-add-pwm-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0140-dt-bindings-pwm-add-IPQ6018-binding.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0141-pwm-driver-for-qualcomm-ipq6018-pwm-block.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0142-dt-bindings-mfd-qcom-tcsr-Add-simple-mfd-support-for-IPQ6018.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0150-dt-bindings-nvmem-add-IPQ5018-compatible.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0151-dt-bindings-thermal-qcom-tsens-Add-ipq5018-compatible.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0152-thermal-qcom-add-new-feat-for-soc-without-rpm.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0153-thermal-qcom-tsens-add-support-for-IPQ5018-tsens.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0154-dts-qcom-IPQ5018-add-tsens-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0155-dt-bindings-phy-qcom-uniphy-pcie-Document-PCIe-uniphy.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0156-phy-qcom-Introduce-PCIe-UNIPHY-28LP-driver.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0157-dt-bindings-phy-qcom-uniphy-pcie-add-IPQ5018-compatible.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0158-phy-qcom-uniphy-pcie-28lp-add-support-for-IPQ5018.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0160-dt-bindings-PCI-qcom-Add-IPQ5018-SoC.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0161-PCI-qcom-add-support-for-IPQ5018.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0162-arm64-dts-qcom-IPQ5018-add-PCIe-related-nodes.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0301-dt-bindings-mfd-qcom-tcsr-add-IPQ5018-compatible.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0302-arm64-dts-qcom-IPQ5018-add-TCSR-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0303-arm64-dts-qcom-IPQ5018-enable-the-download-mode-support.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0304-dt-bindings-pwm-add-IPQ5018-compatible.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0305-pinctrl-qcom-IPQ5018-update-pwm-groups.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0306-arm64-dts-qcom-ipq5018-Add-PWM-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0324-arm64-dts-qcom-ipq5018-Add-crypto-nodes.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0337-arm64-dts-qcom-ipq5018-Add-PRNG-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0339-arm64-dts-qcom-ipq5018-Add-QUP1-UART2-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0340-arm64-dts-qcom-ipq5018-Add-QUP3-I2C-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0401-spi-dt-bindings-Introduce-qcom-spi-qpic-snand.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0402-mtd-rawnand-qcom-cleanup-qcom_nandc-driver.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0403-mtd-rawnand-qcom-Add-qcom-prefix-to-common-api.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0404-mtd-nand-Add-qpic_common-API-file.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0405-mtd-rawnand-qcom-use-FIELD_PREP-and-GENMASK.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0406-spi-spi-qpic-add-driver-for-QCOM-SPI-NAND-flash-Interface.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0408-spi-spi-qpic-fix-compilation-issues.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0411-spi-spi-qpic-snand-support-BCH8.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0412-mtd-spinand-qpic-only-support-max-4-bytes-ID.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0421-arm64-dts-qcom-ipq5018-Add-SPI-nand-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0431-arm64-dts-qcom-ipq5018-Add-more-nand-compatible-for-.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0701-dt-bindings-clock-qcom-Add-CMN-PLL-clock-controller-.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0702-clk-qcom-Add-CMN-PLL-clock-controller-driver-for-IPQ.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0703-clk-qcom-cmn-pll-add-IPQ5018-support.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0704-arm64-dts-qcom-ipq5018-Add-ethernet-cmn-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0711-net-phy-qcom-Introduce-IPQ5018-internal-PHY-driver.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0712-arm64-dts-qcom-ipq5018-add-mdio-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0713-arm64-dts-qcom-ipq5018-add-ge_phy-node.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0714-net-phy-qcom-IPQ5018-enable-configuration-of-DAC-settings.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0715-net-phy-qcom-add-IPQ5018-initvals-and-CDT-feature.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0721-clk-gcc-ipq5018-remove-the-unsupported-clk-combinati.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0722-clk-gcc-ipq5018-refer-to-ge-phy-rx-and-tx-clk-providers-by-name.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0751-net-dsa-qca8k-always-enable-SGMII-auto-negotiation.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0752-net-dsa-qca8k-support-PHY-to-PHY-CPU-link.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0801-dt-bindings-remoteproc-qcom-Add-support-for-multipd-model.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0802-firmware-qcom_scm-ipq5332-add-support-to-pass-metada.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0803-firmware-qcom_scm-ipq5332-add-msa-lock-unlock-suppor.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0804-remoteproc-qcom-q6v5-Add-multipd-interrupts-support.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0805-remoteproc-qcom-Add-Hexagon-based-multipd-rproc-driv.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0806-rproc-qcom_q6v5_mpd-split-q6_wcss-to-rootpd-and-user.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0807-remoteproc-qcom_q6v5_mpd-fix-incorrent-use-of-rproc-.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0811-firmware-qcom_scm-support-MPD.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0812-soc-qcom-mdt_loader-support-MPD.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0813-remoteproc-qcom_q6v5_mpd-enable-clocks.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0814-remoteproc-qcom_q6v5_mpd-support-ipq5018.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0815-remoteproc-qcom_q6v5_mpd-add-support-for-passing-v1-bootargs.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0816-arm64-dts-qcom-ipq5018-add-wifi-support.patch
 create mode 100644 target/linux/qualcommax/patches-6.6/0817-arm64-dts-qcom-ipq5018-add-tz_apps-reserved-memory-region.patch

diff --git a/config/Config-kernel.in b/config/Config-kernel.in
index 64c8c63466..41ff64e567 100644
--- a/config/Config-kernel.in
+++ b/config/Config-kernel.in
@@ -567,7 +567,7 @@ config KERNEL_BPF_EVENTS
 
 config KERNEL_PROBE_EVENTS_BTF_ARGS
 	bool "Support BTF function arguments for probe events"
-	depends on KERNEL_DEBUG_INFO_BTF && KERNEL_KPROBE_EVENTS && LINUX_6_6
+	depends on KERNEL_DEBUG_INFO_BTF && KERNEL_KPROBE_EVENTS
 
 config KERNEL_BPF_KPROBE_OVERRIDE
 	bool
@@ -607,8 +607,19 @@ choice
 
 	config KERNEL_TRANSPARENT_HUGEPAGE_MADVISE
 		bool "madvise"
+
+	config KERNEL_TRANSPARENT_HUGEPAGE_NEVER
+		bool "never"
+		depends on !LINUX_6_6
 endchoice
 
+config KERNEL_ARM64_CONTPTE
+	bool "Compile the kernel with Contiguous PTE mappings for user memory"
+	depends on KERNEL_ARM64
+	depends on KERNEL_TRANSPARENT_HUGEPAGE
+	depends on !LINUX_6_6
+	default y
+
 config KERNEL_HUGETLBFS
 	bool
 
@@ -737,6 +748,11 @@ config KERNEL_SLABINFO
 	select KERNEL_SLUB_DEBUG_ON
 	bool "Enable /proc slab debug info"
 
+config KERNEL_STACKDEPOT_MAX_FRAMES
+	int
+	default 64
+	depends on KERNEL_SLUB_DEBUG
+
 config KERNEL_PROC_PAGE_MONITOR
 	bool "Enable /proc page monitoring"
 
@@ -861,6 +877,18 @@ if KERNEL_CGROUPS
 		  Memory Nodes and assigning tasks to run only within those sets.
 		  This is primarily useful on large SMP or NUMA systems.
 
+	config KERNEL_CPUSETS_V1
+		bool "Legacy cgroup v1 cpusets controller"
+		depends on KERNEL_CPUSETS
+		depends on !LINUX_6_6
+		default n
+		help
+		  Legacy cgroup v1 cpusets controller which has been deprecated by
+		  cgroup v2 implementation. The v1 is there for legacy applications
+		  which haven't migrated to the new cgroup v2 interface yet. If you
+		  do not have any such application then you are completely fine leaving
+		  this option disabled.
+
 	config KERNEL_PROC_PID_CPUSET
 		bool "Include legacy /proc/<pid>/cpuset file"
 		depends on KERNEL_CPUSETS
@@ -952,6 +980,22 @@ if KERNEL_CGROUPS
 		  Memory Controller, which are page-based, and can be swapped. Users of
 		  the kmem extension can use it to guarantee that no group of processes
 		  will ever exhaust kernel resources alone.
+	
+	config KERNEL_MEMCG_V1
+		bool "Legacy cgroup v1 memory controller"
+		default n
+		depends on KERNEL_MEMCG
+		depends on !LINUX_6_6
+		help
+		  Legacy cgroup v1 memory controller which has been deprecated by
+		  cgroup v2 implementation. The v1 is there for legacy applications
+		  which haven't migrated to the new cgroup v2 interface yet. If you
+		  do not have any such application then you are completely fine leaving
+		  this option disabled.
+
+		  Please note that feature set of the legacy memory controller is likely
+		  going to shrink due to deprecation process. New deployments with v1
+		  controller are highly discouraged.
 
 	config KERNEL_CGROUP_PERF
 		bool "Enable perf_event per-cpu per-container group (cgroup) monitoring"
diff --git a/package/firmware/linux-firmware/intel.mk b/package/firmware/linux-firmware/intel.mk
index eb5ac29159..58f5879248 100644
--- a/package/firmware/linux-firmware/intel.mk
+++ b/package/firmware/linux-firmware/intel.mk
@@ -270,3 +270,15 @@ define Package/i915-firmware-gsc/install
 	done
 endef
 $(eval $(call BuildPackage,i915-firmware-gsc))
+
+Package/ivpu-firmware = $(call Package/firmware-default,Intel VPU firmware,,LICENSE.intel_vpu)
+define Package/ivpu-firmware/install
+	$(INSTALL_DIR) $(1)/lib/firmware/intel/vpu
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/intel/vpu/*.bin $(1)/lib/firmware/intel/vpu
+	for t in `cd $(1)/lib/firmware/intel/vpu && ls vpu_*.bin | cut -d. -f1 | cut -d_ -f2 | sort | uniq`; do \
+	  source=`cd $(1)/lib/firmware && ls intel/vpu/vpu_$$$${t}_v*.bin | sort | tail -n1`;                   \
+	  target=$(1)/lib/firmware/vpu_$$$${t}.bin;                                                             \
+	  if [ -n "$$$$source" ]; then ln -sf $$$$source $$$$target; fi                                         \
+	done
+endef
+$(eval $(call BuildPackage,ivpu-firmware))
diff --git a/package/kernel/ath10k-ct/Makefile b/package/kernel/ath10k-ct/Makefile
index f9795d8c8d..dc78a12e45 100644
--- a/package/kernel/ath10k-ct/Makefile
+++ b/package/kernel/ath10k-ct/Makefile
@@ -1,21 +1,21 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=ath10k-ct
-PKG_RELEASE:=2
+PKG_RELEASE:=1
 
 PKG_LICENSE:=GPLv2
 PKG_LICENSE_FILES:=
 
 PKG_SOURCE_URL:=https://github.com/greearb/ath10k-ct.git
 PKG_SOURCE_PROTO:=git
-PKG_SOURCE_DATE:=2024-07-30
-PKG_SOURCE_VERSION:=ac71b14dc93aef0af6f0f24808b0afb673eaa5f5
-PKG_MIRROR_HASH:=f7774fc7002bbea450f543927acd528fb1bb6742f0e9ef28a402df3796893d93
+PKG_SOURCE_DATE:=2025-04-30
+PKG_SOURCE_VERSION:=23ee90f0ee20323b90870e8be694db3e0c972b67
+PKG_MIRROR_HASH:=ee91de4f34c76db6a80c477ee3430e4cc493d55d59d7ae8e11d78500d2d8e0d8
 
-# Build the 6.10 ath10k-ct driver version.
+# Build the 6.14 ath10k-ct driver version.
 # Probably this should match as closely as
 # possible to whatever mac80211 backports version is being used.
-CT_KVER="-6.10"
+CT_KVER="-6.14"
 
 PKG_MAINTAINER:=Ben Greear <greearb@candelatech.com>
 PKG_BUILD_PARALLEL:=1
diff --git a/package/kernel/ath10k-ct/patches/001-patch-version.patch b/package/kernel/ath10k-ct/patches/001-patch-version.patch
deleted file mode 100644
index 4c90a3f316..0000000000
--- a/package/kernel/ath10k-ct/patches/001-patch-version.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/ath10k-6.10/pci.c
-+++ b/ath10k-6.10/pci.c
-@@ -3871,7 +3871,7 @@ static int __ath10k_pci_probe(struct pci
- 	int (*pci_hard_reset)(struct ath10k *ar);
- 	u32 (*targ_cpu_to_ce_addr)(struct ath10k *ar, u32 addr);
- 
--	printk(KERN_INFO "ath10k 6.7 driver, optimized for CT firmware, probing pci device: 0x%x.\n",
-+	printk(KERN_INFO "ath10k 6.10 driver, optimized for CT firmware, probing pci device: 0x%x.\n",
- 	       pci_dev->device);
- 
- 	switch (pci_dev->device) {
diff --git a/package/kernel/ath10k-ct/patches/002-ath10k-6.10-remove-unsupported-feature.patch b/package/kernel/ath10k-ct/patches/002-ath10k-6.10-remove-unsupported-feature.patch
index ca64c8a110..f2adce735a 100644
--- a/package/kernel/ath10k-ct/patches/002-ath10k-6.10-remove-unsupported-feature.patch
+++ b/package/kernel/ath10k-ct/patches/002-ath10k-6.10-remove-unsupported-feature.patch
@@ -1,6 +1,6 @@
---- a/ath10k-6.10/mac.c
-+++ b/ath10k-6.10/mac.c
-@@ -11626,7 +11626,6 @@ int ath10k_mac_register(struct ath10k *a
+--- a/ath10k-6.14/mac.c
++++ b/ath10k-6.14/mac.c
+@@ -11650,7 +11650,6 @@ int ath10k_mac_register(struct ath10k *a
  	ar->hw->wiphy->n_cipher_suites = ar->hw_params.n_cipher_suites;
  
  	wiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
diff --git a/package/kernel/ath10k-ct/patches/003-ath10k-ct-make-it-compatible-with-the-old-LTS-kernel.patch b/package/kernel/ath10k-ct/patches/003-ath10k-ct-make-it-compatible-with-the-old-LTS-kernel.patch
new file mode 100644
index 0000000000..4f1918cf52
--- /dev/null
+++ b/package/kernel/ath10k-ct/patches/003-ath10k-ct-make-it-compatible-with-the-old-LTS-kernel.patch
@@ -0,0 +1,22 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 28 Mar 2025 19:56:06 +0800
+Subject: [PATCH] ath10k-ct: make it compatible with the old LTS kernel
+
+Rollback some APIs to fix compilation errors.
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ ath10k-6.14/ahb.c | 2 +-
+ 1 files changed, 1 insertions(+), 1 deletions(-)
+
+--- a/ath10k-6.14/ahb.c
++++ b/ath10k-6.14/ahb.c
+@@ -842,7 +842,7 @@ static struct platform_driver ath10k_ahb
+ 		.of_match_table = ath10k_ahb_of_match,
+ 	},
+ 	.probe = ath10k_ahb_probe,
+-	.remove = ath10k_ahb_remove,
++	.remove_new = ath10k_ahb_remove,
+ };
+ 
+ int ath10k_ahb_init(void)
diff --git a/package/kernel/ath10k-ct/patches/004-Revert-wifi-ath10k-Use-iommu_paging_domain_alloc.patch b/package/kernel/ath10k-ct/patches/004-Revert-wifi-ath10k-Use-iommu_paging_domain_alloc.patch
new file mode 100644
index 0000000000..f765950cad
--- /dev/null
+++ b/package/kernel/ath10k-ct/patches/004-Revert-wifi-ath10k-Use-iommu_paging_domain_alloc.patch
@@ -0,0 +1,28 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 28 Mar 2025 19:56:06 +0800
+Subject: [PATCH] Revert "wifi: ath10k: Use iommu_paging_domain_alloc()"
+
+IPQ4019 wireless can't start after upstream commit d5b7485588df[1].
+
+[1] https://github.com/torvalds/linux/commit/d5b7485588dffb39c5687e965623124ab7ebcd51
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ ath10k-6.14/snoc.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/ath10k-6.14/snoc.c
++++ b/ath10k-6.14/snoc.c
+@@ -1635,10 +1635,10 @@ static int ath10k_fw_init(struct ath10k
+ 
+ 	ar_snoc->fw.dev = &pdev->dev;
+ 
+-	iommu_dom = iommu_paging_domain_alloc(ar_snoc->fw.dev);
+-	if (IS_ERR(iommu_dom)) {
++	iommu_dom = iommu_domain_alloc(&platform_bus_type);
++	if (!iommu_dom) {
+ 		ath10k_err(ar, "failed to allocate iommu domain\n");
+-		ret = PTR_ERR(iommu_dom);
++		ret = -ENOMEM;
+ 		goto err_unregister;
+ 	}
+ 
diff --git a/package/kernel/ath10k-ct/patches/005-ath10k-ct-fix-missing-prototypes-warnings-on-6.12-ke.patch b/package/kernel/ath10k-ct/patches/005-ath10k-ct-fix-missing-prototypes-warnings-on-6.12-ke.patch
new file mode 100644
index 0000000000..84f3d1896b
--- /dev/null
+++ b/package/kernel/ath10k-ct/patches/005-ath10k-ct-fix-missing-prototypes-warnings-on-6.12-ke.patch
@@ -0,0 +1,79 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Mon, 28 Apr 2025 23:40:15 +0800
+Subject: [PATCH] ath10k-ct: fix missing-prototypes warnings on 6.12 kernel
+
+Fix various missing-prototypes warnings by:
+
+* Mark functions only used in current source file as static.
+* Comment out unused functions.
+
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/ath10k-ct-regular/ath10k-ct-2025.03.14~63f5b605/ath10k-6.14/debug.c:425:6: error: no previous prototype for 'ath10k_debug_fw_ratepwr_table_process' [-Werror=missing-prototypes]
+  425 | void ath10k_debug_fw_ratepwr_table_process(struct ath10k *ar, struct sk_buff *skb)
+      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/ath10k-ct-regular/ath10k-ct-2025.03.14~63f5b605/ath10k-6.14/debug.c:437:6: error: no previous prototype for 'ath10k_debug_fw_powerctl_table_process' [-Werror=missing-prototypes]
+  437 | void ath10k_debug_fw_powerctl_table_process(struct ath10k *ar, struct sk_buff *skb)
+      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/ath10k-ct-regular/ath10k-ct-2025.03.14~63f5b605/ath10k-6.14/debug.c:884:5: error: no previous prototype for 'ath10k_refresh_target_pdev_ext_ct_stats' [-Werror=missing-prototypes]
+  884 | int ath10k_refresh_target_pdev_ext_ct_stats(struct ath10k *ar)
+      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/ath10k-ct-regular/ath10k-ct-2025.03.14~63f5b605/ath10k-6.14/htt_tx.c:1190:6: error: no previous prototype for 'ieee80211_is_robust_mgmt_frame_tx' [-Werror=missing-prototypes]
+ 1190 | bool ieee80211_is_robust_mgmt_frame_tx(struct ieee80211_hdr *hdr)
+      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/ath10k-ct-regular/ath10k-ct-2025.03.14~63f5b605/ath10k-6.14/wmi.c:3203:5: error: no previous prototype for 'ath10k_wmi_event_txbf_cv_mesg' [-Werror=missing-prototypes]
+ 3203 | int ath10k_wmi_event_txbf_cv_mesg(struct ath10k *ar, struct sk_buff *skb)
+      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ ath10k-6.14/debug.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/ath10k-6.14/debug.c
++++ b/ath10k-6.14/debug.c
+@@ -422,6 +422,7 @@ static void ath10k_debug_fw_stats_reset(
+ 	spin_unlock_bh(&ar->data_lock);
+ }
+ 
++/*
+ void ath10k_debug_fw_ratepwr_table_process(struct ath10k *ar, struct sk_buff *skb)
+ {
+ 	size_t sz = skb->len;
+@@ -445,6 +446,7 @@ void ath10k_debug_fw_powerctl_table_proc
+ 	memcpy(ar->debug.powerctl_tbl.data, skb->data, sz);
+ 	complete(&ar->debug.powerctl_tbl_complete);
+ }
++*/
+ 
+ void ath10k_debug_fw_stats_process(struct ath10k *ar, struct sk_buff *skb)
+ {
+@@ -881,7 +883,7 @@ static int ath10k_refresh_target_rx_reor
+ 	return 0; /* fail silently if firmware does not support this option. */
+ }
+ 
+-int ath10k_refresh_target_pdev_ext_ct_stats(struct ath10k *ar)
++static int ath10k_refresh_target_pdev_ext_ct_stats(struct ath10k *ar)
+ {
+ 	if (test_bit(ATH10K_FW_FEATURE_CUST_STATS_CT,
+ 		     ar->running_fw->fw_file.fw_features))
+--- a/ath10k-6.14/htt_tx.c
++++ b/ath10k-6.14/htt_tx.c
+@@ -1187,7 +1187,7 @@ static u8 ath10k_htt_tx_get_tid(struct s
+  * since we do tx hw crypt, and it won't actually be encrypted even when this flag is
+  * set.
+  */
+-bool ieee80211_is_robust_mgmt_frame_tx(struct ieee80211_hdr *hdr)
++static bool ieee80211_is_robust_mgmt_frame_tx(struct ieee80211_hdr *hdr)
+ {
+         if (ieee80211_is_disassoc(hdr->frame_control) ||
+             ieee80211_is_deauth(hdr->frame_control))
+--- a/ath10k-6.14/wmi.c
++++ b/ath10k-6.14/wmi.c
+@@ -3200,7 +3200,7 @@ printme:
+ 	return 0;
+ }
+ 
+-int ath10k_wmi_event_txbf_cv_mesg(struct ath10k *ar, struct sk_buff *skb)
++static int ath10k_wmi_event_txbf_cv_mesg(struct ath10k *ar, struct sk_buff *skb)
+ {
+ 	struct wmi_txbf_cv_event *ev;
+ 
diff --git a/package/kernel/ath10k-ct/patches/010-api_update.patch b/package/kernel/ath10k-ct/patches/010-api_update.patch
deleted file mode 100644
index dff725b4e4..0000000000
--- a/package/kernel/ath10k-ct/patches/010-api_update.patch
+++ /dev/null
@@ -1,42 +0,0 @@
---- a/ath10k-6.10/mac.c
-+++ b/ath10k-6.10/mac.c
-@@ -1675,7 +1675,7 @@ static void ath10k_recalc_radar_detectio
- 		 * by indicating that radar was detected.
- 		 */
- 		ath10k_warn(ar, "failed to start CAC: %d\n", ret);
--		ieee80211_radar_detected(ar->hw);
-+		ieee80211_radar_detected(ar->hw, NULL);
- 	}
- }
- 
-@@ -6238,7 +6238,7 @@ err:
- 	return ret;
- }
- 
--static void ath10k_stop(struct ieee80211_hw *hw)
-+static void ath10k_stop(struct ieee80211_hw *hw, bool suspend)
- {
- 	struct ath10k *ar = hw->priv;
- 	u32 opt;
---- a/ath10k-6.10/debug.c
-+++ b/ath10k-6.10/debug.c
-@@ -3319,7 +3319,7 @@ static ssize_t ath10k_write_simulate_rad
- 	if (!arvif->is_started)
- 		return -EINVAL;
- 
--	ieee80211_radar_detected(ar->hw);
-+	ieee80211_radar_detected(ar->hw, NULL);
- 
- 	return count;
- }
---- a/ath10k-6.10/wmi.c
-+++ b/ath10k-6.10/wmi.c
-@@ -4402,7 +4402,7 @@ static void ath10k_radar_detected(struct
- 	if (ar->dfs_block_radar_events)
- 		ath10k_info(ar, "DFS Radar detected, but ignored as requested\n");
- 	else
--		ieee80211_radar_detected(ar->hw);
-+		ieee80211_radar_detected(ar->hw, NULL);
- }
- 
- static void ath10k_radar_confirmation_work(struct work_struct *work)
diff --git a/package/kernel/ath10k-ct/patches/201-wifi-ath10k-add-LED-and-GPIO-controlling-support-for.patch b/package/kernel/ath10k-ct/patches/201-wifi-ath10k-add-LED-and-GPIO-controlling-support-for.patch
deleted file mode 100644
index c1137d081e..0000000000
--- a/package/kernel/ath10k-ct/patches/201-wifi-ath10k-add-LED-and-GPIO-controlling-support-for.patch
+++ /dev/null
@@ -1,616 +0,0 @@
-From 8e1debd82466a3fe711784ab37e6b54e56011267 Mon Sep 17 00:00:00 2001
-From: Sebastian Gottschall <s.gottschall@dd-wrt.com>
-Date: Mon, 13 May 2024 17:22:25 +0300
-Subject: [PATCH] wifi: ath10k: add LED and GPIO controlling support for
- various chipsets
-
-Adds LED and GPIO Control support for 988x, 9887, 9888, 99x0, 9984
-based chipsets with on chipset connected led's using WMI Firmware API.
-The LED device will get available named as "ath10k-phyX" at sysfs and
-can be controlled with various triggers.
-Adds also debugfs interface for gpio control.
-
-Signed-off-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
-Reviewed-by: Steve deRosier <derosier@cal-sierra.com>
-[kvalo: major reorg and cleanup]
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
-[ansuel: rebase and small cleanup]
-Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
-Tested-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://msgid.link/20230611080505.17393-1-ansuelsmth@gmail.com
----
- ath10k-6.10/Kconfig   |  6 ++
- ath10k-6.10/Makefile  |  1 +
- ath10k-6.10/core.c    | 32 ++++++++
- ath10k-6.10/core.h    |  8 ++
- ath10k-6.10/hw.h      |  1 +
- ath10k-6.10/leds.c    | 90 +++++++++++++++++++++++
- ath10k-6.10/leds.h    | 34 +++++++++
- ath10k-6.10/mac.c     |  1 +
- ath10k-6.10/wmi-ops.h | 32 ++++++++
- ath10k-6.10/wmi-tlv.c |  2 +
- ath10k-6.10/wmi.c     | 54 ++++++++++++++
- ath10k-6.10/wmi.h     | 35 +++++++++
- 12 files changed, 296 insertions(+)
- create mode 100644 ath10k-6.10/leds.c
- create mode 100644 ath10k-6.10/leds.h
-
---- a/ath10k-6.10/Kconfig
-+++ b/ath10k-6.10/Kconfig
-@@ -68,6 +68,12 @@ config ATH10K_DEBUGFS
- 
- 	  If unsure, say Y to make it easier to debug problems.
- 
-+config ATH10K_LEDS
-+	bool
-+	depends on ATH10K
-+	depends on LEDS_CLASS=y || LEDS_CLASS=MAC80211
-+	default y
-+
- config ATH10K_SPECTRAL
- 	bool "Atheros ath10k spectral scan support"
- 	depends on ATH10K_DEBUGFS
---- a/ath10k-6.10/Makefile
-+++ b/ath10k-6.10/Makefile
-@@ -20,6 +20,7 @@ ath10k_core-$(CONFIG_ATH10K_SPECTRAL) +=
- ath10k_core-$(CONFIG_NL80211_TESTMODE) += testmode.o
- ath10k_core-$(CONFIG_ATH10K_TRACING) += trace.o
- ath10k_core-$(CONFIG_THERMAL) += thermal.o
-+ath10k_core-$(CONFIG_ATH10K_LEDS) += leds.o
- ath10k_core-$(CONFIG_MAC80211_DEBUGFS) += debugfs_sta.o
- ath10k_core-$(CONFIG_PM) += wow.o
- ath10k_core-$(CONFIG_ATH10K_CE) += ce.o
---- a/ath10k-6.10/core.c
-+++ b/ath10k-6.10/core.c
-@@ -29,6 +29,7 @@
- #include "testmode.h"
- #include "wmi-ops.h"
- #include "coredump.h"
-+#include "leds.h"
- 
- /* Disable ath10k-ct DBGLOG output by default */
- unsigned int ath10k_debug_mask = ATH10K_DBG_NO_DBGLOG;
-@@ -81,6 +82,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca988x hw2.0",
- 		.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
-+		.led_pin = 1,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
-@@ -121,6 +123,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca988x hw2.0 ubiquiti",
- 		.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
-+		.led_pin = 0,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
-@@ -162,6 +165,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca9887 hw1.0",
- 		.patch_load_addr = QCA9887_HW_1_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
-+		.led_pin = 1,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
-@@ -203,6 +207,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca6174 hw3.2 sdio",
- 		.patch_load_addr = QCA6174_HW_3_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 19,
-+		.led_pin = 0,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
- 		.max_probe_resp_desc_thres = 0,
-@@ -239,6 +244,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca6164 hw2.1",
- 		.patch_load_addr = QCA6174_HW_2_1_PATCH_LOAD_ADDR,
- 		.uart_pin = 6,
-+		.led_pin = 0,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
- 		.max_probe_resp_desc_thres = 0,
-@@ -279,6 +285,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca6174 hw2.1",
- 		.patch_load_addr = QCA6174_HW_2_1_PATCH_LOAD_ADDR,
- 		.uart_pin = 6,
-+		.led_pin = 0,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
- 		.max_probe_resp_desc_thres = 0,
-@@ -319,6 +326,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca6174 hw3.0",
- 		.patch_load_addr = QCA6174_HW_3_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 6,
-+		.led_pin = 0,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
- 		.max_probe_resp_desc_thres = 0,
-@@ -359,6 +367,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca6174 hw3.2",
- 		.patch_load_addr = QCA6174_HW_3_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 6,
-+		.led_pin = 0,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
- 		.max_probe_resp_desc_thres = 0,
-@@ -403,6 +412,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca99x0 hw2.0",
- 		.patch_load_addr = QCA99X0_HW_2_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
-+		.led_pin = 17,
- 		.otp_exe_param = 0x00000700,
- 		.continuous_frag_desc = true,
- 		.cck_rate_map_rev2 = true,
-@@ -449,6 +459,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca9984/qca9994 hw1.0",
- 		.patch_load_addr = QCA9984_HW_1_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
-+		.led_pin = 17,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
- 		.otp_exe_param = 0x00000700,
- 		.continuous_frag_desc = true,
-@@ -501,6 +512,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca9888 hw2.0",
- 		.patch_load_addr = QCA9888_HW_2_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
-+		.led_pin = 17,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
- 		.otp_exe_param = 0x00000700,
- 		.continuous_frag_desc = true,
-@@ -551,6 +563,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca9377 hw1.0",
- 		.patch_load_addr = QCA9377_HW_1_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 6,
-+		.led_pin = 0,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
- 		.max_probe_resp_desc_thres = 0,
-@@ -591,6 +604,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca9377 hw1.1",
- 		.patch_load_addr = QCA9377_HW_1_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 6,
-+		.led_pin = 0,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
- 		.max_probe_resp_desc_thres = 0,
-@@ -633,6 +647,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca9377 hw1.1 sdio",
- 		.patch_load_addr = QCA9377_HW_1_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 19,
-+		.led_pin = 0,
- 		.otp_exe_param = 0,
- 		.channel_counters_freq_hz = 88000,
- 		.max_probe_resp_desc_thres = 0,
-@@ -666,6 +681,7 @@ static const struct ath10k_hw_params ath
- 		.name = "qca4019 hw1.0",
- 		.patch_load_addr = QCA4019_HW_1_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
-+		.led_pin = 0,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
- 		.otp_exe_param = 0x0010000,
- 		.continuous_frag_desc = true,
-@@ -711,6 +727,7 @@ static const struct ath10k_hw_params ath
- 		.dev_id = 0,
- 		.bus = ATH10K_BUS_SNOC,
- 		.name = "wcn3990 hw1.0",
-+		.led_pin = 0,
- 		.continuous_frag_desc = true,
- 		.tx_chain_mask = 0x7,
- 		.rx_chain_mask = 0x7,
-@@ -4073,6 +4090,10 @@ int ath10k_core_start(struct ath10k *ar,
- 			ath10k_wmi_check_apply_board_power_ctl_table(ar);
- 	}
- 
-+	status = ath10k_leds_start(ar);
-+	if (status)
-+		goto err_hif_stop;
-+
- 	return 0;
- 
- err_hif_stop:
-@@ -4334,9 +4355,18 @@ static void ath10k_core_register_work(st
- 		goto err_spectral_destroy;
- 	}
- 
-+	status = ath10k_leds_register(ar);
-+	if (status) {
-+		ath10k_err(ar, "could not register leds: %d\n",
-+			   status);
-+		goto err_thermal_unregister;
-+	}
-+
- 	set_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags);
- 	return;
- 
-+err_thermal_unregister:
-+	ath10k_thermal_unregister(ar);
- err_spectral_destroy:
- 	ath10k_spectral_destroy(ar);
- err_debug_destroy:
-@@ -4396,6 +4426,8 @@ void ath10k_core_unregister(struct ath10
- 	if (!test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags))
- 		return;
- 
-+	ath10k_leds_unregister(ar);
-+
- 	ath10k_thermal_unregister(ar);
- 	/* Stop spectral before unregistering from mac80211 to remove the
- 	 * relayfs debugfs file cleanly. Otherwise the parent debugfs tree
---- a/ath10k-6.10/core.h
-+++ b/ath10k-6.10/core.h
-@@ -15,6 +15,7 @@
- #include <linux/pci.h>
- #include <linux/uuid.h>
- #include <linux/time.h>
-+#include <linux/leds.h>
- 
- #include "htt.h"
- #include "htc.h"
-@@ -1592,6 +1593,13 @@ struct ath10k {
- 	} testmode;
- 
- 	struct {
-+		struct gpio_led wifi_led;
-+		struct led_classdev cdev;
-+		char label[48];
-+		u32 gpio_state_pin;
-+	} leds;
-+
-+	struct {
- 		/* protected by data_lock */
- 		u32 rx_crc_err_drop;
- 		u32 fw_crash_counter;
---- a/ath10k-6.10/hw.h
-+++ b/ath10k-6.10/hw.h
-@@ -516,6 +516,7 @@ struct ath10k_hw_params {
- 	const char *name;
- 	u32 patch_load_addr;
- 	int uart_pin;
-+	int led_pin;
- 	u32 otp_exe_param;
- 
- 	/* Type of hw cycle counter wraparound logic, for more info
---- /dev/null
-+++ b/ath10k-6.10/leds.c
-@@ -0,0 +1,90 @@
-+// SPDX-License-Identifier: ISC
-+/*
-+ * Copyright (c) 2005-2011 Atheros Communications Inc.
-+ * Copyright (c) 2011-2017 Qualcomm Atheros, Inc.
-+ * Copyright (c) 2018 Sebastian Gottschall <s.gottschall@dd-wrt.com>
-+ * Copyright (c) 2018 The Linux Foundation. All rights reserved.
-+ */
-+
-+#include <linux/leds.h>
-+
-+#include "core.h"
-+#include "wmi.h"
-+#include "wmi-ops.h"
-+
-+#include "leds.h"
-+
-+static int ath10k_leds_set_brightness_blocking(struct led_classdev *led_cdev,
-+					       enum led_brightness brightness)
-+{
-+	struct ath10k *ar = container_of(led_cdev, struct ath10k,
-+					 leds.cdev);
-+	struct gpio_led *led = &ar->leds.wifi_led;
-+
-+	mutex_lock(&ar->conf_mutex);
-+
-+	if (ar->state != ATH10K_STATE_ON)
-+		goto out;
-+
-+	ar->leds.gpio_state_pin = (brightness != LED_OFF) ^ led->active_low;
-+	ath10k_wmi_gpio_output(ar, led->gpio, ar->leds.gpio_state_pin);
-+
-+out:
-+	mutex_unlock(&ar->conf_mutex);
-+
-+	return 0;
-+}
-+
-+int ath10k_leds_start(struct ath10k *ar)
-+{
-+	if (ar->hw_params.led_pin == 0)
-+		/* leds not supported */
-+		return 0;
-+
-+	/* under some circumstances, the gpio pin gets reconfigured
-+	 * to default state by the firmware, so we need to
-+	 * reconfigure it this behaviour has only ben seen on
-+	 * QCA9984 and QCA99XX devices so far
-+	 */
-+	ath10k_wmi_gpio_config(ar, ar->hw_params.led_pin, 0,
-+			       WMI_GPIO_PULL_NONE, WMI_GPIO_INTTYPE_DISABLE);
-+	ath10k_wmi_gpio_output(ar, ar->hw_params.led_pin, 1);
-+
-+	return 0;
-+}
-+
-+int ath10k_leds_register(struct ath10k *ar)
-+{
-+	int ret;
-+
-+	if (ar->hw_params.led_pin == 0)
-+		/* leds not supported */
-+		return 0;
-+
-+	snprintf(ar->leds.label, sizeof(ar->leds.label), "ath10k-%s",
-+		 wiphy_name(ar->hw->wiphy));
-+	ar->leds.wifi_led.active_low = 1;
-+	ar->leds.wifi_led.gpio = ar->hw_params.led_pin;
-+	ar->leds.wifi_led.name = ar->leds.label;
-+	ar->leds.wifi_led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
-+
-+	ar->leds.cdev.name = ar->leds.label;
-+	ar->leds.cdev.brightness_set_blocking = ath10k_leds_set_brightness_blocking;
-+	ar->leds.cdev.default_trigger = ar->leds.wifi_led.default_trigger;
-+
-+	ret = led_classdev_register(wiphy_dev(ar->hw->wiphy), &ar->leds.cdev);
-+	if (ret)
-+		return ret;
-+
-+	return 0;
-+}
-+
-+void ath10k_leds_unregister(struct ath10k *ar)
-+{
-+	if (ar->hw_params.led_pin == 0)
-+		/* leds not supported */
-+		return;
-+
-+	led_classdev_unregister(&ar->leds.cdev);
-+}
-+
---- /dev/null
-+++ b/ath10k-6.10/leds.h
-@@ -0,0 +1,34 @@
-+/* SPDX-License-Identifier: ISC */
-+/*
-+ * Copyright (c) 2005-2011 Atheros Communications Inc.
-+ * Copyright (c) 2011-2017 Qualcomm Atheros, Inc.
-+ * Copyright (c) 2018 Sebastian Gottschall <s.gottschall@dd-wrt.com>
-+ * Copyright (c) 2018 The Linux Foundation. All rights reserved.
-+ */
-+
-+#ifndef _LEDS_H_
-+#define _LEDS_H_
-+
-+#include "core.h"
-+
-+#ifdef CONFIG_ATH10K_LEDS
-+void ath10k_leds_unregister(struct ath10k *ar);
-+int ath10k_leds_start(struct ath10k *ar);
-+int ath10k_leds_register(struct ath10k *ar);
-+#else
-+static inline void ath10k_leds_unregister(struct ath10k *ar)
-+{
-+}
-+
-+static inline int ath10k_leds_start(struct ath10k *ar)
-+{
-+	return 0;
-+}
-+
-+static inline int ath10k_leds_register(struct ath10k *ar)
-+{
-+	return 0;
-+}
-+
-+#endif
-+#endif /* _LEDS_H_ */
---- a/ath10k-6.10/mac.c
-+++ b/ath10k-6.10/mac.c
-@@ -26,6 +26,7 @@
- #include "wmi-tlv.h"
- #include "wmi-ops.h"
- #include "wow.h"
-+#include "leds.h"
- 
- /*********/
- /* Rates */
---- a/ath10k-6.10/wmi-ops.h
-+++ b/ath10k-6.10/wmi-ops.h
-@@ -228,7 +228,10 @@ struct wmi_ops {
- 			 const struct wmi_bb_timing_cfg_arg *arg);
- 	struct sk_buff *(*gen_per_peer_per_tid_cfg)(struct ath10k *ar,
- 						    const struct wmi_per_peer_per_tid_cfg_arg *arg);
-+	struct sk_buff *(*gen_gpio_config)(struct ath10k *ar, u32 gpio_num,
-+					   u32 input, u32 pull_type, u32 intr_mode);
- 
-+	struct sk_buff *(*gen_gpio_output)(struct ath10k *ar, u32 gpio_num, u32 set);
- };
- 
- int ath10k_wmi_cmd_send(struct ath10k *ar, struct sk_buff *skb, u32 cmd_id);
-@@ -1147,6 +1150,35 @@ ath10k_wmi_force_fw_hang(struct ath10k *
- 	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->force_fw_hang_cmdid);
- }
- 
-+static inline int ath10k_wmi_gpio_config(struct ath10k *ar, u32 gpio_num,
-+					 u32 input, u32 pull_type, u32 intr_mode)
-+{
-+	struct sk_buff *skb;
-+
-+	if (!ar->wmi.ops->gen_gpio_config)
-+		return -EOPNOTSUPP;
-+
-+	skb = ar->wmi.ops->gen_gpio_config(ar, gpio_num, input, pull_type, intr_mode);
-+	if (IS_ERR(skb))
-+		return PTR_ERR(skb);
-+
-+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->gpio_config_cmdid);
-+}
-+
-+static inline int ath10k_wmi_gpio_output(struct ath10k *ar, u32 gpio_num, u32 set)
-+{
-+	struct sk_buff *skb;
-+
-+	if (!ar->wmi.ops->gen_gpio_config)
-+		return -EOPNOTSUPP;
-+
-+	skb = ar->wmi.ops->gen_gpio_output(ar, gpio_num, set);
-+	if (IS_ERR(skb))
-+		return PTR_ERR(skb);
-+
-+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->gpio_output_cmdid);
-+}
-+
- static inline int
- ath10k_wmi_dbglog_cfg(struct ath10k *ar, u64 module_enable, u32 log_level)
- {
---- a/ath10k-6.10/wmi-tlv.c
-+++ b/ath10k-6.10/wmi-tlv.c
-@@ -4606,6 +4606,8 @@ static const struct wmi_ops wmi_tlv_ops
- 	.gen_echo = ath10k_wmi_tlv_op_gen_echo,
- 	.gen_vdev_spectral_conf = ath10k_wmi_tlv_op_gen_vdev_spectral_conf,
- 	.gen_vdev_spectral_enable = ath10k_wmi_tlv_op_gen_vdev_spectral_enable,
-+	/* .gen_gpio_config not implemented */
-+	/* .gen_gpio_output not implemented */
- };
- 
- static const struct wmi_peer_flags_map wmi_tlv_peer_flags_map = {
---- a/ath10k-6.10/wmi.c
-+++ b/ath10k-6.10/wmi.c
-@@ -8467,6 +8467,49 @@ ath10k_wmi_op_gen_peer_set_param(struct
- 	return skb;
- }
- 
-+static struct sk_buff *ath10k_wmi_op_gen_gpio_config(struct ath10k *ar,
-+						     u32 gpio_num, u32 input,
-+						     u32 pull_type, u32 intr_mode)
-+{
-+	struct wmi_gpio_config_cmd *cmd;
-+	struct sk_buff *skb;
-+
-+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
-+	if (!skb)
-+		return ERR_PTR(-ENOMEM);
-+
-+	cmd = (struct wmi_gpio_config_cmd *)skb->data;
-+	cmd->pull_type = __cpu_to_le32(pull_type);
-+	cmd->gpio_num = __cpu_to_le32(gpio_num);
-+	cmd->input = __cpu_to_le32(input);
-+	cmd->intr_mode = __cpu_to_le32(intr_mode);
-+
-+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi gpio_config gpio_num 0x%08x input 0x%08x pull_type 0x%08x intr_mode 0x%08x\n",
-+		   gpio_num, input, pull_type, intr_mode);
-+
-+	return skb;
-+}
-+
-+static struct sk_buff *ath10k_wmi_op_gen_gpio_output(struct ath10k *ar,
-+						     u32 gpio_num, u32 set)
-+{
-+	struct wmi_gpio_output_cmd *cmd;
-+	struct sk_buff *skb;
-+
-+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
-+	if (!skb)
-+		return ERR_PTR(-ENOMEM);
-+
-+	cmd = (struct wmi_gpio_output_cmd *)skb->data;
-+	cmd->gpio_num = __cpu_to_le32(gpio_num);
-+	cmd->set = __cpu_to_le32(set);
-+
-+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi gpio_output gpio_num 0x%08x set 0x%08x\n",
-+		   gpio_num, set);
-+
-+	return skb;
-+}
-+
- static struct sk_buff *
- ath10k_wmi_op_gen_set_psmode(struct ath10k *ar, u32 vdev_id,
- 			     enum wmi_sta_ps_mode psmode)
-@@ -10274,6 +10317,9 @@ static const struct wmi_ops wmi_ops = {
- 	.fw_stats_fill = ath10k_wmi_main_op_fw_stats_fill,
- 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
- 	.gen_echo = ath10k_wmi_op_gen_echo,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
-+
- 	/* .gen_bcn_tmpl not implemented */
- 	/* .gen_prb_tmpl not implemented */
- 	/* .gen_p2p_go_bcn_ie not implemented */
-@@ -10344,6 +10390,8 @@ static const struct wmi_ops wmi_10_1_ops
- 	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
- 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
- 	.gen_echo = ath10k_wmi_op_gen_echo,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
- 	/* .gen_bcn_tmpl not implemented */
- 	/* .gen_prb_tmpl not implemented */
- 	/* .gen_p2p_go_bcn_ie not implemented */
-@@ -10423,6 +10471,8 @@ static const struct wmi_ops wmi_10_2_ops
- 	.gen_delba_send = ath10k_wmi_op_gen_delba_send,
- 	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
- 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
- 	/* .gen_pdev_enable_adaptive_cca not implemented */
- };
- 
-@@ -10494,6 +10544,8 @@ static const struct wmi_ops wmi_10_2_4_o
- 		ath10k_wmi_op_gen_pdev_enable_adaptive_cca,
- 	.get_vdev_subtype = ath10k_wmi_10_2_4_op_get_vdev_subtype,
- 	.gen_bb_timing = ath10k_wmi_10_2_4_op_gen_bb_timing,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
- 	/* .gen_bcn_tmpl not implemented */
- 	/* .gen_prb_tmpl not implemented */
- 	/* .gen_p2p_go_bcn_ie not implemented */
-@@ -10576,6 +10628,8 @@ static const struct wmi_ops wmi_10_4_ops
- 	.gen_pdev_bss_chan_info_req = ath10k_wmi_10_2_op_gen_pdev_bss_chan_info,
- 	.gen_echo = ath10k_wmi_op_gen_echo,
- 	.gen_pdev_get_tpc_config = ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
- };
- 
- int ath10k_wmi_attach(struct ath10k *ar)
---- a/ath10k-6.10/wmi.h
-+++ b/ath10k-6.10/wmi.h
-@@ -3137,6 +3137,41 @@ enum wmi_10_4_feature_mask {
- 
- };
- 
-+/* WMI_GPIO_CONFIG_CMDID */
-+enum {
-+	WMI_GPIO_PULL_NONE,
-+	WMI_GPIO_PULL_UP,
-+	WMI_GPIO_PULL_DOWN,
-+};
-+
-+enum {
-+	WMI_GPIO_INTTYPE_DISABLE,
-+	WMI_GPIO_INTTYPE_RISING_EDGE,
-+	WMI_GPIO_INTTYPE_FALLING_EDGE,
-+	WMI_GPIO_INTTYPE_BOTH_EDGE,
-+	WMI_GPIO_INTTYPE_LEVEL_LOW,
-+	WMI_GPIO_INTTYPE_LEVEL_HIGH
-+};
-+
-+/* WMI_GPIO_CONFIG_CMDID */
-+struct wmi_gpio_config_cmd {
-+	__le32 gpio_num;             /* GPIO number to be setup */
-+	__le32 input;                /* 0 - Output/ 1 - Input */
-+	__le32 pull_type;            /* Pull type defined above */
-+	__le32 intr_mode;            /* Interrupt mode defined above (Input) */
-+} __packed;
-+
-+/* WMI_GPIO_OUTPUT_CMDID */
-+struct wmi_gpio_output_cmd {
-+	__le32 gpio_num;    /* GPIO number to be setup */
-+	__le32 set;         /* Set the GPIO pin*/
-+} __packed;
-+
-+/* WMI_GPIO_INPUT_EVENTID */
-+struct wmi_gpio_input_event {
-+	__le32 gpio_num;    /* GPIO number which changed state */
-+} __packed;
-+
- struct wmi_ext_resource_config_10_4_cmd {
- 	/* contains enum wmi_host_platform_type */
- 	__le32 host_platform_config;
diff --git a/package/kernel/ath10k-ct/patches/202-ath10k-use-tpt-trigger-by-default.patch b/package/kernel/ath10k-ct/patches/202-ath10k-use-tpt-trigger-by-default.patch
index cd1d300b38..c884777baf 100644
--- a/package/kernel/ath10k-ct/patches/202-ath10k-use-tpt-trigger-by-default.patch
+++ b/package/kernel/ath10k-ct/patches/202-ath10k-use-tpt-trigger-by-default.patch
@@ -9,13 +9,13 @@ traffic.
 
 Signed-off-by: Mathias Kresin <dev@kresin.me>
 ---
- ath10k-6.7/core.h | 4 ++++
- ath10k-6.7/leds.c | 4 +---
- ath10k-6.7/mac.c  | 2 +-
+ ath10k-6.14/core.h | 4 ++++
+ ath10k-6.14/leds.c | 4 +---
+ ath10k-6.14/mac.c  | 2 +-
  3 files changed, 6 insertions(+), 4 deletions(-)
 
---- a/ath10k-6.10/core.h
-+++ b/ath10k-6.10/core.h
+--- a/ath10k-6.14/core.h
++++ b/ath10k-6.14/core.h
 @@ -1707,6 +1707,10 @@ struct ath10k {
  	u8 csi_data[4096];
  	u16 csi_data_len;
@@ -27,8 +27,8 @@ Signed-off-by: Mathias Kresin <dev@kresin.me>
  	/* must be last */
  	u8 drv_priv[] __aligned(sizeof(void *));
  };
---- a/ath10k-6.10/leds.c
-+++ b/ath10k-6.10/leds.c
+--- a/ath10k-6.14/leds.c
++++ b/ath10k-6.14/leds.c
 @@ -70,7 +70,7 @@ int ath10k_leds_register(struct ath10k *
  
  	ar->leds.cdev.name = ar->leds.label;
@@ -38,9 +38,9 @@ Signed-off-by: Mathias Kresin <dev@kresin.me>
  
  	ret = led_classdev_register(wiphy_dev(ar->hw->wiphy), &ar->leds.cdev);
  	if (ret)
---- a/ath10k-6.10/mac.c
-+++ b/ath10k-6.10/mac.c
-@@ -11631,7 +11631,7 @@ int ath10k_mac_register(struct ath10k *a
+--- a/ath10k-6.14/mac.c
++++ b/ath10k-6.14/mac.c
+@@ -11654,7 +11654,7 @@ int ath10k_mac_register(struct ath10k *a
  	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
  
  #ifdef CPTCFG_MAC80211_LEDS
diff --git a/package/kernel/ath10k-ct/patches/205-ath10k-ct-silence-warning-caused-by-unsupported-retr.patch b/package/kernel/ath10k-ct/patches/205-ath10k-ct-silence-warning-caused-by-unsupported-retr.patch
deleted file mode 100644
index 9d6b0954ff..0000000000
--- a/package/kernel/ath10k-ct/patches/205-ath10k-ct-silence-warning-caused-by-unsupported-retr.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From: Shiji Yang <yangshiji66@outlook.com>
-Date: Fri, 28 Mar 2025 20:26:04 +0800
-Subject: [PATCH] ath10k-ct: silence warning caused by unsupported retry_limit
- value
-
-Some retry_limit values are not supported by ath10k wave2 chips.
-We can just skip config it for these chips. And it's safe to
-return 0 in this case because the hardware is still working.
-
-Suggested-by: Ben Greear <greearb@candelatech.com>
-Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
----
- ath10k-6.14/mac.c | 3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/ath10k-6.10/mac.c
-+++ b/ath10k-6.10/mac.c
-@@ -5395,7 +5395,7 @@ static int ath10k_config_retry_limit(str
- 		 */
- 		ath10k_warn(ar, "Firmware lacks feature flag indicating a retry limit of > 2 is OK, requested limit: %d\n",
- 			    limit);
--		return -EINVAL;
-+		goto skip_retry_limit;
- 	}
- 
- 	list_for_each_entry(arvif, &ar->arvifs, list) {
-@@ -5406,6 +5406,7 @@ static int ath10k_config_retry_limit(str
- 		}
- 	}
- 
-+skip_retry_limit:
- 	return ret;
- }
- 
diff --git a/package/kernel/ath10k-ct/patches/206-ath10k-ct-silence-noisy-log-caused-by-flushing-queue.patch b/package/kernel/ath10k-ct/patches/206-ath10k-ct-silence-noisy-log-caused-by-flushing-queue.patch
index 8b8042e5d7..2f6db1dd2a 100644
--- a/package/kernel/ath10k-ct/patches/206-ath10k-ct-silence-noisy-log-caused-by-flushing-queue.patch
+++ b/package/kernel/ath10k-ct/patches/206-ath10k-ct-silence-noisy-log-caused-by-flushing-queue.patch
@@ -10,9 +10,9 @@ Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
  ath10k-6.14/mac.c | 8 ++++----
  1 file changed, 4 insertions(+), 4 deletions(-)
 
---- a/ath10k-6.10/mac.c
-+++ b/ath10k-6.10/mac.c
-@@ -9061,12 +9061,12 @@ static void ath10k_flush(struct ieee8021
+--- a/ath10k-6.14/mac.c
++++ b/ath10k-6.14/mac.c
+@@ -9081,12 +9081,12 @@ static void ath10k_flush(struct ieee8021
          if (vif) {
                  arvif = (void *)vif->drv_priv;
                  vid = arvif->vdev_id;
diff --git a/package/kernel/ath10k-ct/patches/300-fix-fortify-checking-error.patch b/package/kernel/ath10k-ct/patches/300-fix-fortify-checking-error.patch
index 89921d6a34..84a74c0d3e 100644
--- a/package/kernel/ath10k-ct/patches/300-fix-fortify-checking-error.patch
+++ b/package/kernel/ath10k-ct/patches/300-fix-fortify-checking-error.patch
@@ -1,5 +1,5 @@
---- a/ath10k-6.10/wmi.h
-+++ b/ath10k-6.10/wmi.h
+--- a/ath10k-6.14/wmi.h
++++ b/ath10k-6.14/wmi.h
 @@ -6310,7 +6310,7 @@ struct qca9880_set_ctl_table_cmd {
  	__le32 ctl_len; /* in bytes.  This may be ignored in firmware,
  			 * make sure ctl_info data is sizeof(qca9880_power_ctl) */
diff --git a/package/kernel/ath10k-ct/patches/960-0010-ath10k-limit-htt-rx-ring-size.patch b/package/kernel/ath10k-ct/patches/960-0010-ath10k-limit-htt-rx-ring-size.patch
index bd25222e1d..31a5161c0a 100644
--- a/package/kernel/ath10k-ct/patches/960-0010-ath10k-limit-htt-rx-ring-size.patch
+++ b/package/kernel/ath10k-ct/patches/960-0010-ath10k-limit-htt-rx-ring-size.patch
@@ -1,5 +1,5 @@
---- a/ath10k-6.10/htt.h
-+++ b/ath10k-6.10/htt.h
+--- a/ath10k-6.14/htt.h
++++ b/ath10k-6.14/htt.h
 @@ -238,7 +238,11 @@ enum htt_rx_ring_flags {
  };
  
diff --git a/package/kernel/ath10k-ct/patches/960-0011-ath10k-limit-pci-buffer-size.patch b/package/kernel/ath10k-ct/patches/960-0011-ath10k-limit-pci-buffer-size.patch
index 708a7caea2..6490e3ca9b 100644
--- a/package/kernel/ath10k-ct/patches/960-0011-ath10k-limit-pci-buffer-size.patch
+++ b/package/kernel/ath10k-ct/patches/960-0011-ath10k-limit-pci-buffer-size.patch
@@ -1,5 +1,5 @@
---- a/ath10k-6.10/pci.c
-+++ b/ath10k-6.10/pci.c
+--- a/ath10k-6.14/pci.c
++++ b/ath10k-6.14/pci.c
 @@ -132,7 +132,11 @@ static const struct ce_attr pci_host_ce_
  		.flags = CE_ATTR_FLAGS,
  		.src_nentries = 0,
diff --git a/package/kernel/ath10k-ct/patches/988-ath10k-always-use-mac80211-loss-detection.patch b/package/kernel/ath10k-ct/patches/988-ath10k-always-use-mac80211-loss-detection.patch
index 1f9f38c2b0..cc93623ed8 100644
--- a/package/kernel/ath10k-ct/patches/988-ath10k-always-use-mac80211-loss-detection.patch
+++ b/package/kernel/ath10k-ct/patches/988-ath10k-always-use-mac80211-loss-detection.patch
@@ -13,12 +13,12 @@ own loss detection mechanism.
 
 Signed-off-by: David Bauer <mail@david-bauer.net>
 ---
- ath10k-6.10/mac.c | 1 -
+ ath10k-6.14/mac.c | 1 -
  1 file changed, 1 deletion(-)
 
---- a/ath10k-6.10/mac.c
-+++ b/ath10k-6.10/mac.c
-@@ -11317,7 +11317,6 @@ int ath10k_mac_register(struct ath10k *a
+--- a/ath10k-6.14/mac.c
++++ b/ath10k-6.14/mac.c
+@@ -11339,7 +11339,6 @@ int ath10k_mac_register(struct ath10k *a
  	ieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);
  	ieee80211_hw_set(ar->hw, QUEUE_CONTROL);
  	ieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);
diff --git a/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c b/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c
index 9876dee90f..ad2e0ca863 100644
--- a/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c
+++ b/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c
@@ -674,7 +674,7 @@ static void gpio_keys_irq_close(struct gpio_keys_button_dev *bdev)
 	}
 }
 
-static int gpio_keys_remove(struct platform_device *pdev)
+static void gpio_keys_remove(struct platform_device *pdev)
 {
 	struct gpio_keys_button_dev *bdev = platform_get_drvdata(pdev);
 
@@ -684,13 +684,11 @@ static int gpio_keys_remove(struct platform_device *pdev)
 		gpio_keys_polled_close(bdev);
 	else
 		gpio_keys_irq_close(bdev);
-
-	return 0;
 }
 
 static struct platform_driver gpio_keys_driver = {
 	.probe	= gpio_keys_probe,
-	.remove	= gpio_keys_remove,
+	.remove_new = gpio_keys_remove,
 	.driver	= {
 		.name	= "gpio-keys",
 		.of_match_table = of_match_ptr(gpio_keys_of_match),
@@ -699,7 +697,7 @@ static struct platform_driver gpio_keys_driver = {
 
 static struct platform_driver gpio_keys_polled_driver = {
 	.probe	= gpio_keys_polled_probe,
-	.remove	= gpio_keys_remove,
+	.remove_new = gpio_keys_remove,
 	.driver	= {
 		.name	= "gpio-keys-polled",
 		.of_match_table = of_match_ptr(gpio_keys_polled_of_match),
diff --git a/package/kernel/lantiq/ltq-adsl-mei/src/drv_mei_cpe.c b/package/kernel/lantiq/ltq-adsl-mei/src/drv_mei_cpe.c
index 20a63716a3..0364d140e9 100644
--- a/package/kernel/lantiq/ltq-adsl-mei/src/drv_mei_cpe.c
+++ b/package/kernel/lantiq/ltq-adsl-mei/src/drv_mei_cpe.c
@@ -185,7 +185,7 @@ static void *g_xdata_addr = NULL;
 static u32 *mei_arc_swap_buff = NULL;	//  holding swap pages
 
 extern void ltq_mask_and_ack_irq(struct irq_data *d);
-static void inline MEI_MASK_AND_ACK_IRQ(int x)
+static inline void MEI_MASK_AND_ACK_IRQ(int x)
 {
 	struct irq_data d;
 	d.hwirq = x;
@@ -1178,7 +1178,7 @@ DSL_BSP_AdslLedSet (DSL_DEV_Device_t * dev, DSL_DEV_LedId_t led_number, DSL_DEV_
 * \param       CMVMSG          The pointer to message buffer.
 * \ingroup     Internal
 */
-void
+static void
 makeCMV (u8 opcode, u8 group, u16 address, u16 index, int size, u16 * data, u16 *CMVMSG)
 {
         memset (CMVMSG, 0, MSG_LENGTH * 2);
@@ -2444,7 +2444,7 @@ IFX_MEI_IoctlCopyTo (int from_kernel, char *dest, char *from, int size)
 	return ret;
 }
 
-int
+static int
 IFX_MEI_Ioctls (DSL_DEV_Device_t * pDev, int from_kernel, unsigned int command, unsigned long lon)
 {
 	int i = 0;
diff --git a/package/kernel/lantiq/ltq-adsl-mei/src/ifxmips_mei_interface.h b/package/kernel/lantiq/ltq-adsl-mei/src/ifxmips_mei_interface.h
index c591bdfb22..ec4c4429ba 100644
--- a/package/kernel/lantiq/ltq-adsl-mei/src/ifxmips_mei_interface.h
+++ b/package/kernel/lantiq/ltq-adsl-mei/src/ifxmips_mei_interface.h
@@ -618,6 +618,9 @@ extern DSL_DEV_MeiError_t DSL_BSP_Showtime(DSL_DEV_Device_t *, DSL_uint32_t, DSL
 extern int DSL_BSP_ATMLedCBRegister( int (*ifx_adsl_ledcallback)(void));
 extern DSL_DEV_MeiError_t DSL_BSP_MemoryDebugAccess(DSL_DEV_Device_t *, DSL_BSP_MemoryAccessType_t, DSL_uint32_t, DSL_uint32_t *, DSL_uint32_t);
 extern volatile DSL_DEV_Device_t *adsl_dev;
+extern int DSL_BSP_ATMLedCBUnregister (int (*ifx_adsl_ledcallback) (void));
+extern int ifx_mei_atm_led_blink(void);
+extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
 
 /**
  *    Dummy structure by now to show mechanism of extended data that will be
diff --git a/package/kernel/lantiq/ltq-adsl/patches/411-add-missing-header-platform_device.h.patch b/package/kernel/lantiq/ltq-adsl/patches/411-add-missing-header-platform_device.h.patch
new file mode 100644
index 0000000000..b5cd9541f0
--- /dev/null
+++ b/package/kernel/lantiq/ltq-adsl/patches/411-add-missing-header-platform_device.h.patch
@@ -0,0 +1,25 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 20:01:14 +0800
+Subject: [PATCH] add missing header platform_device.h
+
+Fix compilation error:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-dsl-danube/drv_dsl_cpe_api-3.24.4.4/src/common/drv_dsl_cpe_os_linux.c:1155:15: error: variable 'ltq_adsl_driver' has initializer but incomplete type
+ 1155 | static struct platform_driver ltq_adsl_driver = {
+      |               ^~~~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/common/drv_dsl_cpe_os_linux.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/src/common/drv_dsl_cpe_os_linux.c
++++ b/src/common/drv_dsl_cpe_os_linux.c
+@@ -13,6 +13,7 @@
+ #define DSL_INTERN
+ #include <linux/kthread.h>
+ #include <linux/of_platform.h>
++#include <linux/platform_device.h>
+ 
+ #include "drv_dsl_cpe_api.h"
+ #include "drv_dsl_cpe_api_ioctl.h"
diff --git a/package/kernel/lantiq/ltq-adsl/patches/412-silence-missing-prototypes-warnings.patch b/package/kernel/lantiq/ltq-adsl/patches/412-silence-missing-prototypes-warnings.patch
new file mode 100644
index 0000000000..8792140055
--- /dev/null
+++ b/package/kernel/lantiq/ltq-adsl/patches/412-silence-missing-prototypes-warnings.patch
@@ -0,0 +1,32 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 20:58:09 +0800
+Subject: [PATCH] silence missing-prototypes warnings
+
+This patch silences various missing-prototypes build warnings on
+6.12 kernel.
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/Makefile.am | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/src/Makefile.am
++++ b/src/Makefile.am
+@@ -299,6 +299,8 @@ if KERNEL_2_6
+ 
+ drv_dsl_cpe_api_OBJS = "$(subst .c,.o,$(filter %.c,$(drv_dsl_cpe_api_SOURCES)))"
+ 
++PKGFIX_CFLAGS = -Wno-error=missing-prototypes
++
+ drv_dsl_cpe_api.ko: $(drv_dsl_cpe_api_SOURCES)
+ 	@echo "drv_dsl_cpe_api: Making Linux 2.6.x kernel object"
+ 	if test ! -e common/drv_dsl_cpe_api.c ; then \
+@@ -311,7 +313,7 @@ drv_dsl_cpe_api.ko: $(drv_dsl_cpe_api_SO
+ 	@echo "# drv_dsl_cpe_api: Generated to build Linux 2.6.x kernel object" > $(PWD)/Kbuild
+ 	@echo "obj-m := $(subst .ko,.o,$@)"			>> $(PWD)/Kbuild
+ 	@echo "$(subst .ko,,$@)-y := $(drv_dsl_cpe_api_OBJS)"	>> $(PWD)/Kbuild
+-	@echo "EXTRA_CFLAGS := -DHAVE_CONFIG_H $(drv_dsl_cpe_api_CFLAGS) $(DSL_DRIVER_INCL_PATH) $(IFXOS_INCLUDE_PATH) -I@abs_srcdir@/include -I$(PWD)/include"	>> $(PWD)/Kbuild
++	@echo "EXTRA_CFLAGS := -DHAVE_CONFIG_H $(drv_dsl_cpe_api_CFLAGS) $(PKGFIX_CFLAGS) $(DSL_DRIVER_INCL_PATH) $(IFXOS_INCLUDE_PATH) -I@abs_srcdir@/include -I$(PWD)/include"	>> $(PWD)/Kbuild
+ 	$(MAKE) ARCH=@KERNEL_ARCH@ -C @KERNEL_BUILD_PATH@ O=@KERNEL_BUILD_PATH@ M=$(PWD) modules
+ 
+ clean-generic:
diff --git a/package/kernel/lantiq/ltq-atm/patches/100-ltq_atm-fix-compillation-warning.patch b/package/kernel/lantiq/ltq-atm/patches/100-ltq_atm-fix-compillation-warning.patch
deleted file mode 100644
index c74cfcb6b4..0000000000
--- a/package/kernel/lantiq/ltq-atm/patches/100-ltq_atm-fix-compillation-warning.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/ltq_atm.c
-+++ b/ltq_atm.c
-@@ -338,7 +338,8 @@ static int ppe_ioctl(struct atm_dev *dev
- 		break;
- 
- 	case PPE_ATM_MIB_VCC:   /*  VCC related MIB */
--		copy_from_user(&mib_vcc, arg, sizeof(mib_vcc));
-+		if (copy_from_user(&mib_vcc, arg, sizeof(mib_vcc)))
-+			return -EFAULT;
- 		conn = find_vpivci(mib_vcc.vpi, mib_vcc.vci);
- 		if (conn >= 0) {
- 			mib_vcc.mib_vcc.aal5VccCrcErrors     = g_atm_priv_data.conn[conn].aal5_vcc_crc_err;
diff --git a/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_amazon_se.c b/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_amazon_se.c
index 0c6d9c101a..c51f34dda3 100644
--- a/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_amazon_se.c
+++ b/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_amazon_se.c
@@ -254,7 +254,7 @@ static inline int pp32_download_code(u32 *code_src, unsigned int code_dword_len,
  * ####################################
  */
 
-extern void ase_fw_ver(unsigned int *major, unsigned int *minor)
+static void ase_fw_ver(unsigned int *major, unsigned int *minor)
 {
     ASSERT(major != NULL, "pointer is NULL");
     ASSERT(minor != NULL, "pointer is NULL");
@@ -263,7 +263,7 @@ extern void ase_fw_ver(unsigned int *major, unsigned int *minor)
     *minor = FW_VER_ID->minor;
 }
 
-int ase_init(struct platform_device *pdev)
+static int ase_init(struct platform_device *pdev)
 {
     init_pmu();
 
@@ -280,7 +280,7 @@ int ase_init(struct platform_device *pdev)
     return 0;
 }
 
-void ase_shutdown(void)
+static void ase_shutdown(void)
 {
     uninit_pmu();
 }
@@ -294,7 +294,7 @@ void ase_shutdown(void)
  *    int  --- 0: Success
  *             else:        Error Code
  */
-int ase_start(int pp32)
+static int ase_start(int pp32)
 {
     int ret;
 
@@ -320,7 +320,7 @@ int ase_start(int pp32)
  *  Output:
  *    none
  */
-void ase_stop(int pp32)
+static void ase_stop(int pp32)
 {
     /*  halt PP32   */
     IFX_REG_W32(DBG_CTRL_STOP, PP32_DBG_CTRL);
diff --git a/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_ar9.c b/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_ar9.c
index d786557682..b1e911915e 100644
--- a/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_ar9.c
+++ b/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_ar9.c
@@ -185,7 +185,7 @@ static inline int pp32_download_code(u32 *code_src, unsigned int code_dword_len,
     return 0;
 }
 
-void ar9_fw_ver(unsigned int *major, unsigned int *minor)
+static void ar9_fw_ver(unsigned int *major, unsigned int *minor)
 {
     ASSERT(major != NULL, "pointer is NULL");
     ASSERT(minor != NULL, "pointer is NULL");
@@ -194,7 +194,7 @@ void ar9_fw_ver(unsigned int *major, unsigned int *minor)
     *minor = FW_VER_ID->minor;
 }
 
-int ar9_init(struct platform_device *pdev)
+static int ar9_init(struct platform_device *pdev)
 {
 	init_pmu();
 	reset_ppe(pdev);
@@ -205,7 +205,7 @@ int ar9_init(struct platform_device *pdev)
 	return 0;
 }
 
-void ar9_shutdown(void)
+static void ar9_shutdown(void)
 {
 	ltq_pmu_disable(IFX_PMU_MODULE_PPE_SLL01 |
 		IFX_PMU_MODULE_PPE_TC |
@@ -215,7 +215,7 @@ void ar9_shutdown(void)
 		IFX_PMU_MODULE_DSL_DFE);
 }
 
-int ar9_start(int pp32)
+static int ar9_start(int pp32)
 {
 	int ret;
 
@@ -231,7 +231,7 @@ int ar9_start(int pp32)
 	return 0;
 }
 
-void ar9_stop(int pp32)
+static void ar9_stop(int pp32)
 {
 	IFX_REG_W32(DBG_CTRL_STOP, PP32_DBG_CTRL(0));
 }
diff --git a/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_danube.c b/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_danube.c
index 3ff21fa03e..d32e888272 100644
--- a/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_danube.c
+++ b/package/kernel/lantiq/ltq-atm/src/ifxmips_atm_danube.c
@@ -198,7 +198,7 @@ static void danube_shutdown(void)
 {
 }
 
-int danube_start(int pp32)
+static int danube_start(int pp32)
 {
 	int ret;
 
@@ -218,7 +218,7 @@ int danube_start(int pp32)
 	return 0;
 }
 
-void danube_stop(int pp32)
+static void danube_stop(int pp32)
 {
 	IFX_REG_W32(DBG_CTRL_STOP_SET(1), PP32_DBG_CTRL);
 }
diff --git a/package/kernel/lantiq/ltq-atm/src/ltq_atm.c b/package/kernel/lantiq/ltq-atm/src/ltq_atm.c
index 6b1e0321b3..3bc9a0769d 100644
--- a/package/kernel/lantiq/ltq-atm/src/ltq_atm.c
+++ b/package/kernel/lantiq/ltq-atm/src/ltq_atm.c
@@ -36,6 +36,7 @@
 #include <linux/init.h>
 #include <linux/ioctl.h>
 #include <linux/atmdev.h>
+#include <linux/mod_devicetable.h>
 #include <linux/platform_device.h>
 #include <linux/of_device.h>
 #include <linux/atm.h>
@@ -338,7 +339,8 @@ static int ppe_ioctl(struct atm_dev *dev, unsigned int cmd, void *arg)
 		break;
 
 	case PPE_ATM_MIB_VCC:   /*  VCC related MIB */
-		copy_from_user(&mib_vcc, arg, sizeof(mib_vcc));
+		if (copy_from_user(&mib_vcc, arg, sizeof(mib_vcc)))
+			return -EFAULT;
 		conn = find_vpivci(mib_vcc.vpi, mib_vcc.vci);
 		if (conn >= 0) {
 			mib_vcc.mib_vcc.aal5VccCrcErrors     = g_atm_priv_data.conn[conn].aal5_vcc_crc_err;
diff --git a/package/kernel/lantiq/ltq-deu/src/ifxmips_aes.c b/package/kernel/lantiq/ltq-deu/src/ifxmips_aes.c
index 3be7461108..85234dd7a8 100644
--- a/package/kernel/lantiq/ltq-deu/src/ifxmips_aes.c
+++ b/package/kernel/lantiq/ltq-deu/src/ifxmips_aes.c
@@ -148,7 +148,7 @@ extern int disable_multiblock;
  *  \param key_len key lengths of 16, 24 and 32 bytes supported  
  *  \return -EINVAL - bad key length, 0 - SUCCESS
 */                                 
-int aes_set_key (struct crypto_tfm *tfm, const u8 *in_key, unsigned int key_len)
+static int aes_set_key (struct crypto_tfm *tfm, const u8 *in_key, unsigned int key_len)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 
@@ -177,7 +177,7 @@ int aes_set_key (struct crypto_tfm *tfm, const u8 *in_key, unsigned int key_len)
  *  \param key_len key lengths of 16, 24 and 32 bytes supported
  *  \return -EINVAL - bad key length, 0 - SUCCESS
 */
-int aes_set_key_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigned int key_len)
+static int aes_set_key_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigned int key_len)
 {
     return aes_set_key(crypto_skcipher_tfm(tfm), in_key, key_len);
 }
@@ -189,7 +189,7 @@ int aes_set_key_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigne
  *  \param ctx_arg crypto algo context  
  *  \return
 */
-void aes_set_key_hw (void *ctx_arg)
+static void aes_set_key_hw (void *ctx_arg)
 {
     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
     volatile struct aes_t *aes = (volatile struct aes_t *) AES_START;
@@ -343,7 +343,7 @@ void ifx_deu_aes (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
  *  \return 0 - SUCCESS
  *          -EINVAL - bad key length
 */                                 
-int ctr_rfc3686_aes_set_key (struct crypto_tfm *tfm, const uint8_t *in_key, unsigned int key_len)
+static int ctr_rfc3686_aes_set_key (struct crypto_tfm *tfm, const uint8_t *in_key, unsigned int key_len)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
 
@@ -376,7 +376,7 @@ int ctr_rfc3686_aes_set_key (struct crypto_tfm *tfm, const uint8_t *in_key, unsi
  *  \return 0 - SUCCESS
  *          -EINVAL - bad key length
 */
-int ctr_rfc3686_aes_set_key_skcipher (struct crypto_skcipher *tfm, const uint8_t *in_key, unsigned int key_len)
+static int ctr_rfc3686_aes_set_key_skcipher (struct crypto_skcipher *tfm, const uint8_t *in_key, unsigned int key_len)
 {
     return ctr_rfc3686_aes_set_key(crypto_skcipher_tfm(tfm), in_key, key_len);
 }
@@ -413,7 +413,7 @@ int ctr_rfc3686_aes_set_key_skcipher (struct crypto_skcipher *tfm, const uint8_t
  *  \param encdec 1 for encrypt; 0 for decrypt  
  *  \param inplace not used  
 */                                 
-void ifx_deu_aes_ecb (void *ctx, uint8_t *dst, const uint8_t *src,
+static void ifx_deu_aes_ecb (void *ctx, uint8_t *dst, const uint8_t *src,
         uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_aes (ctx, dst, src, NULL, nbytes, encdec, 0);
@@ -430,7 +430,7 @@ void ifx_deu_aes_ecb (void *ctx, uint8_t *dst, const uint8_t *src,
  *  \param encdec 1 for encrypt; 0 for decrypt  
  *  \param inplace not used  
 */                                 
-void ifx_deu_aes_cbc (void *ctx, uint8_t *dst, const uint8_t *src,
+static void ifx_deu_aes_cbc (void *ctx, uint8_t *dst, const uint8_t *src,
         uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_aes (ctx, dst, src, iv, nbytes, encdec, 1);
@@ -447,7 +447,7 @@ void ifx_deu_aes_cbc (void *ctx, uint8_t *dst, const uint8_t *src,
  *  \param encdec 1 for encrypt; 0 for decrypt  
  *  \param inplace not used  
 */                                 
-void ifx_deu_aes_ofb (void *ctx, uint8_t *dst, const uint8_t *src,
+static void ifx_deu_aes_ofb (void *ctx, uint8_t *dst, const uint8_t *src,
         uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_aes (ctx, dst, src, iv, nbytes, encdec, 2);
@@ -464,7 +464,7 @@ void ifx_deu_aes_ofb (void *ctx, uint8_t *dst, const uint8_t *src,
  *  \param encdec 1 for encrypt; 0 for decrypt  
  *  \param inplace not used  
 */                                 
-void ifx_deu_aes_cfb (void *ctx, uint8_t *dst, const uint8_t *src,
+static void ifx_deu_aes_cfb (void *ctx, uint8_t *dst, const uint8_t *src,
         uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_aes (ctx, dst, src, iv, nbytes, encdec, 3);
@@ -481,7 +481,7 @@ void ifx_deu_aes_cfb (void *ctx, uint8_t *dst, const uint8_t *src,
  *  \param encdec 1 for encrypt; 0 for decrypt  
  *  \param inplace not used  
 */                                 
-void ifx_deu_aes_ctr (void *ctx, uint8_t *dst, const uint8_t *src,
+static void ifx_deu_aes_ctr (void *ctx, uint8_t *dst, const uint8_t *src,
         uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_aes (ctx, dst, src, iv, nbytes, encdec, 4);
@@ -494,7 +494,7 @@ void ifx_deu_aes_ctr (void *ctx, uint8_t *dst, const uint8_t *src,
  *  \param out output bytestream
  *  \param in input bytestream
 */
-void ifx_deu_aes_encrypt (struct crypto_tfm *tfm, uint8_t *out, const uint8_t *in)
+static void ifx_deu_aes_encrypt (struct crypto_tfm *tfm, uint8_t *out, const uint8_t *in)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
     ifx_deu_aes (ctx, out, in, NULL, AES_BLOCK_SIZE,
@@ -508,7 +508,7 @@ void ifx_deu_aes_encrypt (struct crypto_tfm *tfm, uint8_t *out, const uint8_t *i
  *  \param out output bytestream
  *  \param in input bytestream
 */
-void ifx_deu_aes_decrypt (struct crypto_tfm *tfm, uint8_t *out, const uint8_t *in)
+static void ifx_deu_aes_decrypt (struct crypto_tfm *tfm, uint8_t *out, const uint8_t *in)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(tfm);
     ifx_deu_aes (ctx, out, in, NULL, AES_BLOCK_SIZE,
@@ -544,7 +544,7 @@ struct crypto_alg ifxdeu_aes_alg = {
  *  \param req skcipher request
  *  \return err
 */
-int ecb_aes_encrypt(struct skcipher_request *req)
+static int ecb_aes_encrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -570,7 +570,7 @@ int ecb_aes_encrypt(struct skcipher_request *req)
  *  \param req skcipher request
  *  \return err
 */
-int ecb_aes_decrypt(struct skcipher_request *req)
+static int ecb_aes_decrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -615,7 +615,7 @@ struct skcipher_alg ifxdeu_ecb_aes_alg = {
  *  \param req skcipher request
  *  \return err
 */
-int cbc_aes_encrypt(struct skcipher_request *req)
+static int cbc_aes_encrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -642,7 +642,7 @@ int cbc_aes_encrypt(struct skcipher_request *req)
  *  \param req skcipher request
  *  \return err
 */
-int cbc_aes_decrypt(struct skcipher_request *req)
+static int cbc_aes_decrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -694,7 +694,7 @@ struct skcipher_alg ifxdeu_cbc_aes_alg = {
  *  \param encdec 1 for encrypt; 0 for decrypt
  *
 */
-void ifx_deu_aes_xts (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
+static void ifx_deu_aes_xts (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
         u8 *iv_arg, size_t nbytes, int encdec)
 {
     /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
@@ -797,7 +797,7 @@ void ifx_deu_aes_xts (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
  *  \param req skcipher request
  *  \return err
 */
-int xts_aes_encrypt(struct skcipher_request *req)
+static int xts_aes_encrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -853,7 +853,7 @@ int xts_aes_encrypt(struct skcipher_request *req)
  *  \param req skcipher request
  *  \return err
 */
-int xts_aes_decrypt(struct skcipher_request *req)
+static int xts_aes_decrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -911,7 +911,7 @@ int xts_aes_decrypt(struct skcipher_request *req)
  *  \param key_len key lengths of 16, 24 and 32 bytes supported
  *  \return -EINVAL - bad key length, 0 - SUCCESS
 */
-int xts_aes_set_key_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigned int key_len)
+static int xts_aes_set_key_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigned int key_len)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(crypto_skcipher_tfm(tfm));
     unsigned int keylen = (key_len / 2);
@@ -958,7 +958,7 @@ struct skcipher_alg ifxdeu_xts_aes_alg = {
  *  \param req skcipher request
  *  \return err
 */
-int ofb_aes_encrypt(struct skcipher_request *req)
+static int ofb_aes_encrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -991,7 +991,7 @@ int ofb_aes_encrypt(struct skcipher_request *req)
  *  \param req skcipher request
  *  \return err
 */
-int ofb_aes_decrypt(struct skcipher_request *req)
+static int ofb_aes_decrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -1046,7 +1046,7 @@ struct skcipher_alg ifxdeu_ofb_aes_alg = {
  *  \param req skcipher request
  *  \return err
 */
-int cfb_aes_encrypt(struct skcipher_request *req)
+static int cfb_aes_encrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -1079,7 +1079,7 @@ int cfb_aes_encrypt(struct skcipher_request *req)
  *  \param req skcipher request
  *  \return err
 */
-int cfb_aes_decrypt(struct skcipher_request *req)
+static int cfb_aes_decrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -1134,7 +1134,7 @@ struct skcipher_alg ifxdeu_cfb_aes_alg = {
  *  \param req skcipher request
  *  \return err
 */
-int ctr_basic_aes_encrypt(struct skcipher_request *req)
+static int ctr_basic_aes_encrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -1167,7 +1167,7 @@ int ctr_basic_aes_encrypt(struct skcipher_request *req)
  *  \param req skcipher request
  *  \return err
 */
-int ctr_basic_aes_decrypt(struct skcipher_request *req)
+static int ctr_basic_aes_decrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -1221,7 +1221,7 @@ struct skcipher_alg ifxdeu_ctr_basic_aes_alg = {
  *  \param req skcipher request
  *  \return err
 */
-int ctr_rfc3686_aes_encrypt(struct skcipher_request *req)
+static int ctr_rfc3686_aes_encrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -1264,7 +1264,7 @@ int ctr_rfc3686_aes_encrypt(struct skcipher_request *req)
  *  \param req skcipher request
  *  \return err
 */
-int ctr_rfc3686_aes_decrypt(struct skcipher_request *req)
+static int ctr_rfc3686_aes_decrypt(struct skcipher_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -1576,7 +1576,7 @@ static struct shash_alg ifxdeu_cbcmac_aes_alg = {
  *  \param key_len key lengths of 16, 24 and 32 bytes supported
  *  \return -EINVAL - bad key length, 0 - SUCCESS
 */
-int aes_set_key_aead (struct crypto_aead *aead, const u8 *in_key, unsigned int key_len)
+static int aes_set_key_aead (struct crypto_aead *aead, const u8 *in_key, unsigned int key_len)
 {
     struct aes_ctx *ctx = crypto_aead_ctx(aead);
     int err;
@@ -1601,7 +1601,7 @@ int aes_set_key_aead (struct crypto_aead *aead, const u8 *in_key, unsigned int k
  *  \param in_key input authsize
  *  \return -EINVAL - bad authsize length, 0 - SUCCESS
 */
-int gcm_aes_setauthsize (struct crypto_aead *aead, unsigned int authsize)
+static int gcm_aes_setauthsize (struct crypto_aead *aead, unsigned int authsize)
 {
     return crypto_gcm_check_authsize(authsize);
 }
@@ -1612,7 +1612,7 @@ int gcm_aes_setauthsize (struct crypto_aead *aead, unsigned int authsize)
  *  \param req aead request
  *  \return err
 */
-int gcm_aes_encrypt(struct aead_request *req)
+static int gcm_aes_encrypt(struct aead_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
@@ -1726,7 +1726,7 @@ int gcm_aes_encrypt(struct aead_request *req)
  *  \param req aead request
  *  \return err
 */
-int gcm_aes_decrypt(struct aead_request *req)
+static int gcm_aes_decrypt(struct aead_request *req)
 {
     struct aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
     struct skcipher_walk walk;
diff --git a/package/kernel/lantiq/ltq-deu/src/ifxmips_des.c b/package/kernel/lantiq/ltq-deu/src/ifxmips_des.c
index 953c3feddc..fc376c4d89 100644
--- a/package/kernel/lantiq/ltq-deu/src/ifxmips_des.c
+++ b/package/kernel/lantiq/ltq-deu/src/ifxmips_des.c
@@ -126,7 +126,7 @@ extern int disable_deudma;
  *  \param key input key  
  *  \param keylen key length  
 */                                 
-int des_setkey(struct crypto_tfm *tfm, const u8 *key,
+static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
                       unsigned int keylen)
 {
         struct ifx_deu_des_ctx *dctx = crypto_tfm_ctx(tfm);
@@ -161,7 +161,7 @@ int des_setkey(struct crypto_tfm *tfm, const u8 *key,
  *  \param key_len key lengths of 16, 24 and 32 bytes supported
  *  \return -EINVAL - bad key length, 0 - SUCCESS
 */
-int des_setkey_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigned int key_len)
+static int des_setkey_skcipher (struct crypto_skcipher *tfm, const u8 *in_key, unsigned int key_len)
 {
     return des_setkey(crypto_skcipher_tfm(tfm), in_key, key_len);
 }
@@ -296,7 +296,7 @@ void ifx_deu_des (void *ctx_arg, u8 *out_arg, const u8 *in_arg,
  *  \param encdec 1 for encrypt; 0 for decrypt  
  *  \param inplace not used  
 */
-void ifx_deu_des_ecb (void *ctx, uint8_t *dst, const uint8_t *src,
+static void ifx_deu_des_ecb (void *ctx, uint8_t *dst, const uint8_t *src,
                 uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_des (ctx, dst, src, NULL, nbytes, encdec, 0);
@@ -313,7 +313,7 @@ void ifx_deu_des_ecb (void *ctx, uint8_t *dst, const uint8_t *src,
  *  \param encdec 1 for encrypt; 0 for decrypt  
  *  \param inplace not used  
 */                                 
-void ifx_deu_des_cbc (void *ctx, uint8_t *dst, const uint8_t *src,
+static void ifx_deu_des_cbc (void *ctx, uint8_t *dst, const uint8_t *src,
                 uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_des (ctx, dst, src, iv, nbytes, encdec, 1);
@@ -330,11 +330,13 @@ void ifx_deu_des_cbc (void *ctx, uint8_t *dst, const uint8_t *src,
  *  \param encdec 1 for encrypt; 0 for decrypt  
  *  \param inplace not used  
 */                                 
-void ifx_deu_des_ofb (void *ctx, uint8_t *dst, const uint8_t *src,
+/*
+static void ifx_deu_des_ofb (void *ctx, uint8_t *dst, const uint8_t *src,
                 uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_des (ctx, dst, src, iv, nbytes, encdec, 2);
 }
+*/
 
 /*! \fn void ifx_deu_des_cfb (void *ctx, uint8_t *dst, const uint8_t *src, uint8_t *iv, size_t nbytes, int encdec, int inplace)
     \ingroup IFX_DES_FUNCTIONS
@@ -347,11 +349,13 @@ void ifx_deu_des_ofb (void *ctx, uint8_t *dst, const uint8_t *src,
     \param encdec 1 for encrypt; 0 for decrypt  
     \param inplace not used  
 */                                 
-void ifx_deu_des_cfb (void *ctx, uint8_t *dst, const uint8_t *src,
+/*
+static void ifx_deu_des_cfb (void *ctx, uint8_t *dst, const uint8_t *src,
                 uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_des (ctx, dst, src, iv, nbytes, encdec, 3);
 }
+*/
 
 /*! \fn void ifx_deu_des_ctr (void *ctx, uint8_t *dst, const uint8_t *src, uint8_t *iv, size_t nbytes, int encdec, int inplace)
  *  \ingroup IFX_DES_FUNCTIONS
@@ -364,11 +368,13 @@ void ifx_deu_des_cfb (void *ctx, uint8_t *dst, const uint8_t *src,
  *  \param encdec 1 for encrypt; 0 for decrypt  
  *  \param inplace not used  
 */                                 
+/*
 void ifx_deu_des_ctr (void *ctx, uint8_t *dst, const uint8_t *src,
                 uint8_t *iv, size_t nbytes, int encdec, int inplace)
 {
      ifx_deu_des (ctx, dst, src, iv, nbytes, encdec, 4);
 }
+*/
 
 /*! \fn void ifx_deu_des_encrypt (struct crypto_tfm *tfm, uint8_t *out, const uint8_t *in)
  *  \ingroup IFX_DES_FUNCTIONS
@@ -377,7 +383,7 @@ void ifx_deu_des_ctr (void *ctx, uint8_t *dst, const uint8_t *src,
  *  \param out output bytestream  
  *  \param in input bytestream  
 */                                               
-void ifx_deu_des_encrypt (struct crypto_tfm *tfm, uint8_t * out, const uint8_t * in)
+static void ifx_deu_des_encrypt (struct crypto_tfm *tfm, uint8_t * out, const uint8_t * in)
 {
      struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(tfm);
      ifx_deu_des (ctx, out, in, NULL, DES_BLOCK_SIZE,
@@ -392,7 +398,7 @@ void ifx_deu_des_encrypt (struct crypto_tfm *tfm, uint8_t * out, const uint8_t *
  *  \param out output bytestream  
  *  \param in input bytestream  
 */                                               
-void ifx_deu_des_decrypt (struct crypto_tfm *tfm, uint8_t * out, const uint8_t * in)
+static void ifx_deu_des_decrypt (struct crypto_tfm *tfm, uint8_t * out, const uint8_t * in)
 {
      struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(tfm);
      ifx_deu_des (ctx, out, in, NULL, DES_BLOCK_SIZE,
@@ -420,7 +426,7 @@ void ifx_deu_des_decrypt (struct crypto_tfm *tfm, uint8_t * out, const uint8_t *
  *  \param key input key  
  *  \param keylen key length  
 */                                 
-int des3_ede_setkey(struct crypto_tfm *tfm, const u8 *key,
+static int des3_ede_setkey(struct crypto_tfm *tfm, const u8 *key,
                     unsigned int keylen)
 {
         struct ifx_deu_des_ctx *dctx = crypto_tfm_ctx(tfm);
@@ -454,7 +460,7 @@ int des3_ede_setkey(struct crypto_tfm *tfm, const u8 *key,
  *  \param key input key
  *  \param keylen key length
 */
-int des3_ede_setkey_skcipher(struct crypto_skcipher *tfm, const u8 *key,
+static int des3_ede_setkey_skcipher(struct crypto_skcipher *tfm, const u8 *key,
                     unsigned int keylen)
 {
         return des3_ede_setkey(crypto_skcipher_tfm(tfm), key, keylen);
@@ -508,7 +514,7 @@ struct crypto_alg ifxdeu_des3_ede_alg = {
  *  \param req skcipher request
  *  \return err
 */
-int ecb_des_encrypt(struct skcipher_request *req)
+static int ecb_des_encrypt(struct skcipher_request *req)
 {
         struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
         struct skcipher_walk walk;
@@ -534,7 +540,7 @@ int ecb_des_encrypt(struct skcipher_request *req)
  *  \param req skcipher request
  *  \return err
 */
-int ecb_des_decrypt(struct skcipher_request *req)
+static int ecb_des_decrypt(struct skcipher_request *req)
 {
         struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
         struct skcipher_walk walk;
@@ -599,7 +605,7 @@ struct skcipher_alg ifxdeu_ecb_des3_ede_alg = {
  *  \param req skcipher request
  *  \return err
 */
-int cbc_des_encrypt(struct skcipher_request *req)
+static int cbc_des_encrypt(struct skcipher_request *req)
 {
         struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
         struct skcipher_walk walk;
@@ -627,7 +633,7 @@ int cbc_des_encrypt(struct skcipher_request *req)
  *  \param req skcipher request
  *  \return err
 */
-int cbc_des_decrypt(struct skcipher_request *req)
+static int cbc_des_decrypt(struct skcipher_request *req)
 {
         struct ifx_deu_des_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
         struct skcipher_walk walk;
diff --git a/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_ar9.h b/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_ar9.h
index 2f373589a5..324d20012b 100644
--- a/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_ar9.h
+++ b/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_ar9.h
@@ -304,4 +304,7 @@ struct deu_dma_t {
 	} controlr;
 };
 
+u32 input_swap(u32 input);
+void chip_version(void);
+
 #endif /* IFXMIPS_DEU_AR9_H */
diff --git a/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_danube.h b/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_danube.h
index 25561cf6e0..eb2f749bb3 100644
--- a/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_danube.h
+++ b/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_danube.h
@@ -255,4 +255,6 @@ struct deu_dma_t {
 	} controlr;
 };
 
+u32 input_swap(u32 input);
+
 #endif  /* IFXMIPS_DEU_DANUBE_H */
diff --git a/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_vr9.h b/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_vr9.h
index fcbda40159..235a393e7f 100644
--- a/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_vr9.h
+++ b/package/kernel/lantiq/ltq-deu/src/ifxmips_deu_vr9.h
@@ -321,4 +321,7 @@ struct deu_dma_t {
 	} controlr;
 };
 
+u32 input_swap(u32 input);
+void chip_version(void);
+
 #endif /* IFXMIPS_DEU_VR9_H */
diff --git a/package/kernel/lantiq/ltq-ifxos/patches/101-add-missing-prototype-for-IFX_Var_Fifo_getRoom.patch b/package/kernel/lantiq/ltq-ifxos/patches/101-add-missing-prototype-for-IFX_Var_Fifo_getRoom.patch
new file mode 100644
index 0000000000..0d35f63df3
--- /dev/null
+++ b/package/kernel/lantiq/ltq-ifxos/patches/101-add-missing-prototype-for-IFX_Var_Fifo_getRoom.patch
@@ -0,0 +1,26 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Wed, 7 May 2025 20:24:34 +0800
+Subject: [PATCH] add missing prototype for IFX_Var_Fifo_getRoom()
+
+Fix build warning on 6.12 kernel:
+
+/home/db/owrt/build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/linux-ipq40xx_generic/ifxos-ugw_8.5.2.10/src/common/ifx_fifo.c:532:14: error: no previous prototype for 'IFX_Var_Fifo_getRoom' [-Werror=missing-prototypes]
+  532 | IFX_uint32_t IFX_Var_Fifo_getRoom (IFX_VFIFO *pFifo)
+      |              ^~~~~~~~~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/include/ifx_fifo.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/src/include/ifx_fifo.h
++++ b/src/include/ifx_fifo.h
+@@ -104,6 +104,8 @@ extern IFX_int8_t   IFX_Var_Fifo_isFull
+                            IFX_VFIFO *pFifo);
+ extern IFX_uint32_t IFX_Var_Fifo_getCount(
+                            IFX_VFIFO *pFifo);
++extern IFX_uint32_t IFX_Var_Fifo_getRoom(
++                           IFX_VFIFO *pFifo);
+ 
+ #ifdef __cplusplus
+ }
diff --git a/package/kernel/lantiq/ltq-ptm/patches/102-fix-missing-prototypes-warning.patch b/package/kernel/lantiq/ltq-ptm/patches/102-fix-missing-prototypes-warning.patch
new file mode 100644
index 0000000000..faa5784fca
--- /dev/null
+++ b/package/kernel/lantiq/ltq-ptm/patches/102-fix-missing-prototypes-warning.patch
@@ -0,0 +1,26 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 02:34:14 +0800
+Subject: [PATCH] fix missing-prototypes warning
+
+Fix the build warning on 6.12 kernel:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/ltq-ptm-vr9/ltq-ptm/ifxmips_ptm_vdsl.c:64:15: error: no previous prototype for 'cgu_get_pp32_clock' [-Werror=missing-prototypes]
+   64 | unsigned long cgu_get_pp32_clock(void)
+      |               ^~~~~~~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ ifxmips_ptm_vdsl.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/ifxmips_ptm_vdsl.c
++++ b/ifxmips_ptm_vdsl.c
+@@ -61,7 +61,7 @@ static void *g_xdata_addr = NULL;
+ 
+ #define ENABLE_TMP_DBG                          0
+ 
+-unsigned long cgu_get_pp32_clock(void)
++static unsigned long cgu_get_pp32_clock(void)
+ {
+ 	struct clk *c = clk_get_ppe();
+ 	unsigned long rate = clk_get_rate(c);
diff --git a/package/kernel/lantiq/ltq-ptm/patches/103-add-missing-header-mod_devicetable.h.patch b/package/kernel/lantiq/ltq-ptm/patches/103-add-missing-header-mod_devicetable.h.patch
new file mode 100644
index 0000000000..530f62dda4
--- /dev/null
+++ b/package/kernel/lantiq/ltq-ptm/patches/103-add-missing-header-mod_devicetable.h.patch
@@ -0,0 +1,26 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 02:36:31 +0800
+Subject: [PATCH] add missing header mod_devicetable.h
+
+Fix compilation error:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/ltq-ptm-vr9/ltq-ptm/ifxmips_ptm_vdsl.c:969:34: error: array type has incomplete element type 'struct of_device_id'
+  969 | static const struct of_device_id ltq_ptm_match[] = {
+      |                                  ^~~~~~~~~~~~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/ltq-ptm-vr9/ltq-ptm/ifxmips_ptm_vdsl.c:969:34: error: 'ltq_ptm_match' defined but not used [-Werror=unused-variable]
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ ifxmips_ptm_vdsl.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/ifxmips_ptm_vdsl.c
++++ b/ifxmips_ptm_vdsl.c
+@@ -34,6 +34,7 @@
+ #include <linux/interrupt.h>
+ #include <linux/netdevice.h>
+ #include <linux/platform_device.h>
++#include <linux/mod_devicetable.h>
+ #include <linux/of_device.h>
+ 
+ #include "ifxmips_ptm_vdsl.h"
diff --git a/package/kernel/lantiq/ltq-ptm/patches/104-add-missing-header-mod_devicetable.h.patch b/package/kernel/lantiq/ltq-ptm/patches/104-add-missing-header-mod_devicetable.h.patch
new file mode 100644
index 0000000000..7e6d845def
--- /dev/null
+++ b/package/kernel/lantiq/ltq-ptm/patches/104-add-missing-header-mod_devicetable.h.patch
@@ -0,0 +1,25 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 21:16:08 +0800
+Subject: [PATCH] add missing header "mod_devicetable.h"
+
+Fix compilation error:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xway/ltq-ptm-danube/ltq-ptm/ifxmips_ptm_adsl.c:1433:34: error: array type has incomplete element type 'struct of_device_id'
+ 1433 | static const struct of_device_id ltq_ptm_match[] = {
+      |                                  ^~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ ifxmips_ptm_adsl.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/ifxmips_ptm_adsl.c
++++ b/ifxmips_ptm_adsl.c
+@@ -43,6 +43,7 @@
+ #include <linux/ioctl.h>
+ #include <linux/etherdevice.h>
+ #include <linux/interrupt.h>
++#include <linux/mod_devicetable.h>
+ #include <linux/netdevice.h>
+ #include <linux/platform_device.h>
+ #include <linux/of_device.h>
diff --git a/package/kernel/lantiq/ltq-tapi/patches/616-fix-missing-prototypes-warnings.patch b/package/kernel/lantiq/ltq-tapi/patches/616-fix-missing-prototypes-warnings.patch
new file mode 100644
index 0000000000..c0ecb42116
--- /dev/null
+++ b/package/kernel/lantiq/ltq-tapi/patches/616-fix-missing-prototypes-warnings.patch
@@ -0,0 +1,56 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Thu, 8 May 2025 23:30:39 +0800
+Subject: [PATCH] fix missing prototypes warnings
+
+This patch fixes various missing-prototypes build warnings on
+6.12 kernel:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_tapi-3.13.0/src/drv_tapi_event.c:2815:13: error: no previous prototype for 'IFX_TAPI_EventWrpBufferPool_ElementCountGet' [-Werror=missing-prototypes]
+ 2815 | IFX_int32_t IFX_TAPI_EventWrpBufferPool_ElementCountGet(IFX_void_t)
+      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_tapi-3.13.0/src/drv_tapi_event.c:2844:13: error: no previous prototype for 'IFX_TAPI_EventWrpBufferPool_ElementAvailCountGet' [-Werror=missing-prototypes]
+ 2844 | IFX_int32_t IFX_TAPI_EventWrpBufferPool_ElementAvailCountGet(IFX_void_t)
+      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_tapi-3.13.0/src/drv_tapi_fxo.c:145:13: error: no previous prototype for 'TAPI_FXO_DAA_Ioctl' [-Werror=missing-prototypes]
+  145 | IFX_int32_t TAPI_FXO_DAA_Ioctl (TAPI_CHANNEL *pChannel,
+      |             ^~~~~~~~~~~~~~~~~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_tapi-3.13.0/src/drv_tapi_fxo.c:291:13: error: no previous prototype for 'TAPI_FXO_SmartSlic_Ioctl' [-Werror=missing-prototypes]
+  291 | IFX_int32_t TAPI_FXO_SmartSlic_Ioctl(TAPI_CHANNEL *pChannel,
+      |             ^~~~~~~~~~~~~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/drv_tapi_event.h | 3 +++
+ src/drv_tapi_fxo.c   | 4 ++--
+ 2 files changed, 5 insertions(+), 2 deletions(-)
+
+--- a/src/drv_tapi_event.h
++++ b/src/drv_tapi_event.h
+@@ -24,4 +24,7 @@
+ #define IFX_EVENT_DISABLE 1
+ #define IFX_EVENT_ENABLE 0
+ 
++IFX_int32_t IFX_TAPI_EventWrpBufferPool_ElementCountGet(IFX_void_t);
++IFX_int32_t IFX_TAPI_EventWrpBufferPool_ElementAvailCountGet(IFX_void_t);
++
+ #endif /* _DRV_TAPIEVENT_H */
+--- a/src/drv_tapi_fxo.c
++++ b/src/drv_tapi_fxo.c
+@@ -142,7 +142,7 @@ IFX_return_t IFX_TAPI_FXO_Event_Dispatch
+    \remarks
+       This function is called if DAA TAPI plugin is used for FXO handling.
+ */
+-IFX_int32_t TAPI_FXO_DAA_Ioctl (TAPI_CHANNEL *pChannel,
++static IFX_int32_t TAPI_FXO_DAA_Ioctl (TAPI_CHANNEL *pChannel,
+                                 IFX_uint32_t cmd,
+                                 IFX_ulong_t arg)
+ {
+@@ -288,7 +288,7 @@ IFX_int32_t TAPI_FXO_DAA_Ioctl (TAPI_CHA
+       This function is called if LL driver is used for FXO ioctl handling.
+       Used on systems which have SmartSLIC with fused FXO line(s).
+ */
+-IFX_int32_t TAPI_FXO_SmartSlic_Ioctl(TAPI_CHANNEL *pChannel,
++static IFX_int32_t TAPI_FXO_SmartSlic_Ioctl(TAPI_CHANNEL *pChannel,
+                                      IFX_uint32_t cmd,
+                                      IFX_ulong_t arg)
+ {
diff --git a/package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/132-add-missing-prototype-for-ifx_mei_atm_led_blink.patch b/package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/132-add-missing-prototype-for-ifx_mei_atm_led_blink.patch
new file mode 100644
index 0000000000..e2f77ba75b
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/132-add-missing-prototype-for-ifx_mei_atm_led_blink.patch
@@ -0,0 +1,24 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Wed, 7 May 2025 21:57:39 +0800
+Subject: [PATCH] add missing prototype for ifx_mei_atm_led_blink()
+
+Fix build warning on 6.12 kernel:
+/home/db/owrt/build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/linux-ipq40xx_generic/dsl_cpe_mei-ugw_8.5.2.10/src/drv_mei_cpe_api_atm_ptm_intern.c:658:5: error: no previous prototype for 'ifx_mei_atm_led_blink' [-Werror=missing-prototypes]
+  658 | int ifx_mei_atm_led_blink(void)
+      |     ^~~~~~~~~~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/drv_mei_cpe_api_atm_ptm_intern.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/src/drv_mei_cpe_api_atm_ptm_intern.h
++++ b/src/drv_mei_cpe_api_atm_ptm_intern.h
+@@ -91,6 +91,7 @@ extern IFX_int32_t MEI_InternalLineTCMod
+                               IFX_int8_t nInstance,
+                               IFX_boolean_t bPowerUp,
+                               IFX_boolean_t bKillMEIControlThread);
++int ifx_mei_atm_led_blink(void);
+ 
+ #ifdef PPA_SUPPORTS_CALLBACKS
+ extern int ppa_callback_set(e_ltq_mei_cb_type type, void *func);
diff --git a/package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/133-convert-platform-driver-.remove-to-.remove_new.patch b/package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/133-convert-platform-driver-.remove-to-.remove_new.patch
new file mode 100644
index 0000000000..0ad2ab72b0
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/133-convert-platform-driver-.remove-to-.remove_new.patch
@@ -0,0 +1,43 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Wed, 7 May 2025 22:07:16 +0800
+Subject: [PATCH] convert platform driver .remove to .remove_new
+
+Fix build error on 6.12 kernel:
+
+/home/db/owrt/build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/linux-ipq40xx_generic/dsl_cpe_mei-ugw_8.5.2.10/src/drv_mei_cpe_linux.c:2270:14: error: initialization of 'void (*)(struct platform_device *)' from incompatible pointer type 'int (*)(struct platform_device *)' [-Wincompatible-pointer-types]
+ 2270 |    .remove = ltq_dsl_cpe_mei_remove,
+      |              ^~~~~~~~~~~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/drv_mei_cpe_linux.c | 5 ++---
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+--- a/src/drv_mei_cpe_linux.c
++++ b/src/drv_mei_cpe_linux.c
+@@ -2234,7 +2234,7 @@ static int dev_found = 0;
+ /* containt the number of devices registered in module_init */
+ static int dev_registered = 0;
+ 
+-static int ltq_dsl_cpe_mei_remove(struct platform_device *pdev)
++static void ltq_dsl_cpe_mei_remove(struct platform_device *pdev)
+ {
+    /* clear platform */
+    MEI_DEVICE_CFG_VALUE_SET(platform, e_MEI_DEV_PLATFORM_CONFIG_UNKNOWN);
+@@ -2244,7 +2244,6 @@ static int ltq_dsl_cpe_mei_remove(struct
+         dev_registered--;
+     }
+ #endif
+-   return 0;
+ }
+ 
+ static const struct of_device_id ltq_dsl_cpe_mei_match[] = {
+@@ -2267,7 +2266,7 @@ static struct platform_driver ltq_dsl_cp
+       .owner          = THIS_MODULE,
+       .of_match_table = ltq_dsl_cpe_mei_match,
+    },
+-   .remove = ltq_dsl_cpe_mei_remove,
++   .remove_new = ltq_dsl_cpe_mei_remove,
+ };
+ 
+ static int ltq_dsl_cpe_mei_reboot_notifier(struct notifier_block *nb,
diff --git a/package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/134-fix-ignored-qualifiers-build-warning.patch b/package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/134-fix-ignored-qualifiers-build-warning.patch
new file mode 100644
index 0000000000..87bd38a08d
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vdsl-vr11-mei/patches/134-fix-ignored-qualifiers-build-warning.patch
@@ -0,0 +1,50 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Wed, 7 May 2025 22:53:48 +0800
+Subject: [PATCH] fix ignored-qualifiers build warnings
+
+This patch fixes the following build warnings:
+
+/home/db/owrt/build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/linux-ipq40xx_generic/dsl_cpe_mei-ugw_8.5.2.10/src/drv_mei_cpe_mei_access_vrx.c:41:15: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
+   41 | static inline volatile IFX_uint32_t MEI_RCU_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+      |               ^~~~~~~~
+/home/db/owrt/build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/linux-ipq40xx_generic/dsl_cpe_mei-ugw_8.5.2.10/src/drv_mei_cpe_mei_access_vrx.c:55:15: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
+   55 | static inline volatile IFX_uint32_t MEI_CGU_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+      |               ^~~~~~~~
+/home/db/owrt/build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/linux-ipq40xx_generic/dsl_cpe_mei-ugw_8.5.2.10/src/drv_mei_cpe_mei_access_vrx.c:63:15: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
+   63 | static inline volatile IFX_uint32_t MEI_RCU_Slave_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+      |               ^~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/drv_mei_cpe_mei_access_vrx.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/src/drv_mei_cpe_mei_access_vrx.c
++++ b/src/drv_mei_cpe_mei_access_vrx.c
+@@ -38,7 +38,7 @@
+    Local macro definition
+    ========================================================================= */
+ 
+-static inline volatile IFX_uint32_t MEI_RCU_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
++static inline IFX_uint32_t MEI_RCU_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+ {
+    IFX_uint32_t ret = 0;
+    if (MEI_DEVICE_CFG_IS_PLATFORM(e_MEI_DEV_PLATFORM_CONFIG_VR9))
+@@ -52,7 +52,7 @@ static inline volatile IFX_uint32_t MEI_
+    return ret;
+ }
+ #if (MEI_SUPPORT_DEVICE_VR11 == 1)
+-static inline volatile IFX_uint32_t MEI_CGU_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
++static inline IFX_uint32_t MEI_CGU_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+ {
+    IFX_uint32_t ret = 0;
+    ret = (MEI_DRV_PCIE_VIRT_MEMBASE_GET(pMeiDrvCntrl) | MEI_CGU_OFFSET);
+@@ -60,7 +60,7 @@ static inline volatile IFX_uint32_t MEI_
+ }
+ #endif
+ 
+-static inline volatile IFX_uint32_t MEI_RCU_Slave_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
++static inline IFX_uint32_t MEI_RCU_Slave_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+ {
+    IFX_uint32_t ret = 0;
+    if (MEI_DEVICE_CFG_IS_PLATFORM(e_MEI_DEV_PLATFORM_CONFIG_VR9))
diff --git a/package/kernel/lantiq/ltq-vdsl-vr11/patches/301-fix-missing-prototypes-warnings.patch b/package/kernel/lantiq/ltq-vdsl-vr11/patches/301-fix-missing-prototypes-warnings.patch
new file mode 100644
index 0000000000..609ebbc72e
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vdsl-vr11/patches/301-fix-missing-prototypes-warnings.patch
@@ -0,0 +1,172 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Wed, 7 May 2025 23:22:11 +0800
+Subject: [PATCH] fix missing prototypes warnings
+
+This patch fixes various missing-prototypes build warnings on
+6.12 kernel.
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/bnd/drv_dsl_cpe_api_bnd_vrx.c   |  2 +-
+ src/common/drv_dsl_cpe_api.c        | 16 ++++++++--------
+ src/common/drv_dsl_cpe_os_linux.c   |  4 ++--
+ src/device/drv_dsl_cpe_device_vrx.c |  2 +-
+ src/g997/drv_dsl_cpe_api_g997_vrx.c |  1 +
+ src/include/drv_dsl_cpe_intern.h    |  6 +++---
+ 6 files changed, 16 insertions(+), 15 deletions(-)
+
+--- a/src/bnd/drv_dsl_cpe_api_bnd_vrx.c
++++ b/src/bnd/drv_dsl_cpe_api_bnd_vrx.c
+@@ -75,7 +75,7 @@ static DSL_Error_t DSL_DRV_BND_VRX_HsCon
+    - DSL_SUCCESS in case of success
+    - DSL_ERROR if operation failed
+ */
+-DSL_Error_t DSL_DRV_BND_VRX_PafHsStatusGet(
++static DSL_Error_t DSL_DRV_BND_VRX_PafHsStatusGet(
+    DSL_Context_t *pContext,
+    DSL_BND_VRX_PafHsStatus_t *pData)
+ {
+--- a/src/common/drv_dsl_cpe_api.c
++++ b/src/common/drv_dsl_cpe_api.c
+@@ -3873,7 +3873,7 @@ DSL_Error_t DSL_DRV_LoopLengthStatusGet(
+    return nErrCode;
+ }
+ 
+-DSL_Error_t DSL_DRV_RetxStatisticsGet(
++static DSL_Error_t DSL_DRV_RetxStatisticsGet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_IN_OUT DSL_ReTxStatistics_t *pData)
+ {
+@@ -4053,7 +4053,7 @@ DSL_Error_t DSL_DRV_SystemInterfaceConfi
+    \ref DSL_FIO_SYSTEM_INTERFACE_STATUS_GET
+ */
+ #ifdef INCLUDE_DSL_SYSTEM_INTERFACE
+-DSL_Error_t DSL_DRV_SystemInterfaceStatusGet(
++static DSL_Error_t DSL_DRV_SystemInterfaceStatusGet(
+    DSL_Context_t *pContext,
+    DSL_SystemInterfaceStatus_t *pData)
+ {
+@@ -5593,7 +5593,7 @@ DSL_Error_t DSL_DRV_DBG_DebugFeatureConf
+ #endif /* DSL_DEBUG_DISABLE*/
+ 
+ #ifdef INCLUDE_DSL_FILTER_DETECTION
+-DSL_Error_t DSL_DRV_FilterDetectionDataGet(
++static DSL_Error_t DSL_DRV_FilterDetectionDataGet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_OUT DSL_FilterDetection_t *pData)
+ {
+@@ -5742,7 +5742,7 @@ DSL_Error_t DSL_DRV_FilterDetectionBasic
+ }
+ #endif /* INCLUDE_DSL_FILTER_DETECTION */
+ 
+-DSL_Error_t DSL_DRV_HybridSelectionDataGet(
++static DSL_Error_t DSL_DRV_HybridSelectionDataGet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_OUT DSL_HybridSelection_t *pData)
+ {
+@@ -5804,7 +5804,7 @@ DSL_Error_t DSL_DRV_HybridSelectionDataG
+    return nErrCode;
+ }
+ 
+-DSL_Error_t DSL_DRV_OlrStatisticsGet(
++static DSL_Error_t DSL_DRV_OlrStatisticsGet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_OUT DSL_OlrStatistics_t *pData)
+ {
+@@ -5932,7 +5932,7 @@ DSL_void_t DSL_DRV_InitDataFree(
+ #endif /* INCLUDE_DSL_INIT_DATA_PREPARE*/
+ }
+ 
+-DSL_Error_t DSL_DRV_IoctlHandleHelperCall(
++static DSL_Error_t DSL_DRV_IoctlHandleHelperCall(
+    DSL_OpenContext_t *pOpenCtx,
+    DSL_Context_t *pContext,
+    DSL_boolean_t bIsInKernel,
+@@ -6573,7 +6573,7 @@ DSL_Error_t DSL_DRV_T1413_XTUR_VendorRev
+    return nErrCode;
+ }
+ 
+-DSL_Error_t DSL_DRV_PSDCalibrationConfigGet(
++static DSL_Error_t DSL_DRV_PSDCalibrationConfigGet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_IN_OUT DSL_PSDCalibration_t *pData)
+ {
+@@ -6608,7 +6608,7 @@ DSL_Error_t DSL_DRV_PSDCalibrationConfig
+    return nErrCode;
+ }
+ 
+-DSL_Error_t DSL_DRV_PSDCalibrationConfigSet(
++static DSL_Error_t DSL_DRV_PSDCalibrationConfigSet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_IN_OUT DSL_PSDCalibration_t *pData)
+ {
+--- a/src/common/drv_dsl_cpe_os_linux.c
++++ b/src/common/drv_dsl_cpe_os_linux.c
+@@ -1341,7 +1341,7 @@ static void DSL_DRV_NlSendMsg(DSL_char_t
+ #endif
+ 
+ /* Entry point of driver */
+-int __init DSL_ModuleInit(void)
++static int __init DSL_ModuleInit(void)
+ {
+    DSL_int_t i;
+ 
+@@ -1457,7 +1457,7 @@ void DSL_ModuleCleanup(void)
+    return;
+ }
+ 
+-void __exit DSL_ModuleExit(void)
++static void __exit DSL_ModuleExit(void)
+ {
+    printk("DSL: Unloading module" DSL_DRV_CRLF);
+ 
+--- a/src/device/drv_dsl_cpe_device_vrx.c
++++ b/src/device/drv_dsl_cpe_device_vrx.c
+@@ -6914,7 +6914,7 @@ DSL_Error_t DSL_DRV_VRX_ShowtimeMeasurem
+    return nErrCode;
+ }
+ 
+-DSL_Error_t DSL_DRV_VRX_ShowtimeBasicMFDMeasurementUpdate(DSL_Context_t *pContext)
++static DSL_Error_t DSL_DRV_VRX_ShowtimeBasicMFDMeasurementUpdate(DSL_Context_t *pContext)
+ {
+    DSL_Error_t nErrCode = DSL_SUCCESS;
+    ACK_MFD_InitResultsGet_t sInitResultAck = { 0 };
+--- a/src/g997/drv_dsl_cpe_api_g997_vrx.c
++++ b/src/g997/drv_dsl_cpe_api_g997_vrx.c
+@@ -11,6 +11,7 @@
+ #define DSL_INTERN
+ 
+ #include "drv_dsl_cpe_api.h"
++#include "drv_dsl_cpe_device_g997.h"
+ 
+ #ifdef INCLUDE_DSL_CPE_API_VRX
+ 
+--- a/src/include/drv_dsl_cpe_intern.h
++++ b/src/include/drv_dsl_cpe_intern.h
+@@ -1151,7 +1151,7 @@ DSL_Error_t DSL_DRV_InteropFeatureConfig
+    For a detailed description please refer to the equivalent ioctl
+    \ref DSL_FIO_RETX_STATISTICS_GET
+ */
+-#ifdef INCLUDE_DSL_CPE_API_DANUBE
++#if defined(INCLUDE_DSL_CPE_API_DANUBE) && 0
+ #ifndef SWIG_TMP
+ DSL_Error_t DSL_DRV_RetxStatisticsGet(
+    DSL_IN DSL_Context_t *pContext,
+@@ -1436,7 +1436,7 @@ DSL_Error_t DSL_DRV_SystemInterfaceConfi
+    For a detailed description please refer to the equivalent ioctl
+    \ref DSL_FIO_FILTER_DETECTION_DATA_GET
+ */
+-#if defined(INCLUDE_DSL_CPE_API_DANUBE) && defined(INCLUDE_DSL_FILTER_DETECTION)
++#if defined(INCLUDE_DSL_CPE_API_DANUBE) && defined(INCLUDE_DSL_FILTER_DETECTION) && 0
+ #ifndef SWIG_TMP
+ DSL_Error_t DSL_DRV_FilterDetectionDataGet(
+    DSL_IN DSL_Context_t *pContext,
+@@ -1462,7 +1462,7 @@ DSL_Error_t DSL_DRV_FilterDetectionBasic
+    For a detailed description please refer to the equivalent ioctl
+    \ref DSL_FIO_HYBRID_SELECTION_DATA_GET
+ */
+-#ifdef INCLUDE_DSL_CPE_API_DANUBE
++#if defined(INCLUDE_DSL_CPE_API_DANUBE) && 0
+ #ifndef SWIG_TMP
+ DSL_Error_t DSL_DRV_HybridSelectionDataGet(
+    DSL_IN DSL_Context_t *pContext,
diff --git a/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/100-compat.patch b/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/100-compat.patch
index 7e7381a346..e061e68934 100644
--- a/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/100-compat.patch
+++ b/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/100-compat.patch
@@ -313,17 +313,22 @@
  
  #if (MEI_EXPORT_INTERNAL_API == 1) && (MEI_DRV_ATM_PTM_INTERFACE_ENABLE == 1)
  
-@@ -59,8 +58,21 @@ extern IFX_int32_t MEI_InternalTcReset(
+@@ -58,9 +57,26 @@ extern IFX_int32_t MEI_InternalTcRequest
+ extern IFX_int32_t MEI_InternalTcReset(
                                MEI_DYN_CNTRL_T        *pMeiDynCntrl,
                                MEI_TC_Reset_t         *pArgTcReset);
- 
++struct port_cell_info;
++extern int ifx_mei_atm_showtime_check(int *is_showtime,
++                              struct port_cell_info *port_cell,
++                              void **xdata_addr);
++
 +#if 1
 +#include <lantiq_atm.h>
 +typedef enum {
 +	LTQ_MEI_SHOWTIME_ENTER,
 +	LTQ_MEI_SHOWTIME_EXIT
 +} e_ltq_mei_cb_type;
-+
+ 
 +typedef void (*ltq_mei_atm_showtime_enter_t)(IFX_uint8_t, struct port_cell_info *, void *);
 +typedef void (*ltq_mei_atm_showtime_exit_t)(IFX_uint8_t);
 +
diff --git a/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/405-convert-platform-driver-.remove-to-.remove_new.patch b/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/405-convert-platform-driver-.remove-to-.remove_new.patch
new file mode 100644
index 0000000000..9e64e689b6
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/405-convert-platform-driver-.remove-to-.remove_new.patch
@@ -0,0 +1,41 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 00:54:48 +0800
+Subject: [PATCH] convert platform driver .remove to .remove_new
+
+Fix compilation error on 6.12 kernel:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_mei_cpe-1.5.17.6/src/drv_mei_cpe_linux.c:2073:23: error: initialization of 'void (*)(struct platform_device *)' from incompatible pointer type 'int (*)(struct platform_device *)' [-Wincompatible-pointer-types]
+ 2073 |    .remove = __exit_p(ltq_dsl_cpe_mei_remove),
+      |                       ^~~~~~~~~~~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/drv_mei_cpe_linux.c | 5 ++---
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+--- a/src/drv_mei_cpe_linux.c
++++ b/src/drv_mei_cpe_linux.c
+@@ -2048,13 +2048,12 @@ static int MEI_InstallProcEntry(unsigned
+ #endif
+ 
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
+-static int __exit ltq_dsl_cpe_mei_remove(struct platform_device *pdev)
++static void __exit ltq_dsl_cpe_mei_remove(struct platform_device *pdev)
+ {
+    MEI_module_exit();
+ 
+    /* clear platform */
+    MEI_DEVICE_CFG_VALUE_SET(platform, e_MEI_DEV_PLATFORM_CONFIG_UNKNOWN);
+-   return 0;
+ }
+ 
+ static const struct of_device_id ltq_dsl_cpe_mei_match[] = {
+@@ -2070,7 +2069,7 @@ static struct platform_driver ltq_dsl_cp
+       .owner          = THIS_MODULE,
+       .of_match_table = ltq_dsl_cpe_mei_match,
+    },
+-   .remove = __exit_p(ltq_dsl_cpe_mei_remove),
++   .remove_new = __exit_p(ltq_dsl_cpe_mei_remove),
+ };
+ 
+ static int __init ltq_dsl_cpe_mei_probe(struct platform_device *pdev)
diff --git a/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/406-fix-ignored-qualifiers-build-warnings.patch b/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/406-fix-ignored-qualifiers-build-warnings.patch
new file mode 100644
index 0000000000..a573dac7be
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/406-fix-ignored-qualifiers-build-warnings.patch
@@ -0,0 +1,38 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 00:58:00 +0800
+Subject: [PATCH] fix ignored-qualifiers build warnings
+
+This patch fixes the following build warnings:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_mei_cpe-1.5.17.6/src/drv_mei_cpe_mei_access_vrx.c:41:15: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
+   41 | static inline volatile IFX_uint32_t MEI_RCU_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+      |               ^~~~~~~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_mei_cpe-1.5.17.6/src/drv_mei_cpe_mei_access_vrx.c:56:15: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
+   56 | static inline volatile IFX_uint32_t MEI_RCU_Slave_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+      |               ^~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/drv_mei_cpe_mei_access_vrx.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/src/drv_mei_cpe_mei_access_vrx.c
++++ b/src/drv_mei_cpe_mei_access_vrx.c
+@@ -38,7 +38,7 @@
+    Local macro definition
+    ========================================================================= */
+ 
+-static inline volatile IFX_uint32_t MEI_RCU_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
++static inline IFX_uint32_t MEI_RCU_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+ {
+    IFX_uint32_t ret = 0;
+    if (MEI_DEVICE_CFG_IS_PLATFORM(e_MEI_DEV_PLATFORM_CONFIG_VR9))
+@@ -53,7 +53,7 @@ static inline volatile IFX_uint32_t MEI_
+    return ret;
+ }
+ 
+-static inline volatile IFX_uint32_t MEI_RCU_Slave_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
++static inline IFX_uint32_t MEI_RCU_Slave_get(MEI_MEI_DRV_CNTRL_T *pMeiDrvCntrl)
+ {
+    IFX_uint32_t ret = 0;
+    if (MEI_DEVICE_CFG_IS_PLATFORM(e_MEI_DEV_PLATFORM_CONFIG_VR9))
diff --git a/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/407-fix-missing-prototypes-warnings.patch b/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/407-fix-missing-prototypes-warnings.patch
new file mode 100644
index 0000000000..f909e9802a
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vdsl-vr9-mei/patches/407-fix-missing-prototypes-warnings.patch
@@ -0,0 +1,53 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 01:10:32 +0800
+Subject: [PATCH] fix missing prototypes warnings
+
+This patch fixes various missing-prototypes build warnings on
+6.12 kernel.
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_mei_cpe-1.5.17.6/src/drv_mei_cpe_api_atm_ptm_intern.c:314:5: error: no previous prototype for 'ifx_mei_atm_led_blink' [-Werror=missing-prototypes]
+  314 | int ifx_mei_atm_led_blink(void)
+      |     ^~~~~~~~~~~~~~~~~~~~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_mei_cpe-1.5.17.6/src/drv_mei_cpe_api_atm_ptm_intern.c:325:5: error: no previous prototype for 'ltq_ifx_mei_atm_showtime_enter_compat' [-Werror=missing-prototypes]
+  325 | int ltq_ifx_mei_atm_showtime_enter_compat(IFX_uint8_t dslLineNum,
+      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_mei_cpe-1.5.17.6/src/drv_mei_cpe_api_atm_ptm_intern.c:334:5: error: no previous prototype for 'ltq_ifx_mei_atm_showtime_exit_compat' [-Werror=missing-prototypes]
+  334 | int ltq_ifx_mei_atm_showtime_exit_compat(IFX_uint8_t dslLineNum) {
+      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/drv_mei_cpe_api_atm_ptm_intern.c | 4 ++--
+ src/drv_mei_cpe_api_atm_ptm_intern.h | 1 +
+ 2 files changed, 3 insertions(+), 2 deletions(-)
+
+--- a/src/drv_mei_cpe_api_atm_ptm_intern.c
++++ b/src/drv_mei_cpe_api_atm_ptm_intern.c
+@@ -322,7 +322,7 @@ int ifx_mei_atm_led_blink(void)
+ int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
+ int (*ifx_mei_atm_showtime_exit)(void) = NULL;
+ 
+-int ltq_ifx_mei_atm_showtime_enter_compat(IFX_uint8_t dslLineNum,
++static int ltq_ifx_mei_atm_showtime_enter_compat(IFX_uint8_t dslLineNum,
+ 				      struct port_cell_info *cellInfo,
+ 				      void *xdata) {
+ 	if (ifx_mei_atm_showtime_enter)
+@@ -331,7 +331,7 @@ int ltq_ifx_mei_atm_showtime_enter_compa
+ 	return -e_MEI_ERR_OP_FAILED;
+ }
+ 
+-int ltq_ifx_mei_atm_showtime_exit_compat(IFX_uint8_t dslLineNum) {
++static int ltq_ifx_mei_atm_showtime_exit_compat(IFX_uint8_t dslLineNum) {
+ 	if (ifx_mei_atm_showtime_exit)
+ 		return ifx_mei_atm_showtime_exit();
+ 
+--- a/src/drv_mei_cpe_api_atm_ptm_intern.h
++++ b/src/drv_mei_cpe_api_atm_ptm_intern.h
+@@ -61,6 +61,7 @@ struct port_cell_info;
+ extern int ifx_mei_atm_showtime_check(int *is_showtime,
+                               struct port_cell_info *port_cell,
+                               void **xdata_addr);
++extern int ifx_mei_atm_led_blink(void);
+ 
+ #if 1
+ #include <lantiq_atm.h>
diff --git a/package/kernel/lantiq/ltq-vdsl-vr9/patches/303-fix-missing-prototypes-warning.patch b/package/kernel/lantiq/ltq-vdsl-vr9/patches/303-fix-missing-prototypes-warning.patch
new file mode 100644
index 0000000000..013dffcb87
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vdsl-vr9/patches/303-fix-missing-prototypes-warning.patch
@@ -0,0 +1,100 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 02:48:52 +0800
+Subject: [PATCH] fix missing-prototypes warning
+
+This patch fixes various missing-prototypes build warnings on
+6.12 kernel.
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/common/drv_dsl_cpe_api.c        | 12 ++++++------
+ src/common/drv_dsl_cpe_os_linux.c   |  4 ++--
+ src/g997/drv_dsl_cpe_api_g997_vrx.c |  1 +
+ 3 files changed, 9 insertions(+), 8 deletions(-)
+
+--- a/src/common/drv_dsl_cpe_api.c
++++ b/src/common/drv_dsl_cpe_api.c
+@@ -2871,7 +2871,7 @@ DSL_Error_t DSL_DRV_LoopLengthStatusGet(
+    return nErrCode;
+ }
+ 
+-DSL_Error_t DSL_DRV_RetxStatisticsGet(
++static DSL_Error_t DSL_DRV_RetxStatisticsGet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_IN_OUT DSL_ReTxStatistics_t *pData)
+ {
+@@ -3044,7 +3044,7 @@ DSL_Error_t DSL_DRV_SystemInterfaceConfi
+    \ref DSL_FIO_SYSTEM_INTERFACE_STATUS_GET
+ */
+ #ifdef INCLUDE_DSL_SYSTEM_INTERFACE
+-DSL_Error_t DSL_DRV_SystemInterfaceStatusGet(
++static DSL_Error_t DSL_DRV_SystemInterfaceStatusGet(
+    DSL_Context_t *pContext,
+    DSL_SystemInterfaceStatus_t *pData)
+ {
+@@ -4372,7 +4372,7 @@ DSL_Error_t DSL_DRV_DBG_DebugFeatureConf
+ #endif /* DSL_DEBUG_DISABLE*/
+ 
+ #ifdef INCLUDE_DSL_FILTER_DETECTION
+-DSL_Error_t DSL_DRV_FilterDetectionDataGet(
++static DSL_Error_t DSL_DRV_FilterDetectionDataGet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_OUT DSL_FilterDetection_t *pData)
+ {
+@@ -4422,7 +4422,7 @@ DSL_Error_t DSL_DRV_FilterDetectionDataG
+ }
+ #endif /* INCLUDE_DSL_FILTER_DETECTION */
+ 
+-DSL_Error_t DSL_DRV_HybridSelectionDataGet(
++static DSL_Error_t DSL_DRV_HybridSelectionDataGet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_OUT DSL_HybridSelection_t *pData)
+ {
+@@ -4476,7 +4476,7 @@ DSL_Error_t DSL_DRV_HybridSelectionDataG
+    return nErrCode;
+ }
+ 
+-DSL_Error_t DSL_DRV_OlrStatisticsGet(
++static DSL_Error_t DSL_DRV_OlrStatisticsGet(
+    DSL_IN DSL_Context_t *pContext,
+    DSL_OUT DSL_OlrStatistics_t *pData)
+ {
+@@ -4596,7 +4596,7 @@ DSL_void_t DSL_DRV_InitDataFree(
+ #endif /* INCLUDE_DSL_INIT_DATA_PREPARE*/
+ }
+ 
+-DSL_Error_t DSL_DRV_IoctlHandleHelperCall(
++static DSL_Error_t DSL_DRV_IoctlHandleHelperCall(
+    DSL_OpenContext_t *pOpenCtx,
+    DSL_Context_t *pContext,
+    DSL_boolean_t bIsInKernel,
+--- a/src/common/drv_dsl_cpe_os_linux.c
++++ b/src/common/drv_dsl_cpe_os_linux.c
+@@ -1214,7 +1214,7 @@ static struct class *dsl_class;
+ static dev_t dsl_devt;
+ 
+ /* Entry point of driver */
+-int __init DSL_ModuleInit(void)
++static int __init DSL_ModuleInit(void)
+ {
+    DSL_int_t i;
+ 
+@@ -1262,7 +1262,7 @@ int __init DSL_ModuleInit(void)
+    return 0;
+ }
+ 
+-void __exit DSL_ModuleCleanup(void)
++static void __exit DSL_ModuleCleanup(void)
+ {
+    printk("Module will be unloaded"DSL_DRV_CRLF);
+ 
+--- a/src/g997/drv_dsl_cpe_api_g997_vrx.c
++++ b/src/g997/drv_dsl_cpe_api_g997_vrx.c
+@@ -11,6 +11,7 @@
+ #define DSL_INTERN
+ 
+ #include "drv_dsl_cpe_api.h"
++#include "drv_dsl_cpe_device_g997.h"
+ 
+ #ifdef INCLUDE_DSL_CPE_API_VRX
+ 
diff --git a/package/kernel/lantiq/ltq-vmmc/patches/021-ignore-missing-prototypes-warning.patch b/package/kernel/lantiq/ltq-vmmc/patches/021-ignore-missing-prototypes-warning.patch
new file mode 100644
index 0000000000..c36edc4b4b
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vmmc/patches/021-ignore-missing-prototypes-warning.patch
@@ -0,0 +1,29 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 08:22:25 +0800
+Subject: [PATCH] ignore missing-prototypes warning
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/Makefile.am | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/src/Makefile.am
++++ b/src/Makefile.am
+@@ -226,6 +226,8 @@ install-exec-hook: $(bin_PROGRAMS)
+ if KERNEL_2_6
+ drv_vmmc_OBJS = "$(subst .c,.o, $(drv_vmmc_SOURCES) $(nodist_drv_vmmc_SOURCES))"
+ 
++PKGFIX_CFLAGS = -Wno-error=missing-prototypes
++
+ drv_vmmc.ko: $(drv_vmmc_SOURCES) $(EXTRA_DIST)
+ 	@echo "Making Linux 2.6.x kernel object"
+ 	@for f in $(drv_vmmc_SOURCES) $(nodist_drv_vmmc_SOURCES) ; do \
+@@ -238,7 +240,7 @@ drv_vmmc.ko: $(drv_vmmc_SOURCES) $(EXTRA
+ 	@echo "# drv_vmmc: Generated to build Linux 2.6.x kernel object" > $(PWD)/Kbuild
+ 	@echo "obj-m := $(subst .ko,.o,$@)"			>> $(PWD)/Kbuild
+ 	@echo "$(subst .ko,,$@)-y := $(drv_vmmc_OBJS)"	>> $(PWD)/Kbuild
+-	@echo "EXTRA_CFLAGS := -DHAVE_CONFIG_H $(drv_vmmc_CFLAGS) $(INCLUDES)"	>> $(PWD)/Kbuild
++	@echo "EXTRA_CFLAGS := -DHAVE_CONFIG_H $(drv_vmmc_CFLAGS) $(PKGFIX_CFLAGS) $(INCLUDES)" >> $(PWD)/Kbuild
+ 	$(MAKE) ARCH=@KERNEL_ARCH@ -C @KERNEL_BUILD_PATH@ O=@KERNEL_BUILD_PATH@ M=$(PWD) modules
+ 
+ clean-generic:
diff --git a/package/kernel/lantiq/ltq-vmmc/patches/500-ar9_vr9.patch b/package/kernel/lantiq/ltq-vmmc/patches/500-ar9_vr9.patch
index 76fc863c35..24cd3f7ca8 100644
--- a/package/kernel/lantiq/ltq-vmmc/patches/500-ar9_vr9.patch
+++ b/package/kernel/lantiq/ltq-vmmc/patches/500-ar9_vr9.patch
@@ -18,7 +18,7 @@
  #include "drv_mps_vmmc_dbg.h"
  #include "drv_mps_vmmc_device.h"
  
-+const void (*ifx_bsp_basic_mps_decrypt)(unsigned int addr, int n) = NULL;
++void (*ifx_bsp_basic_mps_decrypt)(unsigned int addr, int n) = NULL;
 +
 +#define IFX_MPS_SRAM IFXMIPS_MPS_SRAM
 +
@@ -106,13 +106,13 @@
        pFWDwnld->length -= sizeof(IFX_uint32_t);
 +      switch(ltq_soc_type()) {
 +   	   case SOC_TYPE_AR9:
-+		   ifx_bsp_basic_mps_decrypt = (const void (*)(unsigned int, int))0xbf0017c4;
++		   ifx_bsp_basic_mps_decrypt = (void (*)(unsigned int, int))0xbf0017c4;
 +		   break;
 +	   case SOC_TYPE_VR9:
-+		   ifx_bsp_basic_mps_decrypt = (const void (*)(unsigned int, int))0xbf001ea4;
++		   ifx_bsp_basic_mps_decrypt = (void (*)(unsigned int, int))0xbf001ea4;
 +		   break;
 +	   case SOC_TYPE_VR9_2:
-+		   ifx_bsp_basic_mps_decrypt = (const void (*)(unsigned int, int))0xbf001f38;
++		   ifx_bsp_basic_mps_decrypt = (void (*)(unsigned int, int))0xbf001f38;
 +		   break;
 +      }
 +      if (ifx_bsp_basic_mps_decrypt)
diff --git a/package/kernel/lantiq/ltq-vmmc/patches/606-fix-version-macro-definition-conflicts-on-6.12-kerne.patch b/package/kernel/lantiq/ltq-vmmc/patches/606-fix-version-macro-definition-conflicts-on-6.12-kerne.patch
new file mode 100644
index 0000000000..f6ab6792ec
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vmmc/patches/606-fix-version-macro-definition-conflicts-on-6.12-kerne.patch
@@ -0,0 +1,143 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Thu, 8 May 2025 23:53:01 +0800
+Subject: [PATCH] fix version macro definition conflicts on 6.12 kernel
+
+Add LANTIQ prefix before MIN/MAX to fix:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/drv_vmmc_init.c:91:9: error: "MAX" redefined [-Werror]
+   91 | #define MAX(x,y) ((x) > (y) ? (x) : (y))
+      |         ^~~
+./include/linux/minmax.h:330:9: note: this is the location of the previous definition
+  330 | #define MAX(a,b) __cmp(max,a,b)
+      |         ^~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/drv_vmmc_init_cap.c:42:9: error: "MIN" redefined [-Werror]
+   42 | #define MIN(x,y) ({ (x) < (y) ? (x) : (y); })
+      |         ^~~
+./include/linux/minmax.h:329:9: note: this is the location of the previous definition
+  329 | #define MIN(a,b) __cmp(min,a,b)
+      |         ^~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/drv_vmmc_sig_cptd.c:41:9: error: "MAX" redefined [-Werror]
+   41 | #define MAX(x,y) ((x) > (y) ? (x) : (y))
+      |         ^~~
+./include/linux/minmax.h:330:9: note: this is the location of the previous definition
+  330 | #define MAX(a,b) __cmp(max,a,b)
+      |         ^~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/drv_vmmc_init.c     | 12 ++++++------
+ src/drv_vmmc_init_cap.c |  4 ++--
+ src/drv_vmmc_sig_cptd.c |  4 ++--
+ 3 files changed, 10 insertions(+), 10 deletions(-)
+
+--- a/src/drv_vmmc_init.c
++++ b/src/drv_vmmc_init.c
+@@ -88,7 +88,7 @@ CREATE_TRACE_GROUP(VMMC);
+ /** what compatible driver version */
+ #define DRV_VMMC_WHAT_STR "@(#)Lantiq VMMC device driver, version " DRV_VMMC_VER_STR
+ 
+-#define MAX(x,y) ((x) > (y) ? (x) : (y))
++#define LANTIQ_MAX(x,y) ((x) > (y) ? (x) : (y))
+ 
+ #define MPS_CH_VALID(mpsCh)      ((mpsCh >= 1 && mpsCh <= 7) ? 1 : 0)
+ 
+@@ -927,17 +927,17 @@ static IFX_int32_t VMMC_TAPI_LL_FW_Init(
+ 
+       /* Maximum number of resources, is the maximum of:
+          nALI, nPCM, nCOD, nSIG, nDECT, nLIN and nAudioCnt. */
+-      tmp1 = MAX (pDev->caps.nALI, pDev->caps.nPCM);
+-      tmp2 = MAX (pDev->caps.nCOD, pDev->caps.nSIG);
+-      pDev->caps.nMaxRes = MAX(tmp1, tmp2);
++      tmp1 = LANTIQ_MAX(pDev->caps.nALI, pDev->caps.nPCM);
++      tmp2 = LANTIQ_MAX(pDev->caps.nCOD, pDev->caps.nSIG);
++      pDev->caps.nMaxRes = LANTIQ_MAX(tmp1, tmp2);
+ #ifdef DECT_SUPPORT
+-      pDev->caps.nMaxRes = MAX(pDev->caps.nMaxRes, pDev->caps.nDECT);
++      pDev->caps.nMaxRes = LANTIQ_MAX(pDev->caps.nMaxRes, pDev->caps.nDECT);
+ #endif /* LIN_SUPPORT */
+ #ifdef LIN_SUPPORT
+-      pDev->caps.nMaxRes = MAX(pDev->caps.nMaxRes, pDev->caps.nLIN);
++      pDev->caps.nMaxRes = LANTIQ_MAX(pDev->caps.nMaxRes, pDev->caps.nLIN);
+ #endif /* LIN_SUPPORT */
+ #if (VMMC_CFG_FEATURES & VMMC_FEAT_AUDIO)
+-      pDev->caps.nMaxRes = MAX(pDev->caps.nMaxRes, pDev->caps.nAudioCnt);
++      pDev->caps.nMaxRes = LANTIQ_MAX(pDev->caps.nMaxRes, pDev->caps.nAudioCnt);
+ #endif /* (VMMC_CFG_FEATURES & VMMC_FEAT_AUDIO) */
+ 
+       if (pDev->caps.nMaxRes > VMMC_MAX_CH_NR)
+@@ -977,7 +977,7 @@ static IFX_int32_t VMMC_TAPI_LL_FW_Init(
+       nResource.DTMFRCount = pDev->caps.nDTMFD;
+       nResource.FSKGCount  = pDev->caps.nCIDS;
+       nResource.FSKRCount  = pDev->caps.nCIDR;
+-      nResource.ToneCount  = MAX(pDev->caps.nSIG, pDev->caps.nDECT);
++      nResource.ToneCount  = LANTIQ_MAX(pDev->caps.nSIG, pDev->caps.nDECT);
+       nResource.HdlcCount  = pDev->caps.nHDLC;
+       IFX_TAPI_ReportResources (pDev->pTapiDev,&nResource);
+ 
+--- a/src/drv_vmmc_init_cap.c
++++ b/src/drv_vmmc_init_cap.c
+@@ -39,7 +39,7 @@
+ /* ============================= */
+ /* Local Macros & Definitions    */
+ /* ============================= */
+-#define MIN(x,y) ({ (x) < (y) ? (x) : (y); })
++#define LANTIQ_MIN(x,y) ({ (x) < (y) ? (x) : (y); })
+ 
+ /* ============================= */
+ /* Local function declaration    */
+@@ -392,7 +392,7 @@ IFX_return_t VMMC_Get_FwCap(VMMC_DEVICE
+       /* Read the maximum length of the message that we can interpret but
+          not more than the firmware can provide. */
+       /* BLEN is the length including the header that the fw reports. */
+-      capCmd.LENGTH = MIN (capCmd.BLEN, sizeof(SYS_CAP_t));
++      capCmd.LENGTH = LANTIQ_MIN(capCmd.BLEN, sizeof(SYS_CAP_t));
+       /* Subtract the length of the header. */
+       capCmd.LENGTH -= CMD_HDR_CNT;
+       /* Read capability once more - this time with maximum length. */
+@@ -479,7 +479,7 @@ IFX_return_t VMMC_Get_FwCap(VMMC_DEVICE
+       pDev->caps.FEAT = capCmd.FEAT;
+       /* Number of UTG resources per channel (== SIG module), either 1 or 2 */
+       pDev->caps.nUtgPerCh = (capCmd.FEAT & EDSP_CAP_FEAT_UTGUD) ? 2 : 1;
+-      pDev->caps.nUtgPerCh = MIN(pDev->caps.nUtgPerCh, LL_TAPI_TONE_MAXRES);
++      pDev->caps.nUtgPerCh = LANTIQ_MIN(pDev->caps.nUtgPerCh, LL_TAPI_TONE_MAXRES);
+       /* Number of AudioChannels */
+       pDev->caps.nAudioCnt = (pDev->caps.FEAT & EDSP_CAP_FEAT_CHAUD) ? 1 : 0;
+       /* Overlays */
+--- a/src/drv_vmmc_sig_cptd.c
++++ b/src/drv_vmmc_sig_cptd.c
+@@ -38,7 +38,7 @@
+ /** define which constant is taken for cpt level calculation */
+ #define CONST_CPT                CONST_CPT_BLACKMAN
+ /* return the maximum of two scalar values */
+-#define MAX(x,y) ((x) > (y) ? (x) : (y))
++#define LANTIQ_MAX(x,y) ((x) > (y) ? (x) : (y))
+ 
+ /* ============================= */
+ /* Local function declaration    */
+@@ -511,7 +511,7 @@ static IFX_int32_t vmmc_sig_CPTD_SetCoef
+       if (nTenPercentTimeTolerance > nMaxTenPercentTimeTolerance)
+          nMaxTenPercentTimeTolerance = nTenPercentTimeTolerance;
+ 
+-      val = (IFX_uint16_t) (pTone->cadence[i] - MAX(nAbsoluteTimeTolerance,
++      val = (IFX_uint16_t) (pTone->cadence[i] - LANTIQ_MAX(nAbsoluteTimeTolerance,
+                                                     nTenPercentTimeTolerance));
+       switch (i)
+       {
+@@ -578,7 +578,7 @@ static IFX_int32_t vmmc_sig_CPTD_SetCoef
+    {
+       /* set tolerance +TIM_TOL */
+       pCmd->TIM_TOL =
+-                (2 * MAX (nAbsoluteTimeTolerance, nMaxTenPercentTimeTolerance));
++                (2 * LANTIQ_MAX(nAbsoluteTimeTolerance, nMaxTenPercentTimeTolerance));
+       /* return because nothing more to do */
+       return IFX_SUCCESS;
+    }
+@@ -605,7 +605,7 @@ static IFX_int32_t vmmc_sig_CPTD_SetCoef
+    /* set tolerance +TIM_TOL and NR of successfully fulfilled timing
+       requirement steps required to pass */
+    pCmd->TIM_TOL =
+-                (2 * MAX (nAbsoluteTimeTolerance, nMaxTenPercentTimeTolerance));
++                (2 * LANTIQ_MAX(nAbsoluteTimeTolerance, nMaxTenPercentTimeTolerance));
+    pCmd->NR = nr;
+ 
+    return IFX_SUCCESS;
diff --git a/package/kernel/lantiq/ltq-vmmc/patches/607-fix-unknown-type-name-errors.patch b/package/kernel/lantiq/ltq-vmmc/patches/607-fix-unknown-type-name-errors.patch
new file mode 100644
index 0000000000..4e1ad1b5eb
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vmmc/patches/607-fix-unknown-type-name-errors.patch
@@ -0,0 +1,28 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 01:31:44 +0800
+Subject: [PATCH] fix unknown type name errors
+
+Fix compilation errors:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/drv_vmmc_sig.h:41:45: error: unknown type name 'IFX_TAPI_DRV_CTX_SIG_t'
+   41 | extern IFX_void_t   VMMC_SIG_Func_Register (IFX_TAPI_DRV_CTX_SIG_t *pSig);
+      |                                             ^~~~~~~~~~~~~~~~~~~~~~
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/drv_vmmc_sig.h:43:54: error: unknown type name 'VMMC_CHANNEL'
+   43 | extern IFX_int32_t  VMMC_SIG_Allocate_Ch_Structures (VMMC_CHANNEL *pCh);
+      |                                                      ^~~~~~~~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/drv_vmmc_sig.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/src/drv_vmmc_sig.h
++++ b/src/drv_vmmc_sig.h
+@@ -20,6 +20,7 @@
+ /* ============================= */
+ /* Includes                      */
+ /* ============================= */
++#include "drv_vmmc_api.h"
+ #include "ifx_types.h"
+ 
+ /* ============================= */
diff --git a/package/kernel/lantiq/ltq-vmmc/patches/608-fix-inline-is-not-at-beginning-of-declaration.patch b/package/kernel/lantiq/ltq-vmmc/patches/608-fix-inline-is-not-at-beginning-of-declaration.patch
new file mode 100644
index 0000000000..4444360182
--- /dev/null
+++ b/package/kernel/lantiq/ltq-vmmc/patches/608-fix-inline-is-not-at-beginning-of-declaration.patch
@@ -0,0 +1,26 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Fri, 9 May 2025 01:43:41 +0800
+Subject: [PATCH] fix 'inline' is not at beginning of declaration
+
+Fix build warning on 6.12 kernel:
+
+/home/db/owrt/build_dir/target-mips_24kc_musl/linux-lantiq_xrx200/drv_vmmc-1.9.0/src/mps/drv_mps_vmmc_common.c:58:1: error: 'inline' is not at beginning of declaration [-Werror=old-style-declaration]
+   58 | static void inline bsp_mask_and_ack_irq(int x)
+      | ^~~~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ src/mps/drv_mps_vmmc_common.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/src/mps/drv_mps_vmmc_common.c
++++ b/src/mps/drv_mps_vmmc_common.c
+@@ -55,7 +55,7 @@
+ #  define bsp_mask_and_ack_irq      ltq_mask_and_ack_irq
+ #else
+ extern void ltq_mask_and_ack_irq(struct irq_data *d);
+-static void inline bsp_mask_and_ack_irq(int x)
++static inline void bsp_mask_and_ack_irq(int x)
+ {
+ 	struct irq_data d;
+ 	d.hwirq = x;
diff --git a/package/kernel/lantiq/vrx518_ep/patches/100-compat.patch b/package/kernel/lantiq/vrx518_ep/patches/100-compat.patch
index a139c7a862..3457779776 100644
--- a/package/kernel/lantiq/vrx518_ep/patches/100-compat.patch
+++ b/package/kernel/lantiq/vrx518_ep/patches/100-compat.patch
@@ -1,6 +1,14 @@
 --- a/ep.c
 +++ b/ep.c
-@@ -373,23 +373,23 @@ int dc_ep_dev_info_req(int dev_idx, enum
+@@ -34,6 +34,7 @@
+ #include <linux/pci.h>
+ #include <linux/pci_regs.h>
+ #include <linux/platform_device.h>
++#include <linux/version.h>
+ 
+ #include "ep.h"
+ #include "aca.h"
+@@ -373,23 +374,23 @@ int dc_ep_dev_info_req(int dev_idx, enum
  
  	switch (module) {
  	case DC_EP_INT_PPE:
@@ -31,18 +39,22 @@
  		break;
  	}
  
-@@ -466,8 +466,8 @@ static int dc_ep_msi_enable(struct pci_d
+@@ -466,8 +467,12 @@ static int dc_ep_msi_enable(struct pci_d
  		return -EIO;
  	}
  
 -	err = pci_enable_msi_exact(pdev, nvec);
 -	if (err) {
++#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 10, 0))
 +	err = pci_alloc_irq_vectors(pdev, nvec, nvec, PCI_IRQ_MSI | PCI_IRQ_LEGACY);
++#else
++	err = pci_alloc_irq_vectors(pdev, nvec, nvec, PCI_IRQ_MSI | PCI_IRQ_INTX);
++#endif
 +	if (err < 0) {
  		dev_err(&pdev->dev,
  			"%s: Failed to enable MSI interrupts error code: %d\n",
  			__func__, err);
-@@ -589,15 +589,15 @@ static int dc_ep_probe(struct pci_dev *p
+@@ -589,15 +594,15 @@ static int dc_ep_probe(struct pci_dev *p
  	/* Target structures have a limit of 32 bit DMA pointers.
  	 * DMA pointers can be wider than 32 bits by default on some systems.
  	 */
@@ -61,7 +73,7 @@
  		goto err_region;
  	}
  
-@@ -654,7 +654,7 @@ static int dc_ep_probe(struct pci_dev *p
+@@ -654,7 +659,7 @@ static int dc_ep_probe(struct pci_dev *p
  		goto err_iomap;
  
  	spin_lock(&dc_ep_lock);
@@ -70,7 +82,7 @@
  	spin_unlock(&dc_ep_lock);
  
  #ifndef CONFIG_OF
-@@ -715,7 +715,7 @@ static void dc_ep_remove(struct pci_dev
+@@ -715,7 +720,7 @@ static void dc_ep_remove(struct pci_dev
  	dc_ep_icu_disable(priv);
  	pci_iounmap(pdev, priv->mem);
  	pci_release_region(pdev, DC_EP_BAR_NUM);
diff --git a/package/kernel/lantiq/vrx518_ep/patches/101-Fix-version-macro-definition-conflicts-on-6.12-kerne.patch b/package/kernel/lantiq/vrx518_ep/patches/101-Fix-version-macro-definition-conflicts-on-6.12-kerne.patch
new file mode 100644
index 0000000000..3b108e613b
--- /dev/null
+++ b/package/kernel/lantiq/vrx518_ep/patches/101-Fix-version-macro-definition-conflicts-on-6.12-kerne.patch
@@ -0,0 +1,34 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Wed, 7 May 2025 19:16:16 +0800
+Subject: [PATCH] fix version macro definition conflicts on 6.12 kernel
+
+Add LANTIQ prefix to version variable names to fix:
+
+/home/db/owrt/build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/linux-ipq40xx_generic/vrx518_ep-2.1.0/ep.c:45:9: error: "MIN" redefined [-Werror]
+   45 | #define MIN     1
+      |         ^~~
+./include/linux/minmax.h:329:9: note: this is the location of the previous definition
+  329 | #define MIN(a,b) __cmp(min,a,b)
+      |         ^~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ ep.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/ep.c
++++ b/ep.c
+@@ -42,10 +42,10 @@
+ 
+ #define DC_EP_DBG
+ 
+-#define MAJ	2
+-#define MIN	1
++#define LANTIQ_MAJ	2
++#define LANTIQ_MIN	1
+ #define BUILD	0
+-#define DRV_VERSION __stringify(MAJ) "." __stringify(MIN) "." \
++#define DRV_VERSION __stringify(LANTIQ_MAJ) "." __stringify(LANTIQ_MIN) "." \
+ 	__stringify(BUILD) "-k"
+ 
+ static bool pcie_switch_exist;
diff --git a/package/kernel/lantiq/vrx518_tc/patches/206-dcdp-ptm_tc-allow-larger-mtu-to-support-rfc4638.patch b/package/kernel/lantiq/vrx518_tc/patches/206-dcdp-ptm_tc-allow-larger-mtu-to-support-rfc4638.patch
index 35a709e9fa..54a21187ff 100644
--- a/package/kernel/lantiq/vrx518_tc/patches/206-dcdp-ptm_tc-allow-larger-mtu-to-support-rfc4638.patch
+++ b/package/kernel/lantiq/vrx518_tc/patches/206-dcdp-ptm_tc-allow-larger-mtu-to-support-rfc4638.patch
@@ -22,9 +22,9 @@ Signed-off-by: Andrew MacIntyre <andymac@pcug.org.au>
  dcdp/ptm_tc.c | 1 +
  1 file changed, 1 insertion(+)
 
---- a/dcdp/ptm_tc.c	2023-12-17 16:11:22.503500398 +1100
-+++ b/dcdp/ptm_tc.c	2024-01-26 16:48:49.881623474 +1100
-@@ -657,6 +657,7 @@ static void ptm_setup(struct net_device
+--- a/dcdp/ptm_tc.c
++++ b/dcdp/ptm_tc.c
+@@ -666,6 +666,7 @@ static void ptm_setup(struct net_device
  	ether_setup(dev);
  	dev->watchdog_timeo = 10 * HZ;
  	dev->netdev_ops = &g_ptm_netdev_ops;
diff --git a/package/kernel/lantiq/vrx518_tc/patches/300-fix-missing-prototypes-warnings.patch b/package/kernel/lantiq/vrx518_tc/patches/300-fix-missing-prototypes-warnings.patch
new file mode 100644
index 0000000000..562e349786
--- /dev/null
+++ b/package/kernel/lantiq/vrx518_tc/patches/300-fix-missing-prototypes-warnings.patch
@@ -0,0 +1,66 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Thu, 8 May 2025 7:43:51 +0800
+Subject: [PATCH] fix missing prototypes warnings
+
+This patch fixes various missing-prototypes build warnings on
+6.12 kernel.
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ dcdp/atm_tc.c           | 2 +-
+ dcdp/inc/platform.h     | 1 +
+ dcdp/platform/sw_plat.c | 1 +
+ dcdp/tc_proc.c          | 4 ++--
+ 4 files changed, 5 insertions(+), 3 deletions(-)
+
+--- a/dcdp/atm_tc.c
++++ b/dcdp/atm_tc.c
+@@ -279,7 +279,7 @@ unsigned int find_vpi(unsigned int vpi)
+  *    success: 0
+  *    failed: -1
+  */
+-unsigned int find_vpivci_from_queue_id(
++static unsigned int find_vpivci_from_queue_id(
+ 	unsigned int queue_id,
+ 	unsigned int *vpi,
+ 	unsigned int *vci)
+--- a/dcdp/inc/platform.h
++++ b/dcdp/inc/platform.h
+@@ -20,6 +20,7 @@
+   the file called "COPYING".
+ 
+ *******************************************************************************/
++struct tc_priv;
+ extern size_t plat_priv_sz(void);
+ extern int platform_init(struct tc_priv *, const char *);
+ extern void platform_exit(void);
+--- a/dcdp/platform/sw_plat.c
++++ b/dcdp/platform/sw_plat.c
+@@ -38,6 +38,7 @@
+ #include <linux/workqueue.h>
+ #include "../inc/dsl_tc.h"
+ 
++#include "../inc/platform.h"
+ #include "../inc/tc_main.h"
+ #include "../inc/reg_addr.h"
+ #include "../inc/tc_common.h"
+--- a/dcdp/tc_proc.c
++++ b/dcdp/tc_proc.c
+@@ -1945,7 +1945,7 @@ static void fwdbg_help(struct tc_comm *p
+ 	if (!cmds[i].cmd)
+ 		fwdbg_help(priv, NULL, 0, result);
+ }
+-int fw_dbg_start(struct tc_comm *priv,
++static int fw_dbg_start(struct tc_comm *priv,
+ 	char *commands[], int num, char *result)
+ {
+ 	int i;
+@@ -1964,7 +1964,7 @@ int fw_dbg_start(struct tc_comm *priv,
+ 	return 0;
+ }
+ 
+-ssize_t proc_write_fwdbg_seq(
++static ssize_t proc_write_fwdbg_seq(
+ 	struct file *file,
+ 	const char __user *buf,
+ 	size_t count,
diff --git a/package/kernel/linux/modules/bluetooth.mk b/package/kernel/linux/modules/bluetooth.mk
new file mode 100644
index 0000000000..3e6b38a88c
--- /dev/null
+++ b/package/kernel/linux/modules/bluetooth.mk
@@ -0,0 +1,165 @@
+#
+# Copyright (C) 2006-2025 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+BLUETOOTH_MENU:=Bluetooth Support
+
+define KernelPackage/bluetooth
+  SUBMENU:=$(BLUETOOTH_MENU)
+  TITLE:=Bluetooth support
+  DEPENDS:=+kmod-crypto-hash +kmod-crypto-ecb +kmod-lib-crc16 +kmod-hid +kmod-crypto-cmac +kmod-regmap-core +kmod-crypto-ecdh
+  KCONFIG:= \
+	CONFIG_BT \
+	CONFIG_BT_BREDR=y \
+	CONFIG_BT_DEBUGFS=n \
+	CONFIG_BT_LE=y \
+	CONFIG_BT_RFCOMM \
+	CONFIG_BT_BNEP \
+	CONFIG_BT_HIDP
+  $(call AddDepends/rfkill)
+  FILES:= \
+	$(LINUX_DIR)/net/bluetooth/bluetooth.ko \
+	$(LINUX_DIR)/net/bluetooth/rfcomm/rfcomm.ko \
+	$(LINUX_DIR)/net/bluetooth/bnep/bnep.ko \
+	$(LINUX_DIR)/net/bluetooth/hidp/hidp.ko
+  AUTOLOAD:=$(call AutoProbe,bluetooth rfcomm bnep hidp)
+endef
+
+define KernelPackage/bluetooth/description
+ Kernel support for Bluetooth devices
+endef
+
+$(eval $(call KernelPackage,bluetooth))
+
+
+define KernelPackage/hci-uart
+  SUBMENU:=$(BLUETOOTH_MENU)
+  TITLE:=Bluetooth HCI UART support
+  DEPENDS:=+kmod-bluetooth
+  KCONFIG:= \
+	CONFIG_BT_HCIUART \
+	CONFIG_BT_HCIUART_BCM=n \
+	CONFIG_BT_HCIUART_INTEL=n \
+	CONFIG_BT_HCIUART_H4 \
+	CONFIG_BT_HCIUART_NOKIA=n
+  FILES:= \
+	$(LINUX_DIR)/drivers/bluetooth/hci_uart.ko
+  AUTOLOAD:=$(call AutoProbe,hci_uart)
+endef
+
+define KernelPackage/hci-uart/description
+ Kernel support for Bluetooth HCI UART devices
+endef
+
+$(eval $(call KernelPackage,hci-uart))
+
+
+define KernelPackage/btusb
+  SUBMENU:=$(BLUETOOTH_MENU)
+  TITLE:=Bluetooth HCI USB support
+  DEPENDS:=@USB_SUPPORT +kmod-usb-core +kmod-bluetooth +kmod-btmtk
+  KCONFIG:= \
+	CONFIG_BT_HCIBTUSB \
+	CONFIG_BT_HCIBTUSB_BCM=n \
+	CONFIG_BT_HCIBTUSB_MTK=y \
+	CONFIG_BT_HCIBTUSB_RTL=y
+  FILES:= \
+	$(LINUX_DIR)/drivers/bluetooth/btusb.ko \
+	$(LINUX_DIR)/drivers/bluetooth/btintel.ko \
+	$(LINUX_DIR)/drivers/bluetooth/btrtl.ko
+  AUTOLOAD:=$(call AutoProbe,btusb)
+endef
+
+define KernelPackage/btusb/description
+ Kernel support for USB Bluetooth HCI USB devices
+endef
+
+$(eval $(call KernelPackage,btusb))
+
+
+define KernelPackage/btmtk
+  SUBMENU:=$(BLUETOOTH_MENU)
+  TITLE:=MTK Bluetooth support
+  HIDDEN:=1
+  DEPENDS:=+kmod-bluetooth +!LINUX_6_6&&USB_SUPPORT:kmod-usb-core
+  KCONFIG:=CONFIG_BT_MTK
+  FILES:=$(LINUX_DIR)/drivers/bluetooth/btmtk.ko
+endef
+
+$(eval $(call KernelPackage,btmtk))
+
+
+define KernelPackage/ath3k
+  SUBMENU:=$(BLUETOOTH_MENU)
+  TITLE:=ATH3K Kernel Module support
+  DEPENDS:=+kmod-hci-uart +kmod-btusb +ar3k-firmware
+  KCONFIG:= \
+	CONFIG_BT_ATH3K \
+	CONFIG_BT_HCIUART_ATH3K=y
+  FILES:= \
+	$(LINUX_DIR)/drivers/bluetooth/ath3k.ko
+  AUTOLOAD:=$(call AutoProbe,ath3k)
+endef
+
+define KernelPackage/ath3k/description
+ Kernel support for ATH3K Module
+endef
+
+$(eval $(call KernelPackage,ath3k))
+
+
+define KernelPackage/bluetooth-6lowpan
+  SUBMENU:=$(BLUETOOTH_MENU)
+  TITLE:=Bluetooth 6LoWPAN support
+  DEPENDS:=+kmod-6lowpan +kmod-bluetooth
+  KCONFIG:=CONFIG_BT_6LOWPAN
+  FILES:=$(LINUX_DIR)/net/bluetooth/bluetooth_6lowpan.ko
+  AUTOLOAD:=$(call AutoProbe,bluetooth_6lowpan)
+endef
+
+define KernelPackage/bluetooth-6lowpan/description
+ Kernel support for 6LoWPAN over Bluetooth Low Energy devices
+endef
+
+$(eval $(call KernelPackage,bluetooth-6lowpan))
+
+
+define KernelPackage/btmrvl
+  SUBMENU:=$(BLUETOOTH_MENU)
+  TITLE:=Marvell Bluetooth Kernel Module support
+  DEPENDS:=+kmod-mmc +kmod-bluetooth +mwifiex-sdio-firmware
+  KCONFIG:= \
+	CONFIG_BT_MRVL \
+	CONFIG_BT_MRVL_SDIO
+  FILES:= \
+	$(LINUX_DIR)/drivers/bluetooth/btmrvl.ko \
+	$(LINUX_DIR)/drivers/bluetooth/btmrvl_sdio.ko
+  AUTOLOAD:=$(call AutoProbe,btmrvl btmrvl_sdio)
+endef
+
+define KernelPackage/btmrvl/description
+ Kernel support for Marvell SDIO Bluetooth Module
+endef
+
+$(eval $(call KernelPackage,btmrvl))
+
+
+define KernelPackage/btsdio
+  SUBMENU:=$(BLUETOOTH_MENU)
+  TITLE:=Bluetooth HCI SDIO driver
+  DEPENDS:=+kmod-bluetooth +kmod-mmc
+  KCONFIG:= \
+	CONFIG_BT_HCIBTSDIO
+  FILES:= \
+	$(LINUX_DIR)/drivers/bluetooth/btsdio.ko
+  AUTOLOAD:=$(call AutoProbe,btsdio)
+endef
+
+define KernelPackage/btsdio/description
+ Kernel support for Bluetooth device with SDIO interface
+endef
+
+$(eval $(call KernelPackage,btsdio))
diff --git a/package/kernel/linux/modules/crypto.mk b/package/kernel/linux/modules/crypto.mk
index 78c9712176..2e6ee14572 100644
--- a/package/kernel/linux/modules/crypto.mk
+++ b/package/kernel/linux/modules/crypto.mk
@@ -558,6 +558,17 @@ endef
 
 $(eval $(call KernelPackage,crypto-kpp))
 
+define KernelPackage/crypto-lib-aescfb
+  TITLE:=AES cipher operations feedback mode library
+  DEPENDS:=@!LINUX_6_6
+  KCONFIG:=CONFIG_CRYPTO_LIB_AESCFB
+  FILES:=$(LINUX_DIR)/lib/crypto/libaescfb.ko
+  AUTOLOAD:=$(call AutoLoad,09,libaescfb)
+  $(call AddDepends/crypto)
+endef
+
+$(eval $(call KernelPackage,crypto-lib-aescfb))
+
 define KernelPackage/crypto-lib-chacha20
   TITLE:=ChaCha library interface
   KCONFIG:=CONFIG_CRYPTO_LIB_CHACHA
diff --git a/package/kernel/linux/modules/fs.mk b/package/kernel/linux/modules/fs.mk
index 1fbab8fb61..c71f0d9eb7 100644
--- a/package/kernel/linux/modules/fs.mk
+++ b/package/kernel/linux/modules/fs.mk
@@ -31,7 +31,7 @@ define KernelPackage/fs-afs
   SUBMENU:=$(FS_MENU)
   TITLE:=Andrew FileSystem client
   DEFAULT:=n
-  DEPENDS:=+kmod-rxrpc +kmod-dnsresolver +kmod-fs-fscache
+  DEPENDS:=+kmod-rxrpc +kmod-dnsresolver +LINUX_6_6:kmod-fs-fscache +!LINUX_6_6:kmod-fs-netfs
   KCONFIG:=\
 	CONFIG_AFS_FS=m \
 	CONFIG_AFS_DEBUG=n \
@@ -83,6 +83,22 @@ endef
 $(eval $(call KernelPackage,fs-btrfs))
 
 
+define KernelPackage/fs-cachefiles
+  SUBMENU:=$(FS_MENU)
+  TITLE:=Filesystem caching on files
+  DEPENDS:=LINUX_6_6:kmod-fs-fscache !LINUX_6_6:kmod-fs-netfs
+  KCONFIG:=\
+	CONFIG_CACHEFILES \
+	CONFIG_CACHEFILES_DEBUG=n \
+	CONFIG_CACHEFILES_ERROR_INJECTION=n \
+	CONFIG_CACHEFILES_ONDEMAND=n
+  FILES:= $(LINUX_DIR)/fs/cachefiles/cachefiles.ko
+  AUTOLOAD:=$(call AutoLoad,30,cachefiles)
+endef
+
+$(eval $(call KernelPackage,fs-cachefiles))
+
+
 define KernelPackage/fs-smbfs-common
   SUBMENU:=$(FS_MENU)
   TITLE:=SMBFS common dependencies support
@@ -262,22 +278,13 @@ $(eval $(call KernelPackage,fs-f2fs))
 define KernelPackage/fs-fscache
   SUBMENU:=$(FS_MENU)
   TITLE:=General filesystem local cache manager
-  DEPENDS:=+kmod-fs-netfs
+  DEPENDS:=@LINUX_6_6 +kmod-fs-netfs
   KCONFIG:=\
 	CONFIG_FSCACHE \
 	CONFIG_FSCACHE_STATS=y \
-	CONFIG_FSCACHE_HISTOGRAM=n \
-	CONFIG_FSCACHE_DEBUG=n \
-	CONFIG_FSCACHE_OBJECT_LIST=n \
-	CONFIG_CACHEFILES \
-	CONFIG_CACHEFILES_DEBUG=n \
-	CONFIG_CACHEFILES_HISTOGRAM=n \
-	CONFIG_CACHEFILES_ERROR_INJECTION=n \
-	CONFIG_CACHEFILES_ONDEMAND=n
-  FILES:= \
-	$(LINUX_DIR)/fs/fscache/fscache.ko \
-	$(LINUX_DIR)/fs/cachefiles/cachefiles.ko
-  AUTOLOAD:=$(call AutoLoad,29,fscache cachefiles)
+	CONFIG_FSCACHE_DEBUG=n
+  FILES:= $(LINUX_DIR)/fs/fscache/fscache.ko
+  AUTOLOAD:=$(call AutoLoad,29,fscache)
 endef
 
 $(eval $(call KernelPackage,fs-fscache))
@@ -422,7 +429,10 @@ $(eval $(call KernelPackage,fs-msdos))
 define KernelPackage/fs-netfs
   SUBMENU:=$(FS_MENU)
   TITLE:=Network Filesystems support
-  KCONFIG:= CONFIG_NETFS_SUPPORT
+  KCONFIG:= \
+	CONFIG_NETFS_SUPPORT \
+	CONFIG_FSCACHE=y@ge6.12 \
+	CONFIG_FSCACHE_STATS=y@ge6.12
   FILES:=$(LINUX_DIR)/fs/netfs/netfs.ko
   AUTOLOAD:=$(call AutoLoad,28,netfs)
 endef
@@ -564,6 +574,7 @@ $(eval $(call KernelPackage,fs-nfsd))
 define KernelPackage/fs-ntfs
   SUBMENU:=$(FS_MENU)
   TITLE:=NTFS filesystem read-only (old driver) support
+  DEPENDS:=@LINUX_6_6
   KCONFIG:=CONFIG_NTFS_FS
   FILES:=$(LINUX_DIR)/fs/ntfs/ntfs.ko
   AUTOLOAD:=$(call AutoLoad,30,ntfs)
diff --git a/package/kernel/linux/modules/hwmon.mk b/package/kernel/linux/modules/hwmon.mk
index ae9b35114b..3e19a36cb0 100644
--- a/package/kernel/linux/modules/hwmon.mk
+++ b/package/kernel/linux/modules/hwmon.mk
@@ -9,6 +9,7 @@ HWMON_MENU:=Hardware Monitoring Support
 
 define KernelPackage/hwmon-core
   SUBMENU:=$(HWMON_MENU)
+  DEPENDS:=+!LINUX_6_6:kmod-i2c-core
   TITLE:=Hardware monitoring support
   KCONFIG:= \
 	CONFIG_HWMON \
@@ -361,7 +362,7 @@ define KernelPackage/hwmon-lm92
   KCONFIG:=CONFIG_SENSORS_LM92
   FILES:=$(LINUX_DIR)/drivers/hwmon/lm92.ko
   AUTOLOAD:=$(call AutoProbe,lm92)
-  $(call AddDepends/hwmon,+kmod-i2c-core)
+  $(call AddDepends/hwmon,+kmod-i2c-core +!LINUX_6_6:kmod-regmap-core)
 endef
 
 define KernelPackage/hwmon-lm92/description
@@ -421,7 +422,7 @@ define KernelPackage/hwmon-max6697
   KCONFIG:=CONFIG_SENSORS_MAX6697
   FILES:=$(LINUX_DIR)/drivers/hwmon/max6697.ko
   AUTOLOAD:=$(call AutoProbe,max6697)
-  $(call AddDepends/hwmon,+kmod-i2c-core)
+  $(call AddDepends/hwmon,+kmod-i2c-core +!LINUX_6_6:kmod-regmap-i2c)
 endef
 
 define KernelPackage/hwmon-max6697/description
@@ -547,7 +548,7 @@ define KernelPackage/hwmon-sch5627
 	$(LINUX_DIR)/drivers/hwmon/sch5627.ko \
 	$(LINUX_DIR)/drivers/hwmon/sch56xx-common.ko
   AUTOLOAD:=$(call AutoProbe,sch5627)
-  $(call AddDepends/hwmon,+kmod-i2c-core)
+  $(call AddDepends/hwmon,+kmod-i2c-core +!LINUX_6_6:kmod-regmap-core)
 endef
 
 define KernelPackage/hwmon-sch5627/description
diff --git a/package/kernel/linux/modules/i2c.mk b/package/kernel/linux/modules/i2c.mk
index 3aaf560ea9..a8b05fb614 100644
--- a/package/kernel/linux/modules/i2c.mk
+++ b/package/kernel/linux/modules/i2c.mk
@@ -150,7 +150,9 @@ I2C_I801_MODULES:= \
 define KernelPackage/i2c-i801
   $(call i2c_defaults,$(I2C_I801_MODULES),59)
   TITLE:=Intel I801 and compatible I2C interfaces
-  DEPENDS:=@PCI_SUPPORT @TARGET_x86 +kmod-i2c-core +kmod-i2c-smbus
+  DEPENDS:= \
+    @PCI_SUPPORT @TARGET_x86 +kmod-i2c-core +kmod-i2c-smbus \
+    (!LINUX_6_6&&PACKAGE_kmod-i2c-mux-gpio):kmod-i2c-mux-gpio
 endef
 
 define KernelPackage/i2c-i801/description
@@ -289,7 +291,7 @@ I2C_PIIX4_MODULES:= \
 define KernelPackage/i2c-piix4
   $(call i2c_defaults,$(I2C_PIIX4_MODULES),59)
   TITLE:=Intel PIIX4 and compatible I2C interfaces
-  DEPENDS:=@PCI_SUPPORT @TARGET_x86 +kmod-i2c-core
+  DEPENDS:=@PCI_SUPPORT @TARGET_x86 +kmod-i2c-core +!LINUX_6_6:kmod-i2c-smbus
 endef
 
 define KernelPackage/i2c-piix4/description
diff --git a/package/kernel/linux/modules/iio.mk b/package/kernel/linux/modules/iio.mk
index e98a6830da..bd6a77f720 100644
--- a/package/kernel/linux/modules/iio.mk
+++ b/package/kernel/linux/modules/iio.mk
@@ -9,6 +9,7 @@ IIO_MENU:=Industrial I/O Modules
 define KernelPackage/iio-core
   SUBMENU:=$(IIO_MENU)
   TITLE:=Industrial IO core
+  DEPENDS:=+!LINUX_6_6:kmod-dma-buf
   KCONFIG:= \
 	CONFIG_IIO \
 	CONFIG_IIO_BUFFER=y \
@@ -252,7 +253,7 @@ $(eval $(call KernelPackage,iio-bme680-spi))
 
 define KernelPackage/iio-bmp280
   TITLE:=BMP180/BMP280/BME280 pressure/temperatur sensor
-  DEPENDS:=+kmod-regmap-core
+  DEPENDS:=+kmod-regmap-core +!LINUX_6_6:kmod-industrialio-triggered-buffer
   KCONFIG:=CONFIG_BMP280
   FILES:=$(LINUX_DIR)/drivers/iio/pressure/bmp280.ko
   $(call AddDepends/iio)
diff --git a/package/kernel/linux/modules/netdevices.mk b/package/kernel/linux/modules/netdevices.mk
index 9126ef7d75..ab84570b1a 100644
--- a/package/kernel/linux/modules/netdevices.mk
+++ b/package/kernel/linux/modules/netdevices.mk
@@ -120,6 +120,38 @@ endef
 $(eval $(call KernelPackage,atl1e))
 
 
+define KernelPackage/libie
+  SUBMENU:=$(NETWORK_DEVICES_MENU)
+  TITLE:=Intel Ethernet library
+  DEPENDS:=@!LINUX_6_6 +kmod-libeth
+  KCONFIG:=CONFIG_LIBIE
+  HIDDEN:=1
+  FILES:=$(LINUX_DIR)/drivers/net/ethernet/intel/libie/libie.ko
+endef
+
+define KernelPackage/libie/description
+ Intel Ethernet library
+endef
+
+$(eval $(call KernelPackage,libie))
+
+
+define KernelPackage/libeth
+  SUBMENU:=$(NETWORK_DEVICES_MENU)
+  TITLE:=Common Intel Ethernet library
+  DEPENDS:=@!LINUX_6_6
+  KCONFIG:=CONFIG_LIBETH
+  HIDDEN:=1
+  FILES:=$(LINUX_DIR)/drivers/net/ethernet/intel/libeth/libeth.ko
+endef
+
+define KernelPackage/libeth/description
+ Common Intel Ethernet library
+endef
+
+$(eval $(call KernelPackage,libeth))
+
+
 define KernelPackage/libphy
   SUBMENU:=$(NETWORK_DEVICES_MENU)
   TITLE:=PHY library
@@ -513,7 +545,7 @@ $(eval $(call KernelPackage,phy-airoha-en8811h))
 define KernelPackage/phy-aquantia
   SUBMENU:=$(NETWORK_DEVICES_MENU)
   TITLE:=Aquantia Ethernet PHYs
-  DEPENDS:=+kmod-libphy +kmod-hwmon-core +kmod-lib-crc-ccitt
+  DEPENDS:=+kmod-libphy +kmod-hwmon-core +LINUX_6_6:kmod-lib-crc-ccitt +!LINUX_6_6:kmod-lib-crc-itu-t
   KCONFIG:=CONFIG_AQUANTIA_PHY
   FILES:=$(LINUX_DIR)/drivers/net/phy/aquantia/aquantia.ko
   AUTOLOAD:=$(call AutoLoad,18,aquantia,1)
@@ -1132,7 +1164,7 @@ $(eval $(call KernelPackage,ixgbevf))
 define KernelPackage/i40e
   SUBMENU:=$(NETWORK_DEVICES_MENU)
   TITLE:=Intel(R) Ethernet Controller XL710 Family support
-  DEPENDS:=@PCI_SUPPORT +kmod-ptp
+  DEPENDS:=@PCI_SUPPORT +kmod-ptp +!LINUX_6_6:kmod-libie
   KCONFIG:=CONFIG_I40E \
     CONFIG_I40E_DCA=n
   FILES:=$(LINUX_DIR)/drivers/net/ethernet/intel/i40e/i40e.ko
@@ -1146,10 +1178,29 @@ endef
 $(eval $(call KernelPackage,i40e))
 
 
+define KernelPackage/ice
+  SUBMENU:=$(NETWORK_DEVICES_MENU)
+  TITLE:=Intel(R) Ethernet Controller E810 Series support
+  DEPENDS:=@PCI_SUPPORT +kmod-ptp +!LINUX_6_6:kmod-hwmon-core +!LINUX_6_6:kmod-libie
+  KCONFIG:=CONFIG_ICE \
+    CONFIG_ICE_HWMON=y \
+    CONFIG_ICE_HWTS=n \
+    CONFIG_ICE_SWITCHDEV=y
+  FILES:=$(LINUX_DIR)/drivers/net/ethernet/intel/ice/ice.ko
+  AUTOLOAD:=$(call AutoProbe,ice)
+endef
+
+define KernelPackage/ice/description
+  Kernel modules for Intel(R) Ethernet Controller E810 Series
+endef
+
+$(eval $(call KernelPackage,ice))
+
+
 define KernelPackage/iavf
   SUBMENU:=$(NETWORK_DEVICES_MENU)
   TITLE:=Intel(R) Ethernet Adaptive Virtual Function support
-  DEPENDS:=@PCI_SUPPORT
+  DEPENDS:=@PCI_SUPPORT +!LINUX_6_6:kmod-libie
   KCONFIG:= \
        CONFIG_I40EVF \
        CONFIG_IAVF
@@ -1801,7 +1852,7 @@ $(eval $(call KernelPackage,sfp))
 define KernelPackage/pcs-xpcs
   SUBMENU:=$(NETWORK_DEVICES_MENU)
   TITLE:=Synopsis DesignWare PCS driver
-  DEPENDS:=@(TARGET_x86_64||TARGET_armsr) +kmod-phylink
+  DEPENDS:=@(TARGET_x86_64||TARGET_armsr) +kmod-phylink +!LINUX_6_6:kmod-mdio-devres
   KCONFIG:=CONFIG_PCS_XPCS
   FILES:=$(LINUX_DIR)/drivers/net/pcs/pcs_xpcs.ko
   AUTOLOAD:=$(call AutoLoad,20,pcs_xpcs)
@@ -1999,7 +2050,7 @@ $(eval $(call KernelPackage,atlantic))
 define KernelPackage/lan743x
   SUBMENU:=$(NETWORK_DEVICES_MENU)
   TITLE:=Microchip LAN743x PCI Express Gigabit Ethernet NIC
-  DEPENDS:=@PCI_SUPPORT +kmod-ptp +kmod-mdio-devres +kmod-fixed-phy
+  DEPENDS:=@PCI_SUPPORT +kmod-ptp +kmod-mdio-devres +kmod-fixed-phy +!LINUX_6_6:kmod-phylink
   KCONFIG:=CONFIG_LAN743X
   FILES:=$(LINUX_DIR)/drivers/net/ethernet/microchip/lan743x.ko
   AUTOLOAD:=$(call AutoProbe,lan743x)
diff --git a/package/kernel/linux/modules/netsupport.mk b/package/kernel/linux/modules/netsupport.mk
index 06ef823280..0e9a36972a 100644
--- a/package/kernel/linux/modules/netsupport.mk
+++ b/package/kernel/linux/modules/netsupport.mk
@@ -1376,6 +1376,7 @@ $(eval $(call KernelPackage,mpls))
 define KernelPackage/9pnet
   SUBMENU:=$(NETWORK_SUPPORT_MENU)
   TITLE:=Plan 9 Resource Sharing Support (9P2000)
+  DEPENDS:=+!LINUX_6_6:kmod-fs-netfs
   KCONFIG:= \
 	CONFIG_NET_9P \
 	CONFIG_NET_9P_DEBUG=n \
diff --git a/package/kernel/linux/modules/other.mk b/package/kernel/linux/modules/other.mk
index 7b64985fd6..8da6216cbf 100644
--- a/package/kernel/linux/modules/other.mk
+++ b/package/kernel/linux/modules/other.mk
@@ -27,120 +27,6 @@ endef
 $(eval $(call KernelPackage,6lowpan))
 
 
-define KernelPackage/bluetooth
-  SUBMENU:=$(OTHER_MENU)
-  TITLE:=Bluetooth support
-  DEPENDS:=@USB_SUPPORT +kmod-usb-core +kmod-crypto-hash +kmod-crypto-ecb +kmod-lib-crc16 +kmod-hid +kmod-crypto-cmac +kmod-regmap-core +kmod-crypto-ecdh
-  KCONFIG:= \
-	CONFIG_BT \
-	CONFIG_BT_BREDR=y \
-	CONFIG_BT_DEBUGFS=n \
-	CONFIG_BT_LE=y \
-	CONFIG_BT_RFCOMM \
-	CONFIG_BT_BNEP \
-	CONFIG_BT_HCIBTUSB \
-	CONFIG_BT_HCIBTUSB_BCM=n \
-	CONFIG_BT_HCIBTUSB_MTK=y \
-	CONFIG_BT_HCIBTUSB_RTL=y \
-	CONFIG_BT_HCIUART \
-	CONFIG_BT_HCIUART_BCM=n \
-	CONFIG_BT_HCIUART_INTEL=n \
-	CONFIG_BT_HCIUART_H4 \
-	CONFIG_BT_HCIUART_NOKIA=n \
-	CONFIG_BT_HIDP
-  $(call AddDepends/rfkill)
-  FILES:= \
-	$(LINUX_DIR)/net/bluetooth/bluetooth.ko \
-	$(LINUX_DIR)/net/bluetooth/rfcomm/rfcomm.ko \
-	$(LINUX_DIR)/net/bluetooth/bnep/bnep.ko \
-	$(LINUX_DIR)/net/bluetooth/hidp/hidp.ko \
-	$(LINUX_DIR)/drivers/bluetooth/hci_uart.ko \
-	$(LINUX_DIR)/drivers/bluetooth/btusb.ko \
-	$(LINUX_DIR)/drivers/bluetooth/btintel.ko \
-	$(LINUX_DIR)/drivers/bluetooth/btrtl.ko \
-	$(LINUX_DIR)/drivers/bluetooth/btmtk.ko
-  AUTOLOAD:=$(call AutoProbe,bluetooth rfcomm bnep hidp hci_uart btusb)
-endef
-
-define KernelPackage/bluetooth/description
- Kernel support for Bluetooth devices
-endef
-
-$(eval $(call KernelPackage,bluetooth))
-
-define KernelPackage/ath3k
-  SUBMENU:=$(OTHER_MENU)
-  TITLE:=ATH3K Kernel Module support
-  DEPENDS:=+kmod-bluetooth +ar3k-firmware
-  KCONFIG:= \
-	CONFIG_BT_ATH3K \
-	CONFIG_BT_HCIUART_ATH3K=y
-  FILES:= \
-	$(LINUX_DIR)/drivers/bluetooth/ath3k.ko
-  AUTOLOAD:=$(call AutoProbe,ath3k)
-endef
-
-define KernelPackage/ath3k/description
- Kernel support for ATH3K Module
-endef
-
-$(eval $(call KernelPackage,ath3k))
-
-
-define KernelPackage/bluetooth-6lowpan
-  SUBMENU:=$(OTHER_MENU)
-  TITLE:=Bluetooth 6LoWPAN support
-  DEPENDS:=+kmod-6lowpan +kmod-bluetooth
-  KCONFIG:=CONFIG_BT_6LOWPAN
-  FILES:=$(LINUX_DIR)/net/bluetooth/bluetooth_6lowpan.ko
-  AUTOLOAD:=$(call AutoProbe,bluetooth_6lowpan)
-endef
-
-define KernelPackage/bluetooth-6lowpan/description
- Kernel support for 6LoWPAN over Bluetooth Low Energy devices
-endef
-
-$(eval $(call KernelPackage,bluetooth-6lowpan))
-
-
-define KernelPackage/btmrvl
-  SUBMENU:=$(OTHER_MENU)
-  TITLE:=Marvell Bluetooth Kernel Module support
-  DEPENDS:=+kmod-mmc +kmod-bluetooth +mwifiex-sdio-firmware
-  KCONFIG:= \
-	CONFIG_BT_MRVL \
-	CONFIG_BT_MRVL_SDIO
-  FILES:= \
-	$(LINUX_DIR)/drivers/bluetooth/btmrvl.ko \
-	$(LINUX_DIR)/drivers/bluetooth/btmrvl_sdio.ko
-  AUTOLOAD:=$(call AutoProbe,btmrvl btmrvl_sdio)
-endef
-
-define KernelPackage/btmrvl/description
- Kernel support for Marvell SDIO Bluetooth Module
-endef
-
-$(eval $(call KernelPackage,btmrvl))
-
-
-define KernelPackage/btsdio
-  SUBMENU:=$(OTHER_MENU)
-  TITLE:=Bluetooth HCI SDIO driver
-  DEPENDS:=+kmod-bluetooth +kmod-mmc
-  KCONFIG:= \
-	CONFIG_BT_HCIBTSDIO
-  FILES:= \
-	$(LINUX_DIR)/drivers/bluetooth/btsdio.ko
-  AUTOLOAD:=$(call AutoProbe,btsdio)
-endef
-
-define KernelPackage/btsdio/description
- Kernel support for Bluetooth device with SDIO interface
-endef
-
-$(eval $(call KernelPackage,btsdio))
-
-
 define KernelPackage/dma-buf
   SUBMENU:=$(OTHER_MENU)
   TITLE:=DMA shared buffer support
@@ -801,6 +687,11 @@ $(eval $(call KernelPackage,ikconfig))
 
 define KernelPackage/zram
   SUBMENU:=$(OTHER_MENU)
+  DEPENDS:= \
+	+(KERNEL_ZRAM_BACKEND_LZO||KERNEL_ZRAM_DEF_COMP_LZORLE||KERNEL_ZRAM_DEF_COMP_LZO):kmod-lib-lzo \
+	+(KERNEL_ZRAM_BACKEND_LZ4||KERNEL_ZRAM_DEF_COMP_LZ4):kmod-lib-lz4 \
+	+(KERNEL_ZRAM_BACKEND_LZ4HC||KERNEL_ZRAM_DEF_COMP_LZ4HC):kmod-lib-lz4hc \
+	+(KERNEL_ZRAM_BACKEND_ZSTD||KERNEL_ZRAM_DEF_COMP_ZSTD):kmod-lib-zstd
   TITLE:=ZRAM
   KCONFIG:= \
 	CONFIG_ZSMALLOC \
@@ -820,29 +711,46 @@ endef
 
 define KernelPackage/zram/config
   if PACKAGE_kmod-zram
+    if !LINUX_6_6
+        config KERNEL_ZRAM_BACKEND_LZO
+                bool "lzo and lzo-rle compression support" if KERNEL_ZRAM_BACKEND_LZ4 || \
+                    KERNEL_ZRAM_BACKEND_LZ4HC || KERNEL_ZRAM_BACKEND_ZSTD
+                default !KERNEL_ZRAM_BACKEND_LZ4 && \
+                    !KERNEL_ZRAM_BACKEND_LZ4HC && !KERNEL_ZRAM_BACKEND_ZSTD
+
+        config KERNEL_ZRAM_BACKEND_LZ4
+                bool "lz4 compression support"
+
+        config KERNEL_ZRAM_BACKEND_LZ4HC
+                bool "lz4hc compression support"
+
+        config KERNEL_ZRAM_BACKEND_ZSTD
+                bool "zstd compression support"
+
+    endif
     choice
       prompt "ZRAM Default compressor"
-      default ZRAM_DEF_COMP_LZORLE
+      default KERNEL_ZRAM_DEF_COMP_LZORLE
 
-    config ZRAM_DEF_COMP_LZORLE
+    config KERNEL_ZRAM_DEF_COMP_LZORLE
             bool "lzo-rle"
-            select PACKAGE_kmod-lib-lzo
+            depends on KERNEL_ZRAM_BACKEND_LZO || LINUX_6_6
 
-    config ZRAM_DEF_COMP_LZO
+    config KERNEL_ZRAM_DEF_COMP_LZO
             bool "lzo"
-            select PACKAGE_kmod-lib-lzo
+            depends on KERNEL_ZRAM_BACKEND_LZO || LINUX_6_6
 
-    config ZRAM_DEF_COMP_LZ4
+    config KERNEL_ZRAM_DEF_COMP_LZ4
             bool "lz4"
-            select PACKAGE_kmod-lib-lz4
+            depends on KERNEL_ZRAM_BACKEND_LZ4 || LINUX_6_6
 
-    config ZRAM_DEF_COMP_LZ4HC
+    config KERNEL_ZRAM_DEF_COMP_LZ4HC
             bool "lz4-hc"
-            select PACKAGE_kmod-lib-lz4hc
+            depends on KERNEL_ZRAM_BACKEND_LZ4HC || LINUX_6_6
 
-    config ZRAM_DEF_COMP_ZSTD
+    config KERNEL_ZRAM_DEF_COMP_ZSTD
             bool "zstd"
-            select PACKAGE_kmod-lib-zstd
+            depends on KERNEL_ZRAM_BACKEND_ZSTD || LINUX_6_6
 
     endchoice
   endif
@@ -1041,8 +949,7 @@ $(eval $(call KernelPackage,keys-trusted))
 define KernelPackage/tpm
   SUBMENU:=$(OTHER_MENU)
   TITLE:=TPM Hardware Support
-  DEPENDS:= +kmod-random-core +kmod-asn1-decoder \
-	  +kmod-asn1-encoder +kmod-oid-registry
+  DEPENDS:= +kmod-random-core
   KCONFIG:= CONFIG_TCG_TPM
   FILES:= $(LINUX_DIR)/drivers/char/tpm/tpm.ko
   AUTOLOAD:=$(call AutoLoad,10,tpm,1)
diff --git a/package/kernel/linux/modules/sound.mk b/package/kernel/linux/modules/sound.mk
index f3e44e01ee..b7ad8ce0a6 100644
--- a/package/kernel/linux/modules/sound.mk
+++ b/package/kernel/linux/modules/sound.mk
@@ -383,6 +383,20 @@ endef
 
 $(eval $(call KernelPackage,sound-hda-core))
 
+define KernelPackage/snd-hda-scodec-component
+  SUBMENU:=$(SOUND_MENU)
+  TITLE:= HD Audio Codec Component
+  DEPENDS:=@!LINUX_6_6
+  KCONFIG:= \
+	CONFIG_SND_HDA_SCODEC_COMPONENT
+  FILES:= \
+	$(LINUX_DIR)/sound/pci/hda/snd-hda-scodec-component.ko
+  AUTOLOAD:=$(call AutoProbe,snd-hda-scodec-component)
+  $(call AddDepends/sound,kmod-sound-hda-core)
+endef
+
+$(eval $(call KernelPackage,snd-hda-scodec-component))
+
 define KernelPackage/sound-hda-codec-realtek
   SUBMENU:=$(SOUND_MENU)
   TITLE:= HD Audio Realtek Codec
@@ -391,7 +405,7 @@ define KernelPackage/sound-hda-codec-realtek
   FILES:= \
 	$(LINUX_DIR)/sound/pci/hda/snd-hda-codec-realtek.ko
   AUTOLOAD:=$(call AutoProbe,snd-hda-codec-realtek)
-  $(call AddDepends/sound,kmod-sound-hda-core)
+  $(call AddDepends/sound,kmod-sound-hda-core +!LINUX_6_6:kmod-snd-hda-scodec-component)
 endef
 
 define KernelPackage/sound-hda-codec-realtek/description
diff --git a/package/kernel/linux/modules/usb.mk b/package/kernel/linux/modules/usb.mk
index 481d2be59a..00260c2fbc 100644
--- a/package/kernel/linux/modules/usb.mk
+++ b/package/kernel/linux/modules/usb.mk
@@ -1808,10 +1808,7 @@ define KernelPackage/usb3
 	+TARGET_bcm53xx:kmod-usb-bcma \
 	+TARGET_bcm53xx:kmod-phy-bcm-ns-usb3 \
 	+TARGET_ramips_mt7621:kmod-usb-xhci-mtk \
-	+TARGET_mediatek:kmod-usb-xhci-mtk \
-	+TARGET_apm821xx_nand:kmod-usb-xhci-pci-renesas \
-	+TARGET_lantiq_xrx200:kmod-usb-xhci-pci-renesas \
-	+TARGET_mvebu_cortexa9:kmod-usb-xhci-pci-renesas
+	+TARGET_mediatek:kmod-usb-xhci-mtk
   KCONFIG:= \
 	CONFIG_USB_PCI=y \
 	CONFIG_USB_XHCI_PCI \
@@ -1898,8 +1895,8 @@ $(eval $(call KernelPackage,usb-xhci-mtk))
 
 define KernelPackage/usb-xhci-pci-renesas
   TITLE:=Support for additional Renesas xHCI controller with firmware
+  DEPENDS:=+kmod-usb3
   KCONFIG:=CONFIG_USB_XHCI_PCI_RENESAS
-  HIDDEN:=1
   FILES:=$(LINUX_DIR)/drivers/usb/host/xhci-pci-renesas.ko
   AUTOLOAD:=$(call AutoLoad,54,xhci-pci-renesas,1)
   $(call AddDepends/usb)
diff --git a/package/kernel/linux/modules/video.mk b/package/kernel/linux/modules/video.mk
index 9bb030bf57..f72dd91d4c 100644
--- a/package/kernel/linux/modules/video.mk
+++ b/package/kernel/linux/modules/video.mk
@@ -63,7 +63,7 @@ $(eval $(call KernelPackage,acpi-video))
 define KernelPackage/backlight
 	SUBMENU:=$(VIDEO_MENU)
 	TITLE:=Backlight support
-	DEPENDS:=@DISPLAY_SUPPORT
+	DEPENDS:=@DISPLAY_SUPPORT +!LINUX_6_6:kmod-fb
 	HIDDEN:=1
 	KCONFIG:=CONFIG_BACKLIGHT_CLASS_DEVICE \
 		CONFIG_BACKLIGHT_LCD_SUPPORT=y \
@@ -129,7 +129,7 @@ define KernelPackage/fb
 	CONFIG_VT_HW_CONSOLE_BINDING=y
   FILES:=$(LINUX_DIR)/drivers/video/fbdev/core/fb.ko \
 	$(LINUX_DIR)/lib/fonts/font.ko \
-	$(LINUX_DIR)/drivers/video/fbdev/core/fb_io_fops.ko
+	$(LINUX_DIR)/drivers/video/fbdev/core/fb_io_fops.ko@lt6.8
   AUTOLOAD:=$(call AutoLoad,06,fb font)
 endef
 
@@ -386,7 +386,7 @@ define KernelPackage/drm-ttm-helper
   SUBMENU:=$(VIDEO_MENU)
   TITLE:=Helpers for ttm-based gem objects
   HIDDEN:=1
-  DEPENDS:=@DISPLAY_SUPPORT +kmod-drm-ttm
+  DEPENDS:=@DISPLAY_SUPPORT +kmod-drm-ttm +!LINUX_6_6:kmod-drm-kms-helper
   KCONFIG:=CONFIG_DRM_TTM_HELPER
   FILES:=$(LINUX_DIR)/drivers/gpu/drm/drm_ttm_helper.ko
   AUTOLOAD:=$(call AutoProbe,drm_ttm_helper)
@@ -429,6 +429,23 @@ endef
 
 $(eval $(call KernelPackage,drm-suballoc-helper))
 
+define KernelPackage/drm-vram-helper
+  SUBMENU:=$(VIDEO_MENU)
+  HIDDEN:=1
+  TITLE:=DRM helpers for VRAM memory management
+  DEPENDS:=@DISPLAY_SUPPORT \
+    +kmod-drm-kms-helper +kmod-drm-ttm-helper
+  KCONFIG:=CONFIG_DRM_VRAM_HELPER
+  FILES:=$(LINUX_DIR)/drivers/gpu/drm/drm_vram_helper.ko
+  AUTOLOAD:=$(call AutoProbe,drm_vram_helper)
+endef
+
+define KernelPackage/drm-vram-helper/description
+  DRM helpers for VRAM memory management.
+endef
+
+$(eval $(call KernelPackage,drm-vram-helper))
+
 define KernelPackage/drm-amdgpu
   SUBMENU:=$(VIDEO_MENU)
   TITLE:=AMDGPU DRM support
diff --git a/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch b/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch
index b13bc33498..aa953c00fb 100644
--- a/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch
+++ b/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -9919,6 +9919,21 @@ static int ath10k_mac_init_rd(struct ath
+@@ -9920,6 +9920,21 @@ static int ath10k_mac_init_rd(struct ath
  	return 0;
  }
  
@@ -22,7 +22,7 @@
  int ath10k_mac_register(struct ath10k *ar)
  {
  	static const u32 cipher_suites[] = {
-@@ -10281,6 +10296,12 @@ int ath10k_mac_register(struct ath10k *a
+@@ -10282,6 +10297,12 @@ int ath10k_mac_register(struct ath10k *a
  
  	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
  
diff --git a/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch b/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch
index fc41f5f151..4f555d704e 100644
--- a/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch
+++ b/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch
@@ -40,7 +40,7 @@ Signed-off-by: Mathias Kresin <dev@kresin.me>
  	if (ret)
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -10297,7 +10297,7 @@ int ath10k_mac_register(struct ath10k *a
+@@ -10298,7 +10298,7 @@ int ath10k_mac_register(struct ath10k *a
  	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
  
  #ifdef CPTCFG_MAC80211_LEDS
diff --git a/package/kernel/mac80211/patches/ath10k/988-ath10k-always-use-mac80211-loss-detection.patch b/package/kernel/mac80211/patches/ath10k/988-ath10k-always-use-mac80211-loss-detection.patch
index b9cdae7e1f..d14f25104e 100644
--- a/package/kernel/mac80211/patches/ath10k/988-ath10k-always-use-mac80211-loss-detection.patch
+++ b/package/kernel/mac80211/patches/ath10k/988-ath10k-always-use-mac80211-loss-detection.patch
@@ -18,7 +18,7 @@ Signed-off-by: David Bauer <mail@david-bauer.net>
 
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -10089,7 +10089,6 @@ int ath10k_mac_register(struct ath10k *a
+@@ -10090,7 +10090,6 @@ int ath10k_mac_register(struct ath10k *a
  	ieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);
  	ieee80211_hw_set(ar->hw, QUEUE_CONTROL);
  	ieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);
diff --git a/package/kernel/mac80211/patches/ath11k/201-wifi-ath11k-Support-setting-bdf-addr-and-caldb-addr-.patch b/package/kernel/mac80211/patches/ath11k/201-wifi-ath11k-Support-setting-bdf-addr-and-caldb-addr-.patch
new file mode 100644
index 0000000000..81aee57546
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/201-wifi-ath11k-Support-setting-bdf-addr-and-caldb-addr-.patch
@@ -0,0 +1,62 @@
+From 824dde8652815aa67b4e2bf2d8a9455a8ef82b8f Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Thu, 29 Jun 2023 06:12:45 +0000
+Subject: [PATCH] wifi: ath11k: Support setting bdf-addr and caldb-addr via DT
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+---
+ drivers/net/wireless/ath/ath11k/qmi.c | 15 +++++++++++----
+ 1 file changed, 11 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath11k/qmi.c
++++ b/drivers/net/wireless/ath/ath11k/qmi.c
+@@ -2028,6 +2028,7 @@ static int ath11k_qmi_assign_target_mem_
+ 	struct device_node *hremote_node = NULL;
+ 	struct resource res;
+ 	u32 host_ddr_sz;
++	u32 addr;
+ 	int i, idx, ret;
+ 
+ 	for (i = 0, idx = 0; i < ab->qmi.mem_seg_count; i++) {
+@@ -2067,7 +2068,9 @@ static int ath11k_qmi_assign_target_mem_
+ 			idx++;
+ 			break;
+ 		case BDF_MEM_REGION_TYPE:
+-			ab->qmi.target_mem[idx].paddr = ab->hw_params.bdf_addr;
++			if(of_property_read_u32(dev->of_node, "qcom,bdf-addr", &addr))
++				addr = ab->hw_params.bdf_addr;
++			ab->qmi.target_mem[idx].paddr = addr;
+ 			ab->qmi.target_mem[idx].vaddr = NULL;
+ 			ab->qmi.target_mem[idx].size = ab->qmi.target_mem[i].size;
+ 			ab->qmi.target_mem[idx].type = ab->qmi.target_mem[i].type;
+@@ -2089,8 +2092,9 @@ static int ath11k_qmi_assign_target_mem_
+ 					if (!ab->qmi.target_mem[idx].iaddr)
+ 						return -EIO;
+ 				} else {
+-					ab->qmi.target_mem[idx].paddr =
+-						ATH11K_QMI_CALDB_ADDRESS;
++					if(of_property_read_u32(dev->of_node, "qcom,caldb-addr", &addr))
++						addr = ATH11K_QMI_CALDB_ADDRESS;
++					ab->qmi.target_mem[idx].paddr = addr;
+ 				}
+ 			} else {
+ 				ab->qmi.target_mem[idx].paddr = 0;
+@@ -2295,6 +2299,7 @@ static int ath11k_qmi_load_file_target_m
+ 	struct qmi_wlanfw_bdf_download_resp_msg_v01 resp;
+ 	struct qmi_txn txn;
+ 	const u8 *temp = data;
++	u32 addr;
+ 	void __iomem *bdf_addr = NULL;
+ 	int ret = 0;
+ 	u32 remaining = len;
+@@ -2306,7 +2311,9 @@ static int ath11k_qmi_load_file_target_m
+ 	memset(&resp, 0, sizeof(resp));
+ 
+ 	if (ab->hw_params.fixed_bdf_addr) {
+-		bdf_addr = ioremap(ab->hw_params.bdf_addr, ab->hw_params.fw.board_size);
++		if(of_property_read_u32(ab->dev->of_node, "qcom,bdf-addr", &addr))
++			addr = ab->hw_params.bdf_addr;
++		bdf_addr = ioremap(addr, ab->hw_params.fw.board_size);
+ 		if (!bdf_addr) {
+ 			ath11k_warn(ab, "qmi ioremap error for bdf_addr\n");
+ 			ret = -EIO;
diff --git a/package/kernel/mac80211/patches/ath11k/910-ath11k-fix-remapped-ce-accessing-issue-on-64bit-OS.patch b/package/kernel/mac80211/patches/ath11k/910-ath11k-fix-remapped-ce-accessing-issue-on-64bit-OS.patch
new file mode 100644
index 0000000000..5878fa08df
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/910-ath11k-fix-remapped-ce-accessing-issue-on-64bit-OS.patch
@@ -0,0 +1,153 @@
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Thu,  2 May 2024 00:14:31 +0800
+Subject: [PATCH] wifi: ath11k: fix remapped ce accessing issue on 64bit OS
+
+On 64bit OS, when ab->mem_ce is lower than or 4G far away from ab->mem,
+u32 is not enough to store the offsets, which makes ath11k_ahb_read32()
+and ath11k_ahb_write32() access incorrect address and causes Data Abort
+Exception.
+
+Let's use the high bits of offsets to decide where to access, which is
+similar as ath11k_pci_get_window_start() done. In the future, we can merge
+these functions for unified regs accessing.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+---
+
+--- a/drivers/net/wireless/ath/ath11k/ahb.c
++++ b/drivers/net/wireless/ath/ath11k/ahb.c
+@@ -198,12 +198,18 @@ static const struct ath11k_pci_ops ath11
+ 
+ static inline u32 ath11k_ahb_read32(struct ath11k_base *ab, u32 offset)
+ {
+-	return ioread32(ab->mem + offset);
++	if ((offset & ATH11K_REG_TYPE_MASK) == ATH11K_REG_TYPE_CE)
++		return ioread32(ab->mem_ce + FIELD_GET(ATH11K_REG_OFFSET_MASK, offset));
++	else
++		return ioread32(ab->mem + FIELD_GET(ATH11K_REG_OFFSET_MASK, offset));
+ }
+ 
+ static inline void ath11k_ahb_write32(struct ath11k_base *ab, u32 offset, u32 value)
+ {
+-	iowrite32(value, ab->mem + offset);
++	if ((offset & ATH11K_REG_TYPE_MASK) == ATH11K_REG_TYPE_CE)
++		iowrite32(value, ab->mem_ce + FIELD_GET(ATH11K_REG_OFFSET_MASK, offset));
++	else
++		iowrite32(value, ab->mem + FIELD_GET(ATH11K_REG_OFFSET_MASK, offset));
+ }
+ 
+ static void ath11k_ahb_kill_tasklets(struct ath11k_base *ab)
+@@ -275,9 +281,9 @@ static void ath11k_ahb_ce_irq_enable(str
+ 	const struct ce_ie_addr *ce_ie_addr = ab->hw_params.ce_ie_addr;
+ 	u32 ie1_reg_addr, ie2_reg_addr, ie3_reg_addr;
+ 
+-	ie1_reg_addr = ce_ie_addr->ie1_reg_addr + ATH11K_CE_OFFSET(ab);
+-	ie2_reg_addr = ce_ie_addr->ie2_reg_addr + ATH11K_CE_OFFSET(ab);
+-	ie3_reg_addr = ce_ie_addr->ie3_reg_addr + ATH11K_CE_OFFSET(ab);
++	ie1_reg_addr = ce_ie_addr->ie1_reg_addr;
++	ie2_reg_addr = ce_ie_addr->ie2_reg_addr;
++	ie3_reg_addr = ce_ie_addr->ie3_reg_addr;
+ 
+ 	ce_attr = &ab->hw_params.host_ce_config[ce_id];
+ 	if (ce_attr->src_nentries)
+@@ -296,9 +302,9 @@ static void ath11k_ahb_ce_irq_disable(st
+ 	const struct ce_ie_addr *ce_ie_addr = ab->hw_params.ce_ie_addr;
+ 	u32 ie1_reg_addr, ie2_reg_addr, ie3_reg_addr;
+ 
+-	ie1_reg_addr = ce_ie_addr->ie1_reg_addr + ATH11K_CE_OFFSET(ab);
+-	ie2_reg_addr = ce_ie_addr->ie2_reg_addr + ATH11K_CE_OFFSET(ab);
+-	ie3_reg_addr = ce_ie_addr->ie3_reg_addr + ATH11K_CE_OFFSET(ab);
++	ie1_reg_addr = ce_ie_addr->ie1_reg_addr;
++	ie2_reg_addr = ce_ie_addr->ie2_reg_addr;
++	ie3_reg_addr = ce_ie_addr->ie3_reg_addr;
+ 
+ 	ce_attr = &ab->hw_params.host_ce_config[ce_id];
+ 	if (ce_attr->src_nentries)
+--- a/drivers/net/wireless/ath/ath11k/hal.c
++++ b/drivers/net/wireless/ath/ath11k/hal.c
+@@ -1247,20 +1247,16 @@ static int ath11k_hal_srng_create_config
+ 	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_TCL_REG + HAL_TCL_STATUS_RING_HP;
+ 
+ 	s = &hal->srng_config[HAL_CE_SRC];
+-	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_BASE_LSB +
+-		ATH11K_CE_OFFSET(ab);
+-	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_HP +
+-		ATH11K_CE_OFFSET(ab);
++	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_BASE_LSB;
++	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_HP;
+ 	s->reg_size[0] = HAL_SEQ_WCSS_UMAC_CE1_SRC_REG(ab) -
+ 		HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab);
+ 	s->reg_size[1] = HAL_SEQ_WCSS_UMAC_CE1_SRC_REG(ab) -
+ 		HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab);
+ 
+ 	s = &hal->srng_config[HAL_CE_DST];
+-	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_BASE_LSB +
+-		ATH11K_CE_OFFSET(ab);
+-	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_HP +
+-		ATH11K_CE_OFFSET(ab);
++	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_BASE_LSB;
++	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_HP;
+ 	s->reg_size[0] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
+ 		HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab);
+ 	s->reg_size[1] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
+@@ -1268,9 +1264,8 @@ static int ath11k_hal_srng_create_config
+ 
+ 	s = &hal->srng_config[HAL_CE_DST_STATUS];
+ 	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) +
+-		HAL_CE_DST_STATUS_RING_BASE_LSB + ATH11K_CE_OFFSET(ab);
+-	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_STATUS_RING_HP +
+-		ATH11K_CE_OFFSET(ab);
++		HAL_CE_DST_STATUS_RING_BASE_LSB;
++	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_STATUS_RING_HP;
+ 	s->reg_size[0] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
+ 		HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab);
+ 	s->reg_size[1] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
+--- a/drivers/net/wireless/ath/ath11k/hw.c
++++ b/drivers/net/wireless/ath/ath11k/hw.c
+@@ -2268,9 +2268,9 @@ const struct ce_ie_addr ath11k_ce_ie_add
+ };
+ 
+ const struct ce_ie_addr ath11k_ce_ie_addr_ipq5018 = {
+-	.ie1_reg_addr = CE_HOST_IPQ5018_IE_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
+-	.ie2_reg_addr = CE_HOST_IPQ5018_IE_2_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
+-	.ie3_reg_addr = CE_HOST_IPQ5018_IE_3_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
++	.ie1_reg_addr = ATH11K_REG_TYPE_CE + CE_HOST_IPQ5018_IE_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
++	.ie2_reg_addr = ATH11K_REG_TYPE_CE + CE_HOST_IPQ5018_IE_2_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
++	.ie3_reg_addr = ATH11K_REG_TYPE_CE + CE_HOST_IPQ5018_IE_3_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
+ };
+ 
+ const struct ce_remap ath11k_ce_remap_ipq5018 = {
+@@ -2801,13 +2801,13 @@ const struct ath11k_hw_regs ipq5018_regs
+ 	.hal_reo_status_hp = 0x00003070,
+ 
+ 	/* WCSS relative address */
+-	.hal_seq_wcss_umac_ce0_src_reg = 0x08400000
++	.hal_seq_wcss_umac_ce0_src_reg = ATH11K_REG_TYPE_CE + 0x08400000
+ 		- HAL_IPQ5018_CE_WFSS_REG_BASE,
+-	.hal_seq_wcss_umac_ce0_dst_reg = 0x08401000
++	.hal_seq_wcss_umac_ce0_dst_reg = ATH11K_REG_TYPE_CE + 0x08401000
+ 		- HAL_IPQ5018_CE_WFSS_REG_BASE,
+-	.hal_seq_wcss_umac_ce1_src_reg = 0x08402000
++	.hal_seq_wcss_umac_ce1_src_reg = ATH11K_REG_TYPE_CE + 0x08402000
+ 		- HAL_IPQ5018_CE_WFSS_REG_BASE,
+-	.hal_seq_wcss_umac_ce1_dst_reg = 0x08403000
++	.hal_seq_wcss_umac_ce1_dst_reg = ATH11K_REG_TYPE_CE + 0x08403000
+ 		- HAL_IPQ5018_CE_WFSS_REG_BASE,
+ 
+ 	/* WBM Idle address */
+--- a/drivers/net/wireless/ath/ath11k/hw.h
++++ b/drivers/net/wireless/ath/ath11k/hw.h
+@@ -81,7 +81,12 @@
+ #define ATH11K_M3_FILE			"m3.bin"
+ #define ATH11K_REGDB_FILE_NAME		"regdb.bin"
+ 
+-#define ATH11K_CE_OFFSET(ab)	(ab->mem_ce - ab->mem)
++#define ATH11K_REG_TYPE_MASK		GENMASK(31, 28)
++#define  ATH11K_REG_TYPE(x)		FIELD_PREP_CONST(ATH11K_REG_TYPE_MASK, x)
++#define  ATH11K_REG_TYPE_NORMAL		ATH11K_REG_TYPE(0)
++#define  ATH11K_REG_TYPE_DP		ATH11K_REG_TYPE(1)
++#define  ATH11K_REG_TYPE_CE		ATH11K_REG_TYPE(2)
++#define ATH11K_REG_OFFSET_MASK		GENMASK(27, 0)
+ 
+ enum ath11k_hw_rate_cck {
+ 	ATH11K_HW_RATE_CCK_LP_11M = 0,
diff --git a/package/kernel/mac80211/patches/ath11k/920-wifi-ath11k-add-hw-params-for-QCN6122.patch b/package/kernel/mac80211/patches/ath11k/920-wifi-ath11k-add-hw-params-for-QCN6122.patch
new file mode 100644
index 0000000000..6d5aa7e2c1
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/920-wifi-ath11k-add-hw-params-for-QCN6122.patch
@@ -0,0 +1,115 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Wed, 27 Oct 2024 16:34:11 +0400
+Subject: [PATCH] wifi: ath11k: add hw params for QCN6122
+
+Add QCN6122 platform support.
+
+QCN6122 is a PCIe based solution that is attached to and enumerated
+by the WPSS (Wireless Processor SubSystem) Q6 processor.
+
+Though it is a PCIe device, since it is not attached to APSS processor
+(Application Processor SubSystem), APSS will be unaware of such a decice
+and hence it is registered to the APSS processor as a platform device(AHB).
+Because of this hybrid nature, it is called as a hybrid bus device.
+
+As such, QCN6122 is a hybrid bus type device and follows the same codepath
+as for WCN6750.
+
+This is a heavily simplified version of below downstream patch:
+Download from https://git.codelinaro.org/clo/qsdk/oss/system/feeds/wlan-open/-/blob/NHSS.QSDK.12.4.5.r2/mac80211/patches/232-ath11k-qcn6122-support.patch
+
+Co-developed-by: George Moussalem <george.moussalem@outlook.com>
+Signed-off-by: Sowmiya Sree Elavalagan <ssreeela@codeaurora.org>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+
+--- a/drivers/net/wireless/ath/ath11k/core.c
++++ b/drivers/net/wireless/ath/ath11k/core.c
+@@ -809,6 +809,67 @@ static struct ath11k_hw_params ath11k_hw
+ 		.support_fw_mac_sequence = true,
+ 		.support_dual_stations = true,
+ 	},
++	{
++		.hw_rev = ATH11K_HW_QCN6122_HW10,
++		.name = "qcn6122 hw1.0",
++		.fw = {
++			.dir = "QCN6122/hw1.0",
++			.board_size = 256 * 1024,
++			.cal_offset = 128 * 1024,
++		},
++		.hal_params = &ath11k_hw_hal_params_ipq8074,
++		.max_radios = MAX_RADIOS_5018,
++		.bdf_addr = 0x4D200000,
++		.hw_ops = &ipq5018_ops,
++		.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),
++		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6122,
++		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
++					BIT(NL80211_IFTYPE_AP) |
++					BIT(NL80211_IFTYPE_MESH_POINT),
++		.spectral = {
++			.fft_sz = 2,
++			.fft_pad_sz = 0,
++			.summary_pad_sz = 16,
++			.fft_hdr_len = 24,
++			.max_fft_bins = 1024,
++		},
++		.credit_flow = false,
++		.max_tx_ring = 1,
++		.supports_monitor = true,
++		.supports_shadow_regs = false,
++		.idle_ps = false,
++		.supports_suspend = false,
++		.host_ce_config = ath11k_host_ce_config_qcn9074,
++		.ce_count = CE_CNT_5018,
++		.target_ce_config = ath11k_target_ce_config_wlan_ipq5018,
++		.target_ce_count = TARGET_CE_CNT_5018,
++		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq5018,
++		.svc_to_ce_map_len = SVC_CE_MAP_LEN_5018,
++		.single_pdev_only = false,
++		.rxdma1_enable = true,
++		.num_rxdma_per_pdev = RXDMA_PER_PDEV_5018,
++		.rx_mac_buf_ring = false,
++		.vdev_start_delay = false,
++		.htt_peer_map_v2 = true,
++		.coldboot_cal_mm = true,
++		.coldboot_cal_ftm = true,
++		.cbcal_restart_fw = true,
++		.fix_l1ss = true,
++		.alloc_cacheable_memory = true,
++		.m3_fw_support = false,
++		.fixed_bdf_addr = true,
++		.fixed_mem_region = true,
++		.static_window_map = true,
++		.hybrid_bus_type = true,
++		.fw_mem_mode = 1,
++		.supports_sta_ps = false,
++		.dbr_debug_support = true,
++		.bios_sar_capa = NULL,
++		.fixed_fw_mem = false,
++		.support_off_channel_tx = false,
++		.tcl_ring_retry = true,
++		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
++	},
+ };
+ 
+ static inline struct ath11k_pdev *ath11k_core_get_single_pdev(struct ath11k_base *ab)
+--- a/drivers/net/wireless/ath/ath11k/core.h
++++ b/drivers/net/wireless/ath/ath11k/core.h
+@@ -148,6 +148,7 @@ enum ath11k_hw_rev {
+ 	ATH11K_HW_WCN6750_HW10,
+ 	ATH11K_HW_IPQ5018_HW10,
+ 	ATH11K_HW_QCA2066_HW21,
++	ATH11K_HW_QCN6122_HW10,
+ };
+ 
+ enum ath11k_firmware_mode {
+--- a/drivers/net/wireless/ath/ath11k/qmi.h
++++ b/drivers/net/wireless/ath/ath11k/qmi.h
+@@ -22,6 +22,7 @@
+ #define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ8074	0x02
+ #define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN9074	0x07
+ #define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_WCN6750	0x03
++#define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6122	0x40
+ #define ATH11K_QMI_WLANFW_MAX_TIMESTAMP_LEN_V01	32
+ #define ATH11K_QMI_RESP_LEN_MAX			8192
+ #define ATH11K_QMI_WLANFW_MAX_NUM_MEM_SEG_V01	52
diff --git a/package/kernel/mac80211/patches/ath11k/921-wifi-ath11k-add-hal-regs-for-QCN6122.patch b/package/kernel/mac80211/patches/ath11k/921-wifi-ath11k-add-hal-regs-for-QCN6122.patch
new file mode 100644
index 0000000000..eae73170b3
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/921-wifi-ath11k-add-hal-regs-for-QCN6122.patch
@@ -0,0 +1,114 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Wed, 27 Oct 2024 16:34:11 +0400
+Subject: [PATCH] wifi: ath11k: add hal regs for QCN6122
+
+Add HAL changes required to support QCN6122. Offsets are similar to those of 
+WCN6750 but QCN6122 does not use the hal_shadow_base_addr, so add platform 
+specific ath11k_hw_regs and register them in hw params.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/net/wireless/ath/ath11k/core.c
++++ b/drivers/net/wireless/ath/ath11k/core.c
+@@ -822,6 +822,7 @@ static struct ath11k_hw_params ath11k_hw
+ 		.bdf_addr = 0x4D200000,
+ 		.hw_ops = &ipq5018_ops,
+ 		.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),
++		.regs = &qcn6122_regs,
+ 		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6122,
+ 		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
+ 					BIT(NL80211_IFTYPE_AP) |
+--- a/drivers/net/wireless/ath/ath11k/hw.c
++++ b/drivers/net/wireless/ath/ath11k/hw.c
+@@ -2822,6 +2822,81 @@ const struct ath11k_hw_regs ipq5018_regs
+ 	.hal_wbm1_release_ring_base_lsb = 0x0000097c,
+ };
+ 
++const struct ath11k_hw_regs qcn6122_regs = {
++	/* SW2TCL(x) R0 ring configuration address */
++	.hal_tcl1_ring_base_lsb = 0x00000694,
++	.hal_tcl1_ring_base_msb = 0x00000698,
++	.hal_tcl1_ring_id = 0x0000069c,
++	.hal_tcl1_ring_misc = 0x000006a4,
++	.hal_tcl1_ring_tp_addr_lsb = 0x000006b0,
++	.hal_tcl1_ring_tp_addr_msb = 0x000006b4,
++	.hal_tcl1_ring_consumer_int_setup_ix0 = 0x000006c4,
++	.hal_tcl1_ring_consumer_int_setup_ix1 = 0x000006c8,
++	.hal_tcl1_ring_msi1_base_lsb = 0x000006dc,
++	.hal_tcl1_ring_msi1_base_msb = 0x000006e0,
++	.hal_tcl1_ring_msi1_data = 0x000006e4,
++	.hal_tcl2_ring_base_lsb = 0x000006ec,
++	.hal_tcl_ring_base_lsb = 0x0000079c,
++
++	/* TCL STATUS ring address */
++	.hal_tcl_status_ring_base_lsb = 0x000008a4,
++
++	/* REO2SW(x) R0 ring configuration address */
++	.hal_reo1_ring_base_lsb = 0x000001ec,
++	.hal_reo1_ring_base_msb = 0x000001f0,
++	.hal_reo1_ring_id = 0x000001f4,
++	.hal_reo1_ring_misc = 0x000001fc,
++	.hal_reo1_ring_hp_addr_lsb = 0x00000200,
++	.hal_reo1_ring_hp_addr_msb = 0x00000204,
++	.hal_reo1_ring_producer_int_setup = 0x00000210,
++	.hal_reo1_ring_msi1_base_lsb = 0x00000234,
++	.hal_reo1_ring_msi1_base_msb = 0x00000238,
++	.hal_reo1_ring_msi1_data = 0x0000023c,
++	.hal_reo2_ring_base_lsb = 0x00000244,
++	.hal_reo1_aging_thresh_ix_0 = 0x00000564,
++	.hal_reo1_aging_thresh_ix_1 = 0x00000568,
++	.hal_reo1_aging_thresh_ix_2 = 0x0000056c,
++	.hal_reo1_aging_thresh_ix_3 = 0x00000570,
++
++	/* REO2SW(x) R2 ring pointers (head/tail) address */
++	.hal_reo1_ring_hp = 0x00003028,
++	.hal_reo1_ring_tp = 0x0000302c,
++	.hal_reo2_ring_hp = 0x00003030,
++
++	/* REO2TCL R0 ring configuration address */
++	.hal_reo_tcl_ring_base_lsb = 0x000003fc,
++	.hal_reo_tcl_ring_hp = 0x00003058,
++
++	/* SW2REO ring address */
++	.hal_sw2reo_ring_base_lsb = 0x0000013c,
++	.hal_sw2reo_ring_hp = 0x00003018,
++
++	/* REO CMD ring address */
++	.hal_reo_cmd_ring_base_lsb = 0x000000e4,
++	.hal_reo_cmd_ring_hp = 0x00003010,
++
++	/* REO status address */
++	.hal_reo_status_ring_base_lsb = 0x00000504,
++	.hal_reo_status_hp = 0x00003070,
++
++	/* WCSS relative address */
++	.hal_seq_wcss_umac_ce0_src_reg = 0x01b80000,
++	.hal_seq_wcss_umac_ce0_dst_reg = 0x01b81000,
++	.hal_seq_wcss_umac_ce1_src_reg = 0x01b82000,
++	.hal_seq_wcss_umac_ce1_dst_reg = 0x01b83000,
++
++	/* WBM Idle address */
++	.hal_wbm_idle_link_ring_base_lsb = 0x00000874,
++	.hal_wbm_idle_link_ring_misc = 0x00000884,
++
++	/* SW2WBM release address */
++	.hal_wbm_release_ring_base_lsb = 0x000001ec,
++
++	/* WBM2SW release address */
++	.hal_wbm0_release_ring_base_lsb = 0x00000924,
++	.hal_wbm1_release_ring_base_lsb = 0x0000097c,
++};
++
+ const struct ath11k_hw_hal_params ath11k_hw_hal_params_ipq8074 = {
+ 	.rx_buf_rbm = HAL_RX_BUF_RBM_SW3_BM,
+ 	.tcl2wbm_rbm_map = ath11k_hw_tcl2wbm_rbm_map_ipq8074,
+--- a/drivers/net/wireless/ath/ath11k/hw.h
++++ b/drivers/net/wireless/ath/ath11k/hw.h
+@@ -425,6 +425,7 @@ extern const struct ath11k_hw_regs qcn90
+ extern const struct ath11k_hw_regs wcn6855_regs;
+ extern const struct ath11k_hw_regs wcn6750_regs;
+ extern const struct ath11k_hw_regs ipq5018_regs;
++extern const struct ath11k_hw_regs qcn6122_regs;
+ 
+ static inline const char *ath11k_bd_ie_type_str(enum ath11k_bd_ie_type type)
+ {
diff --git a/package/kernel/mac80211/patches/ath11k/922-wifi-ath11k-add-hw-ring-mask-for-QCN6122.patch b/package/kernel/mac80211/patches/ath11k/922-wifi-ath11k-add-hw-ring-mask-for-QCN6122.patch
new file mode 100644
index 0000000000..f93a3bc60a
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/922-wifi-ath11k-add-hw-ring-mask-for-QCN6122.patch
@@ -0,0 +1,74 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Wed, 27 Oct 2024 16:34:11 +0400
+Subject: [PATCH] wifi: ath11k: add hw ring mask for QCN6122
+
+Add ring mask for QCN6122 and register them in hw params.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/net/wireless/ath/ath11k/core.c
++++ b/drivers/net/wireless/ath/ath11k/core.c
+@@ -821,6 +821,7 @@ static struct ath11k_hw_params ath11k_hw
+ 		.max_radios = MAX_RADIOS_5018,
+ 		.bdf_addr = 0x4D200000,
+ 		.hw_ops = &ipq5018_ops,
++		.ring_mask = &ath11k_hw_ring_mask_qcn6122,
+ 		.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),
+ 		.regs = &qcn6122_regs,
+ 		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6122,
+--- a/drivers/net/wireless/ath/ath11k/hw.c
++++ b/drivers/net/wireless/ath/ath11k/hw.c
+@@ -2070,6 +2070,43 @@ const struct ath11k_hw_ring_mask ath11k_
+ 	},
+ };
+ 
++const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn6122 = {
++	.tx  = {
++		ATH11K_TX_RING_MASK_0,
++		ATH11K_TX_RING_MASK_1,
++		ATH11K_TX_RING_MASK_2,
++	},
++	.rx_mon_status = {
++		0, 0, 0,
++		ATH11K_RX_MON_STATUS_RING_MASK_0,
++	},
++	.rx = {
++		0, 0, 0, 0,
++		ATH11K_RX_RING_MASK_0,
++		ATH11K_RX_RING_MASK_1,
++		ATH11K_RX_RING_MASK_2,
++		ATH11K_RX_RING_MASK_3,
++	},
++	.rx_err = {
++		0, 0, 0, 0, 0, 0, 0, 0,
++		ATH11K_RX_ERR_RING_MASK_0,
++	},
++	.rx_wbm_rel = {
++		0, 0, 0, 0, 0, 0, 0, 0, 0,
++		ATH11K_RX_WBM_REL_RING_MASK_0,
++	},
++       .reo_status = {
++		0, 0, 0,
++		ATH11K_REO_STATUS_RING_MASK_0,
++	},
++	.rxdma2host = {
++		ATH11K_RXDMA2HOST_RING_MASK_0,
++	},
++	.host2rxdma = {
++		ATH11K_HOST2RXDMA_RING_MASK_0,
++	},
++};
++
+ /* Target firmware's Copy Engine configuration for IPQ5018 */
+ const struct ce_pipe_config ath11k_target_ce_config_wlan_ipq5018[] = {
+ 	/* CE0: host->target HTC control and raw streams */
+--- a/drivers/net/wireless/ath/ath11k/hw.h
++++ b/drivers/net/wireless/ath/ath11k/hw.h
+@@ -289,6 +289,7 @@ extern const struct ath11k_hw_ring_mask
+ extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qca6390;
+ extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn9074;
+ extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_wcn6750;
++extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn6122;
+ 
+ extern const struct ce_ie_addr ath11k_ce_ie_addr_ipq8074;
+ extern const struct ce_ie_addr ath11k_ce_ie_addr_ipq5018;
diff --git a/package/kernel/mac80211/patches/ath11k/923-wifi-ath11k-update-hif_and-pci_ops-for-QCN6122.patch b/package/kernel/mac80211/patches/ath11k/923-wifi-ath11k-update-hif_and-pci_ops-for-QCN6122.patch
new file mode 100644
index 0000000000..8497c3a8c9
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/923-wifi-ath11k-update-hif_and-pci_ops-for-QCN6122.patch
@@ -0,0 +1,102 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Wed, 27 Oct 2024 16:34:11 +0400
+Subject: [PATCH] wifi: ath11k: update hif and pci ops for QCN6122
+
+Add HIF and PCI ops for QCN6122. QCN6122 by default uses DP window 3.
+However, this is configurable, so let's introduce a function to do that and
+follow the existing register access code for (hybrid)AHB devices and use 
+DP window 1.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/net/wireless/ath/ath11k/ahb.c
++++ b/drivers/net/wireless/ath/ath11k/ahb.c
+@@ -768,6 +768,18 @@ static int ath11k_ahb_hif_resume(struct
+ 	return 0;
+ }
+ 
++static void ath11k_ahb_config_static_window_qcn6122(struct ath11k_base *ab)
++{
++	u32 umac_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_SEQ_WCSS_UMAC_OFFSET);
++	u32 ce_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_CE_WFSS_CE_REG_BASE);
++	u32 window;
++
++	window = (umac_window) | (ce_window << 6);
++
++	iowrite32(ATH11K_PCI_WINDOW_ENABLE_BIT | window,
++		  ab->mem + ATH11K_PCI_WINDOW_REG_ADDRESS);
++}
++
+ static const struct ath11k_hif_ops ath11k_ahb_hif_ops_ipq8074 = {
+ 	.start = ath11k_ahb_start,
+ 	.stop = ath11k_ahb_stop,
+@@ -800,6 +812,24 @@ static const struct ath11k_hif_ops ath11
+ 	.ce_irq_disable = ath11k_pci_disable_ce_irqs_except_wake_irq,
+ };
+ 
++static const struct ath11k_hif_ops ath11k_ahb_hif_ops_qcn6122 = {
++	.start = ath11k_pcic_start,
++	.stop = ath11k_pcic_stop,
++	.read32 = ath11k_pcic_read32,
++	.write32 = ath11k_pcic_write32,
++	.read = NULL,
++	.irq_enable = ath11k_pcic_ext_irq_enable,
++	.irq_disable = ath11k_pcic_ext_irq_disable,
++	.get_msi_address =  ath11k_pcic_get_msi_address,
++	.get_user_msi_vector = ath11k_pcic_get_user_msi_assignment,
++	.map_service_to_pipe = ath11k_pcic_map_service_to_pipe,
++	.power_down = ath11k_ahb_power_down,
++	.power_up = ath11k_ahb_power_up,
++	.ce_irq_enable = ath11k_pci_enable_ce_irqs_except_wake_irq,
++	.ce_irq_disable = ath11k_pci_disable_ce_irqs_except_wake_irq,
++	.config_static_window = ath11k_ahb_config_static_window_qcn6122,
++};
++
+ static int ath11k_core_get_rproc(struct ath11k_base *ab)
+ {
+ 	struct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);
+@@ -1144,6 +1174,10 @@ static int ath11k_ahb_probe(struct platf
+ 		hif_ops = &ath11k_ahb_hif_ops_wcn6750;
+ 		pci_ops = &ath11k_ahb_pci_ops_wcn6750;
+ 		break;
++	case ATH11K_HW_QCN6122_HW10:
++		hif_ops = &ath11k_ahb_hif_ops_qcn6122;
++		pci_ops = &ath11k_ahb_pci_ops_wcn6750;
++		break;
+ 	default:
+ 		dev_err(&pdev->dev, "unsupported device type %d\n", hw_rev);
+ 		return -EOPNOTSUPP;
+--- a/drivers/net/wireless/ath/ath11k/hif.h
++++ b/drivers/net/wireless/ath/ath11k/hif.h
+@@ -31,6 +31,7 @@ struct ath11k_hif_ops {
+ 	void (*ce_irq_enable)(struct ath11k_base *ab);
+ 	void (*ce_irq_disable)(struct ath11k_base *ab);
+ 	void (*get_ce_msi_idx)(struct ath11k_base *ab, u32 ce_id, u32 *msi_idx);
++	void (*config_static_window)(struct ath11k_base *ab);
+ };
+ 
+ static inline void ath11k_hif_ce_irq_enable(struct ath11k_base *ab)
+@@ -146,4 +147,12 @@ static inline void ath11k_get_ce_msi_idx
+ 		*msi_data_idx = ce_id;
+ }
+ 
++static inline void ath11k_hif_config_static_window(struct ath11k_base *ab)
++{
++	if (!ab->hw_params.static_window_map || !ab->hif.ops->config_static_window)
++		return;
++
++	ab->hif.ops->config_static_window(ab);
++}
++
+ #endif /* _HIF_H_ */
+--- a/drivers/net/wireless/ath/ath11k/qmi.c
++++ b/drivers/net/wireless/ath/ath11k/qmi.c
+@@ -2187,6 +2187,8 @@ static int ath11k_qmi_request_device_inf
+ 	if (!ab->hw_params.ce_remap)
+ 		ab->mem_ce = ab->mem;
+ 
++	ath11k_hif_config_static_window(ab);
++
+ 	return 0;
+ out:
+ 	return ret;
diff --git a/package/kernel/mac80211/patches/ath11k/924-wifi-ath11k-add-multipd-support-for-QCN6122.patch b/package/kernel/mac80211/patches/ath11k/924-wifi-ath11k-add-multipd-support-for-QCN6122.patch
new file mode 100644
index 0000000000..5b0c58dd94
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/924-wifi-ath11k-add-multipd-support-for-QCN6122.patch
@@ -0,0 +1,110 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Wed, 27 Oct 2024 16:34:11 +0400
+Subject: [PATCH] wifi: ath11k: add multipd support for QCN6122
+
+IPQ5018/QCN6122 platforms use multi PD (protection domains) to avoid having 
+one instance of the running Q6 firmware crashing resulting in crashing the 
+others. See below patch for more info:
+https://lore.kernel.org/all/20231110091939.3025413-1-quic_mmanikan@quicinc.com/
+
+The IPQ5018 platform can have multiple (2) QCN6122 wifi cards. To differentiate
+the two, the PD instance number (1 or 2) is added to the QMI service instance
+ID, which the QCN6122 firmware also expects. IPQ5018 is always the first PD, so
+the QCN6122 cards should be the second or third.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/net/wireless/ath/ath11k/ahb.c
++++ b/drivers/net/wireless/ath/ath11k/ahb.c
+@@ -435,6 +435,7 @@ static void ath11k_ahb_init_qmi_ce_confi
+ 	cfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;
+ 	cfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;
+ 	ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
++	ab->qmi.service_ins_id += ab->userpd_id;
+ }
+ 
+ static void ath11k_ahb_free_ext_irq(struct ath11k_base *ab)
+@@ -1118,6 +1119,27 @@ err_unregister:
+ 	return ret;
+ }
+ 
++static int ath11k_get_userpd_id(struct device *dev)
++{
++	int ret;
++	int userpd_id = 0;
++	const char *subsys_name;
++
++	ret = of_property_read_string(dev->of_node,
++				      "qcom,userpd-subsys-name",
++				      &subsys_name);
++	if (ret) 
++		return 0;
++
++	if (strcmp(subsys_name, "q6v5_wcss_userpd2") == 0)
++		userpd_id = ATH11K_QCN6122_USERPD_2;
++	else if (strcmp(subsys_name, "q6v5_wcss_userpd3") == 0)
++		userpd_id = ATH11K_QCN6122_USERPD_3;
++	dev_info(dev, "Multipd architecture - userpd: %d\n", userpd_id + 1);
++
++	return userpd_id;
++}
++
+ static int ath11k_ahb_fw_resource_deinit(struct ath11k_base *ab)
+ {
+ 	struct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);
+@@ -1159,7 +1181,7 @@ static int ath11k_ahb_probe(struct platf
+ 	const struct ath11k_hif_ops *hif_ops;
+ 	const struct ath11k_pci_ops *pci_ops;
+ 	enum ath11k_hw_rev hw_rev;
+-	int ret;
++	int ret, userpd_id;
+ 
+ 	hw_rev = (uintptr_t)device_get_match_data(&pdev->dev);
+ 
+@@ -1183,6 +1205,7 @@ static int ath11k_ahb_probe(struct platf
+ 		return -EOPNOTSUPP;
+ 	}
+ 
++	userpd_id = ath11k_get_userpd_id(&pdev->dev);
+ 	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+ 	if (ret) {
+ 		dev_err(&pdev->dev, "failed to set 32-bit consistent dma\n");
+@@ -1199,6 +1222,7 @@ static int ath11k_ahb_probe(struct platf
+ 	ab->hif.ops = hif_ops;
+ 	ab->pdev = pdev;
+ 	ab->hw_rev = hw_rev;
++	ab->userpd_id = userpd_id;
+ 	ab->fw_mode = ATH11K_FIRMWARE_MODE_NORMAL;
+ 	platform_set_drvdata(pdev, ab);
+ 
+--- a/drivers/net/wireless/ath/ath11k/core.h
++++ b/drivers/net/wireless/ath/ath11k/core.h
+@@ -45,6 +45,9 @@
+ #define ATH11K_INVALID_HW_MAC_ID	0xFF
+ #define ATH11K_CONNECTION_LOSS_HZ	(3 * HZ)
+ 
++#define	ATH11K_QCN6122_USERPD_2		1
++#define	ATH11K_QCN6122_USERPD_3		2
++
+ /* SMBIOS type containing Board Data File Name Extension */
+ #define ATH11K_SMBIOS_BDF_EXT_TYPE 0xF8
+ 
+@@ -951,6 +954,7 @@ struct ath11k_base {
+ 	struct list_head peers;
+ 	wait_queue_head_t peer_mapping_wq;
+ 	u8 mac_addr[ETH_ALEN];
++	int userpd_id;
+ 	int irq_num[ATH11K_IRQ_NUM_MAX];
+ 	struct ath11k_ext_irq_grp ext_irq_grp[ATH11K_EXT_IRQ_GRP_NUM_MAX];
+ 	struct ath11k_targ_cap target_caps;
+--- a/drivers/net/wireless/ath/ath11k/pci.c
++++ b/drivers/net/wireless/ath/ath11k/pci.c
+@@ -389,6 +389,8 @@ static void ath11k_pci_init_qmi_ce_confi
+ 	} else
+ 		ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
+ 
++	ab->qmi.service_ins_id += ab->userpd_id;
++
+ 	ath11k_ce_get_shadow_config(ab, &cfg->shadow_reg_v2,
+ 				    &cfg->shadow_reg_v2_len);
+ }
diff --git a/package/kernel/mac80211/patches/ath11k/925-wifi-ath11k-add-QCN6122-device-support.patch b/package/kernel/mac80211/patches/ath11k/925-wifi-ath11k-add-QCN6122-device-support.patch
new file mode 100644
index 0000000000..58627ce07e
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/925-wifi-ath11k-add-QCN6122-device-support.patch
@@ -0,0 +1,55 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Wed, 27 Oct 2024 16:34:11 +0400
+Subject: [PATCH] wifi: ath11k: add QCN6122 device support
+
+QCN6122 is a 2x2 11AX PCIe based chipset, but it is attached to the WPSS
+(Wireless Processor SubSystem) Q6 processor, hence it is enumerated
+by the Q6 processor. It is registered to the APSS processor 
+(Application Processor SubSystem) as a platform device (AHB) and remoteproc 
+APIs are used to boot up or shutdown the device like other AHB devices.
+
+Also, device information like BAR and its size is not known to the
+APSS processor as the chip is enumerated by WPSS Q6. These details
+are fetched over QMI.
+
+STA, AP, and MESH modes are supported. 
+Tested on: Linksys MX2000 and GLiNET B3000 access points for prolonged duration
+tests spanning multiple days with multiple clients connected with firmware
+WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
+
+An important point to note is that though QCN6122 is a PCIe device,
+it is an IPQ5018 SoC specific solution and cannot be attached to any other 
+platform.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/net/wireless/ath/ath11k/ahb.c
++++ b/drivers/net/wireless/ath/ath11k/ahb.c
+@@ -37,6 +37,9 @@ static const struct of_device_id ath11k_
+ 	{ .compatible = "qcom,ipq5018-wifi",
+ 	  .data = (void *)ATH11K_HW_IPQ5018_HW10,
+ 	},
++	{ .compatible = "qcom,qcn6122-wifi",
++	  .data = (void *)ATH11K_HW_QCN6122_HW10,
++	},
+ 	{ }
+ };
+ 
+--- a/drivers/net/wireless/ath/ath11k/pcic.c
++++ b/drivers/net/wireless/ath/ath11k/pcic.c
+@@ -126,6 +126,15 @@ static const struct ath11k_msi_config at
+ 		},
+ 		.hw_rev = ATH11K_HW_QCA2066_HW21,
+ 	},
++	{
++		.total_vectors = 13,
++		.total_users = 2,
++		.users = (struct ath11k_msi_user[]) {
++			{ .name = "CE", .num_vectors = 5, .base_vector = 0 },
++			{ .name = "DP", .num_vectors = 8, .base_vector = 5 },
++		},
++		.hw_rev = ATH11K_HW_QCN6122_HW10,
++	},
+ };
+ 
+ int ath11k_pcic_init_msi_config(struct ath11k_base *ab)
diff --git a/package/kernel/mac80211/patches/ath11k/931-wifi-ath11k-Support-to-assign-m3-dump-memory.patch b/package/kernel/mac80211/patches/ath11k/931-wifi-ath11k-Support-to-assign-m3-dump-memory.patch
new file mode 100644
index 0000000000..834a4b5797
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/931-wifi-ath11k-Support-to-assign-m3-dump-memory.patch
@@ -0,0 +1,31 @@
+From 64f6f6cdde0b6b763181145a698207fad4536c06 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Wed, 9 Aug 2023 17:44:49 +0000
+Subject: [PATCH] wifi: ath11k: Support to assign m3 dump memory
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+---
+ drivers/net/wireless/ath/ath11k/qmi.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/drivers/net/wireless/ath/ath11k/qmi.c
++++ b/drivers/net/wireless/ath/ath11k/qmi.c
+@@ -2104,6 +2104,18 @@ static int ath11k_qmi_assign_target_mem_
+ 			ab->qmi.target_mem[idx].type = ab->qmi.target_mem[i].type;
+ 			idx++;
+ 			break;
++		case M3_DUMP_REGION_TYPE:
++			if (of_property_read_u32(dev->of_node, "qcom,m3-dump-addr", &addr)) {
++				ath11k_warn(ab, "qmi fail to get qcom,m3-dump-addr, ignore m3 dump mem req\n");
++				break;
++			}
++
++			ab->qmi.target_mem[idx].paddr = (phys_addr_t) addr;
++			ab->qmi.target_mem[idx].vaddr = NULL;
++			ab->qmi.target_mem[idx].size = ab->qmi.target_mem[i].size;
++			ab->qmi.target_mem[idx].type = ab->qmi.target_mem[i].type;
++			idx++;
++			break;
+ 		default:
+ 			ath11k_warn(ab, "qmi ignore invalid mem req type %d\n",
+ 				    ab->qmi.target_mem[i].type);
diff --git a/package/kernel/mac80211/patches/ath11k/932-wifi-ath11k-poll-reo-status-ipq5018.patch b/package/kernel/mac80211/patches/ath11k/932-wifi-ath11k-poll-reo-status-ipq5018.patch
new file mode 100644
index 0000000000..693cb0e0d4
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath11k/932-wifi-ath11k-poll-reo-status-ipq5018.patch
@@ -0,0 +1,164 @@
+From d890c6d602307c9297df12c7d0287f9ffd26208b Mon Sep 17 00:00:00 2001
+From: Sriram R <srirrama@codeaurora.org>
+Date: Wed, 12 May 2021 19:21:09 +0530
+Subject: [PATCH] ath11k: poll reo status ring for IPQ5018
+
+Currently reo status interrupts are not received
+due to wrong mapping of the reo status interrupt
+line in IPQ5018.
+
+Hence, until the mapping is resolved in HW, use
+polling to reap the reo status ring. Rather than
+a period timer to reap the ring, the timer is
+triggered only on sending a reo command with
+status request.
+
+Without proper reaping of the ring, backpressure
+and ring full issues are seen in multi client test
+setups which leads to flooding the console with
+error messages reporting failure to send reo cmds.
+
+Can be reverted once HW solution is available.
+
+Signed-off-by: Sriram R <srirrama@codeaurora.org>
+---
+--- a/drivers/net/wireless/ath/ath11k/core.c
++++ b/drivers/net/wireless/ath/ath11k/core.c
+@@ -719,6 +719,7 @@ static struct ath11k_hw_params ath11k_hw
+ 		.smp2p_wow_exit = false,
+ 		.support_fw_mac_sequence = false,
+ 		.support_dual_stations = false,
++		.reo_status_poll = true,
+ 	},
+ 	{
+ 		.name = "qca2066 hw2.1",
+--- a/drivers/net/wireless/ath/ath11k/dp.c
++++ b/drivers/net/wireless/ath/ath11k/dp.c
+@@ -348,12 +348,66 @@ void ath11k_dp_stop_shadow_timers(struct
+ 	ath11k_dp_shadow_stop_timer(ab, &ab->dp.reo_cmd_timer);
+ }
+ 
++static void ath11k_dp_handle_reo_status_timer(struct timer_list *timer)
++{
++	struct ath11k_dp *dp = from_timer(dp, timer, reo_status_timer);
++	struct ath11k_base *ab = dp->ab;
++
++	spin_lock_bh(&dp->reo_cmd_lock);
++	dp->reo_status_timer_running = false;
++	spin_unlock_bh(&dp->reo_cmd_lock);
++
++	ath11k_dp_process_reo_status(ab);
++}
++
++void ath11k_dp_start_reo_status_timer(struct ath11k_base *ab)
++{
++	struct ath11k_dp *dp = &ab->dp;
++
++	if (!ab->hw_params.reo_status_poll)
++		return;
++
++	spin_lock_bh(&dp->reo_cmd_lock);
++	if (dp->reo_status_timer_running) {
++		spin_unlock_bh(&dp->reo_cmd_lock);
++		return;
++	}
++	dp->reo_status_timer_running = true;
++	spin_unlock_bh(&dp->reo_cmd_lock);
++
++	mod_timer(&dp->reo_status_timer, jiffies +
++		  msecs_to_jiffies(ATH11K_REO_STATUS_POLL_TIMEOUT_MS));
++}
++
++static void ath11k_dp_stop_reo_status_timer(struct ath11k_base *ab)
++{
++	struct ath11k_dp *dp = &ab->dp;
++
++	if (!ab->hw_params.reo_status_poll)
++		return;
++
++	del_timer_sync(&dp->reo_status_timer);
++	dp->reo_status_timer_running = false;
++}
++
++static void ath11k_dp_init_reo_status_timer(struct ath11k_base *ab)
++{
++	struct ath11k_dp *dp = &ab->dp;
++
++	if (!ab->hw_params.reo_status_poll)
++		return;
++
++	timer_setup(&dp->reo_status_timer,
++		    ath11k_dp_handle_reo_status_timer, 0);
++}
++
+ static void ath11k_dp_srng_common_cleanup(struct ath11k_base *ab)
+ {
+ 	struct ath11k_dp *dp = &ab->dp;
+ 	int i;
+ 
+ 	ath11k_dp_stop_shadow_timers(ab);
++	ath11k_dp_stop_reo_status_timer(ab);
+ 	ath11k_dp_srng_cleanup(ab, &dp->wbm_desc_rel_ring);
+ 	ath11k_dp_srng_cleanup(ab, &dp->tcl_cmd_ring);
+ 	ath11k_dp_srng_cleanup(ab, &dp->tcl_status_ring);
+@@ -375,6 +429,8 @@ static int ath11k_dp_srng_common_setup(s
+ 	int i, ret;
+ 	u8 tcl_num, wbm_num;
+ 
++	ath11k_dp_init_reo_status_timer(ab);
++
+ 	ret = ath11k_dp_srng_setup(ab, &dp->wbm_desc_rel_ring,
+ 				   HAL_SW2WBM_RELEASE, 0, 0,
+ 				   DP_WBM_RELEASE_RING_SIZE);
+--- a/drivers/net/wireless/ath/ath11k/dp.h
++++ b/drivers/net/wireless/ath/ath11k/dp.h
+@@ -46,6 +46,8 @@ struct dp_rx_tid {
+ #define DP_MON_PURGE_TIMEOUT_MS     100
+ #define DP_MON_SERVICE_BUDGET       128
+ 
++#define ATH11K_REO_STATUS_POLL_TIMEOUT_MS 10
++
+ struct dp_reo_cache_flush_elem {
+ 	struct list_head list;
+ 	struct dp_rx_tid data;
+@@ -288,6 +290,10 @@ struct ath11k_dp {
+ 	spinlock_t reo_cmd_lock;
+ 	struct ath11k_hp_update_timer reo_cmd_timer;
+ 	struct ath11k_hp_update_timer tx_ring_timer[DP_TCL_NUM_RING_MAX];
++
++	/* reo status timer and flags */
++	struct timer_list reo_status_timer;
++	bool reo_status_timer_running;
+ };
+ 
+ /* HTT definitions */
+@@ -1691,5 +1697,6 @@ void ath11k_dp_shadow_init_timer(struct
+ 				 struct ath11k_hp_update_timer *update_timer,
+ 				 u32 interval, u32 ring_id);
+ void ath11k_dp_stop_shadow_timers(struct ath11k_base *ab);
++void ath11k_dp_start_reo_status_timer(struct ath11k_base *ab);
+ 
+ #endif
+--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
++++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
+@@ -787,6 +787,10 @@ int ath11k_dp_tx_send_reo_cmd(struct ath
+ 	if (cmd_num == 0)
+ 		return -EINVAL;
+ 
++	/* Trigger reo status polling if required */
++	if (cmd->flag & HAL_REO_CMD_FLG_NEED_STATUS)
++		ath11k_dp_start_reo_status_timer(ab);
++
+ 	if (!cb)
+ 		return 0;
+ 
+--- a/drivers/net/wireless/ath/ath11k/hw.h
++++ b/drivers/net/wireless/ath/ath11k/hw.h
+@@ -232,6 +232,7 @@ struct ath11k_hw_params {
+ 	bool smp2p_wow_exit;
+ 	bool support_fw_mac_sequence;
+ 	bool support_dual_stations;
++	bool reo_status_poll;
+ };
+ 
+ struct ath11k_hw_ops {
diff --git a/package/kernel/mac80211/patches/ath12k/001-wifi-ath12k-add-11d-scan-offload-support-and-handle-country-code-for-WCN7850.patch b/package/kernel/mac80211/patches/ath12k/001-wifi-ath12k-add-11d-scan-offload-support-and-handle-country-code-for-WCN7850.patch
index caa4e20f97..2afd7f8b0e 100644
--- a/package/kernel/mac80211/patches/ath12k/001-wifi-ath12k-add-11d-scan-offload-support-and-handle-country-code-for-WCN7850.patch
+++ b/package/kernel/mac80211/patches/ath12k/001-wifi-ath12k-add-11d-scan-offload-support-and-handle-country-code-for-WCN7850.patch
@@ -532,7 +532,7 @@ Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
  	return ret;
  }
  
-@@ -5994,7 +6009,7 @@ static int ath12k_mac_start(struct ath12
+@@ -5995,7 +6010,7 @@ static int ath12k_mac_start(struct ath12
  
  	/* TODO: Do we need to enable ANI? */
  
@@ -541,7 +541,7 @@ Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
  
  	ar->num_started_vdevs = 0;
  	ar->num_created_vdevs = 0;
-@@ -6174,6 +6189,9 @@ static void ath12k_mac_stop(struct ath12
+@@ -6175,6 +6190,9 @@ static void ath12k_mac_stop(struct ath12
  	cancel_delayed_work_sync(&ar->scan.timeout);
  	cancel_work_sync(&ar->regd_update_work);
  	cancel_work_sync(&ar->ab->rfkill_work);
@@ -551,7 +551,7 @@ Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
  
  	spin_lock_bh(&ar->data_lock);
  	list_for_each_entry_safe(ppdu_stats, tmp, &ar->ppdu_stats_info, list) {
-@@ -6420,6 +6438,117 @@ static void ath12k_mac_op_update_vif_off
+@@ -6421,6 +6439,117 @@ static void ath12k_mac_op_update_vif_off
  	ath12k_mac_update_vif_offload(arvif);
  }
  
@@ -669,7 +669,7 @@ Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
  static int ath12k_mac_vdev_create(struct ath12k *ar, struct ieee80211_vif *vif)
  {
  	struct ath12k_hw *ah = ar->ah;
-@@ -6534,6 +6663,7 @@ static int ath12k_mac_vdev_create(struct
+@@ -6535,6 +6664,7 @@ static int ath12k_mac_vdev_create(struct
  				    arvif->vdev_id, ret);
  			goto err_peer_del;
  		}
@@ -677,7 +677,7 @@ Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
  		break;
  	case WMI_VDEV_TYPE_STA:
  		param_id = WMI_STA_PS_PARAM_RX_WAKE_POLICY;
-@@ -6572,6 +6702,13 @@ static int ath12k_mac_vdev_create(struct
+@@ -6573,6 +6703,13 @@ static int ath12k_mac_vdev_create(struct
  				    arvif->vdev_id, ret);
  			goto err_peer_del;
  		}
@@ -691,7 +691,7 @@ Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
  		break;
  	default:
  		break;
-@@ -6912,6 +7049,11 @@ static void ath12k_mac_op_remove_interfa
+@@ -6913,6 +7050,11 @@ static void ath12k_mac_op_remove_interfa
  	ath12k_dbg(ab, ATH12K_DBG_MAC, "mac remove interface (vdev %d)\n",
  		   arvif->vdev_id);
  
@@ -703,7 +703,7 @@ Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
  	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
  		ret = ath12k_peer_delete(ar, arvif->vdev_id, vif->addr);
  		if (ret)
-@@ -7752,6 +7894,14 @@ ath12k_mac_op_unassign_vif_chanctx(struc
+@@ -7753,6 +7895,14 @@ ath12k_mac_op_unassign_vif_chanctx(struc
  	    ar->num_started_vdevs == 1 && ar->monitor_vdev_created)
  		ath12k_mac_monitor_stop(ar);
  
@@ -718,7 +718,7 @@ Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
  	mutex_unlock(&ar->conf_mutex);
  }
  
-@@ -8290,6 +8440,14 @@ ath12k_mac_op_reconfig_complete(struct i
+@@ -8291,6 +8441,14 @@ ath12k_mac_op_reconfig_complete(struct i
  		ath12k_warn(ar->ab, "pdev %d successfully recovered\n",
  			    ar->pdev->pdev_id);
  
@@ -733,7 +733,7 @@ Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
  		if (ab->is_reset) {
  			recovery_count = atomic_inc_return(&ab->recovery_count);
  
-@@ -9339,6 +9497,9 @@ static void ath12k_mac_setup(struct ath1
+@@ -9340,6 +9498,9 @@ static void ath12k_mac_setup(struct ath1
  
  	INIT_WORK(&ar->wmi_mgmt_tx_work, ath12k_mgmt_over_wmi_tx_work);
  	skb_queue_head_init(&ar->wmi_mgmt_tx_queue);
diff --git a/package/kernel/mac80211/patches/ath12k/002-wifi-ath12k-Fetch-regdb.bin-file-from-board-2.bin.patch b/package/kernel/mac80211/patches/ath12k/002-wifi-ath12k-Fetch-regdb.bin-file-from-board-2.bin.patch
new file mode 100644
index 0000000000..67d62f9257
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/002-wifi-ath12k-Fetch-regdb.bin-file-from-board-2.bin.patch
@@ -0,0 +1,67 @@
+From 24f587572acf7509127dbdfcbf1b681ef84eeba0 Mon Sep 17 00:00:00 2001
+From: Aaradhana Sahu <quic_aarasahu@quicinc.com>
+Date: Thu, 16 Jan 2025 08:58:35 +0530
+Subject: [PATCH] wifi: ath12k: Fetch regdb.bin file from board-2.bin
+
+Currently, ath12k_core_fetch_regdb() finds regdb.bin file through
+board id's but in board-2.bin file regdb.bin file is present with
+default board id because of which regdb.bin is not fetched.
+
+Add support to fetch regdb.bin file from board-2.bin through
+default board id.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Aaradhana Sahu <quic_aarasahu@quicinc.com>
+Reviewed-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
+Link: https://patch.msgid.link/20250116032835.118397-1-quic_aarasahu@quicinc.com
+Signed-off-by: Jeff Johnson <jeff.johnson@oss.qualcomm.com>
+---
+ drivers/net/wireless/ath/ath12k/core.c | 12 +++++++-----
+ 1 file changed, 7 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/core.c
++++ b/drivers/net/wireless/ath/ath12k/core.c
+@@ -161,7 +161,7 @@ EXPORT_SYMBOL(ath12k_core_resume);
+ 
+ static int __ath12k_core_create_board_name(struct ath12k_base *ab, char *name,
+ 					   size_t name_len, bool with_variant,
+-					   bool bus_type_mode)
++					   bool bus_type_mode, bool with_default)
+ {
+ 	/* strlen(',variant=') + strlen(ab->qmi.target.bdf_ext) */
+ 	char variant[9 + ATH12K_QMI_BDF_EXT_STR_LENGTH] = { 0 };
+@@ -192,7 +192,9 @@ static int __ath12k_core_create_board_na
+ 			  "bus=%s,qmi-chip-id=%d,qmi-board-id=%d%s",
+ 			  ath12k_bus_str(ab->hif.bus),
+ 			  ab->qmi.target.chip_id,
+-			  ab->qmi.target.board_id, variant);
++			  with_default ?
++			  ATH12K_BOARD_ID_DEFAULT : ab->qmi.target.board_id,
++			  variant);
+ 		break;
+ 	}
+ 
+@@ -204,19 +206,19 @@ static int __ath12k_core_create_board_na
+ static int ath12k_core_create_board_name(struct ath12k_base *ab, char *name,
+ 					 size_t name_len)
+ {
+-	return __ath12k_core_create_board_name(ab, name, name_len, true, false);
++	return __ath12k_core_create_board_name(ab, name, name_len, true, false, false);
+ }
+ 
+ static int ath12k_core_create_fallback_board_name(struct ath12k_base *ab, char *name,
+ 						  size_t name_len)
+ {
+-	return __ath12k_core_create_board_name(ab, name, name_len, false, false);
++	return __ath12k_core_create_board_name(ab, name, name_len, false, false, true);
+ }
+ 
+ static int ath12k_core_create_bus_type_board_name(struct ath12k_base *ab, char *name,
+ 						  size_t name_len)
+ {
+-	return __ath12k_core_create_board_name(ab, name, name_len, false, true);
++	return __ath12k_core_create_board_name(ab, name, name_len, false, true, true);
+ }
+ 
+ const struct firmware *ath12k_core_firmware_request(struct ath12k_base *ab,
diff --git a/package/kernel/mac80211/patches/ath12k/003-wifi-ath12k-fix-handling-of-6-GHz-rules.patch b/package/kernel/mac80211/patches/ath12k/003-wifi-ath12k-fix-handling-of-6-GHz-rules.patch
new file mode 100644
index 0000000000..8df49d38d3
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/003-wifi-ath12k-fix-handling-of-6-GHz-rules.patch
@@ -0,0 +1,140 @@
+From 64a1ba4072b34af1b76bf15fca5c2075b8cc4d64 Mon Sep 17 00:00:00 2001
+From: Aditya Kumar Singh <aditya.kumar.singh@oss.qualcomm.com>
+Date: Thu, 23 Jan 2025 21:51:38 +0530
+Subject: [PATCH] wifi: ath12k: fix handling of 6 GHz rules
+
+In the US country code, to avoid including 6 GHz rules in the 5 GHz rules
+list, the number of 5 GHz rules is set to a default constant value of 4
+(REG_US_5G_NUM_REG_RULES). However, if there are more than 4 valid 5 GHz
+rules, the current logic will bypass the legitimate 6 GHz rules.
+
+For example, if there are 5 valid 5 GHz rules and 1 valid 6 GHz rule, the
+current logic will only consider 4 of the 5 GHz rules, treating the last
+valid rule as a 6 GHz rule. Consequently, the actual 6 GHz rule is never
+processed, leading to the eventual disabling of 6 GHz channels.
+
+To fix this issue, instead of hardcoding the value to 4, use a helper
+function to determine the number of 6 GHz rules present in the 5 GHz rules
+list and ignore only those rules.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1
+
+Cc: stable@vger.kernel.org
+Fixes: d889913205cf ("wifi: ath12k: driver for Qualcomm Wi-Fi 7 devices")
+Signed-off-by: Aditya Kumar Singh <aditya.kumar.singh@oss.qualcomm.com>
+Link: https://patch.msgid.link/20250123-fix_6ghz_rules_handling-v1-1-d734bfa58ff4@oss.qualcomm.com
+Signed-off-by: Jeff Johnson <jeff.johnson@oss.qualcomm.com>
+---
+ drivers/net/wireless/ath/ath12k/wmi.c | 61 ++++++++++++++++++++++++++---------
+ drivers/net/wireless/ath/ath12k/wmi.h |  1 -
+ 2 files changed, 45 insertions(+), 17 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/wmi.c
++++ b/drivers/net/wireless/ath/ath12k/wmi.c
+@@ -4790,6 +4790,22 @@ static struct ath12k_reg_rule
+ 	return reg_rule_ptr;
+ }
+ 
++static u8 ath12k_wmi_ignore_num_extra_rules(struct ath12k_wmi_reg_rule_ext_params *rule,
++					    u32 num_reg_rules)
++{
++	u8 num_invalid_5ghz_rules = 0;
++	u32 count, start_freq;
++
++	for (count = 0; count < num_reg_rules; count++) {
++		start_freq = le32_get_bits(rule[count].freq_info, REG_RULE_START_FREQ);
++
++		if (start_freq >= ATH12K_MIN_6G_FREQ)
++			num_invalid_5ghz_rules++;
++	}
++
++	return num_invalid_5ghz_rules;
++}
++
+ static int ath12k_pull_reg_chan_list_ext_update_ev(struct ath12k_base *ab,
+ 						   struct sk_buff *skb,
+ 						   struct ath12k_reg_info *reg_info)
+@@ -4800,6 +4816,7 @@ static int ath12k_pull_reg_chan_list_ext
+ 	u32 num_2g_reg_rules, num_5g_reg_rules;
+ 	u32 num_6g_reg_rules_ap[WMI_REG_CURRENT_MAX_AP_TYPE];
+ 	u32 num_6g_reg_rules_cl[WMI_REG_CURRENT_MAX_AP_TYPE][WMI_REG_MAX_CLIENT_TYPE];
++	u8 num_invalid_5ghz_ext_rules;
+ 	u32 total_reg_rules = 0;
+ 	int ret, i, j;
+ 
+@@ -4893,20 +4910,6 @@ static int ath12k_pull_reg_chan_list_ext
+ 
+ 	memcpy(reg_info->alpha2, &ev->alpha2, REG_ALPHA2_LEN);
+ 
+-	/* FIXME: Currently FW includes 6G reg rule also in 5G rule
+-	 * list for country US.
+-	 * Having same 6G reg rule in 5G and 6G rules list causes
+-	 * intersect check to be true, and same rules will be shown
+-	 * multiple times in iw cmd. So added hack below to avoid
+-	 * parsing 6G rule from 5G reg rule list, and this can be
+-	 * removed later, after FW updates to remove 6G reg rule
+-	 * from 5G rules list.
+-	 */
+-	if (memcmp(reg_info->alpha2, "US", 2) == 0) {
+-		reg_info->num_5g_reg_rules = REG_US_5G_NUM_REG_RULES;
+-		num_5g_reg_rules = reg_info->num_5g_reg_rules;
+-	}
+-
+ 	reg_info->dfs_region = le32_to_cpu(ev->dfs_region);
+ 	reg_info->phybitmap = le32_to_cpu(ev->phybitmap);
+ 	reg_info->num_phy = le32_to_cpu(ev->num_phy);
+@@ -5009,8 +5012,29 @@ static int ath12k_pull_reg_chan_list_ext
+ 		}
+ 	}
+ 
++	ext_wmi_reg_rule += num_2g_reg_rules;
++
++	/* Firmware might include 6 GHz reg rule in 5 GHz rule list
++	 * for few countries along with separate 6 GHz rule.
++	 * Having same 6 GHz reg rule in 5 GHz and 6 GHz rules list
++	 * causes intersect check to be true, and same rules will be
++	 * shown multiple times in iw cmd.
++	 * Hence, avoid parsing 6 GHz rule from 5 GHz reg rule list
++	 */
++	num_invalid_5ghz_ext_rules = ath12k_wmi_ignore_num_extra_rules(ext_wmi_reg_rule,
++								       num_5g_reg_rules);
++
++	if (num_invalid_5ghz_ext_rules) {
++		ath12k_dbg(ab, ATH12K_DBG_WMI,
++			   "CC: %s 5 GHz reg rules number %d from fw, %d number of invalid 5 GHz rules",
++			   reg_info->alpha2, reg_info->num_5g_reg_rules,
++			   num_invalid_5ghz_ext_rules);
++
++		num_5g_reg_rules = num_5g_reg_rules - num_invalid_5ghz_ext_rules;
++		reg_info->num_5g_reg_rules = num_5g_reg_rules;
++	}
++
+ 	if (num_5g_reg_rules) {
+-		ext_wmi_reg_rule += num_2g_reg_rules;
+ 		reg_info->reg_rules_5g_ptr =
+ 			create_ext_reg_rules_from_wmi(num_5g_reg_rules,
+ 						      ext_wmi_reg_rule);
+@@ -5022,7 +5046,12 @@ static int ath12k_pull_reg_chan_list_ext
+ 		}
+ 	}
+ 
+-	ext_wmi_reg_rule += num_5g_reg_rules;
++	/* We have adjusted the number of 5 GHz reg rules above. But still those
++	 * many rules needs to be adjusted in ext_wmi_reg_rule.
++	 *
++	 * NOTE: num_invalid_5ghz_ext_rules will be 0 for rest other cases.
++	 */
++	ext_wmi_reg_rule += (num_5g_reg_rules + num_invalid_5ghz_ext_rules);
+ 
+ 	for (i = 0; i < WMI_REG_CURRENT_MAX_AP_TYPE; i++) {
+ 		reg_info->reg_rules_6g_ap_ptr[i] =
+--- a/drivers/net/wireless/ath/ath12k/wmi.h
++++ b/drivers/net/wireless/ath/ath12k/wmi.h
+@@ -3965,7 +3965,6 @@ struct ath12k_wmi_eht_rate_set_params {
+ #define MAX_REG_RULES 10
+ #define REG_ALPHA2_LEN 2
+ #define MAX_6G_REG_RULES 5
+-#define REG_US_5G_NUM_REG_RULES 4
+ 
+ struct wmi_set_current_country_arg {
+ 	u8 alpha2[REG_ALPHA2_LEN];
diff --git a/package/kernel/mac80211/patches/ath12k/102-wifi-ath12k-limit-WMI_SCAN_CHAN_LIST_CMDID-arg.patch b/package/kernel/mac80211/patches/ath12k/102-wifi-ath12k-limit-WMI_SCAN_CHAN_LIST_CMDID-arg.patch
new file mode 100644
index 0000000000..5b1628023f
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/102-wifi-ath12k-limit-WMI_SCAN_CHAN_LIST_CMDID-arg.patch
@@ -0,0 +1,153 @@
+From patchwork Mon Mar 10 13:28:18 2025
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Mantas <mantas@8devices.com>
+X-Patchwork-Id: 14010032
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mail-lf1-f41.google.com (mail-lf1-f41.google.com
+ [209.85.167.41])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 2ADD522A4DA
+	for <linux-wireless@vger.kernel.org>; Mon, 10 Mar 2025 13:28:47 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=209.85.167.41
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1741613330; cv=none;
+ b=Vx8zckt7S92zrauuzzoNjX/1eXhlbq+4R3uNXCWPCBFXXHBuAHrmXrDOQILh1g+IfyWOgpyXyibTTkLg6IWREXcA/OjV+V9ehNaQaHJAt4D14uxuNW6uIDA56myF+bhdmiZnfGZfK3puVBjeCAMbZwGhc81dTR3RaEhKYP93Wcg=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1741613330; c=relaxed/simple;
+	bh=yRMCaDQnvsF6vQ/w9rLRB/etZre1sSzpWUDTNGX0zAk=;
+	h=From:Date:Subject:MIME-Version:Content-Type:Message-Id:To:Cc;
+ b=rFopB9f+nOXbmGbGXoo4SeBAV82xQ6nydiMDCiYAw7sELURejS0lK9xQZolnRGeyNtHnQgix39lrcilr6cdvGMhaziXzS6RYlY2WyoHTMxHwYGUIa9McnJ1AkCczdVv6SgeNUlVVEgAZBqH0Q2pmd5b91h/PMc/aPdQm9SQY8IU=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=quarantine dis=none) header.from=8devices.com;
+ spf=pass smtp.mailfrom=8devices.com;
+ dkim=pass (2048-bit key) header.d=8devices.com header.i=@8devices.com
+ header.b=LitRbtOU; arc=none smtp.client-ip=209.85.167.41
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=quarantine dis=none) header.from=8devices.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=8devices.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=8devices.com header.i=@8devices.com
+ header.b="LitRbtOU"
+Received: by mail-lf1-f41.google.com with SMTP id
+ 2adb3069b0e04-5499c5d9691so1866539e87.2
+        for <linux-wireless@vger.kernel.org>;
+ Mon, 10 Mar 2025 06:28:47 -0700 (PDT)
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
+        d=8devices.com; s=8devices; t=1741613326; x=1742218126;
+ darn=vger.kernel.org;
+        h=cc:to:message-id:content-transfer-encoding:mime-version:subject
+         :date:from:from:to:cc:subject:date:message-id:reply-to;
+        bh=6+w3029kfHch5SeD/z0zur2K64cd98za9hhmN/ji0MY=;
+        b=LitRbtOUxDhUPycKFo/pzuJu9Y11QmpYSvOmkgM9TcNEOsBvLk8z0EJ7+xy24ijRGJ
+         Xz16V9Z1kJGkXBK90klI6s3RjVBQf+dxf37t2kdQWdrgOE2VhXjnnV5zP7odCkMmOViw
+         2UmKSvagsxc6KojE2OYyd+vR3hmL+4fCtegorXMaRrf0Brje8XJmViAUgbc+IAtfL0Ao
+         pnig300fAb4WbnmIJIRiOUKoTESjbJRkUehGJkhe1ztiPE1F86AVMXw5IrDBR/WtMin1
+         9nYYDqfSGvI7fOvfStfZ9hS0ShIhBNd5naccyQ7c0xSTvXJ51vUvNvdZuufm9OKsbQ99
+         nh4g==
+X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
+        d=1e100.net; s=20230601; t=1741613326; x=1742218126;
+        h=cc:to:message-id:content-transfer-encoding:mime-version:subject
+         :date:from:x-gm-message-state:from:to:cc:subject:date:message-id
+         :reply-to;
+        bh=6+w3029kfHch5SeD/z0zur2K64cd98za9hhmN/ji0MY=;
+        b=Gx+AX3aIV66kzjGLGOToc2CuQrnfaWn43yZW2rgRpKJv03162undTbo+SdaI8s+8mY
+         aKrYsNOOqI4h6pHCZsVkBzqVh5ZOs+xJbJaHEETGzyBYA2sy0bdDwDUr0rIzJUD8ZYiw
+         736zfMRE2rxfOLoVIcfBLXMUcR2d63n/4wxgr1s5HVV3o8uEZ5gxNDnz5p/QabiWbT3m
+         AMSVVaOBUTRnd9GcZhzYfKboT7SNrTJz0emqSWPKCWfm8dYIzH3TuIGULfRu5UA1/Y2H
+         Q6ZbLmcYu5+VDKCtQl4nSmun3WUNAyPoeg5PCB1YcuCpqKcjU8l5Kkn+JxNjYAG432us
+         Z5xQ==
+X-Forwarded-Encrypted: i=1;
+ AJvYcCVigvWgctGNxtYGpBtNhTPBpQPHa7l14ZVktj/Oe1W8p1xwSIjIViAk2X3sDC23bbrmI41TVZbgJZDGCMFJ6g==@vger.kernel.org
+X-Gm-Message-State: AOJu0YxJFjAixTwr8dSwTYmdvbVzm/jbyVk+gQV6pF/9Vep5xeVdJMWa
+	TE+4MHJDPdO8dA16Yn/y5c8pLBEYKqRlo8uDHNKV6e5ldbv18Xv6bR163j+rVCQ=
+X-Gm-Gg: ASbGncsUwV1fquQPNOfmTge/yCSzRhyC7+A8STTBe3n+C2XDK1UV8IswQL5UEXlb268
+	mumVPzu1Ex8+Nh+quKWT+CIR3WR0NRXm1oiG0N+Cu2Mm4cm4mipqrV9Yxd6x5OMsG32XKd6r0iQ
+	gr7joJETyo6k1TGc6i0LyoIabLOCc7Nkeu7BD+URUnBvoeQyXBdJpX0bbdvANKW5DrUeX1GkUA7
+	0o4dZYtRola31Z1W9xZMdSefhmI4zZE4uy/RyR/FkQq2Zqk9FGct8DOKoHpOPa0DHVMy0lQAiNI
+	KNg6OYtuJY+/6TpDoZzNpooiLi29WL6hqlpkmlZeluuCBG6HlSbZTQ==
+X-Google-Smtp-Source: 
+ AGHT+IGIixTut4yqDWp69RPz6EjMMq4lD94Ez1yhsRnow6NgvTk6WmKPLFavYgOJC+xGczTQmaocLw==
+X-Received: by 2002:a05:6512:1112:b0:549:5850:f275 with SMTP id
+ 2adb3069b0e04-54990ec8e60mr4354451e87.50.1741613326121;
+        Mon, 10 Mar 2025 06:28:46 -0700 (PDT)
+Received: from [127.0.1.1] ([78.62.132.154])
+        by smtp.gmail.com with ESMTPSA id
+ 2adb3069b0e04-5498b1bcaecsm1460408e87.200.2025.03.10.06.28.45
+        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
+        Mon, 10 Mar 2025 06:28:45 -0700 (PDT)
+From: Mantas Pucka <mantas@8devices.com>
+Date: Mon, 10 Mar 2025 15:28:18 +0200
+Subject: [PATCH ath-next] wifi: ath12k: limit WMI_SCAN_CHAN_LIST_CMDID
+ argument size
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+Message-Id: <20250310-limit-wmi-chanlist-v1-1-8f0fb45459a7@8devices.com>
+X-B4-Tracking: v=1; b=H4sIAPHozmcC/x2MSwqEMBAFryK9tiGJ+MGriIuMtvpAM0MSHEG8u
+ 9FNQVG8d1IQDwnUZid52RHwdUl0ntGwWDcLY0xORplSFVrxig2R/xv46StCZF0Pn2Y0ibaiNPx
+ 5mXC8px3ZuLCTI1J/XTfUqQSebgAAAA==
+X-Change-ID: 20250310-limit-wmi-chanlist-17cb8d27cba6
+To: ath12k@lists.infradead.org
+Cc: Johannes Berg <johannes@sipsolutions.net>,
+ Jeff Johnson <jjohnson@kernel.org>, linux-wireless@vger.kernel.org,
+ linux-kernel@vger.kernel.org, Mantas Pucka <mantas@8devices.com>
+X-Mailer: b4 0.14.2
+
+When using BDF with both 5GHz and 6GHz bands enabled on QCN9274, interface
+fails to start. It happens because FW fails to process
+WMI_SCAN_CHAN_LIST_CMDID with argument size >2048, resulting in a command
+timeout. The current code allows splitting channel list across multiple WMI
+commands but uses WMI max_msg_len (4096) as chunk size, which is still too
+large.
+
+Fix this by limiting the number of channels sent at once, using the value
+specified in WMI interface description [1].
+
+[1] https://git.codelinaro.org/clo/qsdk/platform/vendor/qcom-opensource/wlan/fw-api/-/blob/NHSS.QSDK.13.0.0.6/fw/wmi_unified.h#L6459
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.4.1-00199-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Mantas Pucka <mantas@8devices.com>
+---
+ drivers/net/wireless/ath/ath12k/wmi.c | 3 +++
+ drivers/net/wireless/ath/ath12k/wmi.h | 2 ++
+ 2 files changed, 5 insertions(+)
+
+
+---
+base-commit: 42aa76e608ca845c98e79f9e23af0bdb07b2eb1d
+change-id: 20250310-limit-wmi-chanlist-17cb8d27cba6
+
+Best regards,
+
+--- a/drivers/net/wireless/ath/ath12k/wmi.c
++++ b/drivers/net/wireless/ath/ath12k/wmi.c
+@@ -2558,6 +2558,9 @@ int ath12k_wmi_send_scan_chan_list_cmd(s
+ 		max_chan_limit = (wmi->wmi_ab->max_msg_len[ar->pdev_idx] - len) /
+ 			sizeof(*chan_info);
+ 
++		if (max_chan_limit > WMI_MAX_NUM_CHAN_PER_WMI_CMD)
++			max_chan_limit = WMI_MAX_NUM_CHAN_PER_WMI_CMD;
++
+ 		num_send_chans = min(arg->nallchans, max_chan_limit);
+ 
+ 		arg->nallchans -= num_send_chans;
+--- a/drivers/net/wireless/ath/ath12k/wmi.h
++++ b/drivers/net/wireless/ath/ath12k/wmi.h
+@@ -3743,6 +3743,8 @@ struct wmi_stop_scan_cmd {
+ 	__le32 pdev_id;
+ } __packed;
+ 
++#define WMI_MAX_NUM_CHAN_PER_WMI_CMD	58
++
+ struct ath12k_wmi_scan_chan_list_arg {
+ 	u32 pdev_id;
+ 	u16 nallchans;
diff --git a/package/kernel/mac80211/patches/ath12k/103-wifi-ath12k-fix-5GHz-operation-on-wideband-QCN.patch b/package/kernel/mac80211/patches/ath12k/103-wifi-ath12k-fix-5GHz-operation-on-wideband-QCN.patch
new file mode 100644
index 0000000000..3b8b6226d1
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/103-wifi-ath12k-fix-5GHz-operation-on-wideband-QCN.patch
@@ -0,0 +1,137 @@
+From patchwork Thu Mar 13 09:00:56 2025
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Mantas <mantas@8devices.com>
+X-Patchwork-Id: 14014575
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mail-lf1-f49.google.com (mail-lf1-f49.google.com
+ [209.85.167.49])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id F210C2641F0
+	for <linux-wireless@vger.kernel.org>; Thu, 13 Mar 2025 09:01:28 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=209.85.167.49
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1741856491; cv=none;
+ b=CeFjBZstZXxg4oQQPPON0u0Mw9kvUaCubWSfpcWvN2italvlwccDBr+izqIzCXwxYaoAedVR6iHEQv+LBtIHOsMWHOCI9E6jYAPqjbEUEU0RMdvujKLVFvFXYR4UaRDAMzDGMlFF1qc0pY0sYR4FYfFBBQOarHn2sjZ/csIyj4k=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1741856491; c=relaxed/simple;
+	bh=oLhlWw1tOovRHEGC4gsbi6BHKYXLNDYOrtVP3tTS5nE=;
+	h=From:Date:Subject:MIME-Version:Content-Type:Message-Id:To:Cc;
+ b=baAfN8drFOEwQR9LVuWoVsd3jkMbQECK7Zuc68EzbbJwM4Zb0tbziTk1vvqED+f9JPOMbjRyjvV1hvy3svqZr7OuTZJdSM41D+DsbHvw0jEhaRlKwzpLWuOn9lu56ahcAsvx4A4JRawEK90smoYpejhxkdlSrxqRBh1ey3RwmQU=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=quarantine dis=none) header.from=8devices.com;
+ spf=pass smtp.mailfrom=8devices.com;
+ dkim=pass (2048-bit key) header.d=8devices.com header.i=@8devices.com
+ header.b=FdBxu3P+; arc=none smtp.client-ip=209.85.167.49
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=quarantine dis=none) header.from=8devices.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=8devices.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=8devices.com header.i=@8devices.com
+ header.b="FdBxu3P+"
+Received: by mail-lf1-f49.google.com with SMTP id
+ 2adb3069b0e04-54943bb8006so648002e87.0
+        for <linux-wireless@vger.kernel.org>;
+ Thu, 13 Mar 2025 02:01:28 -0700 (PDT)
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
+        d=8devices.com; s=8devices; t=1741856487; x=1742461287;
+ darn=vger.kernel.org;
+        h=cc:to:message-id:content-transfer-encoding:mime-version:subject
+         :date:from:from:to:cc:subject:date:message-id:reply-to;
+        bh=uj7GGUjO2Cb2hoHrzMda/fIIQwFl12ddzGuw5jrHW8M=;
+        b=FdBxu3P+gf3qNd4jxSOCYUJ1meLFYAm0ou6lnEyomeeXDBFwITM6FM0cgBdXgmkLWZ
+         ZKowNImwE9FKqNGxpg2tZ4obR9aM7HzzkxV3TE+1aIiocbr/5xyXQU+/AUvaM3vui/8d
+         SFiwhX9FwFKdrYi1Og4XFD2aBhA5Fzp0U27grJYGTLchEfkr9Om43y3vZ7w2ENEBU0SO
+         7NFmSwx7BmflIybP2sGCUzjacGQzzec0zz256EY7GpZH9r19jgWiCe1YGWdlxDaRhWze
+         xV4okbZKydpYlUU/qGsgn23cRQuFCvMobvfkmTwsGYwlN4bAzq/cHw83YEFrUzYOngZK
+         z7bg==
+X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
+        d=1e100.net; s=20230601; t=1741856487; x=1742461287;
+        h=cc:to:message-id:content-transfer-encoding:mime-version:subject
+         :date:from:x-gm-message-state:from:to:cc:subject:date:message-id
+         :reply-to;
+        bh=uj7GGUjO2Cb2hoHrzMda/fIIQwFl12ddzGuw5jrHW8M=;
+        b=PhLIANoGtdl34d9fFH7uxPyg1K5yPGRwimsWPVhHon98V9QP64+qUbifocbfojxz8u
+         NEVzhOx0kfmsmkBxUzuRCu6xuTAF8LmjBpAJJxo3/4nqY67np8iZt/MITzx6egbMOUAs
+         txqj0rzXwr55N/9yAD/QuD6bBcd8PcNMPp0CjFAt39AyK6De3BEIcA7b/eLoY3lifaxJ
+         9U5ZZ/dHXwSIr9xuE1EB6pT5FbHcI8iWJTDJ8NdBcmWC8qtGAAMzlzWqHU0nOAJEjwEc
+         T+oaJr8fTAgq4B5OvS1cNClscZHvoM3zlIoczwPPoBZCtUi2gThz9R4BrBxepdoZl1qq
+         NZQA==
+X-Forwarded-Encrypted: i=1;
+ AJvYcCUSbJyRkEPLa3fw7FZX3Ci6+/o8dqI0hd6pkVT20pi6Ufgze7nBQXa+qdK3OM5Ng2TFBrym8JoyBo//MwDHng==@vger.kernel.org
+X-Gm-Message-State: AOJu0Ywjzq2sFNyTMNPyxDt+721RyXdLbDPrF5PY3LnwpKaTfduyXkMF
+	K/7N3Cpb/71aQsMXwmIbXAOGeLVWLBQHdYnQLZlsCTjVNArIjgiX7tNB0Mq56+qYtR9PdMrBAt8
+	m
+X-Gm-Gg: ASbGncvDd0SdjhjPfzaKTXW4e0hclZuKu4pZ4d0XD5/Q6dnv09ZObgGjJbIRrAhYizp
+	zWc8CwidDk8UYPX/OhiAyDhS4XRKRy2QG03sZh17aHDhishhmCE+mcqe+YUM+F4ns/05sAR2MeP
+	wu/Rz6NS6UD4ihGNReTORGB3X4n9I5dgdNheFyqbrRX+Js4zXuvn1jgoEWawfovOu/4HAlnv+7p
+	1ufgXBXJGVj6+OGzyNOyYloTB/Csok3zU9yBfrU+G19mpGaF86t/6yxmUIXCO+cWfbu2GIhVZp3
+	RmSiDo/spnsvtYVGCPc6v9jALz83YcknTLkX8u+08AOkJKK7Mh8rKlCvbfZcB355
+X-Google-Smtp-Source: 
+ AGHT+IE2NulrNIo+M5vahinpDWyI9BdSgzdREdo+l0AN7HhcxOd01ZBOpT3HYFht1EVpKj5T7Edrrw==
+X-Received: by 2002:a05:6512:ba6:b0:549:8f21:bc0e with SMTP id
+ 2adb3069b0e04-54990eb1987mr9398593e87.32.1741856486697;
+        Thu, 13 Mar 2025 02:01:26 -0700 (PDT)
+Received: from [127.0.1.1] ([78.62.132.154])
+        by smtp.gmail.com with ESMTPSA id
+ 2adb3069b0e04-549ba88591csm142134e87.187.2025.03.13.02.01.25
+        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
+        Thu, 13 Mar 2025 02:01:25 -0700 (PDT)
+From: Mantas Pucka <mantas@8devices.com>
+Date: Thu, 13 Mar 2025 11:00:56 +0200
+Subject: [PATCH] wifi: ath12k: fix 5GHz operation on wideband QCN9274
+ radios
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+Message-Id: <20250313-ath12-wideband-caps-v1-1-23ac4247cd8a@8devices.com>
+X-B4-Tracking: v=1; b=H4sIAMee0mcC/x3MQQqAIBBA0avErBvIsUi6SrSwHGs2FhoVhHdPW
+ r7F/y8kjsIJhuqFyJck2UOBqitYNhtWRnHFQA11jVYa7bkpwlsczzY4XOyRkNqZjOqNcZ6hlEd
+ kL89/HaecP+zWjGtlAAAA
+X-Change-ID: 20250313-ath12-wideband-caps-24b281788dfe
+To: ath12k@lists.infradead.org
+Cc: Johannes Berg <johannes@sipsolutions.net>,
+ Jeff Johnson <jjohnson@kernel.org>, linux-wireless@vger.kernel.org,
+ linux-kernel@vger.kernel.org, Mantas Pucka <mantas@8devices.com>
+X-Mailer: b4 0.14.2
+
+Currently ath12k_mac_setup_ht_vht_cap() incorrectly assumes that QCN9274
+radios with 6GHz band can't support 5GHz as well. This prevents the
+addition of HT and VHT capabilities for the 5GHz band. Since QCN9274 is
+capable of operating in multiple bands, remove the 6GHz support check and
+exception for single_pdev_only (i.e. WCN7850).
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.4.1-00199-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Mantas Pucka <mantas@8devices.com>
+---
+ drivers/net/wireless/ath/ath12k/mac.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+
+---
+base-commit: 42aa76e608ca845c98e79f9e23af0bdb07b2eb1d
+change-id: 20250313-ath12-wideband-caps-24b281788dfe
+
+Best regards,
+
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -5186,9 +5186,7 @@ static void ath12k_mac_setup_ht_vht_cap(
+ 						    rate_cap_rx_chainmask);
+ 	}
+ 
+-	if (cap->supported_bands & WMI_HOST_WLAN_5G_CAP &&
+-	    (ar->ab->hw_params->single_pdev_only ||
+-	     !ar->supports_6ghz)) {
++	if (cap->supported_bands & WMI_HOST_WLAN_5G_CAP) {
+ 		band = &ar->mac.sbands[NL80211_BAND_5GHZ];
+ 		ht_cap = cap->band[NL80211_BAND_5GHZ].ht_cap_info;
+ 		if (ht_cap_info)
diff --git a/package/kernel/mac80211/patches/ath12k/104-1-wifi-ath12k-push-HE-MU-MIMO-params-to-hardware.patch b/package/kernel/mac80211/patches/ath12k/104-1-wifi-ath12k-push-HE-MU-MIMO-params-to-hardware.patch
new file mode 100644
index 0000000000..dcf633e101
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/104-1-wifi-ath12k-push-HE-MU-MIMO-params-to-hardware.patch
@@ -0,0 +1,469 @@
+From patchwork Wed Sep 18 21:20:48 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+X-Patchwork-Id: 13807212
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mx0a-0031df01.pphosted.com (mx0a-0031df01.pphosted.com
+ [205.220.168.131])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id A06681CA6B9
+	for <linux-wireless@vger.kernel.org>; Wed, 18 Sep 2024 21:21:13 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=205.220.168.131
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1726694475; cv=none;
+ b=HjUnHV2ZbMRZne/OD71kC1p0zBs+1+LVanM+3YbUfCnjvvtSry2r0Dj0HBjHnId1ltZw0ebTJaEZDcXBybkc2yiiGRlcH5s4feXisp9WApElGptz2Qn1SEtO3VDLKyE5m56eJftK/dpin6HPZGOk3hMBHkxoo966Jp4vlC9e2rY=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1726694475; c=relaxed/simple;
+	bh=lJX5iM2Ahf/ROaeR2Kk4suhcbwA47aOSPqyQsesg4A0=;
+	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
+	 MIME-Version:Content-Type;
+ b=RYEWdi9+UZKYtzHKfAF5xdIOkpdgQjBK8hE1SX/f0rJDxozjZe1jDY28C+kzN4uhSwcBSwr7pZjMLL8LELNITE6fIk/zDY5UAO/jdeUPBnTrmrckzZOwaCFIQ1nt6ssDZDfpJADBjCIuMXB7HNChH3qSMlmYTV9QTDxpBK0fQxM=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com;
+ spf=pass smtp.mailfrom=quicinc.com;
+ dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b=EtpV59A6; arc=none smtp.client-ip=205.220.168.131
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b="EtpV59A6"
+Received: from pps.filterd (m0279862.ppops.net [127.0.0.1])
+	by mx0a-0031df01.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id
+ 48IL3WbX003099;
+	Wed, 18 Sep 2024 21:21:07 GMT
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=quicinc.com; h=
+	cc:content-transfer-encoding:content-type:date:from:in-reply-to
+	:message-id:mime-version:references:subject:to; s=qcppdkim1; bh=
+	3ukRiLVgAcc9GoJxAaFrgsHYImZ/9ZPgSlMf75Ew/1Y=; b=EtpV59A6K8yD5o5B
+	8JSYPL7TI2tnIQciUmyLNJig3DWGn3AZbFqPjgTYUgoQLHjsNWd+WRAKx13tQhSW
+	peq0OW9986uI1TFVpaw0pwVXoBiStEI5MH/7ThiA5nIAI4hYBI6+iiwL7qWpboSL
+	UrG9sWI35wsgcjedTtrzR2QfpeTAvlnReoac/49o5GAysu1oGDN79VAAP7tDZbO2
+	trx/XdQmW/8iqtRR3Idhjcod6B6ovXKkmAZUHzhp4zRupTUsKOU84X3aTYZQLN/B
+	46HuFZSlOJEB/63Co7I2K8YfQT3FikP2mkrIsDwH78Y2OekhXJWFe7dU4SsX6nh6
+	sIXVxA==
+Received: from nalasppmta04.qualcomm.com (Global_NAT1.qualcomm.com
+ [129.46.96.20])
+	by mx0a-0031df01.pphosted.com (PPS) with ESMTPS id 41n4gd387e-1
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:07 +0000 (GMT)
+Received: from nalasex01a.na.qualcomm.com (nalasex01a.na.qualcomm.com
+ [10.47.209.196])
+	by NALASPPMTA04.qualcomm.com (8.18.1.2/8.18.1.2) with ESMTPS id
+ 48ILL6rr020545
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:06 GMT
+Received: from ath12k-linux1.qualcomm.com (10.80.80.8) by
+ nalasex01a.na.qualcomm.com (10.47.209.196) with Microsoft SMTP Server
+ (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
+ 15.2.1544.9; Wed, 18 Sep 2024 14:21:06 -0700
+From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+To: <ath12k@lists.infradead.org>
+CC: <linux-wireless@vger.kernel.org>,
+        Pradeep Kumar Chitrapu
+	<quic_pradeepc@quicinc.com>,
+        Muna Sinada <quic_msinada@quicinc.com>,
+        "Jeff
+ Johnson" <quic_jjohnson@quicinc.com>
+Subject: [PATCH V8 1/9] wifi: ath12k: push HE MU-MIMO params to hardware
+Date: Wed, 18 Sep 2024 14:20:48 -0700
+Message-ID: <20240918212056.4137076-2-quic_pradeepc@quicinc.com>
+X-Mailer: git-send-email 2.34.1
+In-Reply-To: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+References: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+X-ClientProxiedBy: nasanex01a.na.qualcomm.com (10.52.223.231) To
+ nalasex01a.na.qualcomm.com (10.47.209.196)
+X-QCInternal: smtphost
+X-Proofpoint-Virus-Version: vendor=nai engine=6200 definitions=5800
+ signatures=585085
+X-Proofpoint-ORIG-GUID: QTgqLsl2p5OGLwWEQsGrsmA8q68U11H8
+X-Proofpoint-GUID: QTgqLsl2p5OGLwWEQsGrsmA8q68U11H8
+X-Proofpoint-Virus-Version: vendor=baseguard
+ engine=ICAP:2.0.293,Aquarius:18.0.1039,Hydra:6.0.680,FMLib:17.12.60.29
+ definitions=2024-09-06_09,2024-09-06_01,2024-09-02_01
+X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
+ malwarescore=0 suspectscore=0
+ bulkscore=0 clxscore=1015 spamscore=0 adultscore=0 lowpriorityscore=0
+ mlxlogscore=999 impostorscore=0 mlxscore=0 priorityscore=1501 phishscore=0
+ classifier=spam adjust=0 reason=mlx scancount=1 engine=8.19.0-2408220000
+ definitions=main-2409180140
+
+Currently, only the HE IE in management frames is updated with
+respect to MU-MIMO configurations, but this change is not
+reflected in the hardware. Add support to propagate MU-MIMO
+configurations to the hardware as well.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1
+
+Co-developed-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
+---
+ drivers/net/wireless/ath/ath12k/mac.c | 215 +++++++++++++++++---------
+ drivers/net/wireless/ath/ath12k/mac.h |  15 ++
+ drivers/net/wireless/ath/ath12k/wmi.h |  28 +---
+ 3 files changed, 156 insertions(+), 102 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -2851,6 +2851,108 @@ static int ath12k_setup_peer_smps(struct
+ 					 ath12k_smps_map[smps]);
+ }
+ 
++static int ath12k_mac_set_he_txbf_conf(struct ath12k_vif *arvif)
++{
++	struct ath12k *ar = arvif->ar;
++	u32 param = WMI_VDEV_PARAM_SET_HEMU_MODE;
++	u32 value = 0;
++	int ret;
++
++	if (!arvif->vif->bss_conf.he_support)
++		return 0;
++
++	if (arvif->vif->bss_conf.he_su_beamformer) {
++		value |= u32_encode_bits(HE_SU_BFER_ENABLE, HE_MODE_SU_TX_BFER);
++		if (arvif->vif->bss_conf.he_mu_beamformer &&
++		    arvif->vdev_type == WMI_VDEV_TYPE_AP)
++			value |= u32_encode_bits(HE_MU_BFER_ENABLE, HE_MODE_MU_TX_BFER);
++	}
++
++	if (arvif->vif->type != NL80211_IFTYPE_MESH_POINT) {
++		value |= u32_encode_bits(HE_DL_MUOFDMA_ENABLE, HE_MODE_DL_OFDMA) |
++			 u32_encode_bits(HE_UL_MUOFDMA_ENABLE, HE_MODE_UL_OFDMA);
++
++		if (arvif->vif->bss_conf.he_full_ul_mumimo)
++			value |= u32_encode_bits(HE_UL_MUMIMO_ENABLE, HE_MODE_UL_MUMIMO);
++
++		if (arvif->vif->bss_conf.he_su_beamformee)
++			value |= u32_encode_bits(HE_SU_BFEE_ENABLE, HE_MODE_SU_TX_BFEE);
++	}
++
++	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param, value);
++	if (ret) {
++		ath12k_warn(ar->ab, "failed to set vdev %d HE MU mode: %d\n",
++			    arvif->vdev_id, ret);
++		return ret;
++	}
++
++	param = WMI_VDEV_PARAM_SET_HE_SOUNDING_MODE;
++	value =	u32_encode_bits(HE_VHT_SOUNDING_MODE_ENABLE, HE_VHT_SOUNDING_MODE) |
++		u32_encode_bits(HE_TRIG_NONTRIG_SOUNDING_MODE_ENABLE,
++				HE_TRIG_NONTRIG_SOUNDING_MODE);
++	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
++					    param, value);
++	if (ret) {
++		ath12k_warn(ar->ab, "failed to set vdev %d sounding mode: %d\n",
++			    arvif->vdev_id, ret);
++		return ret;
++	}
++
++	return 0;
++}
++
++static int ath12k_mac_vif_recalc_sta_he_txbf(struct ath12k *ar,
++					     struct ieee80211_vif *vif,
++					     struct ieee80211_sta_he_cap *he_cap,
++					     int *hemode)
++{
++	struct ieee80211_he_cap_elem he_cap_elem = {};
++	struct ieee80211_sta_he_cap *cap_band;
++	struct cfg80211_chan_def def;
++
++	if (!vif->bss_conf.he_support)
++		return 0;
++
++	if (vif->type != NL80211_IFTYPE_STATION)
++		return -EINVAL;
++
++	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
++		return -EINVAL;
++
++	if (def.chan->band == NL80211_BAND_2GHZ)
++		cap_band = &ar->mac.iftype[NL80211_BAND_2GHZ][vif->type].he_cap;
++	else
++		cap_band = &ar->mac.iftype[NL80211_BAND_5GHZ][vif->type].he_cap;
++
++	memcpy(&he_cap_elem, &cap_band->he_cap_elem, sizeof(he_cap_elem));
++
++	*hemode = 0;
++	if (HECAP_PHY_SUBFME_GET(he_cap_elem.phy_cap_info)) {
++		if (HECAP_PHY_SUBFMR_GET(he_cap->he_cap_elem.phy_cap_info))
++			*hemode |= u32_encode_bits(HE_SU_BFEE_ENABLE, HE_MODE_SU_TX_BFEE);
++		if (HECAP_PHY_MUBFMR_GET(he_cap->he_cap_elem.phy_cap_info))
++			*hemode |= u32_encode_bits(HE_MU_BFEE_ENABLE, HE_MODE_MU_TX_BFEE);
++	}
++
++	if (vif->type != NL80211_IFTYPE_MESH_POINT) {
++		*hemode |= u32_encode_bits(HE_DL_MUOFDMA_ENABLE, HE_MODE_DL_OFDMA) |
++			  u32_encode_bits(HE_UL_MUOFDMA_ENABLE, HE_MODE_UL_OFDMA);
++
++		if (HECAP_PHY_ULMUMIMO_GET(he_cap_elem.phy_cap_info))
++			if (HECAP_PHY_ULMUMIMO_GET(he_cap->he_cap_elem.phy_cap_info))
++				*hemode |= u32_encode_bits(HE_UL_MUMIMO_ENABLE,
++							  HE_MODE_UL_MUMIMO);
++
++		if (u32_get_bits(*hemode, HE_MODE_MU_TX_BFEE))
++			*hemode |= u32_encode_bits(HE_SU_BFEE_ENABLE, HE_MODE_SU_TX_BFEE);
++
++		if (u32_get_bits(*hemode, HE_MODE_MU_TX_BFER))
++			*hemode |= u32_encode_bits(HE_SU_BFER_ENABLE, HE_MODE_SU_TX_BFER);
++	}
++
++	return 0;
++}
++
+ static void ath12k_bss_assoc(struct ath12k *ar,
+ 			     struct ath12k_vif *arvif,
+ 			     struct ieee80211_bss_conf *bss_conf)
+@@ -2858,9 +2960,11 @@ static void ath12k_bss_assoc(struct ath1
+ 	struct ieee80211_vif *vif = arvif->vif;
+ 	struct ath12k_wmi_vdev_up_params params = {};
+ 	struct ath12k_wmi_peer_assoc_arg peer_arg;
++	struct ieee80211_sta_he_cap he_cap;
+ 	struct ieee80211_sta *ap_sta;
+ 	struct ath12k_peer *peer;
+ 	bool is_auth = false;
++	u32 hemode = 0;
+ 	int ret;
+ 
+ 	lockdep_assert_held(&ar->conf_mutex);
+@@ -2880,8 +2984,29 @@ static void ath12k_bss_assoc(struct ath1
+ 
+ 	ath12k_peer_assoc_prepare(ar, vif, ap_sta, &peer_arg, false);
+ 
++	/* he_cap here is updated at assoc success for sta mode only */
++	he_cap = ap_sta->deflink.he_cap;
++
++	/* ap_sta->deflink.he_cap must be protected by rcu_read_lock */
++	ret = ath12k_mac_vif_recalc_sta_he_txbf(ar, vif, &he_cap, &hemode);
++	if (ret) {
++		ath12k_warn(ar->ab, "failed to recalc he txbf for vdev %i on bss %pM: %d\n",
++			    arvif->vdev_id, bss_conf->bssid, ret);
++		rcu_read_unlock();
++		return;
++	}
++
+ 	rcu_read_unlock();
+ 
++	/* keep this before ath12k_wmi_send_peer_assoc_cmd() */
++	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
++					    WMI_VDEV_PARAM_SET_HEMU_MODE, hemode);
++	if (ret) {
++		ath12k_warn(ar->ab, "failed to submit vdev param txbf 0x%x: %d\n",
++			    hemode, ret);
++		return;
++	}
++
+ 	ret = ath12k_wmi_send_peer_assoc_cmd(ar, &peer_arg);
+ 	if (ret) {
+ 		ath12k_warn(ar->ab, "failed to run peer assoc for %pM vdev %i: %d\n",
+@@ -3220,6 +3345,13 @@ static void ath12k_mac_bss_info_changed(
+ 		ether_addr_copy(arvif->bssid, info->bssid);
+ 
+ 	if (changed & BSS_CHANGED_BEACON_ENABLED) {
++		if (info->enable_beacon) {
++			ret = ath12k_mac_set_he_txbf_conf(arvif);
++			if (ret)
++				ath12k_warn(ar->ab,
++					    "failed to set HE TXBF config for vdev: %d\n",
++					    arvif->vdev_id);
++		}
+ 		ath12k_control_beaconing(arvif, info);
+ 
+ 		if (arvif->is_up && vif->bss_conf.he_support &&
+@@ -5352,11 +5484,14 @@ static void ath12k_mac_copy_he_cap(struc
+ 
+ 	he_cap_elem->mac_cap_info[1] &=
+ 		IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_MASK;
+-
++	he_cap_elem->phy_cap_info[0] &=
++		IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G |
++		IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
++		IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
++	he_cap_elem->phy_cap_info[0] &=
++		~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;
+ 	he_cap_elem->phy_cap_info[5] &=
+ 		~IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK;
+-	he_cap_elem->phy_cap_info[5] &=
+-		~IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK;
+ 	he_cap_elem->phy_cap_info[5] |= num_tx_chains - 1;
+ 
+ 	switch (iftype) {
+@@ -6318,71 +6453,6 @@ static int ath12k_mac_setup_vdev_create_
+ 	return 0;
+ }
+ 
+-static u32
+-ath12k_mac_prepare_he_mode(struct ath12k_pdev *pdev, u32 viftype)
+-{
+-	struct ath12k_pdev_cap *pdev_cap = &pdev->cap;
+-	struct ath12k_band_cap *cap_band = NULL;
+-	u32 *hecap_phy_ptr = NULL;
+-	u32 hemode;
+-
+-	if (pdev->cap.supported_bands & WMI_HOST_WLAN_2G_CAP)
+-		cap_band = &pdev_cap->band[NL80211_BAND_2GHZ];
+-	else
+-		cap_band = &pdev_cap->band[NL80211_BAND_5GHZ];
+-
+-	hecap_phy_ptr = &cap_band->he_cap_phy_info[0];
+-
+-	hemode = u32_encode_bits(HE_SU_BFEE_ENABLE, HE_MODE_SU_TX_BFEE) |
+-		 u32_encode_bits(HECAP_PHY_SUBFMR_GET(hecap_phy_ptr),
+-				 HE_MODE_SU_TX_BFER) |
+-		 u32_encode_bits(HECAP_PHY_ULMUMIMO_GET(hecap_phy_ptr),
+-				 HE_MODE_UL_MUMIMO);
+-
+-	/* TODO: WDS and other modes */
+-	if (viftype == NL80211_IFTYPE_AP) {
+-		hemode |= u32_encode_bits(HECAP_PHY_MUBFMR_GET(hecap_phy_ptr),
+-					  HE_MODE_MU_TX_BFER) |
+-			  u32_encode_bits(HE_DL_MUOFDMA_ENABLE, HE_MODE_DL_OFDMA) |
+-			  u32_encode_bits(HE_UL_MUOFDMA_ENABLE, HE_MODE_UL_OFDMA);
+-	} else {
+-		hemode |= u32_encode_bits(HE_MU_BFEE_ENABLE, HE_MODE_MU_TX_BFEE);
+-	}
+-
+-	return hemode;
+-}
+-
+-static int ath12k_set_he_mu_sounding_mode(struct ath12k *ar,
+-					  struct ath12k_vif *arvif)
+-{
+-	u32 param_id, param_value;
+-	struct ath12k_base *ab = ar->ab;
+-	int ret;
+-
+-	param_id = WMI_VDEV_PARAM_SET_HEMU_MODE;
+-	param_value = ath12k_mac_prepare_he_mode(ar->pdev, arvif->vif->type);
+-	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
+-					    param_id, param_value);
+-	if (ret) {
+-		ath12k_warn(ab, "failed to set vdev %d HE MU mode: %d param_value %x\n",
+-			    arvif->vdev_id, ret, param_value);
+-		return ret;
+-	}
+-	param_id = WMI_VDEV_PARAM_SET_HE_SOUNDING_MODE;
+-	param_value =
+-		u32_encode_bits(HE_VHT_SOUNDING_MODE_ENABLE, HE_VHT_SOUNDING_MODE) |
+-		u32_encode_bits(HE_TRIG_NONTRIG_SOUNDING_MODE_ENABLE,
+-				HE_TRIG_NONTRIG_SOUNDING_MODE);
+-	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
+-					    param_id, param_value);
+-	if (ret) {
+-		ath12k_warn(ab, "failed to set vdev %d HE MU mode: %d\n",
+-			    arvif->vdev_id, ret);
+-		return ret;
+-	}
+-	return ret;
+-}
+-
+ static void ath12k_mac_update_vif_offload(struct ath12k_vif *arvif)
+ {
+ 	struct ieee80211_vif *vif = arvif->vif;
+@@ -7340,7 +7410,6 @@ ath12k_mac_vdev_start_restart(struct ath
+ 	struct ath12k_base *ab = ar->ab;
+ 	struct wmi_vdev_start_req_arg arg = {};
+ 	const struct cfg80211_chan_def *chandef = &ctx->def;
+-	int he_support = arvif->vif->bss_conf.he_support;
+ 	int ret;
+ 
+ 	lockdep_assert_held(&ar->conf_mutex);
+@@ -7396,14 +7465,6 @@ ath12k_mac_vdev_start_restart(struct ath
+ 		spin_unlock_bh(&ab->base_lock);
+ 
+ 		/* TODO: Notify if secondary 80Mhz also needs radar detection */
+-		if (he_support) {
+-			ret = ath12k_set_he_mu_sounding_mode(ar, arvif);
+-			if (ret) {
+-				ath12k_warn(ar->ab, "failed to set he mode vdev %i\n",
+-					    arg.vdev_id);
+-				return ret;
+-			}
+-		}
+ 	}
+ 
+ 	arg.passive |= !!(chandef->chan->flags & IEEE80211_CHAN_NO_IR);
+--- a/drivers/net/wireless/ath/ath12k/mac.h
++++ b/drivers/net/wireless/ath/ath12k/mac.h
+@@ -41,6 +41,21 @@ struct ath12k_generic_iter {
+ #define ATH12K_TX_POWER_MAX_VAL	70
+ #define ATH12K_TX_POWER_MIN_VAL	0
+ 
++#define HECAP_PHY_SUBFMR_GET(hecap_phy) \
++	u8_get_bits(hecap_phy[3], IEEE80211_HE_PHY_CAP3_SU_BEAMFORMER)
++
++#define HECAP_PHY_SUBFME_GET(hecap_phy) \
++	u8_get_bits(hecap_phy[4], IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE)
++
++#define HECAP_PHY_MUBFMR_GET(hecap_phy) \
++	u8_get_bits(hecap_phy[4], IEEE80211_HE_PHY_CAP4_MU_BEAMFORMER)
++
++#define HECAP_PHY_ULMUMIMO_GET(hecap_phy) \
++	u8_get_bits(hecap_phy[2], IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO)
++
++#define HECAP_PHY_ULOFDMA_GET(hecap_phy) \
++	u8_get_bits(hecap_phy[2], IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO)
++
+ enum ath12k_supported_bw {
+ 	ATH12K_BW_20    = 0,
+ 	ATH12K_BW_40    = 1,
+--- a/drivers/net/wireless/ath/ath12k/wmi.h
++++ b/drivers/net/wireless/ath/ath12k/wmi.h
+@@ -2995,31 +2995,6 @@ struct ath12k_wmi_rx_reorder_queue_remov
+ #define WMI_VDEV_PARAM_TXBF_SU_TX_BFER BIT(2)
+ #define WMI_VDEV_PARAM_TXBF_MU_TX_BFER BIT(3)
+ 
+-#define HECAP_PHYDWORD_0	0
+-#define HECAP_PHYDWORD_1	1
+-#define HECAP_PHYDWORD_2	2
+-
+-#define HECAP_PHY_SU_BFER		BIT(31)
+-#define HECAP_PHY_SU_BFEE		BIT(0)
+-#define HECAP_PHY_MU_BFER		BIT(1)
+-#define HECAP_PHY_UL_MUMIMO		BIT(22)
+-#define HECAP_PHY_UL_MUOFDMA		BIT(23)
+-
+-#define HECAP_PHY_SUBFMR_GET(hecap_phy) \
+-	u32_get_bits(hecap_phy[HECAP_PHYDWORD_0], HECAP_PHY_SU_BFER)
+-
+-#define HECAP_PHY_SUBFME_GET(hecap_phy) \
+-	u32_get_bits(hecap_phy[HECAP_PHYDWORD_1], HECAP_PHY_SU_BFEE)
+-
+-#define HECAP_PHY_MUBFMR_GET(hecap_phy) \
+-	u32_get_bits(hecap_phy[HECAP_PHYDWORD_1], HECAP_PHY_MU_BFER)
+-
+-#define HECAP_PHY_ULMUMIMO_GET(hecap_phy) \
+-	u32_get_bits(hecap_phy[HECAP_PHYDWORD_0], HECAP_PHY_UL_MUMIMO)
+-
+-#define HECAP_PHY_ULOFDMA_GET(hecap_phy) \
+-	u32_get_bits(hecap_phy[HECAP_PHYDWORD_0], HECAP_PHY_UL_MUOFDMA)
+-
+ #define HE_MODE_SU_TX_BFEE	BIT(0)
+ #define HE_MODE_SU_TX_BFER	BIT(1)
+ #define HE_MODE_MU_TX_BFEE	BIT(2)
+@@ -3031,8 +3006,11 @@ struct ath12k_wmi_rx_reorder_queue_remov
+ #define HE_DL_MUOFDMA_ENABLE	1
+ #define HE_UL_MUOFDMA_ENABLE	1
+ #define HE_DL_MUMIMO_ENABLE	1
++#define HE_UL_MUMIMO_ENABLE	1
+ #define HE_MU_BFEE_ENABLE	1
+ #define HE_SU_BFEE_ENABLE	1
++#define HE_MU_BFER_ENABLE	1
++#define HE_SU_BFER_ENABLE	1
+ 
+ #define HE_VHT_SOUNDING_MODE_ENABLE		1
+ #define HE_SU_MU_SOUNDING_MODE_ENABLE		1
diff --git a/package/kernel/mac80211/patches/ath12k/104-2-wifi-ath12k-push-EHT-MU-MIMO-params-to-hardware.patch b/package/kernel/mac80211/patches/ath12k/104-2-wifi-ath12k-push-EHT-MU-MIMO-params-to-hardware.patch
new file mode 100644
index 0000000000..65ef65fa7f
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/104-2-wifi-ath12k-push-EHT-MU-MIMO-params-to-hardware.patch
@@ -0,0 +1,222 @@
+From patchwork Wed Sep 18 21:20:49 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+X-Patchwork-Id: 13807210
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mx0a-0031df01.pphosted.com (mx0a-0031df01.pphosted.com
+ [205.220.168.131])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id B81C317967F
+	for <linux-wireless@vger.kernel.org>; Wed, 18 Sep 2024 21:21:12 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=205.220.168.131
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1726694474; cv=none;
+ b=SYN3tI9xaTiXuxK7CUAD6gXBOqoyS1qZxAGNOXDt4yS1Q6oU0YiwQonIkVrnux7/DC3bCm2JScN5vIxVzkGOkFztaIHlZMM/TRsp6GzSIbZdasVpxySumoe965kRna+5fYAmf4i3wJupfj9p6509u7j6kXzz1ZxlSStR4wLObcE=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1726694474; c=relaxed/simple;
+	bh=yQPaApb7knqLxhkxSrizMfAanw18TDUbxBPbfnhzlV0=;
+	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
+	 MIME-Version:Content-Type;
+ b=W+Rk8/tiKUvP6A8WYQFxi97//4Yj4m/rYPXAg0YP+6K+GXDcFK2VD+yEzmymA/fsenli+7ZEJ1zH6XgzLe4+1QFctCYGnq1LPoD01a4AIF8VqJGVdgs6e1ZwCKv8AOLkZUb09QkmM8Ur4R1xFhc4oVqhlvm3NMc24NERWmxzGjI=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com;
+ spf=pass smtp.mailfrom=quicinc.com;
+ dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b=XJxqlj7h; arc=none smtp.client-ip=205.220.168.131
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b="XJxqlj7h"
+Received: from pps.filterd (m0279867.ppops.net [127.0.0.1])
+	by mx0a-0031df01.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id
+ 48IHKWuA006417;
+	Wed, 18 Sep 2024 21:21:08 GMT
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=quicinc.com; h=
+	cc:content-transfer-encoding:content-type:date:from:in-reply-to
+	:message-id:mime-version:references:subject:to; s=qcppdkim1; bh=
+	hcoreX5pgczyblwh1gpL6Ax4OV0yrVpAaKX7psGXczI=; b=XJxqlj7hhoW4GYMB
+	+B9r7ajbqV+ZxP+/1uDt5veOBY8aQgsorBoEbZFKm+ccV0u5SQJ/fFSomLg8QYpE
+	iojXUyYsGJMsXSPW+OdC0DQ2JrhDEHWFQa/6c3C0sdBE5IGgTa8YiAmYAx/A1ti1
+	ruMNSyT8H/xEKkR953axz1DOGJZfp9dCtOM5Xw6nrqpeUEYBShgvQ+1LLXqrH8U4
+	qUlYW2vKFKJgZUe97nwRrwOiunhTD4M2ARe6xHqZ7bL+2bW27sRTSI69vGrcEdKM
+	Ied7A8KmlUAN5BBsOj5MeKAaoy0+h4iY/9W3JgDfOu+LwjuAaKzgPNrttmPehdhJ
+	Q8q0JQ==
+Received: from nalasppmta01.qualcomm.com (Global_NAT1.qualcomm.com
+ [129.46.96.20])
+	by mx0a-0031df01.pphosted.com (PPS) with ESMTPS id 41n4kjk65k-1
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:07 +0000 (GMT)
+Received: from nalasex01a.na.qualcomm.com (nalasex01a.na.qualcomm.com
+ [10.47.209.196])
+	by NALASPPMTA01.qualcomm.com (8.18.1.2/8.18.1.2) with ESMTPS id
+ 48ILL7IZ032342
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:07 GMT
+Received: from ath12k-linux1.qualcomm.com (10.80.80.8) by
+ nalasex01a.na.qualcomm.com (10.47.209.196) with Microsoft SMTP Server
+ (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
+ 15.2.1544.9; Wed, 18 Sep 2024 14:21:06 -0700
+From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+To: <ath12k@lists.infradead.org>
+CC: <linux-wireless@vger.kernel.org>,
+        Pradeep Kumar Chitrapu
+	<quic_pradeepc@quicinc.com>,
+        Muna Sinada <quic_msinada@quicinc.com>,
+        "Jeff
+ Johnson" <quic_jjohnson@quicinc.com>
+Subject: [PATCH V8 2/9] wifi: ath12k: push EHT MU-MIMO params to hardware
+Date: Wed, 18 Sep 2024 14:20:49 -0700
+Message-ID: <20240918212056.4137076-3-quic_pradeepc@quicinc.com>
+X-Mailer: git-send-email 2.34.1
+In-Reply-To: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+References: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+X-ClientProxiedBy: nasanex01a.na.qualcomm.com (10.52.223.231) To
+ nalasex01a.na.qualcomm.com (10.47.209.196)
+X-QCInternal: smtphost
+X-Proofpoint-Virus-Version: vendor=nai engine=6200 definitions=5800
+ signatures=585085
+X-Proofpoint-GUID: DiIEaDHD4453WG2b31qitb3_i0JkAM4u
+X-Proofpoint-ORIG-GUID: DiIEaDHD4453WG2b31qitb3_i0JkAM4u
+X-Proofpoint-Virus-Version: vendor=baseguard
+ engine=ICAP:2.0.293,Aquarius:18.0.1039,Hydra:6.0.680,FMLib:17.12.60.29
+ definitions=2024-09-06_09,2024-09-06_01,2024-09-02_01
+X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
+ bulkscore=0 adultscore=0
+ suspectscore=0 mlxscore=0 clxscore=1015 lowpriorityscore=0 malwarescore=0
+ phishscore=0 impostorscore=0 mlxlogscore=999 priorityscore=1501
+ spamscore=0 classifier=spam adjust=0 reason=mlx scancount=1
+ engine=8.19.0-2408220000 definitions=main-2409180140
+
+Currently, only the EHT IE in management frames is updated with
+respect to MU-MIMO configurations, but this change is not
+reflected in the hardware. Add support to propagate MU-MIMO
+configurations to the hardware as well for AP mode. Similar
+support for STA mode will be added in future.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1
+
+Co-developed-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
+---
+ drivers/net/wireless/ath/ath12k/mac.c | 50 +++++++++++++++++++++++++++
+ drivers/net/wireless/ath/ath12k/wmi.h | 21 +++++++++++
+ 2 files changed, 71 insertions(+)
+
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -2953,6 +2953,50 @@ static int ath12k_mac_vif_recalc_sta_he_
+ 	return 0;
+ }
+ 
++static int ath12k_mac_set_eht_txbf_conf(struct ath12k_vif *arvif)
++{
++	u32 param = WMI_VDEV_PARAM_SET_EHT_MU_MODE;
++	struct ath12k *ar = arvif->ar;
++	u32 value = 0;
++	int ret;
++
++	if (!arvif->vif->bss_conf.eht_support)
++		return 0;
++
++	if (arvif->vif->bss_conf.eht_su_beamformer) {
++		value |= u32_encode_bits(EHT_SU_BFER_ENABLE, EHT_MODE_SU_TX_BFER);
++		if (arvif->vif->bss_conf.eht_mu_beamformer &&
++		    arvif->vdev_type == WMI_VDEV_TYPE_AP)
++			value |= u32_encode_bits(EHT_MU_BFER_ENABLE,
++						 EHT_MODE_MU_TX_BFER) |
++				 u32_encode_bits(EHT_DL_MUOFDMA_ENABLE,
++						 EHT_MODE_DL_OFDMA_MUMIMO) |
++				 u32_encode_bits(EHT_UL_MUOFDMA_ENABLE,
++						 EHT_MODE_UL_OFDMA_MUMIMO);
++	}
++
++	if (arvif->vif->type != NL80211_IFTYPE_MESH_POINT) {
++		value |= u32_encode_bits(EHT_DL_MUOFDMA_ENABLE, EHT_MODE_DL_OFDMA) |
++			 u32_encode_bits(EHT_UL_MUOFDMA_ENABLE, EHT_MODE_UL_OFDMA);
++
++		if (arvif->vif->bss_conf.eht_80mhz_full_bw_ul_mumimo)
++			value |= u32_encode_bits(EHT_UL_MUMIMO_ENABLE, EHT_MODE_MUMIMO);
++
++		if (arvif->vif->bss_conf.eht_su_beamformee)
++			value |= u32_encode_bits(EHT_SU_BFEE_ENABLE,
++						 EHT_MODE_SU_TX_BFEE);
++	}
++
++	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param, value);
++	if (ret) {
++		ath12k_warn(ar->ab, "failed to set vdev %d EHT MU mode: %d\n",
++			    arvif->vdev_id, ret);
++		return ret;
++	}
++
++	return 0;
++}
++
+ static void ath12k_bss_assoc(struct ath12k *ar,
+ 			     struct ath12k_vif *arvif,
+ 			     struct ieee80211_bss_conf *bss_conf)
+@@ -3351,6 +3395,12 @@ static void ath12k_mac_bss_info_changed(
+ 				ath12k_warn(ar->ab,
+ 					    "failed to set HE TXBF config for vdev: %d\n",
+ 					    arvif->vdev_id);
++
++			ret = ath12k_mac_set_eht_txbf_conf(arvif);
++			if (ret)
++				ath12k_warn(ar->ab,
++					    "failed to set EHT TXBF config for vdev: %d\n",
++					    arvif->vdev_id);
+ 		}
+ 		ath12k_control_beaconing(arvif, info);
+ 
+--- a/drivers/net/wireless/ath/ath12k/wmi.h
++++ b/drivers/net/wireless/ath/ath12k/wmi.h
+@@ -1139,6 +1139,7 @@ enum wmi_tlv_vdev_param {
+ 	WMI_VDEV_PARAM_BSS_COLOR,
+ 	WMI_VDEV_PARAM_SET_HEMU_MODE,
+ 	WMI_VDEV_PARAM_HEOPS_0_31 = 0x8003,
++	WMI_VDEV_PARAM_SET_EHT_MU_MODE = 0x8005,
+ };
+ 
+ enum wmi_tlv_peer_flags {
+@@ -3012,6 +3013,26 @@ struct ath12k_wmi_rx_reorder_queue_remov
+ #define HE_MU_BFER_ENABLE	1
+ #define HE_SU_BFER_ENABLE	1
+ 
++#define EHT_MODE_SU_TX_BFEE		BIT(0)
++#define EHT_MODE_SU_TX_BFER		BIT(1)
++#define EHT_MODE_MU_TX_BFEE		BIT(2)
++#define EHT_MODE_MU_TX_BFER		BIT(3)
++#define EHT_MODE_DL_OFDMA		BIT(4)
++#define EHT_MODE_UL_OFDMA		BIT(5)
++#define EHT_MODE_MUMIMO			BIT(6)
++#define EHT_MODE_DL_OFDMA_TXBF		BIT(7)
++#define EHT_MODE_DL_OFDMA_MUMIMO	BIT(8)
++#define EHT_MODE_UL_OFDMA_MUMIMO	BIT(9)
++
++#define EHT_DL_MUOFDMA_ENABLE    1
++#define EHT_UL_MUOFDMA_ENABLE    1
++#define EHT_DL_MUMIMO_ENABLE     1
++#define EHT_UL_MUMIMO_ENABLE     1
++#define EHT_MU_BFEE_ENABLE       1
++#define EHT_SU_BFEE_ENABLE       1
++#define EHT_MU_BFER_ENABLE       1
++#define EHT_SU_BFER_ENABLE       1
++
+ #define HE_VHT_SOUNDING_MODE_ENABLE		1
+ #define HE_SU_MU_SOUNDING_MODE_ENABLE		1
+ #define HE_TRIG_NONTRIG_SOUNDING_MODE_ENABLE	1
diff --git a/package/kernel/mac80211/patches/ath12k/104-3-wifi-ath12k-move-HE-MCS-mapper-to-a-separate-function.patch b/package/kernel/mac80211/patches/ath12k/104-3-wifi-ath12k-move-HE-MCS-mapper-to-a-separate-function.patch
new file mode 100644
index 0000000000..1d6c9cc7db
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/104-3-wifi-ath12k-move-HE-MCS-mapper-to-a-separate-function.patch
@@ -0,0 +1,162 @@
+From patchwork Wed Sep 18 21:20:50 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+X-Patchwork-Id: 13807213
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mx0b-0031df01.pphosted.com (mx0b-0031df01.pphosted.com
+ [205.220.180.131])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 4B2B11CB312
+	for <linux-wireless@vger.kernel.org>; Wed, 18 Sep 2024 21:21:14 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=205.220.180.131
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1726694475; cv=none;
+ b=uo8JC/iAnxSCZyXzNFarViwWJNwY+JldG9aDgn6LOK7yCxMusODCN3rw4mSCs0sLxHrfxFouDKWpiKeM7hGb/fzQzU2eh6bHNvzhjOqaTjAsJo7sVGj4L2QK1UPb2ZxMke35L51ztNTVhAc7IS17sn6blDZnU+1+RGRKXskHc78=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1726694475; c=relaxed/simple;
+	bh=nhEu2OadboIpWVwShgMmYabjiVuEo2mUKJhJlcUzvgI=;
+	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
+	 MIME-Version:Content-Type;
+ b=iPc43CIgA4O9RfgxO3cfBBvDShW3nh4Q/MVoL1JTtx8u/9t1CeFY7KstjtKiPdJ6vxx0yhZwXcwCRFfbZdfRduyybDRKPmgqN/VogzkwizBSFWBL41H02pCvee2mV3poTyZz9CnCJ5L7An5k7ARI3Eo6EwsgaAYIncO/tU2Jsao=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com;
+ spf=pass smtp.mailfrom=quicinc.com;
+ dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b=iXyzdRBT; arc=none smtp.client-ip=205.220.180.131
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b="iXyzdRBT"
+Received: from pps.filterd (m0279869.ppops.net [127.0.0.1])
+	by mx0a-0031df01.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id
+ 48I90GrT001584;
+	Wed, 18 Sep 2024 21:21:09 GMT
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=quicinc.com; h=
+	cc:content-transfer-encoding:content-type:date:from:in-reply-to
+	:message-id:mime-version:references:subject:to; s=qcppdkim1; bh=
+	aj0umwCwR0cGrc/Vc7qz7QRYcnU4amMo6KwLL9RZRaA=; b=iXyzdRBTMie5qv2n
+	KocnG3cRtZjxDUMbNTj+in3o4zrIU5RFumLb3ZmgpbCZD9jcmxkc9fcTdtwxUz8e
+	LTodO1mKSkqtOufy45keXIYYJN3lxfFsZtA5bcmG+QCJZJmPaTpMaf9L9Us9e+JZ
+	Ngjh4JNR3UIXn5+UvNGrRNEWeAlCrwf9Z5bWl1mQmwmkVVuH3nMu1IyPidF3tzRk
+	AdQTPkPtpnoGlYwEWL/noPAYTf4OuZrqPCAj31iBfZvq2RjAdWtPx/ayYEQsNKCu
+	xoBLKjb8hppxfGqn06TpV73nTxvhEDwnwBTwfgrr+xVeKvwz6Mrh8aoYBdUeFUAh
+	OiuxDA==
+Received: from nalasppmta03.qualcomm.com (Global_NAT1.qualcomm.com
+ [129.46.96.20])
+	by mx0a-0031df01.pphosted.com (PPS) with ESMTPS id 41n4hf38cn-1
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:08 +0000 (GMT)
+Received: from nalasex01a.na.qualcomm.com (nalasex01a.na.qualcomm.com
+ [10.47.209.196])
+	by NALASPPMTA03.qualcomm.com (8.18.1.2/8.18.1.2) with ESMTPS id
+ 48ILL7e8005093
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:07 GMT
+Received: from ath12k-linux1.qualcomm.com (10.80.80.8) by
+ nalasex01a.na.qualcomm.com (10.47.209.196) with Microsoft SMTP Server
+ (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
+ 15.2.1544.9; Wed, 18 Sep 2024 14:21:07 -0700
+From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+To: <ath12k@lists.infradead.org>
+CC: <linux-wireless@vger.kernel.org>,
+        Pradeep Kumar Chitrapu
+	<quic_pradeepc@quicinc.com>,
+        Muna Sinada <quic_msinada@quicinc.com>,
+        "Jeff
+ Johnson" <quic_jjohnson@quicinc.com>
+Subject: [PATCH V8 3/9] wifi: ath12k: move HE MCS mapper to a separate
+ function
+Date: Wed, 18 Sep 2024 14:20:50 -0700
+Message-ID: <20240918212056.4137076-4-quic_pradeepc@quicinc.com>
+X-Mailer: git-send-email 2.34.1
+In-Reply-To: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+References: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+X-ClientProxiedBy: nasanex01a.na.qualcomm.com (10.52.223.231) To
+ nalasex01a.na.qualcomm.com (10.47.209.196)
+X-QCInternal: smtphost
+X-Proofpoint-Virus-Version: vendor=nai engine=6200 definitions=5800
+ signatures=585085
+X-Proofpoint-ORIG-GUID: zHmCiFNBcWNOH7v_I9cuj0l6gmfKvBVa
+X-Proofpoint-GUID: zHmCiFNBcWNOH7v_I9cuj0l6gmfKvBVa
+X-Proofpoint-Virus-Version: vendor=baseguard
+ engine=ICAP:2.0.293,Aquarius:18.0.1039,Hydra:6.0.680,FMLib:17.12.60.29
+ definitions=2024-09-06_09,2024-09-06_01,2024-09-02_01
+X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
+ priorityscore=1501 mlxscore=0
+ suspectscore=0 bulkscore=0 lowpriorityscore=0 spamscore=0 clxscore=1015
+ mlxlogscore=999 adultscore=0 malwarescore=0 phishscore=0 impostorscore=0
+ classifier=spam adjust=0 reason=mlx scancount=1 engine=8.19.0-2408220000
+ definitions=main-2409180140
+
+Refactor the HE MCS mapper functionality in
+ath12k_mac_copy_he_cap() into a new function.
+
+This helps improve readability, extensibility and will be used
+when adding support for 160 MHz bandwidth in subsequent patches.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1
+
+Co-developed-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
+---
+ drivers/net/wireless/ath/ath12k/mac.c | 22 ++++++++++++++--------
+ 1 file changed, 14 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -5519,12 +5519,24 @@ static __le16 ath12k_mac_setup_he_6ghz_c
+ 	return cpu_to_le16(bcap->he_6ghz_capa);
+ }
+ 
++static void ath12k_mac_set_hemcsmap(struct ath12k_band_cap *band_cap,
++				    struct ieee80211_sta_he_cap *he_cap)
++{
++	struct ieee80211_he_mcs_nss_supp *mcs_nss = &he_cap->he_mcs_nss_supp;
++
++	mcs_nss->rx_mcs_80 = cpu_to_le16(band_cap->he_mcs & 0xffff);
++	mcs_nss->tx_mcs_80 = cpu_to_le16(band_cap->he_mcs & 0xffff);
++	mcs_nss->rx_mcs_160 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
++	mcs_nss->tx_mcs_160 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
++	mcs_nss->rx_mcs_80p80 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
++	mcs_nss->tx_mcs_80p80 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
++}
++
+ static void ath12k_mac_copy_he_cap(struct ath12k_band_cap *band_cap,
+ 				   int iftype, u8 num_tx_chains,
+ 				   struct ieee80211_sta_he_cap *he_cap)
+ {
+ 	struct ieee80211_he_cap_elem *he_cap_elem = &he_cap->he_cap_elem;
+-	struct ieee80211_he_mcs_nss_supp *mcs_nss = &he_cap->he_mcs_nss_supp;
+ 
+ 	he_cap->has_he = true;
+ 	memcpy(he_cap_elem->mac_cap_info, band_cap->he_cap_info,
+@@ -5562,13 +5574,7 @@ static void ath12k_mac_copy_he_cap(struc
+ 		break;
+ 	}
+ 
+-	mcs_nss->rx_mcs_80 = cpu_to_le16(band_cap->he_mcs & 0xffff);
+-	mcs_nss->tx_mcs_80 = cpu_to_le16(band_cap->he_mcs & 0xffff);
+-	mcs_nss->rx_mcs_160 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
+-	mcs_nss->tx_mcs_160 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
+-	mcs_nss->rx_mcs_80p80 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
+-	mcs_nss->tx_mcs_80p80 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
+-
++	ath12k_mac_set_hemcsmap(band_cap, he_cap);
+ 	memset(he_cap->ppe_thres, 0, sizeof(he_cap->ppe_thres));
+ 	if (he_cap_elem->phy_cap_info[6] &
+ 	    IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT)
diff --git a/package/kernel/mac80211/patches/ath12k/104-4-wifi-ath12k-generate-rx-and-tx-mcs-maps-for-supported-HE-mcs.patch b/package/kernel/mac80211/patches/ath12k/104-4-wifi-ath12k-generate-rx-and-tx-mcs-maps-for-supported-HE-mcs.patch
new file mode 100644
index 0000000000..fe33f85a19
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/104-4-wifi-ath12k-generate-rx-and-tx-mcs-maps-for-supported-HE-mcs.patch
@@ -0,0 +1,186 @@
+From patchwork Wed Sep 18 21:20:51 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+X-Patchwork-Id: 13807215
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mx0b-0031df01.pphosted.com (mx0b-0031df01.pphosted.com
+ [205.220.180.131])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id A88651CB32C
+	for <linux-wireless@vger.kernel.org>; Wed, 18 Sep 2024 21:21:14 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=205.220.180.131
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1726694476; cv=none;
+ b=Lkqx2oSLyeGRxKcm+N4Vmg+KOuwHpt6xhgWj9SpyWNXxxWkVExVyHvPrWaP/u4OXd0YjYBJC3Dg0NJYY9WJyL0A3RP8GK++s9CiRloNaEmEjI71S/f3+0HVXu5bCmi8cyiIMFzCpAcNuZ67J7r/WxvNRbeox3iZHmXK1WFUb4Hs=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1726694476; c=relaxed/simple;
+	bh=nv4kc89H7eGC0FLgCwC70zFDhNkClMNiRf5HjDZHHuQ=;
+	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
+	 MIME-Version:Content-Type;
+ b=B1oJWv7vHZKRChjamOFJnRzQVtL7qBs7/Ho9GojLQtHyCKtrCEOJt/lWvhkqISf48/5MaQOCdkHhCrQT/eHP9hZ1wnCdeOKXh6Wmk/QYt9yEcc0X6HT5wUxgpaA3PooH/cMlJCX0c8hyhT7XBm6vWnPwQjt/FnLTubA3uj+X8oE=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com;
+ spf=pass smtp.mailfrom=quicinc.com;
+ dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b=WweZPnje; arc=none smtp.client-ip=205.220.180.131
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b="WweZPnje"
+Received: from pps.filterd (m0279872.ppops.net [127.0.0.1])
+	by mx0a-0031df01.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id
+ 48IACJst031540;
+	Wed, 18 Sep 2024 21:21:09 GMT
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=quicinc.com; h=
+	cc:content-transfer-encoding:content-type:date:from:in-reply-to
+	:message-id:mime-version:references:subject:to; s=qcppdkim1; bh=
+	ARu9Fu0s66NeuLm2pdCBchANS+rlgd275Q/E4KE2T1o=; b=WweZPnjehL/ZQW57
+	4JHJDsl8A5hyljMaJrVPdmZwNktTurJPMpD5z0akqx2dq3bfjzx2rx5NAtMb831x
+	ieysvT1ApK5V32fmb9xzG7FMIU3DH4eqr/9ApZbHFVPTglHrVoVzHJLps3I+Ts5P
+	gi1dsIAdwTai7hW1FchcW/pZ2kJMq6zN7oljoFs7pc1CvzHfIJowQM8gFfslkqlL
+	lvm9A9knvnUlkrEvzgpoZfZxm/91t9bQzkQDTX91wRc0oGR/9liT+z4Sdum2rLwb
+	fri8rhQIw8w1ExGM1nzChPaajmDIsE86ODjDL2xBbd/DcdsVvOYl8ewJ8AX45qNs
+	+LpHtg==
+Received: from nalasppmta03.qualcomm.com (Global_NAT1.qualcomm.com
+ [129.46.96.20])
+	by mx0a-0031df01.pphosted.com (PPS) with ESMTPS id 41n4j6uagq-1
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:09 +0000 (GMT)
+Received: from nalasex01a.na.qualcomm.com (nalasex01a.na.qualcomm.com
+ [10.47.209.196])
+	by NALASPPMTA03.qualcomm.com (8.18.1.2/8.18.1.2) with ESMTPS id
+ 48ILL8gM005103
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:08 GMT
+Received: from ath12k-linux1.qualcomm.com (10.80.80.8) by
+ nalasex01a.na.qualcomm.com (10.47.209.196) with Microsoft SMTP Server
+ (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
+ 15.2.1544.9; Wed, 18 Sep 2024 14:21:07 -0700
+From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+To: <ath12k@lists.infradead.org>
+CC: <linux-wireless@vger.kernel.org>,
+        Pradeep Kumar Chitrapu
+	<quic_pradeepc@quicinc.com>,
+        Muna Sinada <quic_msinada@quicinc.com>,
+        "Jeff
+ Johnson" <quic_jjohnson@quicinc.com>
+Subject: [PATCH V8 4/9] wifi: ath12k: generate rx and tx mcs maps for
+ supported HE mcs
+Date: Wed, 18 Sep 2024 14:20:51 -0700
+Message-ID: <20240918212056.4137076-5-quic_pradeepc@quicinc.com>
+X-Mailer: git-send-email 2.34.1
+In-Reply-To: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+References: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+X-ClientProxiedBy: nasanex01a.na.qualcomm.com (10.52.223.231) To
+ nalasex01a.na.qualcomm.com (10.47.209.196)
+X-QCInternal: smtphost
+X-Proofpoint-Virus-Version: vendor=nai engine=6200 definitions=5800
+ signatures=585085
+X-Proofpoint-ORIG-GUID: wHJ63GZpWGKZ4XSyQZiVlsARNAgr5CQM
+X-Proofpoint-GUID: wHJ63GZpWGKZ4XSyQZiVlsARNAgr5CQM
+X-Proofpoint-Virus-Version: vendor=baseguard
+ engine=ICAP:2.0.293,Aquarius:18.0.1039,Hydra:6.0.680,FMLib:17.12.60.29
+ definitions=2024-09-06_09,2024-09-06_01,2024-09-02_01
+X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
+ phishscore=0 mlxlogscore=999
+ mlxscore=0 malwarescore=0 bulkscore=0 priorityscore=1501 clxscore=1015
+ adultscore=0 suspectscore=0 lowpriorityscore=0 spamscore=0 impostorscore=0
+ classifier=spam adjust=0 reason=mlx scancount=1 engine=8.19.0-2408220000
+ definitions=main-2409180140
+
+Generate rx and tx mcs maps in ath12k_mac_set_hemcsmap() based
+on number of supported tx/rx chains and set them in supported
+mcs/nss for HE capabilities.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1
+
+Co-developed-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
+---
+ drivers/net/wireless/ath/ath12k/mac.c | 40 ++++++++++++++++++++-------
+ 1 file changed, 30 insertions(+), 10 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -5519,20 +5519,40 @@ static __le16 ath12k_mac_setup_he_6ghz_c
+ 	return cpu_to_le16(bcap->he_6ghz_capa);
+ }
+ 
+-static void ath12k_mac_set_hemcsmap(struct ath12k_band_cap *band_cap,
++static void ath12k_mac_set_hemcsmap(struct ath12k *ar,
++				    struct ath12k_pdev_cap *cap,
+ 				    struct ieee80211_sta_he_cap *he_cap)
+ {
+ 	struct ieee80211_he_mcs_nss_supp *mcs_nss = &he_cap->he_mcs_nss_supp;
++	u16 txmcs_map, rxmcs_map;
++	u32 i;
+ 
+-	mcs_nss->rx_mcs_80 = cpu_to_le16(band_cap->he_mcs & 0xffff);
+-	mcs_nss->tx_mcs_80 = cpu_to_le16(band_cap->he_mcs & 0xffff);
+-	mcs_nss->rx_mcs_160 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
+-	mcs_nss->tx_mcs_160 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
+-	mcs_nss->rx_mcs_80p80 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
+-	mcs_nss->tx_mcs_80p80 = cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
++	rxmcs_map = 0;
++	txmcs_map = 0;
++	for (i = 0; i < 8; i++) {
++		if (i < ar->num_tx_chains &&
++		    (ar->cfg_tx_chainmask >> cap->tx_chain_mask_shift) & BIT(i))
++			txmcs_map |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);
++		else
++			txmcs_map |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);
++
++		if (i < ar->num_rx_chains &&
++		    (ar->cfg_rx_chainmask >> cap->tx_chain_mask_shift) & BIT(i))
++			rxmcs_map |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);
++		else
++			rxmcs_map |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);
++	}
++
++	mcs_nss->rx_mcs_80 = cpu_to_le16(rxmcs_map & 0xffff);
++	mcs_nss->tx_mcs_80 = cpu_to_le16(txmcs_map & 0xffff);
++	mcs_nss->rx_mcs_160 = cpu_to_le16(rxmcs_map & 0xffff);
++	mcs_nss->tx_mcs_160 = cpu_to_le16(txmcs_map & 0xffff);
++	mcs_nss->rx_mcs_80p80 = cpu_to_le16(rxmcs_map & 0xffff);
++	mcs_nss->tx_mcs_80p80 = cpu_to_le16(txmcs_map & 0xffff);
+ }
+ 
+-static void ath12k_mac_copy_he_cap(struct ath12k_band_cap *band_cap,
++static void ath12k_mac_copy_he_cap(struct ath12k *ar,
++				   struct ath12k_band_cap *band_cap,
+ 				   int iftype, u8 num_tx_chains,
+ 				   struct ieee80211_sta_he_cap *he_cap)
+ {
+@@ -5574,7 +5594,7 @@ static void ath12k_mac_copy_he_cap(struc
+ 		break;
+ 	}
+ 
+-	ath12k_mac_set_hemcsmap(band_cap, he_cap);
++	ath12k_mac_set_hemcsmap(ar, &ar->pdev->cap, he_cap);
+ 	memset(he_cap->ppe_thres, 0, sizeof(he_cap->ppe_thres));
+ 	if (he_cap_elem->phy_cap_info[6] &
+ 	    IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT)
+@@ -5763,7 +5783,7 @@ static int ath12k_mac_copy_sband_iftype_
+ 
+ 		data[idx].types_mask = BIT(i);
+ 
+-		ath12k_mac_copy_he_cap(band_cap, i, ar->num_tx_chains, he_cap);
++		ath12k_mac_copy_he_cap(ar, band_cap, i, ar->num_tx_chains, he_cap);
+ 		if (band == NL80211_BAND_6GHZ) {
+ 			data[idx].he_6ghz_capa.capa =
+ 				ath12k_mac_setup_he_6ghz_cap(cap, band_cap);
diff --git a/package/kernel/mac80211/patches/ath12k/104-5-wifi-ath12k-fix-TX-and-RX-MCS-rate-configurations-in-HE-mode.patch b/package/kernel/mac80211/patches/ath12k/104-5-wifi-ath12k-fix-TX-and-RX-MCS-rate-configurations-in-HE-mode.patch
new file mode 100644
index 0000000000..e1d109cd56
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/104-5-wifi-ath12k-fix-TX-and-RX-MCS-rate-configurations-in-HE-mode.patch
@@ -0,0 +1,141 @@
+From patchwork Wed Sep 18 21:20:52 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+X-Patchwork-Id: 13807211
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mx0a-0031df01.pphosted.com (mx0a-0031df01.pphosted.com
+ [205.220.168.131])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 77FB41CA6AC
+	for <linux-wireless@vger.kernel.org>; Wed, 18 Sep 2024 21:21:13 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=205.220.168.131
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1726694475; cv=none;
+ b=RN/ddoo5Vh8RVGeYZ8k8lXTOb7bzs7wSIAQGFjyvpfc9NICOpTDXpM3ai/D/fFtXLR8mFmYa4uIMFdrWML1x/UjZtd+jJnNyL/jo4/t5+ONN0nU4brd/dW7fv/biqLA6CkFbjnw01XnInXLzGT8IIm4NvxBkMy/RVj0tC33y7os=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1726694475; c=relaxed/simple;
+	bh=bsvgv033jSAPUVmS0VlMcScTn/1aM6tw3aACOOiqxvA=;
+	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
+	 MIME-Version:Content-Type;
+ b=rDT2TKhzEg9vR1RSVstUP/e9Z+sWhPbag7vxjm3nmkSJBFS5bR72jSO3YnpEGSQLOgd0c+ou8ce0GQOHHZBEpr8VlMP4o6SK8T3BVg4yPiHhqLzwadektVXzAofZ0K+caSvYUjsPvDd2wH1xDyUPHgvr/DjsPh8bhO1MP80pTYk=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com;
+ spf=pass smtp.mailfrom=quicinc.com;
+ dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b=DbZeRJ9u; arc=none smtp.client-ip=205.220.168.131
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b="DbZeRJ9u"
+Received: from pps.filterd (m0279867.ppops.net [127.0.0.1])
+	by mx0a-0031df01.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id
+ 48I9TNqc020283;
+	Wed, 18 Sep 2024 21:21:09 GMT
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=quicinc.com; h=
+	cc:content-transfer-encoding:content-type:date:from:in-reply-to
+	:message-id:mime-version:references:subject:to; s=qcppdkim1; bh=
+	azR+5F3oXqRD0oIXJq+q0F3HbuiVUYwPuvX5vVskhnw=; b=DbZeRJ9uo40mL5rR
+	p0cASEsdLU8yr/aYeIXTSWCHBf5P73m5S26EYVv6MqTdcnmRT7flYyQWzotNV+gg
+	oHJpR7L5sN+omhK+7gDPRcm5j29/U9+7rMG7I0JwrfR6KbUUNJkrg+omW45ZdRPS
+	/92XJynSBDgzEGETs0AjLe+PLPW4Ucnncc+YscEVm/dtR4f5vQBYwGdCwv4IuczO
+	FJrEmDh3mj7m6JtNVV+A3LT5qS7PCAbiS7qhTAkDfhH9gDZJuUTO2b6ByyO4UkWp
+	afB41wIc4KUDYsTHkThkApxxp0vHfJJLGCweUi+YKYaqvQETgLhHx/UkSRdoRBII
+	N708pg==
+Received: from nalasppmta05.qualcomm.com (Global_NAT1.qualcomm.com
+ [129.46.96.20])
+	by mx0a-0031df01.pphosted.com (PPS) with ESMTPS id 41n4kjk65m-1
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:09 +0000 (GMT)
+Received: from nalasex01a.na.qualcomm.com (nalasex01a.na.qualcomm.com
+ [10.47.209.196])
+	by NALASPPMTA05.qualcomm.com (8.18.1.2/8.18.1.2) with ESMTPS id
+ 48ILL8Gi009579
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:08 GMT
+Received: from ath12k-linux1.qualcomm.com (10.80.80.8) by
+ nalasex01a.na.qualcomm.com (10.47.209.196) with Microsoft SMTP Server
+ (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
+ 15.2.1544.9; Wed, 18 Sep 2024 14:21:08 -0700
+From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+To: <ath12k@lists.infradead.org>
+CC: <linux-wireless@vger.kernel.org>,
+        Pradeep Kumar Chitrapu
+	<quic_pradeepc@quicinc.com>,
+        Jeff Johnson <quic_jjohnson@quicinc.com>
+Subject: [PATCH V8 5/9] wifi: ath12k: fix TX and RX MCS rate configurations in
+ HE mode
+Date: Wed, 18 Sep 2024 14:20:52 -0700
+Message-ID: <20240918212056.4137076-6-quic_pradeepc@quicinc.com>
+X-Mailer: git-send-email 2.34.1
+In-Reply-To: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+References: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+X-ClientProxiedBy: nasanex01a.na.qualcomm.com (10.52.223.231) To
+ nalasex01a.na.qualcomm.com (10.47.209.196)
+X-QCInternal: smtphost
+X-Proofpoint-Virus-Version: vendor=nai engine=6200 definitions=5800
+ signatures=585085
+X-Proofpoint-GUID: JNJY4yItbZ8HP8WQjm82lNqNLkxUdf1v
+X-Proofpoint-ORIG-GUID: JNJY4yItbZ8HP8WQjm82lNqNLkxUdf1v
+X-Proofpoint-Virus-Version: vendor=baseguard
+ engine=ICAP:2.0.293,Aquarius:18.0.1039,Hydra:6.0.680,FMLib:17.12.60.29
+ definitions=2024-09-06_09,2024-09-06_01,2024-09-02_01
+X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
+ bulkscore=0 adultscore=0
+ suspectscore=0 mlxscore=0 clxscore=1015 lowpriorityscore=0 malwarescore=0
+ phishscore=0 impostorscore=0 mlxlogscore=999 priorityscore=1501
+ spamscore=0 classifier=spam adjust=0 reason=mlx scancount=1
+ engine=8.19.0-2408220000 definitions=main-2409180140
+
+Currently, the TX and RX MCS rate configurations per peer are
+reversed when sent to the firmware. As a result, RX MCS rates
+are configured for TX, and vice versa. This commit rectifies
+the configuration to match what the firmware expects.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1
+
+Fixes: d889913205cf ("wifi: ath12k: driver for Qualcomm Wi-Fi 7 devices")
+Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
+---
+ drivers/net/wireless/ath/ath12k/wmi.c | 4 ++--
+ drivers/net/wireless/ath/ath12k/wmi.h | 2 ++
+ 2 files changed, 4 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/wmi.c
++++ b/drivers/net/wireless/ath/ath12k/wmi.c
+@@ -2140,8 +2140,8 @@ int ath12k_wmi_send_peer_assoc_cmd(struc
+ 		he_mcs->tlv_header = ath12k_wmi_tlv_cmd_hdr(WMI_TAG_HE_RATE_SET,
+ 							    sizeof(*he_mcs));
+ 
+-		he_mcs->rx_mcs_set = cpu_to_le32(arg->peer_he_rx_mcs_set[i]);
+-		he_mcs->tx_mcs_set = cpu_to_le32(arg->peer_he_tx_mcs_set[i]);
++		he_mcs->rx_mcs_set = cpu_to_le32(arg->peer_he_tx_mcs_set[i]);
++		he_mcs->tx_mcs_set = cpu_to_le32(arg->peer_he_rx_mcs_set[i]);
+ 		ptr += sizeof(*he_mcs);
+ 	}
+ 
+--- a/drivers/net/wireless/ath/ath12k/wmi.h
++++ b/drivers/net/wireless/ath/ath12k/wmi.h
+@@ -3953,7 +3953,9 @@ struct ath12k_wmi_vht_rate_set_params {
+ 
+ struct ath12k_wmi_he_rate_set_params {
+ 	__le32 tlv_header;
++	/* MCS at which the peer can receive */
+ 	__le32 rx_mcs_set;
++	/* MCS at which the peer can transmit */
+ 	__le32 tx_mcs_set;
+ } __packed;
+ 
diff --git a/package/kernel/mac80211/patches/ath12k/104-6-wifi-ath12k-add-support-for-setting-fixed-HE-rate-GI-LTF.patch b/package/kernel/mac80211/patches/ath12k/104-6-wifi-ath12k-add-support-for-setting-fixed-HE-rate-GI-LTF.patch
new file mode 100644
index 0000000000..72f3e9a567
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/104-6-wifi-ath12k-add-support-for-setting-fixed-HE-rate-GI-LTF.patch
@@ -0,0 +1,1095 @@
+From patchwork Wed Sep 18 21:20:53 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+X-Patchwork-Id: 13807217
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mx0a-0031df01.pphosted.com (mx0a-0031df01.pphosted.com
+ [205.220.168.131])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 01CB41CB521
+	for <linux-wireless@vger.kernel.org>; Wed, 18 Sep 2024 21:21:15 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=205.220.168.131
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1726694478; cv=none;
+ b=CCnmzPX7wAnXz6jkBGnfJkO3OTVTa1pEVXaY+i3jcRKLwLmYLBkbQB7d5qZASnEWRw4vJRXQbpKaSNlechv1fw+VqQci5hz7GrwDmSDWwFwNKynwUkaS+V6CUoPkxGmvijlkSH5/Sp7n4JBdH9MZdY9ACaPCGZlgpTeAiRpgqyQ=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1726694478; c=relaxed/simple;
+	bh=mOCMplbDFdsxafoM0lh9GOTg8poXfVWSA2JaaPzd5gg=;
+	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
+	 MIME-Version:Content-Type;
+ b=m9Y3ZEQjhVcT6ObjX34KItzxLUdCbzQDCo4za4qtMsxHQCEQSny2a/lTtWTbAB42n+JZkBRjC1xrrdmRnXSxy58EZpvKNutjY0YonbJ/hMfa97U5qRTD/50prvNqxkFINPijMCNMgKsnCBz6tfcB78j3qnEvZjNP4eV4rbTicUg=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com;
+ spf=pass smtp.mailfrom=quicinc.com;
+ dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b=lKsSrYSp; arc=none smtp.client-ip=205.220.168.131
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b="lKsSrYSp"
+Received: from pps.filterd (m0279864.ppops.net [127.0.0.1])
+	by mx0a-0031df01.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id
+ 48IINFa1032091;
+	Wed, 18 Sep 2024 21:21:09 GMT
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=quicinc.com; h=
+	cc:content-transfer-encoding:content-type:date:from:in-reply-to
+	:message-id:mime-version:references:subject:to; s=qcppdkim1; bh=
+	97aZlelAxnf1oZWK/vk3qg6OISdr4sArbqi18OQE/2Y=; b=lKsSrYSpewbykrq1
+	6WJRbLR0y481zo+GgIgfHUNcpF2NhItbbS8mgWYFPaMaoohciRsbAYdFFZrc9BG3
+	9IyAzZvpFzBox/oaJjDm/zLc2GVYMSGtwO3W0mMk2uVXU7ZB8dBDNimtsLmXTa1t
+	jyV6n0wj3jlGU1kDYu6zPgrcxWF1NnScnosftToVpHqM7TLfDaj8EJWuzsJnau2A
+	CUOS2o9wPZPAScyeL91kJOHtJddltuJrvLFxbi4gGZW7dWUus99UjFzGTAan/JVK
+	yb5Xr8iEzP2141KqZ9FMQqwqYOGc10t+yYXPMep/fo1mfziiB5kQ0tRtaWQ01Auw
+	uPa6OQ==
+Received: from nalasppmta04.qualcomm.com (Global_NAT1.qualcomm.com
+ [129.46.96.20])
+	by mx0a-0031df01.pphosted.com (PPS) with ESMTPS id 41n4geb5e1-1
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:09 +0000 (GMT)
+Received: from nalasex01a.na.qualcomm.com (nalasex01a.na.qualcomm.com
+ [10.47.209.196])
+	by NALASPPMTA04.qualcomm.com (8.18.1.2/8.18.1.2) with ESMTPS id
+ 48ILL8jN020567
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:08 GMT
+Received: from ath12k-linux1.qualcomm.com (10.80.80.8) by
+ nalasex01a.na.qualcomm.com (10.47.209.196) with Microsoft SMTP Server
+ (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
+ 15.2.1544.9; Wed, 18 Sep 2024 14:21:08 -0700
+From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+To: <ath12k@lists.infradead.org>
+CC: <linux-wireless@vger.kernel.org>,
+        Pradeep Kumar Chitrapu
+	<quic_pradeepc@quicinc.com>,
+        Muna Sinada <quic_msinada@quicinc.com>,
+        "Jeff
+ Johnson" <quic_jjohnson@quicinc.com>
+Subject: [PATCH V8 6/9] wifi: ath12k: add support for setting fixed HE
+ rate/GI/LTF
+Date: Wed, 18 Sep 2024 14:20:53 -0700
+Message-ID: <20240918212056.4137076-7-quic_pradeepc@quicinc.com>
+X-Mailer: git-send-email 2.34.1
+In-Reply-To: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+References: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+X-ClientProxiedBy: nasanex01a.na.qualcomm.com (10.52.223.231) To
+ nalasex01a.na.qualcomm.com (10.47.209.196)
+X-QCInternal: smtphost
+X-Proofpoint-Virus-Version: vendor=nai engine=6200 definitions=5800
+ signatures=585085
+X-Proofpoint-GUID: GGIeqOgMFye5oFp39WDjK5DZ7YoCK3Ap
+X-Proofpoint-ORIG-GUID: GGIeqOgMFye5oFp39WDjK5DZ7YoCK3Ap
+X-Proofpoint-Virus-Version: vendor=baseguard
+ engine=ICAP:2.0.293,Aquarius:18.0.1039,Hydra:6.0.680,FMLib:17.12.60.29
+ definitions=2024-09-06_09,2024-09-06_01,2024-09-02_01
+X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
+ malwarescore=0
+ mlxlogscore=999 impostorscore=0 bulkscore=0 clxscore=1015
+ lowpriorityscore=0 adultscore=0 phishscore=0 suspectscore=0
+ priorityscore=1501 mlxscore=0 spamscore=0 classifier=spam adjust=0
+ reason=mlx scancount=1 engine=8.19.0-2408220000
+ definitions=main-2409180140
+
+Add support to set fixed HE rate/GI/LTF values using nl80211.
+Reuse parts of the existing code path already used for HT/VHT
+to implement the new helpers symmetrically, similar to how
+HT/VHT is handled.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1
+
+Co-developed-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
+Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
+---
+ drivers/net/wireless/ath/ath12k/mac.c | 604 ++++++++++++++++++++++++--
+ drivers/net/wireless/ath/ath12k/wmi.h |  18 +
+ 2 files changed, 574 insertions(+), 48 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -441,6 +441,18 @@ ath12k_mac_max_vht_nss(const u16 *vht_mc
+ 	return 1;
+ }
+ 
++static u32
++ath12k_mac_max_he_nss(const u16 he_mcs_mask[NL80211_HE_NSS_MAX])
++{
++	int nss;
++
++	for (nss = NL80211_HE_NSS_MAX - 1; nss >= 0; nss--)
++		if (he_mcs_mask[nss])
++			return nss + 1;
++
++	return 1;
++}
++
+ static u8 ath12k_parse_mpdudensity(u8 mpdudensity)
+ {
+ /*  From IEEE Std 802.11-2020 defined values for "Minimum MPDU Start Spacing":
+@@ -1916,6 +1928,14 @@ static void ath12k_peer_assoc_h_ht(struc
+ 		arg->peer_rate_caps |= WMI_HOST_RC_CW40_FLAG;
+ 	}
+ 
++	/* As firmware handles these two flags (IEEE80211_HT_CAP_SGI_20
++	 * and IEEE80211_HT_CAP_SGI_40) for enabling SGI, reset both
++	 * flags if guard interval is Default GI
++	 */
++	if (arvif->bitrate_mask.control[band].gi == NL80211_TXRATE_DEFAULT_GI)
++		arg->peer_ht_caps &= ~(IEEE80211_HT_CAP_SGI_20 |
++				IEEE80211_HT_CAP_SGI_40);
++
+ 	if (arvif->bitrate_mask.control[band].gi != NL80211_TXRATE_FORCE_LGI) {
+ 		if (ht_cap->cap & (IEEE80211_HT_CAP_SGI_20 |
+ 		    IEEE80211_HT_CAP_SGI_40))
+@@ -2039,11 +2059,12 @@ static void ath12k_peer_assoc_h_vht(stru
+ 	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+ 	struct cfg80211_chan_def def;
+ 	enum nl80211_band band;
+-	const u16 *vht_mcs_mask;
++	u16 *vht_mcs_mask;
+ 	u16 tx_mcs_map;
+ 	u8 ampdu_factor;
+ 	u8 max_nss, vht_mcs;
+-	int i;
++	int i, vht_nss, nss_idx;
++	bool user_rate_valid = true;
+ 
+ 	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+ 		return;
+@@ -2086,6 +2107,25 @@ static void ath12k_peer_assoc_h_vht(stru
+ 	if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)
+ 		arg->bw_160 = true;
+ 
++	vht_nss =  ath12k_mac_max_vht_nss(vht_mcs_mask);
++
++	if (vht_nss > sta->deflink.rx_nss) {
++		user_rate_valid = false;
++		for (nss_idx = sta->deflink.rx_nss - 1; nss_idx >= 0; nss_idx--) {
++			if (vht_mcs_mask[nss_idx]) {
++				user_rate_valid = true;
++				break;
++			}
++		}
++	}
++
++	if (!user_rate_valid) {
++		ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
++			   "Setting vht range MCS value to peer supported nss:%d for peer %pM\n",
++			   sta->deflink.rx_nss, sta->deflink.addr);
++		vht_mcs_mask[sta->deflink.rx_nss - 1] = vht_mcs_mask[vht_nss - 1];
++	}
++
+ 	/* Calculate peer NSS capability from VHT capabilities if STA
+ 	 * supports VHT.
+ 	 */
+@@ -2125,23 +2165,105 @@ static void ath12k_peer_assoc_h_vht(stru
+ 	/* TODO: rxnss_override */
+ }
+ 
++static int ath12k_mac_get_max_he_mcs_map(u16 mcs_map, int nss)
++{
++	switch ((mcs_map >> (2 * nss)) & 0x3) {
++	case IEEE80211_HE_MCS_SUPPORT_0_7: return BIT(8) - 1;
++	case IEEE80211_HE_MCS_SUPPORT_0_9: return BIT(10) - 1;
++	case IEEE80211_HE_MCS_SUPPORT_0_11: return BIT(12) - 1;
++	}
++	return 0;
++}
++
++static u16 ath12k_peer_assoc_h_he_limit(u16 tx_mcs_set,
++					const u16 *he_mcs_limit)
++{
++	int idx_limit;
++	int nss;
++	u16 mcs_map;
++	u16 mcs;
++
++	for (nss = 0; nss < NL80211_HE_NSS_MAX; nss++) {
++		mcs_map = ath12k_mac_get_max_he_mcs_map(tx_mcs_set, nss) &
++			he_mcs_limit[nss];
++
++		if (mcs_map)
++			idx_limit = fls(mcs_map) - 1;
++		else
++			idx_limit = -1;
++
++		switch (idx_limit) {
++		case 0 ... 7:
++			mcs = IEEE80211_HE_MCS_SUPPORT_0_7;
++			break;
++		case 8:
++		case 9:
++			mcs = IEEE80211_HE_MCS_SUPPORT_0_9;
++			break;
++		case 10:
++		case 11:
++			mcs = IEEE80211_HE_MCS_SUPPORT_0_11;
++			break;
++		default:
++			WARN_ON(1);
++			fallthrough;
++		case -1:
++			mcs = IEEE80211_HE_MCS_NOT_SUPPORTED;
++			break;
++		}
++
++		tx_mcs_set &= ~(0x3 << (nss * 2));
++		tx_mcs_set |= mcs << (nss * 2);
++	}
++
++	return tx_mcs_set;
++}
++
++static bool
++ath12k_peer_assoc_h_he_masked(const u16 he_mcs_mask[NL80211_HE_NSS_MAX])
++{
++	int nss;
++
++	for (nss = 0; nss < NL80211_HE_NSS_MAX; nss++)
++		if (he_mcs_mask[nss])
++			return false;
++
++	return true;
++}
++
+ static void ath12k_peer_assoc_h_he(struct ath12k *ar,
+ 				   struct ieee80211_vif *vif,
+ 				   struct ieee80211_sta *sta,
+ 				   struct ath12k_wmi_peer_assoc_arg *arg)
+ {
+ 	const struct ieee80211_sta_he_cap *he_cap = &sta->deflink.he_cap;
++	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
++	struct cfg80211_chan_def def;
+ 	int i;
+ 	u8 ampdu_factor, max_nss;
+ 	u8 rx_mcs_80 = IEEE80211_HE_MCS_NOT_SUPPORTED;
+ 	u8 rx_mcs_160 = IEEE80211_HE_MCS_NOT_SUPPORTED;
+ 	u16 mcs_160_map, mcs_80_map;
+ 	bool support_160;
+-	u16 v;
++	enum nl80211_band band;
++	u16 *he_mcs_mask;
++	u8 he_mcs;
++	u16 he_tx_mcs = 0, v = 0;
++	int he_nss, nss_idx;
++	bool user_rate_valid = true;
++
++	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
++		return;
+ 
+ 	if (!he_cap->has_he)
+ 		return;
+ 
++	band = def.chan->band;
++	he_mcs_mask = arvif->bitrate_mask.control[band].he_mcs;
++
++	if (ath12k_peer_assoc_h_he_masked(he_mcs_mask))
++		return;
++
+ 	arg->he_flag = true;
+ 
+ 	support_160 = !!(he_cap->he_cap_elem.phy_cap_info[0] &
+@@ -2247,25 +2369,47 @@ static void ath12k_peer_assoc_h_he(struc
+ 	if (he_cap->he_cap_elem.mac_cap_info[0] & IEEE80211_HE_MAC_CAP0_TWT_REQ)
+ 		arg->twt_requester = true;
+ 
++	he_nss = ath12k_mac_max_he_nss(he_mcs_mask);
++
++	if (he_nss > sta->deflink.rx_nss) {
++		user_rate_valid = false;
++		for (nss_idx = sta->deflink.rx_nss - 1; nss_idx >= 0; nss_idx--) {
++			if (he_mcs_mask[nss_idx]) {
++				user_rate_valid = true;
++				break;
++			}
++		}
++	}
++
++	if (!user_rate_valid) {
++		ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
++			   "Setting he range MCS value to peer supported nss:%d for peer %pM\n",
++			   sta->deflink.rx_nss, sta->deflink.addr);
++		he_mcs_mask[sta->deflink.rx_nss - 1] = he_mcs_mask[he_nss - 1];
++	}
++
+ 	switch (sta->deflink.bandwidth) {
+ 	case IEEE80211_STA_RX_BW_160:
+ 		if (he_cap->he_cap_elem.phy_cap_info[0] &
+ 		    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G) {
+-			v = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_80p80);
++			v = ath12k_peer_assoc_h_he_limit(v, he_mcs_mask);
+ 			arg->peer_he_rx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80_80] = v;
+ 
+ 			v = le16_to_cpu(he_cap->he_mcs_nss_supp.tx_mcs_80p80);
+ 			arg->peer_he_tx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80_80] = v;
+ 
+ 			arg->peer_he_mcs_count++;
++			he_tx_mcs = v;
+ 		}
+ 		v = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_160);
+ 		arg->peer_he_rx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_160] = v;
+ 
+-		v = le16_to_cpu(he_cap->he_mcs_nss_supp.tx_mcs_160);
++		v = ath12k_peer_assoc_h_he_limit(v, he_mcs_mask);
+ 		arg->peer_he_tx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_160] = v;
+ 
+ 		arg->peer_he_mcs_count++;
++		if (!he_tx_mcs)
++			he_tx_mcs = v;
+ 		fallthrough;
+ 
+ 	default:
+@@ -2273,11 +2417,34 @@ static void ath12k_peer_assoc_h_he(struc
+ 		arg->peer_he_rx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80] = v;
+ 
+ 		v = le16_to_cpu(he_cap->he_mcs_nss_supp.tx_mcs_80);
++		v = ath12k_peer_assoc_h_he_limit(v, he_mcs_mask);
+ 		arg->peer_he_tx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80] = v;
+ 
+ 		arg->peer_he_mcs_count++;
++		if (!he_tx_mcs)
++			he_tx_mcs = v;
+ 		break;
+ 	}
++
++	/* Calculate peer NSS capability from HE capabilities if STA
++	 * supports HE.
++	 */
++	for (i = 0, max_nss = 0, he_mcs = 0; i < NL80211_HE_NSS_MAX; i++) {
++		he_mcs = he_tx_mcs >> (2 * i) & 3;
++
++		/* In case of fixed rates, MCS Range in he_tx_mcs might have
++		 * unsupported range, with he_mcs_mask set, so check either of them
++		 * to find nss.
++		 */
++		if (he_mcs != IEEE80211_HE_MCS_NOT_SUPPORTED ||
++		    he_mcs_mask[i])
++			max_nss = i + 1;
++	}
++	arg->peer_nss = min(sta->deflink.rx_nss, max_nss);
++
++	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
++		   "mac he peer %pM nss %d mcs cnt %d\n",
++		   sta->deflink.addr, arg->peer_nss, arg->peer_he_mcs_count);
+ }
+ 
+ static void ath12k_peer_assoc_h_he_6ghz(struct ath12k *ar,
+@@ -2586,6 +2753,7 @@ static void ath12k_peer_assoc_h_phymode(
+ 	enum nl80211_band band;
+ 	const u8 *ht_mcs_mask;
+ 	const u16 *vht_mcs_mask;
++	const u16 *he_mcs_mask;
+ 	enum wmi_phy_mode phymode = MODE_UNKNOWN;
+ 
+ 	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+@@ -2594,6 +2762,7 @@ static void ath12k_peer_assoc_h_phymode(
+ 	band = def.chan->band;
+ 	ht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;
+ 	vht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;
++	he_mcs_mask = arvif->bitrate_mask.control[band].he_mcs;
+ 
+ 	switch (band) {
+ 	case NL80211_BAND_2GHZ:
+@@ -2602,7 +2771,8 @@ static void ath12k_peer_assoc_h_phymode(
+ 				phymode = MODE_11BE_EHT40_2G;
+ 			else
+ 				phymode = MODE_11BE_EHT20_2G;
+-		} else if (sta->deflink.he_cap.has_he) {
++		} else if (sta->deflink.he_cap.has_he &&
++			   !ath12k_peer_assoc_h_he_masked(he_mcs_mask)) {
+ 			if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)
+ 				phymode = MODE_11AX_HE80_2G;
+ 			else if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)
+@@ -2632,7 +2802,8 @@ static void ath12k_peer_assoc_h_phymode(
+ 		/* Check EHT first */
+ 		if (sta->deflink.eht_cap.has_eht) {
+ 			phymode = ath12k_mac_get_phymode_eht(ar, sta);
+-		} else if (sta->deflink.he_cap.has_he) {
++		} else if (sta->deflink.he_cap.has_he &&
++			   !ath12k_peer_assoc_h_he_masked(he_mcs_mask)) {
+ 			phymode = ath12k_mac_get_phymode_he(ar, sta);
+ 		} else if (sta->deflink.vht_cap.vht_supported &&
+ 		    !ath12k_peer_assoc_h_vht_masked(vht_mcs_mask)) {
+@@ -4311,6 +4482,20 @@ ath12k_mac_bitrate_mask_num_vht_rates(st
+ }
+ 
+ static int
++ath12k_mac_bitrate_mask_num_he_rates(struct ath12k *ar,
++				     enum nl80211_band band,
++				     const struct cfg80211_bitrate_mask *mask)
++{
++	int num_rates = 0;
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(mask->control[band].he_mcs); i++)
++		num_rates += hweight16(mask->control[band].he_mcs[i]);
++
++	return num_rates;
++}
++
++static int
+ ath12k_mac_set_peer_vht_fixed_rate(struct ath12k_vif *arvif,
+ 				   struct ieee80211_sta *sta,
+ 				   const struct cfg80211_bitrate_mask *mask,
+@@ -4356,6 +4541,57 @@ ath12k_mac_set_peer_vht_fixed_rate(struc
+ 	return ret;
+ }
+ 
++static int
++ath12k_mac_set_peer_he_fixed_rate(struct ath12k_vif *arvif,
++				  struct ieee80211_sta *sta,
++				  const struct cfg80211_bitrate_mask *mask,
++				  enum nl80211_band band)
++{
++	struct ath12k *ar = arvif->ar;
++	u8 he_rate, nss;
++	u32 rate_code;
++	int ret, i;
++
++	lockdep_assert_held(&ar->conf_mutex);
++
++	nss = 0;
++
++	for (i = 0; i < ARRAY_SIZE(mask->control[band].he_mcs); i++) {
++		if (hweight16(mask->control[band].he_mcs[i]) == 1) {
++			nss = i + 1;
++			he_rate = ffs(mask->control[band].he_mcs[i]) - 1;
++		}
++	}
++
++	if (!nss) {
++		ath12k_warn(ar->ab, "No single HE Fixed rate found to set for %pM",
++			    sta->deflink.addr);
++		return -EINVAL;
++	}
++
++	/* Avoid updating invalid nss as fixed rate*/
++	if (nss > sta->deflink.rx_nss)
++		return -EINVAL;
++
++	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
++		   "Setting Fixed HE Rate for peer %pM. Device will not switch to any other selected rates",
++		   sta->deflink.addr);
++
++	rate_code = ATH12K_HW_RATE_CODE(he_rate, nss - 1,
++					WMI_RATE_PREAMBLE_HE);
++
++	ret = ath12k_wmi_set_peer_param(ar, sta->deflink.addr,
++					arvif->vdev_id,
++					WMI_PEER_PARAM_FIXED_RATE,
++					rate_code);
++	if (ret)
++		ath12k_warn(ar->ab,
++			    "failed to update STA %pM Fixed Rate %d: %d\n",
++			    sta->deflink.addr, rate_code, ret);
++
++	return ret;
++}
++
+ static int ath12k_station_assoc(struct ath12k *ar,
+ 				struct ieee80211_vif *vif,
+ 				struct ieee80211_sta *sta,
+@@ -4367,7 +4603,7 @@ static int ath12k_station_assoc(struct a
+ 	struct cfg80211_chan_def def;
+ 	enum nl80211_band band;
+ 	struct cfg80211_bitrate_mask *mask;
+-	u8 num_vht_rates;
++	u8 num_vht_rates, num_he_rates;
+ 
+ 	lockdep_assert_held(&ar->conf_mutex);
+ 
+@@ -4398,15 +4634,19 @@ static int ath12k_station_assoc(struct a
+ 	}
+ 
+ 	num_vht_rates = ath12k_mac_bitrate_mask_num_vht_rates(ar, band, mask);
++	num_he_rates = ath12k_mac_bitrate_mask_num_he_rates(ar, band, mask);
+ 
+-	/* If single VHT rate is configured (by set_bitrate_mask()),
+-	 * peer_assoc will disable VHT. This is now enabled by a peer specific
++	/* If single VHT/HE rate is configured (by set_bitrate_mask()),
++	 * peer_assoc will disable VHT/HE. This is now enabled by a peer specific
+ 	 * fixed param.
+ 	 * Note that all other rates and NSS will be disabled for this peer.
+ 	 */
+ 	if (sta->deflink.vht_cap.vht_supported && num_vht_rates == 1) {
+-		ret = ath12k_mac_set_peer_vht_fixed_rate(arvif, sta, mask,
+-							 band);
++		ret = ath12k_mac_set_peer_vht_fixed_rate(arvif, sta, mask, band);
++		if (ret)
++			return ret;
++	} else if (sta->deflink.he_cap.has_he && num_he_rates == 1) {
++		ret = ath12k_mac_set_peer_he_fixed_rate(arvif, sta, mask, band);
+ 		if (ret)
+ 			return ret;
+ 	}
+@@ -4480,8 +4720,9 @@ static void ath12k_sta_rc_update_wk(stru
+ 	enum nl80211_band band;
+ 	const u8 *ht_mcs_mask;
+ 	const u16 *vht_mcs_mask;
+-	u32 changed, bw, nss, smps, bw_prev;
+-	int err, num_vht_rates;
++	const u16 *he_mcs_mask;
++	u32 changed, bw, nss, mac_nss, smps, bw_prev;
++	int err, num_vht_rates, num_he_rates;
+ 	const struct cfg80211_bitrate_mask *mask;
+ 	struct ath12k_wmi_peer_assoc_arg peer_arg;
+ 	enum wmi_phy_mode peer_phymode;
+@@ -4497,6 +4738,7 @@ static void ath12k_sta_rc_update_wk(stru
+ 	band = def.chan->band;
+ 	ht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;
+ 	vht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;
++	he_mcs_mask = arvif->bitrate_mask.control[band].he_mcs;
+ 
+ 	spin_lock_bh(&ar->data_lock);
+ 
+@@ -4513,8 +4755,10 @@ static void ath12k_sta_rc_update_wk(stru
+ 	mutex_lock(&ar->conf_mutex);
+ 
+ 	nss = max_t(u32, 1, nss);
+-	nss = min(nss, max(ath12k_mac_max_ht_nss(ht_mcs_mask),
+-			   ath12k_mac_max_vht_nss(vht_mcs_mask)));
++	mac_nss = max3(ath12k_mac_max_ht_nss(ht_mcs_mask),
++		       ath12k_mac_max_vht_nss(vht_mcs_mask),
++		       ath12k_mac_max_he_nss(he_mcs_mask));
++	nss = min(nss, mac_nss);
+ 
+ 	if (changed & IEEE80211_RC_BW_CHANGED) {
+ 		ath12k_peer_assoc_h_phymode(ar, arvif->vif, sta, &peer_arg);
+@@ -4592,6 +4836,8 @@ static void ath12k_sta_rc_update_wk(stru
+ 		mask = &arvif->bitrate_mask;
+ 		num_vht_rates = ath12k_mac_bitrate_mask_num_vht_rates(ar, band,
+ 								      mask);
++		num_he_rates = ath12k_mac_bitrate_mask_num_he_rates(ar, band,
++								    mask);
+ 
+ 		/* Peer_assoc_prepare will reject vht rates in
+ 		 * bitrate_mask if its not available in range format and
+@@ -4607,11 +4853,24 @@ static void ath12k_sta_rc_update_wk(stru
+ 		if (sta->deflink.vht_cap.vht_supported && num_vht_rates == 1) {
+ 			ath12k_mac_set_peer_vht_fixed_rate(arvif, sta, mask,
+ 							   band);
++		} else if (sta->deflink.he_cap.has_he && num_he_rates == 1) {
++			ath12k_mac_set_peer_he_fixed_rate(arvif, sta, mask, band);
+ 		} else {
+-			/* If the peer is non-VHT or no fixed VHT rate
++			/* If the peer is non-VHT/HE or no fixed VHT/HE rate
+ 			 * is provided in the new bitrate mask we set the
+-			 * other rates using peer_assoc command.
++			 * other rates using peer_assoc command. Also clear
++			 * the peer fixed rate settings as it has higher proprity
++			 * than peer assoc
+ 			 */
++
++			err = ath12k_wmi_set_peer_param(ar, sta->deflink.addr,
++							arvif->vdev_id,
++							WMI_PEER_PARAM_FIXED_RATE,
++							WMI_FIXED_RATE_NONE);
++			if (err)
++				ath12k_warn(ar->ab,
++					    "failed to disable peer fixed rate for STA %pM ret %d\n",
++					    sta->deflink.addr, err);
+ 			ath12k_peer_assoc_prepare(ar, arvif->vif, sta,
+ 						  &peer_arg, true);
+ 
+@@ -7059,10 +7318,13 @@ static int ath12k_mac_op_add_interface(s
+ 
+ 	for (i = 0; i < ARRAY_SIZE(arvif->bitrate_mask.control); i++) {
+ 		arvif->bitrate_mask.control[i].legacy = 0xffffffff;
++		arvif->bitrate_mask.control[i].gi = NL80211_TXRATE_FORCE_SGI;
+ 		memset(arvif->bitrate_mask.control[i].ht_mcs, 0xff,
+ 		       sizeof(arvif->bitrate_mask.control[i].ht_mcs));
+ 		memset(arvif->bitrate_mask.control[i].vht_mcs, 0xff,
+ 		       sizeof(arvif->bitrate_mask.control[i].vht_mcs));
++		memset(arvif->bitrate_mask.control[i].he_mcs, 0xff,
++		       sizeof(arvif->bitrate_mask.control[i].he_mcs));
+ 	}
+ 
+ 	/* Allocate Default Queue now and reassign during actual vdev create */
+@@ -8223,19 +8485,40 @@ ath12k_mac_has_single_legacy_rate(struct
+ 	if (ath12k_mac_bitrate_mask_num_vht_rates(ar, band, mask))
+ 		return false;
+ 
++	if (ath12k_mac_bitrate_mask_num_he_rates(ar, band, mask))
++		return false;
++
+ 	return num_rates == 1;
+ }
+ 
++static __le16
++ath12k_mac_get_tx_mcs_map(const struct ieee80211_sta_he_cap *he_cap)
++{
++	if (he_cap->he_cap_elem.phy_cap_info[0] &
++	    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)
++		return he_cap->he_mcs_nss_supp.tx_mcs_80p80;
++
++	if (he_cap->he_cap_elem.phy_cap_info[0] &
++	    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G)
++		return he_cap->he_mcs_nss_supp.tx_mcs_160;
++
++	return he_cap->he_mcs_nss_supp.tx_mcs_80;
++}
++
+ static bool
+ ath12k_mac_bitrate_mask_get_single_nss(struct ath12k *ar,
++				       struct ieee80211_vif *vif,
+ 				       enum nl80211_band band,
+ 				       const struct cfg80211_bitrate_mask *mask,
+ 				       int *nss)
+ {
+ 	struct ieee80211_supported_band *sband = &ar->mac.sbands[band];
+ 	u16 vht_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);
++	const struct ieee80211_sta_he_cap *he_cap;
++	u16 he_mcs_map = 0;
+ 	u8 ht_nss_mask = 0;
+ 	u8 vht_nss_mask = 0;
++	u8 he_nss_mask = 0;
+ 	int i;
+ 
+ 	/* No need to consider legacy here. Basic rates are always present
+@@ -8262,7 +8545,24 @@ ath12k_mac_bitrate_mask_get_single_nss(s
+ 			return false;
+ 	}
+ 
+-	if (ht_nss_mask != vht_nss_mask)
++	he_cap = ieee80211_get_he_iftype_cap_vif(sband, vif);
++	if (!he_cap)
++		return false;
++
++	he_mcs_map = le16_to_cpu(ath12k_mac_get_tx_mcs_map(he_cap));
++
++	for (i = 0; i < ARRAY_SIZE(mask->control[band].he_mcs); i++) {
++		if (mask->control[band].he_mcs[i] == 0)
++			continue;
++
++		if (mask->control[band].he_mcs[i] ==
++		    ath12k_mac_get_max_he_mcs_map(he_mcs_map, i))
++			he_nss_mask |= BIT(i);
++		else
++			return false;
++	}
++
++	if (ht_nss_mask != vht_nss_mask || ht_nss_mask != he_nss_mask)
+ 		return false;
+ 
+ 	if (ht_nss_mask == 0)
+@@ -8309,54 +8609,158 @@ ath12k_mac_get_single_legacy_rate(struct
+ 	return 0;
+ }
+ 
+-static int ath12k_mac_set_fixed_rate_params(struct ath12k_vif *arvif,
+-					    u32 rate, u8 nss, u8 sgi, u8 ldpc)
++static int
++ath12k_mac_set_fixed_rate_gi_ltf(struct ath12k_vif *arvif, u8 he_gi, u8 he_ltf)
+ {
+ 	struct ath12k *ar = arvif->ar;
+-	u32 vdev_param;
+ 	int ret;
+ 
+-	lockdep_assert_held(&ar->conf_mutex);
++	/* 0.8 = 0, 1.6 = 2 and 3.2 = 3. */
++	if (he_gi && he_gi != 0xFF)
++		he_gi += 1;
+ 
+-	ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac set fixed rate params vdev %i rate 0x%02x nss %u sgi %u\n",
+-		   arvif->vdev_id, rate, nss, sgi);
++	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
++					    WMI_VDEV_PARAM_SGI, he_gi);
++	if (ret) {
++		ath12k_warn(ar->ab, "failed to set HE GI:%d, error:%d\n",
++			    he_gi, ret);
++		return ret;
++	}
++	/* start from 1 */
++	if (he_ltf != 0xFF)
++		he_ltf += 1;
+ 
+-	vdev_param = WMI_VDEV_PARAM_FIXED_RATE;
+ 	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
+-					    vdev_param, rate);
++					    WMI_VDEV_PARAM_HE_LTF, he_ltf);
+ 	if (ret) {
+-		ath12k_warn(ar->ab, "failed to set fixed rate param 0x%02x: %d\n",
+-			    rate, ret);
++		ath12k_warn(ar->ab, "failed to set HE LTF:%d, error:%d\n",
++			    he_ltf, ret);
+ 		return ret;
+ 	}
++	return 0;
++}
++
++static int
++ath12k_mac_set_auto_rate_gi_ltf(struct ath12k_vif *arvif, u16 he_gi, u8 he_ltf)
++{
++	struct ath12k *ar = arvif->ar;
++	int ret;
++	u32 he_ar_gi_ltf;
++
++	if (he_gi != 0xFF) {
++		switch (he_gi) {
++		case NL80211_RATE_INFO_HE_GI_0_8:
++			he_gi = WMI_AUTORATE_800NS_GI;
++			break;
++		case NL80211_RATE_INFO_HE_GI_1_6:
++			he_gi = WMI_AUTORATE_1600NS_GI;
++			break;
++		case NL80211_RATE_INFO_HE_GI_3_2:
++			he_gi = WMI_AUTORATE_3200NS_GI;
++			break;
++		default:
++			ath12k_warn(ar->ab, "Invalid GI\n");
++			return -EINVAL;
++		}
++	}
++
++	if (he_ltf != 0xFF) {
++		switch (he_ltf) {
++		case NL80211_RATE_INFO_HE_1XLTF:
++			he_ltf = WMI_HE_AUTORATE_LTF_1X;
++			break;
++		case NL80211_RATE_INFO_HE_2XLTF:
++			he_ltf = WMI_HE_AUTORATE_LTF_2X;
++			break;
++		case NL80211_RATE_INFO_HE_4XLTF:
++			he_ltf = WMI_HE_AUTORATE_LTF_4X;
++			break;
++		default:
++			ath12k_warn(ar->ab, "Invalid LTF\n");
++			return -EINVAL;
++		}
++	}
++
++	he_ar_gi_ltf = he_gi | he_ltf;
+ 
+-	vdev_param = WMI_VDEV_PARAM_NSS;
+ 	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
+-					    vdev_param, nss);
++					    WMI_VDEV_PARAM_AUTORATE_MISC_CFG,
++					    he_ar_gi_ltf);
+ 	if (ret) {
+-		ath12k_warn(ar->ab, "failed to set nss param %d: %d\n",
+-			    nss, ret);
++		ath12k_warn(ar->ab,
++			    "failed to set HE autorate GI:%u, LTF:%u params, error:%d\n",
++			    he_gi, he_ltf, ret);
+ 		return ret;
+ 	}
+ 
+-	vdev_param = WMI_VDEV_PARAM_SGI;
++	return 0;
++}
++
++static int ath12k_mac_set_rate_params(struct ath12k_vif *arvif,
++				      u32 rate, u8 nss, u8 sgi, u8 ldpc,
++				      u8 he_gi, u8 he_ltf, bool he_fixed_rate)
++{
++	struct ath12k *ar = arvif->ar;
++	u32 vdev_param;
++	int ret;
++
++	lockdep_assert_held(&ar->conf_mutex);
++
++	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
++		   "mac set rate params vdev %i rate 0x%02x nss 0x%02x sgi 0x%02x ldpc 0x%02x\n",
++		   arvif->vdev_id, rate, nss, sgi, ldpc);
++
++	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
++		   "he_gi 0x%02x he_ltf 0x%02x he_fixed_rate %d\n", he_gi,
++		   he_ltf, he_fixed_rate);
++
++	if (!arvif->vif->bss_conf.he_support) {
++		vdev_param = WMI_VDEV_PARAM_FIXED_RATE;
++		ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
++						    vdev_param, rate);
++		if (ret) {
++			ath12k_warn(ar->ab, "failed to set fixed rate param 0x%02x: %d\n",
++				    rate, ret);
++			return ret;
++		}
++	}
++
++	vdev_param = WMI_VDEV_PARAM_NSS;
++
+ 	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
+-					    vdev_param, sgi);
++					    vdev_param, nss);
+ 	if (ret) {
+-		ath12k_warn(ar->ab, "failed to set sgi param %d: %d\n",
+-			    sgi, ret);
++		ath12k_warn(ar->ab, "failed to set nss param %d: %d\n",
++			    nss, ret);
+ 		return ret;
+ 	}
+ 
+-	vdev_param = WMI_VDEV_PARAM_LDPC;
+ 	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
+-					    vdev_param, ldpc);
++					    WMI_VDEV_PARAM_LDPC, ldpc);
+ 	if (ret) {
+ 		ath12k_warn(ar->ab, "failed to set ldpc param %d: %d\n",
+ 			    ldpc, ret);
+ 		return ret;
+ 	}
+ 
++	if (arvif->vif->bss_conf.he_support) {
++		if (he_fixed_rate)
++			ret = ath12k_mac_set_fixed_rate_gi_ltf(arvif, he_gi, he_ltf);
++		else
++			ret = ath12k_mac_set_auto_rate_gi_ltf(arvif, he_gi, he_ltf);
++		if (ret)
++			return ret;
++	} else {
++		vdev_param = WMI_VDEV_PARAM_SGI;
++		ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
++						    vdev_param, sgi);
++		if (ret) {
++			ath12k_warn(ar->ab, "failed to set sgi param %d: %d\n",
++				    sgi, ret);
++			return ret;
++		}
++	}
++
+ 	return 0;
+ }
+ 
+@@ -8385,6 +8789,31 @@ ath12k_mac_vht_mcs_range_present(struct
+ 	return true;
+ }
+ 
++static bool
++ath12k_mac_he_mcs_range_present(struct ath12k *ar,
++				enum nl80211_band band,
++				const struct cfg80211_bitrate_mask *mask)
++{
++	int i;
++	u16 he_mcs;
++
++	for (i = 0; i < NL80211_HE_NSS_MAX; i++) {
++		he_mcs = mask->control[band].he_mcs[i];
++
++		switch (he_mcs) {
++		case 0:
++		case BIT(8) - 1:
++		case BIT(10) - 1:
++		case BIT(12) - 1:
++			break;
++		default:
++			return false;
++		}
++	}
++
++	return true;
++}
++
+ static void ath12k_mac_set_bitrate_mask_iter(void *data,
+ 					     struct ieee80211_sta *sta)
+ {
+@@ -8424,6 +8853,54 @@ static void ath12k_mac_disable_peer_fixe
+ }
+ 
+ static int
++ath12k_mac_validate_vht_he_fixed_rate_settings(struct ath12k *ar, enum nl80211_band band,
++					       const struct cfg80211_bitrate_mask *mask)
++{
++	bool he_fixed_rate = false, vht_fixed_rate = false;
++	struct ath12k_peer *peer;
++	const u16 *vht_mcs_mask, *he_mcs_mask;
++	u8 vht_nss, he_nss;
++	int ret = 0;
++
++	vht_mcs_mask = mask->control[band].vht_mcs;
++	he_mcs_mask = mask->control[band].he_mcs;
++
++	if (ath12k_mac_bitrate_mask_num_vht_rates(ar, band, mask) == 1)
++		vht_fixed_rate = true;
++
++	if (ath12k_mac_bitrate_mask_num_he_rates(ar, band, mask) == 1)
++		he_fixed_rate = true;
++
++	if (!vht_fixed_rate && !he_fixed_rate)
++		return 0;
++
++	vht_nss = ath12k_mac_max_vht_nss(vht_mcs_mask);
++	he_nss =  ath12k_mac_max_he_nss(he_mcs_mask);
++
++	rcu_read_lock();
++	spin_lock_bh(&ar->ab->base_lock);
++	list_for_each_entry(peer, &ar->ab->peers, list) {
++		if (peer->sta) {
++			if (vht_fixed_rate &&
++			    (!peer->sta->deflink.vht_cap.vht_supported ||
++			    peer->sta->deflink.rx_nss < vht_nss)) {
++				ret = -EINVAL;
++				goto exit;
++			}
++			if (he_fixed_rate && (!peer->sta->deflink.he_cap.has_he ||
++					      peer->sta->deflink.rx_nss < he_nss)) {
++				ret = -EINVAL;
++				goto exit;
++			}
++		}
++	}
++exit:
++	spin_unlock_bh(&ar->ab->base_lock);
++	rcu_read_unlock();
++	return ret;
++}
++
++static int
+ ath12k_mac_op_set_bitrate_mask(struct ieee80211_hw *hw,
+ 			       struct ieee80211_vif *vif,
+ 			       const struct cfg80211_bitrate_mask *mask)
+@@ -8434,13 +8911,17 @@ ath12k_mac_op_set_bitrate_mask(struct ie
+ 	enum nl80211_band band;
+ 	const u8 *ht_mcs_mask;
+ 	const u16 *vht_mcs_mask;
++	const u16 *he_mcs_mask;
++	u8 he_ltf = 0;
++	u8 he_gi = 0;
+ 	u32 rate;
+-	u8 nss;
++	u8 nss, mac_nss;
+ 	u8 sgi;
+ 	u8 ldpc;
+ 	int single_nss;
+ 	int ret;
+ 	int num_rates;
++	bool he_fixed_rate = false;
+ 
+ 	if (ath12k_mac_vif_chan(vif, &def))
+ 		return -EPERM;
+@@ -8448,6 +8929,7 @@ ath12k_mac_op_set_bitrate_mask(struct ie
+ 	band = def.chan->band;
+ 	ht_mcs_mask = mask->control[band].ht_mcs;
+ 	vht_mcs_mask = mask->control[band].vht_mcs;
++	he_mcs_mask = mask->control[band].he_mcs;
+ 	ldpc = !!(ar->ht_cap_info & WMI_HT_CAP_LDPC);
+ 
+ 	sgi = mask->control[band].gi;
+@@ -8456,6 +8938,9 @@ ath12k_mac_op_set_bitrate_mask(struct ie
+ 		goto out;
+ 	}
+ 
++	he_gi = mask->control[band].he_gi;
++	he_ltf = mask->control[band].he_ltf;
++
+ 	/* mac80211 doesn't support sending a fixed HT/VHT MCS alone, rather it
+ 	 * requires passing at least one of used basic rates along with them.
+ 	 * Fixed rate setting across different preambles(legacy, HT, VHT) is
+@@ -8475,15 +8960,27 @@ ath12k_mac_op_set_bitrate_mask(struct ie
+ 		ieee80211_iterate_stations_mtx(hw,
+ 					       ath12k_mac_disable_peer_fixed_rate,
+ 					       arvif);
+-	} else if (ath12k_mac_bitrate_mask_get_single_nss(ar, band, mask,
++	} else if (ath12k_mac_bitrate_mask_get_single_nss(ar, vif, band, mask,
+ 							  &single_nss)) {
+ 		rate = WMI_FIXED_RATE_NONE;
+ 		nss = single_nss;
++		mutex_lock(&ar->conf_mutex);
++		arvif->bitrate_mask = *mask;
++		ieee80211_iterate_stations_mtx(hw,
++					       ath12k_mac_set_bitrate_mask_iter,
++					       arvif);
++		mutex_unlock(&ar->conf_mutex);
+ 	} else {
+ 		rate = WMI_FIXED_RATE_NONE;
+-		nss = min_t(u32, ar->num_tx_chains,
+-			    max(ath12k_mac_max_ht_nss(ht_mcs_mask),
+-				ath12k_mac_max_vht_nss(vht_mcs_mask)));
++
++		if (!ath12k_mac_validate_vht_he_fixed_rate_settings(ar, band, mask))
++			ath12k_warn(ar->ab,
++				    "could not update fixed rate settings to all peers due to mcs/nss incompatiblity\n");
++
++		mac_nss = max3(ath12k_mac_max_ht_nss(ht_mcs_mask),
++			       ath12k_mac_max_vht_nss(vht_mcs_mask),
++			       ath12k_mac_max_he_nss(he_mcs_mask));
++		nss = min_t(u32, ar->num_tx_chains, mac_nss);
+ 
+ 		/* If multiple rates across different preambles are given
+ 		 * we can reconfigure this info with all peers using PEER_ASSOC
+@@ -8519,12 +9016,22 @@ ath12k_mac_op_set_bitrate_mask(struct ie
+ 			goto out;
+ 		}
+ 
++		num_rates = ath12k_mac_bitrate_mask_num_he_rates(ar, band, mask);
++		if (num_rates == 1)
++			he_fixed_rate = true;
++
++		if (!ath12k_mac_he_mcs_range_present(ar, band, mask) &&
++		    num_rates > 1) {
++			ath12k_warn(ar->ab,
++				    "Setting more than one HE MCS Value in bitrate mask not supported\n");
++			return -EINVAL;
++		}
++
++		mutex_lock(&ar->conf_mutex);
+ 		ieee80211_iterate_stations_mtx(hw,
+ 					       ath12k_mac_disable_peer_fixed_rate,
+ 					       arvif);
+ 
+-		mutex_lock(&ar->conf_mutex);
+-
+ 		arvif->bitrate_mask = *mask;
+ 		ieee80211_iterate_stations_mtx(hw,
+ 					       ath12k_mac_set_bitrate_mask_iter,
+@@ -8535,9 +9042,10 @@ ath12k_mac_op_set_bitrate_mask(struct ie
+ 
+ 	mutex_lock(&ar->conf_mutex);
+ 
+-	ret = ath12k_mac_set_fixed_rate_params(arvif, rate, nss, sgi, ldpc);
++	ret = ath12k_mac_set_rate_params(arvif, rate, nss, sgi, ldpc, he_gi,
++					 he_ltf, he_fixed_rate);
+ 	if (ret) {
+-		ath12k_warn(ar->ab, "failed to set fixed rate params on vdev %i: %d\n",
++		ath12k_warn(ar->ab, "failed to set rate params on vdev %i: %d\n",
+ 			    arvif->vdev_id, ret);
+ 	}
+ 
+--- a/drivers/net/wireless/ath/ath12k/wmi.h
++++ b/drivers/net/wireless/ath/ath12k/wmi.h
+@@ -220,6 +220,22 @@ enum WMI_HOST_WLAN_BAND {
+ 	WMI_HOST_WLAN_2G_5G_CAP	= 3,
+ };
+ 
++/* Parameters used for WMI_VDEV_PARAM_AUTORATE_MISC_CFG command.
++ * Used only for HE auto rate mode.
++ */
++enum {
++	/* HE LTF related configuration */
++	WMI_HE_AUTORATE_LTF_1X = BIT(0),
++	WMI_HE_AUTORATE_LTF_2X = BIT(1),
++	WMI_HE_AUTORATE_LTF_4X = BIT(2),
++
++	/* HE GI related configuration */
++	WMI_AUTORATE_400NS_GI = BIT(8),
++	WMI_AUTORATE_800NS_GI = BIT(9),
++	WMI_AUTORATE_1600NS_GI = BIT(10),
++	WMI_AUTORATE_3200NS_GI = BIT(11),
++};
++
+ enum wmi_cmd_group {
+ 	/* 0 to 2 are reserved */
+ 	WMI_GRP_START = 0x3,
+@@ -1132,7 +1148,9 @@ enum wmi_tlv_vdev_param {
+ 	WMI_VDEV_PARAM_HE_RANGE_EXT,
+ 	WMI_VDEV_PARAM_ENABLE_BCAST_PROBE_RESPONSE,
+ 	WMI_VDEV_PARAM_FILS_MAX_CHANNEL_GUARD_TIME,
++	WMI_VDEV_PARAM_HE_LTF = 0x74,
+ 	WMI_VDEV_PARAM_BA_MODE = 0x7e,
++	WMI_VDEV_PARAM_AUTORATE_MISC_CFG = 0x80,
+ 	WMI_VDEV_PARAM_SET_HE_SOUNDING_MODE = 0x87,
+ 	WMI_VDEV_PARAM_6GHZ_PARAMS = 0x99,
+ 	WMI_VDEV_PARAM_PROTOTYPE = 0x8000,
diff --git a/package/kernel/mac80211/patches/ath12k/104-7-wifi-ath12k-clean-up-80P80-support.patch b/package/kernel/mac80211/patches/ath12k/104-7-wifi-ath12k-clean-up-80P80-support.patch
new file mode 100644
index 0000000000..93cbd3b802
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/104-7-wifi-ath12k-clean-up-80P80-support.patch
@@ -0,0 +1,254 @@
+From patchwork Wed Sep 18 21:20:54 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+X-Patchwork-Id: 13807218
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mx0a-0031df01.pphosted.com (mx0a-0031df01.pphosted.com
+ [205.220.168.131])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id E7A2C15853D
+	for <linux-wireless@vger.kernel.org>; Wed, 18 Sep 2024 21:21:29 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=205.220.168.131
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1726694491; cv=none;
+ b=IDDUnQF/Tnpw/FvWitX7ofLgG/RwY2FyN79K1j9v3STIk2mbRSVtS7kUmHv83gWDgLeingrnJyz3kE7pWhAK5Zt+U/d3HoSbyXlaWdr1m98ZLPJnOIO51q8LBaUW4uPaZbMJiRGvTbhFw+0k6FNjQse034o2zQ5vHk1qETT9XsU=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1726694491; c=relaxed/simple;
+	bh=4Sbgjg6TXf4A547Y46Qiyw4U55YEFrIGdUXLZjEx5C0=;
+	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
+	 MIME-Version:Content-Type;
+ b=Y+NDqrjfpb1iFWpY9XYrVbCXhYRTFGsK7MN6jcsgZur7Ro+ZQsyZfhkFA+t+Bb52hk2p2N7v1TAdqLDK2CiFXaWPy/JfESHATwktCnNG+8/UL3n0VIjl+qxGTWt3pS/aWzI6yQjM2FB6tKc4kMnGX//RrgXhEIrh1M4ROs3IpJ0=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com;
+ spf=pass smtp.mailfrom=quicinc.com;
+ dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b=Kt1nBSex; arc=none smtp.client-ip=205.220.168.131
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b="Kt1nBSex"
+Received: from pps.filterd (m0279866.ppops.net [127.0.0.1])
+	by mx0a-0031df01.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id
+ 48IJrYUI005813;
+	Wed, 18 Sep 2024 21:21:27 GMT
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=quicinc.com; h=
+	cc:content-transfer-encoding:content-type:date:from:in-reply-to
+	:message-id:mime-version:references:subject:to; s=qcppdkim1; bh=
+	7iZtYFy4NRmF2YHXqLd4zDMUbigsFxIkBQ6OeDD3zOs=; b=Kt1nBSex9R0mUQFv
+	fimFwEUDD2mzhj9KyoJnJsvbpzJOV9sBCCp3nPyxHNB66qzQUi/U904HE+wQ26S+
+	Dmo2aGOzcx4GHLU8agTSdb51h1ylcD1ulUXKpEqDIEkWv7leWNteXYTqoj2aUvXQ
+	MH261Yr4HRs5iWT53+FXUrPvY1eipkyG20XH2RcNT7XMMIT29hm5DRVTwU0kzAVU
+	/0hrrSBcgbTJP0KA5zSfO+bFE7fyWSxrjOzt7ugW9KdHlAj5iNAeePRUUlvqSGe7
+	07QprF1ixgWWpsIbUnZdd9UZLPKot8h5Vous/24QLAznqmj/FgipHLT6+Dy61eVq
+	L/T40w==
+Received: from nalasppmta04.qualcomm.com (Global_NAT1.qualcomm.com
+ [129.46.96.20])
+	by mx0a-0031df01.pphosted.com (PPS) with ESMTPS id 41n4jdu9q1-1
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:27 +0000 (GMT)
+Received: from nalasex01a.na.qualcomm.com (nalasex01a.na.qualcomm.com
+ [10.47.209.196])
+	by NALASPPMTA04.qualcomm.com (8.18.1.2/8.18.1.2) with ESMTPS id
+ 48ILL9Ux020570
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:09 GMT
+Received: from ath12k-linux1.qualcomm.com (10.80.80.8) by
+ nalasex01a.na.qualcomm.com (10.47.209.196) with Microsoft SMTP Server
+ (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
+ 15.2.1544.9; Wed, 18 Sep 2024 14:21:08 -0700
+From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+To: <ath12k@lists.infradead.org>
+CC: <linux-wireless@vger.kernel.org>,
+        Pradeep Kumar Chitrapu
+	<quic_pradeepc@quicinc.com>,
+        Jeff Johnson <quic_jjohnson@quicinc.com>
+Subject: [PATCH V8 7/9] wifi: ath12k: clean up 80P80 support
+Date: Wed, 18 Sep 2024 14:20:54 -0700
+Message-ID: <20240918212056.4137076-8-quic_pradeepc@quicinc.com>
+X-Mailer: git-send-email 2.34.1
+In-Reply-To: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+References: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+X-ClientProxiedBy: nasanex01a.na.qualcomm.com (10.52.223.231) To
+ nalasex01a.na.qualcomm.com (10.47.209.196)
+X-QCInternal: smtphost
+X-Proofpoint-Virus-Version: vendor=nai engine=6200 definitions=5800
+ signatures=585085
+X-Proofpoint-ORIG-GUID: zOl2cVhwvoAFaH70WioUIdrk_oIr5c-T
+X-Proofpoint-GUID: zOl2cVhwvoAFaH70WioUIdrk_oIr5c-T
+X-Proofpoint-Virus-Version: vendor=baseguard
+ engine=ICAP:2.0.293,Aquarius:18.0.1039,Hydra:6.0.680,FMLib:17.12.60.29
+ definitions=2024-09-06_09,2024-09-06_01,2024-09-02_01
+X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
+ phishscore=0 impostorscore=0
+ clxscore=1015 adultscore=0 mlxscore=0 suspectscore=0 malwarescore=0
+ priorityscore=1501 spamscore=0 bulkscore=0 lowpriorityscore=0
+ mlxlogscore=999 classifier=spam adjust=0 reason=mlx scancount=1
+ engine=8.19.0-2408220000 definitions=main-2409180141
+
+Clean up unused 80P80 references as hardware does not support
+it. This is applicable to both QCN9274 and WCN7850.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
+---
+ drivers/net/wireless/ath/ath12k/mac.c | 51 ++++++---------------------
+ drivers/net/wireless/ath/ath12k/wmi.c |  5 +--
+ drivers/net/wireless/ath/ath12k/wmi.h |  1 -
+ 3 files changed, 11 insertions(+), 46 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -206,7 +206,7 @@ ath12k_phymodes[NUM_NL80211_BANDS][ATH12
+ 			[NL80211_CHAN_WIDTH_40] = MODE_11BE_EHT40,
+ 			[NL80211_CHAN_WIDTH_80] = MODE_11BE_EHT80,
+ 			[NL80211_CHAN_WIDTH_160] = MODE_11BE_EHT160,
+-			[NL80211_CHAN_WIDTH_80P80] = MODE_11BE_EHT80_80,
++			[NL80211_CHAN_WIDTH_80P80] = MODE_UNKNOWN,
+ 			[NL80211_CHAN_WIDTH_320] = MODE_11BE_EHT320,
+ 	},
+ 	[NL80211_BAND_6GHZ] = {
+@@ -217,7 +217,7 @@ ath12k_phymodes[NUM_NL80211_BANDS][ATH12
+ 			[NL80211_CHAN_WIDTH_40] = MODE_11BE_EHT40,
+ 			[NL80211_CHAN_WIDTH_80] = MODE_11BE_EHT80,
+ 			[NL80211_CHAN_WIDTH_160] = MODE_11BE_EHT160,
+-			[NL80211_CHAN_WIDTH_80P80] = MODE_11BE_EHT80_80,
++			[NL80211_CHAN_WIDTH_80P80] = MODE_UNKNOWN,
+ 			[NL80211_CHAN_WIDTH_320] = MODE_11BE_EHT320,
+ 	},
+ 
+@@ -2390,17 +2390,6 @@ static void ath12k_peer_assoc_h_he(struc
+ 
+ 	switch (sta->deflink.bandwidth) {
+ 	case IEEE80211_STA_RX_BW_160:
+-		if (he_cap->he_cap_elem.phy_cap_info[0] &
+-		    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G) {
+-			v = ath12k_peer_assoc_h_he_limit(v, he_mcs_mask);
+-			arg->peer_he_rx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80_80] = v;
+-
+-			v = le16_to_cpu(he_cap->he_mcs_nss_supp.tx_mcs_80p80);
+-			arg->peer_he_tx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80_80] = v;
+-
+-			arg->peer_he_mcs_count++;
+-			he_tx_mcs = v;
+-		}
+ 		v = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_160);
+ 		arg->peer_he_rx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_160] = v;
+ 
+@@ -2658,16 +2647,11 @@ static enum wmi_phy_mode ath12k_mac_get_
+ 						    struct ieee80211_sta *sta)
+ {
+ 	if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160) {
+-		switch (sta->deflink.vht_cap.cap &
+-			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {
+-		case IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:
++		if (sta->deflink.vht_cap.cap &
++		    IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ)
+ 			return MODE_11AC_VHT160;
+-		case IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:
+-			return MODE_11AC_VHT80_80;
+-		default:
+-			/* not sure if this is a valid case? */
+-			return MODE_11AC_VHT160;
+-		}
++
++		return MODE_UNKNOWN;
+ 	}
+ 
+ 	if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)
+@@ -2689,11 +2673,8 @@ static enum wmi_phy_mode ath12k_mac_get_
+ 		if (sta->deflink.he_cap.he_cap_elem.phy_cap_info[0] &
+ 		     IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G)
+ 			return MODE_11AX_HE160;
+-		else if (sta->deflink.he_cap.he_cap_elem.phy_cap_info[0] &
+-		     IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)
+-			return MODE_11AX_HE80_80;
+-		/* not sure if this is a valid case? */
+-		return MODE_11AX_HE160;
++
++		return MODE_UNKNOWN;
+ 	}
+ 
+ 	if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)
+@@ -2721,14 +2702,7 @@ static enum wmi_phy_mode ath12k_mac_get_
+ 		    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G)
+ 			return MODE_11BE_EHT160;
+ 
+-		if (sta->deflink.he_cap.he_cap_elem.phy_cap_info[0] &
+-			 IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)
+-			return MODE_11BE_EHT80_80;
+-
+-		ath12k_warn(ar->ab, "invalid EHT PHY capability info for 160 Mhz: %d\n",
+-			    sta->deflink.he_cap.he_cap_elem.phy_cap_info[0]);
+-
+-		return MODE_11BE_EHT160;
++		return MODE_UNKNOWN;
+ 	}
+ 
+ 	if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)
+@@ -5806,8 +5780,6 @@ static void ath12k_mac_set_hemcsmap(stru
+ 	mcs_nss->tx_mcs_80 = cpu_to_le16(txmcs_map & 0xffff);
+ 	mcs_nss->rx_mcs_160 = cpu_to_le16(rxmcs_map & 0xffff);
+ 	mcs_nss->tx_mcs_160 = cpu_to_le16(txmcs_map & 0xffff);
+-	mcs_nss->rx_mcs_80p80 = cpu_to_le16(rxmcs_map & 0xffff);
+-	mcs_nss->tx_mcs_80p80 = cpu_to_le16(txmcs_map & 0xffff);
+ }
+ 
+ static void ath12k_mac_copy_he_cap(struct ath12k *ar,
+@@ -5829,6 +5801,7 @@ static void ath12k_mac_copy_he_cap(struc
+ 		IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G |
+ 		IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
+ 		IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
++	/* 80PLUS80 is not supported */
+ 	he_cap_elem->phy_cap_info[0] &=
+ 		~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;
+ 	he_cap_elem->phy_cap_info[5] &=
+@@ -8495,10 +8468,6 @@ static __le16
+ ath12k_mac_get_tx_mcs_map(const struct ieee80211_sta_he_cap *he_cap)
+ {
+ 	if (he_cap->he_cap_elem.phy_cap_info[0] &
+-	    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)
+-		return he_cap->he_mcs_nss_supp.tx_mcs_80p80;
+-
+-	if (he_cap->he_cap_elem.phy_cap_info[0] &
+ 	    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G)
+ 		return he_cap->he_mcs_nss_supp.tx_mcs_160;
+ 
+--- a/drivers/net/wireless/ath/ath12k/wmi.c
++++ b/drivers/net/wireless/ath/ath12k/wmi.c
+@@ -986,10 +986,7 @@ static void ath12k_wmi_put_wmi_channel(s
+ 
+ 	chan->mhz = cpu_to_le32(arg->freq);
+ 	chan->band_center_freq1 = cpu_to_le32(arg->band_center_freq1);
+-	if (arg->mode == MODE_11AC_VHT80_80)
+-		chan->band_center_freq2 = cpu_to_le32(arg->band_center_freq2);
+-	else
+-		chan->band_center_freq2 = 0;
++	chan->band_center_freq2 = 0;
+ 
+ 	chan->info |= le32_encode_bits(arg->mode, WMI_CHAN_INFO_MODE);
+ 	if (arg->passive)
+--- a/drivers/net/wireless/ath/ath12k/wmi.h
++++ b/drivers/net/wireless/ath/ath12k/wmi.h
+@@ -3633,7 +3633,6 @@ struct wmi_vdev_install_key_arg {
+ #define WMI_HOST_MAX_HE_RATE_SET		3
+ #define WMI_HECAP_TXRX_MCS_NSS_IDX_80		0
+ #define WMI_HECAP_TXRX_MCS_NSS_IDX_160		1
+-#define WMI_HECAP_TXRX_MCS_NSS_IDX_80_80	2
+ 
+ struct wmi_rate_set_arg {
+ 	u32 num_rates;
diff --git a/package/kernel/mac80211/patches/ath12k/104-8-wifi-ath12k-add-support-for-160-MHz-bandwidth.patch b/package/kernel/mac80211/patches/ath12k/104-8-wifi-ath12k-add-support-for-160-MHz-bandwidth.patch
new file mode 100644
index 0000000000..e3956385bd
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/104-8-wifi-ath12k-add-support-for-160-MHz-bandwidth.patch
@@ -0,0 +1,399 @@
+From patchwork Wed Sep 18 21:20:55 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+X-Patchwork-Id: 13807216
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mx0b-0031df01.pphosted.com (mx0b-0031df01.pphosted.com
+ [205.220.180.131])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id C64DB1CB518
+	for <linux-wireless@vger.kernel.org>; Wed, 18 Sep 2024 21:21:15 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=205.220.180.131
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1726694477; cv=none;
+ b=aWI5JISgL9c0iB/8EAXYKF/Lb2sJoeG+v5+Va4eb/voqwiSQ4FtwPkCC00b9attXvu4dD9wEHGKPW8Uh2kb1tSTl0uNHxijRmLYK2VUWkLHsZ3Pd6VvGoTpbtmOTgsGklZHZiFd+jyWgGkHB4ZBkHSkG9JH6VR44MSIgNj8g14A=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1726694477; c=relaxed/simple;
+	bh=AYJpDHbXZ0n0NNHQi7/aGcqo7YfyoYhv+FrXZ143wMA=;
+	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
+	 MIME-Version:Content-Type;
+ b=jD1C2mzFvENculg9HS0v02iWUDzrWXiuU5GXTyC/0BKAJirnQkOUdVm7u0AEPiMxfkktLT3QCJLuvnKu3ZqSXWNbc2zOdUHTyW12fKdDNHib1WYYySBnfqu4EmiJKGcTE57VFlVdbklngOCDTCqHvVgP7YitGg2fWLPqBP/4yhM=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com;
+ spf=pass smtp.mailfrom=quicinc.com;
+ dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b=OMqc+btb; arc=none smtp.client-ip=205.220.180.131
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b="OMqc+btb"
+Received: from pps.filterd (m0279872.ppops.net [127.0.0.1])
+	by mx0a-0031df01.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id
+ 48I8sxTR020476;
+	Wed, 18 Sep 2024 21:21:11 GMT
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=quicinc.com; h=
+	cc:content-transfer-encoding:content-type:date:from:in-reply-to
+	:message-id:mime-version:references:subject:to; s=qcppdkim1; bh=
+	dFohRj9vqwjJTRRYk31/1oJCFqLLKUuQ/verxCo/cGo=; b=OMqc+btbHl9cHSxO
+	NauW5WX4C34QsGL/4d03QTtCDlctfB5PRmINiP2/jGcVZk3NZWS3d2f5zjPY7+hd
+	uaUDslDMQwvAj1Jay/we1qNaFIPuzj4c9BbHqvvXa0WiCgQWpBC2h2jcFLXbeVHE
+	5bqH+plXU5cz1d2YbsRpCXsdUWL/+S3u6A6/qxj6UraJ1s/rkE4ndQe/AQuf96Ja
+	ylYiZPdtJJXzB6rPDN1bQsSET/PNXzIkrYTaDLF9A6688WU9izJdAjRcsu8oB8o1
+	U+yftDfoegI7+ZyTZ4JUnQs7zJp171L/qsF0U9RONZCIbSLN9pkTo6xp6CrHGeLQ
+	0tCmwQ==
+Received: from nalasppmta05.qualcomm.com (Global_NAT1.qualcomm.com
+ [129.46.96.20])
+	by mx0a-0031df01.pphosted.com (PPS) with ESMTPS id 41n4j6uagr-1
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:10 +0000 (GMT)
+Received: from nalasex01a.na.qualcomm.com (nalasex01a.na.qualcomm.com
+ [10.47.209.196])
+	by NALASPPMTA05.qualcomm.com (8.18.1.2/8.18.1.2) with ESMTPS id
+ 48ILL9IB009589
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:09 GMT
+Received: from ath12k-linux1.qualcomm.com (10.80.80.8) by
+ nalasex01a.na.qualcomm.com (10.47.209.196) with Microsoft SMTP Server
+ (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
+ 15.2.1544.9; Wed, 18 Sep 2024 14:21:09 -0700
+From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+To: <ath12k@lists.infradead.org>
+CC: <linux-wireless@vger.kernel.org>,
+        Pradeep Kumar Chitrapu
+	<quic_pradeepc@quicinc.com>,
+        P Praneesh <quic_ppranees@quicinc.com>,
+        "Jeff
+ Johnson" <quic_jjohnson@quicinc.com>
+Subject: [PATCH V8 8/9] wifi: ath12k: add support for 160 MHz bandwidth
+Date: Wed, 18 Sep 2024 14:20:55 -0700
+Message-ID: <20240918212056.4137076-9-quic_pradeepc@quicinc.com>
+X-Mailer: git-send-email 2.34.1
+In-Reply-To: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+References: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+X-ClientProxiedBy: nasanex01a.na.qualcomm.com (10.52.223.231) To
+ nalasex01a.na.qualcomm.com (10.47.209.196)
+X-QCInternal: smtphost
+X-Proofpoint-Virus-Version: vendor=nai engine=6200 definitions=5800
+ signatures=585085
+X-Proofpoint-ORIG-GUID: wO0mnzqAAbcWYLNaoEhU3YfsdCyDJ2hk
+X-Proofpoint-GUID: wO0mnzqAAbcWYLNaoEhU3YfsdCyDJ2hk
+X-Proofpoint-Virus-Version: vendor=baseguard
+ engine=ICAP:2.0.293,Aquarius:18.0.1039,Hydra:6.0.680,FMLib:17.12.60.29
+ definitions=2024-09-06_09,2024-09-06_01,2024-09-02_01
+X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
+ phishscore=0 mlxlogscore=999
+ mlxscore=0 malwarescore=0 bulkscore=0 priorityscore=1501 clxscore=1015
+ adultscore=0 suspectscore=0 lowpriorityscore=0 spamscore=0 impostorscore=0
+ classifier=spam adjust=0 reason=mlx scancount=1 engine=8.19.0-2408220000
+ definitions=main-2409180140
+
+Add support to configure maximum NSS in 160 MHz bandwidth.
+Firmware advertises support for handling NSS ratio information
+as a part of service ready ext event using nss_ratio_enabled
+flag. Save this information in ath12k_pdev_cap to calculate
+NSS ratio.
+
+Additionally, reorder the code by moving
+ath12k_peer_assoc_h_phymode() before ath12k_peer_assoc_h_vht()
+to ensure that arg->peer_phymode correctly reflects the bandwidth
+in the max NSS calculation.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1
+
+Co-developed-by: P Praneesh <quic_ppranees@quicinc.com>
+Signed-off-by: P Praneesh <quic_ppranees@quicinc.com>
+Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
+---
+ drivers/net/wireless/ath/ath12k/core.h |  2 +
+ drivers/net/wireless/ath/ath12k/mac.c  | 85 ++++++++++++++++++++++----
+ drivers/net/wireless/ath/ath12k/mac.h  |  2 +
+ drivers/net/wireless/ath/ath12k/wmi.c  | 19 +++++-
+ drivers/net/wireless/ath/ath12k/wmi.h  | 28 +++++++++
+ 5 files changed, 124 insertions(+), 12 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/core.h
++++ b/drivers/net/wireless/ath/ath12k/core.h
+@@ -717,6 +717,8 @@ struct ath12k_pdev_cap {
+ 	u32 tx_chain_mask_shift;
+ 	u32 rx_chain_mask_shift;
+ 	struct ath12k_band_cap band[NUM_NL80211_BANDS];
++	bool nss_ratio_enabled;
++	u8 nss_ratio_info;
+ };
+ 
+ struct mlo_timestamp {
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -2050,6 +2050,34 @@ ath12k_peer_assoc_h_vht_limit(u16 tx_mcs
+ 	return tx_mcs_set;
+ }
+ 
++static u8 ath12k_get_nss_160mhz(struct ath12k *ar,
++				u8 max_nss)
++{
++	u8 nss_ratio_info = ar->pdev->cap.nss_ratio_info;
++	u8 max_sup_nss = 0;
++
++	switch (nss_ratio_info) {
++	case WMI_NSS_RATIO_1BY2_NSS:
++		max_sup_nss = max_nss >> 1;
++		break;
++	case WMI_NSS_RATIO_3BY4_NSS:
++		ath12k_warn(ar->ab, "WMI_NSS_RATIO_3BY4_NSS not supported\n");
++		break;
++	case WMI_NSS_RATIO_1_NSS:
++		max_sup_nss = max_nss;
++		break;
++	case WMI_NSS_RATIO_2_NSS:
++		ath12k_warn(ar->ab, "WMI_NSS_RATIO_2_NSS not supported\n");
++		break;
++	default:
++		ath12k_warn(ar->ab, "invalid nss ratio received from fw: %d\n",
++			    nss_ratio_info);
++		break;
++	}
++
++	return max_sup_nss;
++}
++
+ static void ath12k_peer_assoc_h_vht(struct ath12k *ar,
+ 				    struct ieee80211_vif *vif,
+ 				    struct ieee80211_sta *sta,
+@@ -2065,6 +2093,7 @@ static void ath12k_peer_assoc_h_vht(stru
+ 	u8 max_nss, vht_mcs;
+ 	int i, vht_nss, nss_idx;
+ 	bool user_rate_valid = true;
++	u32 rx_nss, tx_nss, nss_160;
+ 
+ 	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+ 		return;
+@@ -2159,10 +2188,24 @@ static void ath12k_peer_assoc_h_vht(stru
+ 	/* TODO:  Check */
+ 	arg->tx_max_mcs_nss = 0xFF;
+ 
+-	ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac vht peer %pM max_mpdu %d flags 0x%x\n",
+-		   sta->addr, arg->peer_max_mpdu, arg->peer_flags);
++	if (arg->peer_phymode == MODE_11AC_VHT160) {
++		tx_nss = ath12k_get_nss_160mhz(ar, max_nss);
++		rx_nss = min(arg->peer_nss, tx_nss);
++		arg->peer_bw_rxnss_override = ATH12K_BW_NSS_MAP_ENABLE;
+ 
+-	/* TODO: rxnss_override */
++		if (!rx_nss) {
++			ath12k_warn(ar->ab, "invalid max_nss\n");
++			return;
++		}
++
++		nss_160 = u32_encode_bits(rx_nss - 1, ATH12K_PEER_RX_NSS_160MHZ);
++		arg->peer_bw_rxnss_override |= nss_160;
++	}
++
++	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
++		   "mac vht peer %pM max_mpdu %d flags 0x%x nss_override 0x%x\n",
++		   sta->addr, arg->peer_max_mpdu, arg->peer_flags,
++		   arg->peer_bw_rxnss_override);
+ }
+ 
+ static int ath12k_mac_get_max_he_mcs_map(u16 mcs_map, int nss)
+@@ -2251,6 +2294,7 @@ static void ath12k_peer_assoc_h_he(struc
+ 	u16 he_tx_mcs = 0, v = 0;
+ 	int he_nss, nss_idx;
+ 	bool user_rate_valid = true;
++	u32 rx_nss, tx_nss, nss_160;
+ 
+ 	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+ 		return;
+@@ -2429,11 +2473,28 @@ static void ath12k_peer_assoc_h_he(struc
+ 		    he_mcs_mask[i])
+ 			max_nss = i + 1;
+ 	}
++	max_nss = min(max_nss, ar->num_tx_chains);
+ 	arg->peer_nss = min(sta->deflink.rx_nss, max_nss);
+ 
++	if (arg->peer_phymode == MODE_11AX_HE160) {
++		tx_nss = ath12k_get_nss_160mhz(ar, max_nss);
++		rx_nss = min(arg->peer_nss, tx_nss);
++		arg->peer_bw_rxnss_override = ATH12K_BW_NSS_MAP_ENABLE;
++
++		if (!rx_nss) {
++			ath12k_warn(ar->ab, "invalid max_nss\n");
++			return;
++		}
++
++		nss_160 = u32_encode_bits(rx_nss - 1, ATH12K_PEER_RX_NSS_160MHZ);
++		arg->peer_bw_rxnss_override |= nss_160;
++	}
++
+ 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
+-		   "mac he peer %pM nss %d mcs cnt %d\n",
+-		   sta->deflink.addr, arg->peer_nss, arg->peer_he_mcs_count);
++		   "mac he peer %pM nss %d mcs cnt %d nss_override 0x%x\n",
++		   sta->deflink.addr, arg->peer_nss,
++		   arg->peer_he_mcs_count,
++		   arg->peer_bw_rxnss_override);
+ }
+ 
+ static void ath12k_peer_assoc_h_he_6ghz(struct ath12k *ar,
+@@ -2965,13 +3026,13 @@ static void ath12k_peer_assoc_prepare(st
+ 	ath12k_peer_assoc_h_basic(ar, vif, sta, arg);
+ 	ath12k_peer_assoc_h_crypto(ar, vif, sta, arg);
+ 	ath12k_peer_assoc_h_rates(ar, vif, sta, arg);
++	ath12k_peer_assoc_h_phymode(ar, vif, sta, arg);
+ 	ath12k_peer_assoc_h_ht(ar, vif, sta, arg);
+ 	ath12k_peer_assoc_h_vht(ar, vif, sta, arg);
+ 	ath12k_peer_assoc_h_he(ar, vif, sta, arg);
+ 	ath12k_peer_assoc_h_he_6ghz(ar, vif, sta, arg);
+ 	ath12k_peer_assoc_h_eht(ar, vif, sta, arg);
+ 	ath12k_peer_assoc_h_qos(ar, vif, sta, arg);
+-	ath12k_peer_assoc_h_phymode(ar, vif, sta, arg);
+ 	ath12k_peer_assoc_h_smps(sta, arg);
+ 
+ 	/* TODO: amsdu_disable req? */
+@@ -5552,10 +5613,8 @@ ath12k_create_vht_cap(struct ath12k *ar,
+ 
+ 	ath12k_set_vht_txbf_cap(ar, &vht_cap.cap);
+ 
+-	/* TODO: Enable back VHT160 mode once association issues are fixed */
+-	/* Disabling VHT160 and VHT80+80 modes */
+-	vht_cap.cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;
+-	vht_cap.cap &= ~IEEE80211_VHT_CAP_SHORT_GI_160;
++	/* 80P80 is not supported */
++	vht_cap.cap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ;
+ 
+ 	rxmcs_map = 0;
+ 	txmcs_map = 0;
+@@ -9711,7 +9770,8 @@ static int ath12k_mac_setup_iface_combin
+ 	combinations[0].radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+ 						BIT(NL80211_CHAN_WIDTH_20) |
+ 						BIT(NL80211_CHAN_WIDTH_40) |
+-						BIT(NL80211_CHAN_WIDTH_80);
++						BIT(NL80211_CHAN_WIDTH_80) |
++						BIT(NL80211_CHAN_WIDTH_160);
+ 
+ 	wiphy->iface_combinations = combinations;
+ 	wiphy->n_iface_combinations = 1;
+@@ -9927,6 +9987,9 @@ static int ath12k_mac_hw_register(struct
+ 	ieee80211_hw_set(hw, SUPPORTS_TX_FRAG);
+ 	ieee80211_hw_set(hw, REPORTS_LOW_ACK);
+ 
++	if (cap->nss_ratio_enabled)
++		ieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);
++
+ 	if ((ht_cap & WMI_HT_CAP_ENABLED) || ar->supports_6ghz) {
+ 		ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+ 		ieee80211_hw_set(hw, TX_AMPDU_SETUP_IN_HW);
+--- a/drivers/net/wireless/ath/ath12k/mac.h
++++ b/drivers/net/wireless/ath/ath12k/mac.h
+@@ -37,6 +37,8 @@ struct ath12k_generic_iter {
+ #define IEEE80211_DISABLE_VHT_MCS_SUPPORT_0_11	BIT(24)
+ 
+ #define ATH12K_CHAN_WIDTH_NUM			14
++#define ATH12K_BW_NSS_MAP_ENABLE		BIT(31)
++#define ATH12K_PEER_RX_NSS_160MHZ		GENMASK(2, 0)
+ 
+ #define ATH12K_TX_POWER_MAX_VAL	70
+ #define ATH12K_TX_POWER_MIN_VAL	0
+--- a/drivers/net/wireless/ath/ath12k/wmi.c
++++ b/drivers/net/wireless/ath/ath12k/wmi.c
+@@ -525,6 +525,10 @@ ath12k_pull_mac_phy_cap_svc_ready_ext(st
+ 		pdev_cap->he_mcs = le32_to_cpu(mac_caps->he_supp_mcs_5g);
+ 		pdev_cap->tx_chain_mask = le32_to_cpu(mac_caps->tx_chain_mask_5g);
+ 		pdev_cap->rx_chain_mask = le32_to_cpu(mac_caps->rx_chain_mask_5g);
++		pdev_cap->nss_ratio_enabled =
++			WMI_NSS_RATIO_EN_DIS_GET(mac_caps->nss_ratio);
++		pdev_cap->nss_ratio_info =
++			WMI_NSS_RATIO_INFO_GET(mac_caps->nss_ratio);
+ 	} else {
+ 		return -EINVAL;
+ 	}
+@@ -982,11 +986,24 @@ int ath12k_wmi_vdev_down(struct ath12k *
+ static void ath12k_wmi_put_wmi_channel(struct ath12k_wmi_channel_params *chan,
+ 				       struct wmi_vdev_start_req_arg *arg)
+ {
++	u32 center_freq1 = arg->band_center_freq1;
++
+ 	memset(chan, 0, sizeof(*chan));
+ 
+ 	chan->mhz = cpu_to_le32(arg->freq);
+ 	chan->band_center_freq1 = cpu_to_le32(arg->band_center_freq1);
+-	chan->band_center_freq2 = 0;
++	if (arg->mode == MODE_11AX_HE160) {
++		if (arg->freq > center_freq1)
++			chan->band_center_freq1 =
++					cpu_to_le32(center_freq1 + 40);
++		else
++			chan->band_center_freq1 =
++					cpu_to_le32(center_freq1 - 40);
++
++		chan->band_center_freq2 = cpu_to_le32(arg->band_center_freq1);
++	} else {
++		chan->band_center_freq2 = 0;
++	}
+ 
+ 	chan->info |= le32_encode_bits(arg->mode, WMI_CHAN_INFO_MODE);
+ 	if (arg->passive)
+--- a/drivers/net/wireless/ath/ath12k/wmi.h
++++ b/drivers/net/wireless/ath/ath12k/wmi.h
+@@ -2264,6 +2264,21 @@ enum wmi_direct_buffer_module {
+ 	WMI_DIRECT_BUF_MAX
+ };
+ 
++/**
++ * enum wmi_nss_ratio - NSS ratio received from FW during service ready ext event
++ * @WMI_NSS_RATIO_1BY2_NSS: Max nss of 160MHz is equals to half of the max nss of 80MHz
++ * @WMI_NSS_RATIO_3BY4_NSS: Max nss of 160MHz is equals to 3/4 of the max nss of 80MHz
++ * @WMI_NSS_RATIO_1_NSS: Max nss of 160MHz is equals to the max nss of 80MHz
++ * @WMI_NSS_RATIO_2_NSS: Max nss of 160MHz is equals to two times the max nss of 80MHz
++ */
++
++enum wmi_nss_ratio {
++	WMI_NSS_RATIO_1BY2_NSS,
++	WMI_NSS_RATIO_3BY4_NSS,
++	WMI_NSS_RATIO_1_NSS,
++	WMI_NSS_RATIO_2_NSS
++};
++
+ struct ath12k_wmi_pdev_band_arg {
+ 	u32 pdev_id;
+ 	u32 start_freq;
+@@ -2580,6 +2595,12 @@ struct ath12k_wmi_hw_mode_cap_params {
+ } __packed;
+ 
+ #define WMI_MAX_HECAP_PHY_SIZE                 (3)
++#define WMI_NSS_RATIO_EN_DIS_BITPOS    BIT(0)
++#define WMI_NSS_RATIO_EN_DIS_GET(_val) \
++	le32_get_bits(_val, WMI_NSS_RATIO_EN_DIS_BITPOS)
++#define WMI_NSS_RATIO_INFO_BITPOS              GENMASK(4, 1)
++#define WMI_NSS_RATIO_INFO_GET(_val) \
++	le32_get_bits(_val, WMI_NSS_RATIO_INFO_BITPOS)
+ 
+ /* pdev_id is present in lower 16 bits of pdev_and_hw_link_ids in
+  * ath12k_wmi_mac_phy_caps_params & ath12k_wmi_caps_ext_params.
+@@ -2621,6 +2642,13 @@ struct ath12k_wmi_mac_phy_caps_params {
+ 	__le32 he_cap_info_2g_ext;
+ 	__le32 he_cap_info_5g_ext;
+ 	__le32 he_cap_info_internal;
++	__le32 wireless_modes;
++	__le32 low_2ghz_chan_freq;
++	__le32 high_2ghz_chan_freq;
++	__le32 low_5ghz_chan_freq;
++	__le32 high_5ghz_chan_freq;
++	__le32 nss_ratio;
++
+ } __packed;
+ 
+ struct ath12k_wmi_hal_reg_caps_ext_params {
diff --git a/package/kernel/mac80211/patches/ath12k/104-9-wifi-ath12k-add-extended-NSS-bandwidth-support-for-160-MHz.patch b/package/kernel/mac80211/patches/ath12k/104-9-wifi-ath12k-add-extended-NSS-bandwidth-support-for-160-MHz.patch
new file mode 100644
index 0000000000..709ef8ecc4
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath12k/104-9-wifi-ath12k-add-extended-NSS-bandwidth-support-for-160-MHz.patch
@@ -0,0 +1,191 @@
+From patchwork Wed Sep 18 21:20:56 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+X-Patchwork-Id: 13807214
+X-Patchwork-Delegate: quic_jjohnson@quicinc.com
+Received: from mx0a-0031df01.pphosted.com (mx0a-0031df01.pphosted.com
+ [205.220.168.131])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id A44471CB32B
+	for <linux-wireless@vger.kernel.org>; Wed, 18 Sep 2024 21:21:14 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=205.220.168.131
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1726694476; cv=none;
+ b=YnQUUZ4IfmLtgtYCtYRGhH8uRGd6VL74IRylGv6Ihb2PMO/n5UdfZlDk/m9w0OH4/sSsqULSz2lupiSTwXCPxc+73uK+OUjIEmCfPlNdrtzK2naXyiXAASPqonpnRBnyoIFwaE8zj8AHUqk5TAajedqpK9EnOaboX2XGYVbe0yI=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1726694476; c=relaxed/simple;
+	bh=TAPBD6g5pYNuC8Odk6t6JkL8GvKdG9H30IPHTEgA7C0=;
+	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
+	 MIME-Version:Content-Type;
+ b=djAINL+wQRgQaGOI4fotrExnm1Yz5quwEW2I7s85hWLI3gB+HsjwPKWJypllDKm8W0FDcrsoZWFmOrfx0wJ5LIe+OtXJ4ijSG7xcJeGtgDXZ3hAA5ZBk/B+CD+g+NZ3c0mwkSKpUm5dUBPKi1+kJsPuVEwKeCmdMVj8QHSYMXPw=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com;
+ spf=pass smtp.mailfrom=quicinc.com;
+ dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b=i4iTJD+Z; arc=none smtp.client-ip=205.220.168.131
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=quicinc.com
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=quicinc.com header.i=@quicinc.com
+ header.b="i4iTJD+Z"
+Received: from pps.filterd (m0279863.ppops.net [127.0.0.1])
+	by mx0a-0031df01.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id
+ 48I9VJ15022098;
+	Wed, 18 Sep 2024 21:21:11 GMT
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=quicinc.com; h=
+	cc:content-transfer-encoding:content-type:date:from:in-reply-to
+	:message-id:mime-version:references:subject:to; s=qcppdkim1; bh=
+	2gwv4CbPGErAHv9NWtZrCSVk7NoZpHzKz9tuTs+8dV4=; b=i4iTJD+ZMXDp8Ul8
+	HTo5IL/NLwS3mnlutEaaL+juUKm+wsFdl/BeMp9CC4H/sapolIhM4Zje9t3H9K0R
+	+z1OxQDEekvWrrfUlikEaUHjOEwQ4YKSPJ+1uAIrbbA3REWeW5z39IITJ3dGU05N
+	hnfPQEiFcPgDbFQv0Iaf434znv8rbOow6dc+M1E6EjpGd92Mq80BpsJqP8Ee0RUr
+	WO3rsws1kXzFs6ELsg/FmC3l6eG9A4z9SUxcZ7QqTaz8aPOAZS/lclN0cOJT7VgK
+	7UNPGoDoJhTmHEX17W/rQR8RiV8c0hMciOuB1sfI7H/1uGkEPMjmfIsEdBjQ/9oa
+	DDiHrg==
+Received: from nalasppmta02.qualcomm.com (Global_NAT1.qualcomm.com
+ [129.46.96.20])
+	by mx0a-0031df01.pphosted.com (PPS) with ESMTPS id 41n4hfk92c-1
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:11 +0000 (GMT)
+Received: from nalasex01a.na.qualcomm.com (nalasex01a.na.qualcomm.com
+ [10.47.209.196])
+	by NALASPPMTA02.qualcomm.com (8.18.1.2/8.18.1.2) with ESMTPS id
+ 48ILLA0u011397
+	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NOT);
+	Wed, 18 Sep 2024 21:21:10 GMT
+Received: from ath12k-linux1.qualcomm.com (10.80.80.8) by
+ nalasex01a.na.qualcomm.com (10.47.209.196) with Microsoft SMTP Server
+ (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
+ 15.2.1544.9; Wed, 18 Sep 2024 14:21:09 -0700
+From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+To: <ath12k@lists.infradead.org>
+CC: <linux-wireless@vger.kernel.org>,
+        Pradeep Kumar Chitrapu
+	<quic_pradeepc@quicinc.com>,
+        Jeff Johnson <quic_jjohnson@quicinc.com>
+Subject: [PATCH V8 9/9] wifi: ath12k: add extended NSS bandwidth support for
+ 160 MHz
+Date: Wed, 18 Sep 2024 14:20:56 -0700
+Message-ID: <20240918212056.4137076-10-quic_pradeepc@quicinc.com>
+X-Mailer: git-send-email 2.34.1
+In-Reply-To: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+References: <20240918212056.4137076-1-quic_pradeepc@quicinc.com>
+Precedence: bulk
+X-Mailing-List: linux-wireless@vger.kernel.org
+List-Id: <linux-wireless.vger.kernel.org>
+List-Subscribe: <mailto:linux-wireless+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-wireless+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+X-ClientProxiedBy: nasanex01a.na.qualcomm.com (10.52.223.231) To
+ nalasex01a.na.qualcomm.com (10.47.209.196)
+X-QCInternal: smtphost
+X-Proofpoint-Virus-Version: vendor=nai engine=6200 definitions=5800
+ signatures=585085
+X-Proofpoint-GUID: Mta6b5FqdCLrvsiUf1WwMHFr8SiJUh5L
+X-Proofpoint-ORIG-GUID: Mta6b5FqdCLrvsiUf1WwMHFr8SiJUh5L
+X-Proofpoint-Virus-Version: vendor=baseguard
+ engine=ICAP:2.0.293,Aquarius:18.0.1039,Hydra:6.0.680,FMLib:17.12.60.29
+ definitions=2024-09-06_09,2024-09-06_01,2024-09-02_01
+X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
+ priorityscore=1501
+ clxscore=1015 phishscore=0 malwarescore=0 mlxlogscore=999 mlxscore=0
+ impostorscore=0 adultscore=0 suspectscore=0 lowpriorityscore=0 spamscore=0
+ bulkscore=0 classifier=spam adjust=0 reason=mlx scancount=1
+ engine=8.19.0-2408220000 definitions=main-2409180140
+
+Currently rx and tx MCS map for 160 MHz under HE capabilities
+are not updating properly, when 160 MHz is configured with NSS
+lesser than max NSS support. Fix this by utilizing
+nss_ratio_enabled and nss_ratio_info fields sent by firmware
+in service ready event.
+
+However, if firmware advertises EXT NSS BW support in VHT caps
+as 1(1x2) and when nss_ratio_info indicates 1:1, reset the EXT
+NSS BW Support in VHT caps to 0 which indicates 1x1. This is
+to avoid incorrectly choosing 1:2 NSS ratio when using the
+default VHT caps advertised by firmware.
+
+Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1
+
+Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
+Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
+---
+ drivers/net/wireless/ath/ath12k/mac.c | 33 ++++++++++++++++++++++-----
+ 1 file changed, 27 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -2477,8 +2477,10 @@ static void ath12k_peer_assoc_h_he(struc
+ 	arg->peer_nss = min(sta->deflink.rx_nss, max_nss);
+ 
+ 	if (arg->peer_phymode == MODE_11AX_HE160) {
+-		tx_nss = ath12k_get_nss_160mhz(ar, max_nss);
++		tx_nss = ath12k_get_nss_160mhz(ar, ar->num_tx_chains);
+ 		rx_nss = min(arg->peer_nss, tx_nss);
++
++		arg->peer_nss = min(sta->deflink.rx_nss, ar->num_rx_chains);
+ 		arg->peer_bw_rxnss_override = ATH12K_BW_NSS_MAP_ENABLE;
+ 
+ 		if (!rx_nss) {
+@@ -5636,6 +5638,12 @@ ath12k_create_vht_cap(struct ath12k *ar,
+ 	vht_cap.vht_mcs.rx_mcs_map = cpu_to_le16(rxmcs_map);
+ 	vht_cap.vht_mcs.tx_mcs_map = cpu_to_le16(txmcs_map);
+ 
++	/* Check if the HW supports 1:1 NSS ratio and reset
++	 * EXT NSS BW Support field to 0 to indicate 1:1 ratio
++	 */
++	if (ar->pdev->cap.nss_ratio_info == WMI_NSS_RATIO_1_NSS)
++		vht_cap.cap &= ~IEEE80211_VHT_CAP_EXT_NSS_BW_MASK;
++
+ 	return vht_cap;
+ }
+ 
+@@ -5816,11 +5824,12 @@ static void ath12k_mac_set_hemcsmap(stru
+ 				    struct ieee80211_sta_he_cap *he_cap)
+ {
+ 	struct ieee80211_he_mcs_nss_supp *mcs_nss = &he_cap->he_mcs_nss_supp;
+-	u16 txmcs_map, rxmcs_map;
++	u8 maxtxnss_160 = ath12k_get_nss_160mhz(ar, ar->num_tx_chains);
++	u8 maxrxnss_160 = ath12k_get_nss_160mhz(ar, ar->num_rx_chains);
++	u16 txmcs_map_160 = 0, rxmcs_map_160 = 0;
++	u16 txmcs_map = 0, rxmcs_map = 0;
+ 	u32 i;
+ 
+-	rxmcs_map = 0;
+-	txmcs_map = 0;
+ 	for (i = 0; i < 8; i++) {
+ 		if (i < ar->num_tx_chains &&
+ 		    (ar->cfg_tx_chainmask >> cap->tx_chain_mask_shift) & BIT(i))
+@@ -5833,12 +5842,24 @@ static void ath12k_mac_set_hemcsmap(stru
+ 			rxmcs_map |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);
+ 		else
+ 			rxmcs_map |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);
++
++		if (i < maxtxnss_160 &&
++		    (ar->cfg_tx_chainmask >> cap->tx_chain_mask_shift) & BIT(i))
++			txmcs_map_160 |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);
++		else
++			txmcs_map_160 |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);
++
++		if (i < maxrxnss_160 &&
++		    (ar->cfg_tx_chainmask >> cap->tx_chain_mask_shift) & BIT(i))
++			rxmcs_map_160 |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);
++		else
++			rxmcs_map_160 |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);
+ 	}
+ 
+ 	mcs_nss->rx_mcs_80 = cpu_to_le16(rxmcs_map & 0xffff);
+ 	mcs_nss->tx_mcs_80 = cpu_to_le16(txmcs_map & 0xffff);
+-	mcs_nss->rx_mcs_160 = cpu_to_le16(rxmcs_map & 0xffff);
+-	mcs_nss->tx_mcs_160 = cpu_to_le16(txmcs_map & 0xffff);
++	mcs_nss->rx_mcs_160 = cpu_to_le16(rxmcs_map_160 & 0xffff);
++	mcs_nss->tx_mcs_160 = cpu_to_le16(txmcs_map_160 & 0xffff);
+ }
+ 
+ static void ath12k_mac_copy_he_cap(struct ath12k *ar,
diff --git a/package/kernel/mac80211/patches/ath9k/341-wifi-ath9k-obtain-system-gpios.patch b/package/kernel/mac80211/patches/ath9k/341-wifi-ath9k-obtain-system-gpios.patch
new file mode 100644
index 0000000000..4feb748229
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath9k/341-wifi-ath9k-obtain-system-gpios.patch
@@ -0,0 +1,273 @@
+From patchwork Tue Apr 23 12:12:33 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Linus Walleij <linus.walleij@linaro.org>
+X-Patchwork-Id: 1926515
+Return-Path: 
+ <linux-gpio+bounces-5755-incoming=patchwork.ozlabs.org@vger.kernel.org>
+X-Original-To: incoming@patchwork.ozlabs.org
+Delivered-To: patchwork-incoming@legolas.ozlabs.org
+Authentication-Results: legolas.ozlabs.org;
+	dkim=pass (2048-bit key;
+ unprotected) header.d=linaro.org header.i=@linaro.org header.a=rsa-sha256
+ header.s=google header.b=qX99TQMM;
+	dkim-atps=neutral
+Authentication-Results: legolas.ozlabs.org;
+ spf=pass (sender SPF authorized) smtp.mailfrom=vger.kernel.org
+ (client-ip=2604:1380:45e3:2400::1; helo=sv.mirrors.kernel.org;
+ envelope-from=linux-gpio+bounces-5755-incoming=patchwork.ozlabs.org@vger.kernel.org;
+ receiver=patchwork.ozlabs.org)
+Received: from sv.mirrors.kernel.org (sv.mirrors.kernel.org
+ [IPv6:2604:1380:45e3:2400::1])
+	(using TLSv1.3 with cipher TLS_AES_256_GCM_SHA384 (256/256 bits)
+	 key-exchange X25519 server-signature ECDSA (secp384r1))
+	(No client certificate requested)
+	by legolas.ozlabs.org (Postfix) with ESMTPS id 4VP1Gc6RZKz1yZP
+	for <incoming@patchwork.ozlabs.org>; Tue, 23 Apr 2024 22:12:56 +1000 (AEST)
+Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org
+ [52.25.139.140])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
+	(No client certificate requested)
+	by sv.mirrors.kernel.org (Postfix) with ESMTPS id 5BB9C28522A
+	for <incoming@patchwork.ozlabs.org>; Tue, 23 Apr 2024 12:12:55 +0000 (UTC)
+Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
+	by smtp.subspace.kernel.org (Postfix) with ESMTP id 2F83B8563D;
+	Tue, 23 Apr 2024 12:12:41 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+	dkim=pass (2048-bit key) header.d=linaro.org header.i=@linaro.org
+ header.b="qX99TQMM"
+X-Original-To: linux-gpio@vger.kernel.org
+Received: from mail-lj1-f179.google.com (mail-lj1-f179.google.com
+ [209.85.208.179])
+	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
+	(No client certificate requested)
+	by smtp.subspace.kernel.org (Postfix) with ESMTPS id A8F3C82865
+	for <linux-gpio@vger.kernel.org>; Tue, 23 Apr 2024 12:12:37 +0000 (UTC)
+Authentication-Results: smtp.subspace.kernel.org;
+ arc=none smtp.client-ip=209.85.208.179
+ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
+	t=1713874361; cv=none;
+ b=d6RcvcAu8hBYAK8Io489ZHQpJVXPwuokP6iMcAkbvElCerbXD6jAdqdi+RjDlo5C49GHGO4FQ19UwQn/VE//qSwiK1ulTSBp3OkvAmyb7yYAFnDs9AVNWRw+5/NxeFNn3fj5PyvqVymIbaJKabfrOVNwkz/5JMHxEIJtr6Crmog=
+ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
+	s=arc-20240116; t=1713874361; c=relaxed/simple;
+	bh=0eXJ5AIjzz1TBGZ8SlshIPrEHZaZwZfYEdof+dSpu4Y=;
+	h=From:Date:Subject:MIME-Version:Content-Type:Message-Id:To:Cc;
+ b=EfFtruUxRIGy+jylEiJ2rPEyPCjGCc8ptT9FVxe6s0O/kW38Y6196xVQeiSV2tSKVCEOIO+9HoqmpgdKsJE7gU9++EcrasP96MYpsklYpc2zsWW3b8QEhfxfZ9Ai/idyYihE2u9dQ7a143P/Ij/twDrZTt24wO/mtHDrE5XcCFI=
+ARC-Authentication-Results: i=1; smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=linaro.org;
+ spf=pass smtp.mailfrom=linaro.org;
+ dkim=pass (2048-bit key) header.d=linaro.org header.i=@linaro.org
+ header.b=qX99TQMM; arc=none smtp.client-ip=209.85.208.179
+Authentication-Results: smtp.subspace.kernel.org;
+ dmarc=pass (p=none dis=none) header.from=linaro.org
+Authentication-Results: smtp.subspace.kernel.org;
+ spf=pass smtp.mailfrom=linaro.org
+Received: by mail-lj1-f179.google.com with SMTP id
+ 38308e7fff4ca-2dd041acff1so40839131fa.1
+        for <linux-gpio@vger.kernel.org>;
+ Tue, 23 Apr 2024 05:12:37 -0700 (PDT)
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
+        d=linaro.org; s=google; t=1713874356; x=1714479156;
+ darn=vger.kernel.org;
+        h=cc:to:message-id:content-transfer-encoding:mime-version:subject
+         :date:from:from:to:cc:subject:date:message-id:reply-to;
+        bh=vysJsMiH5IVqdTs4yMwZxZ7nUmt2aG7eBhkn8qm8hvI=;
+        b=qX99TQMMdHbskFYUaw8c93sIJsUhKmj/WPdyahHcupUhwn5wol4aVoPczkOKYwJZhE
+         eoInxzjAHIl3UNKyvPPrD4MrbLcSoFT6mTFMsgRQYUghsLattmGcqIebu9XT556dBhsf
+         DydmpqGgnTOIa+IEknFxg24mo8Xn2LVmDC7LSGEYykUy1xLHd1NSq56YEaYXC7641xeZ
+         9TOL0rZszeGld5cCS3013EmEeXQGCC3lAP83Eb48vbFXjPojkN0s40rZ2s8YpVsGT0iP
+         LeLVtP/E8XJqi4YipKryKSgbgOvQ1Bclle5+s+2qcJQNnSEjekMwR59BIRs3OZH2SRfN
+         gQdQ==
+X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
+        d=1e100.net; s=20230601; t=1713874356; x=1714479156;
+        h=cc:to:message-id:content-transfer-encoding:mime-version:subject
+         :date:from:x-gm-message-state:from:to:cc:subject:date:message-id
+         :reply-to;
+        bh=vysJsMiH5IVqdTs4yMwZxZ7nUmt2aG7eBhkn8qm8hvI=;
+        b=jEBH4NQ7SzFi2tnb1lgL06IchnBJoscNgKesjlorvou6X/9wDE/VbgxNFKR0zWwdTk
+         BEjG/ifFJxLmM9jdaCKu5cJc4yiDNXp7yZd48D71V34zJ4aINAGAx4hcOKqf95neFknx
+         nsFPpBFnTYFEpCLF0TebVoL6h6ehPzSojmkArzsrMppNvW2cwJ5gDlkqy2y4SezLanmM
+         6iU0ksnwE0bb2iLkahhgo00Ejt33yqxwa+3xBfhOe9oYKSSZYnY7qVq055SSwt9IAq+H
+         REGyJN+GrvupTHagiioYe3LPXDPdOui9ZixXXDllw1t1yGUy+TkJu8xSqtvHEfg81FHP
+         AxtA==
+X-Forwarded-Encrypted: i=1;
+ AJvYcCUbxzPklfPYrLgyY1I0ycuj7Dh04dcGVonYocA2mzxzlAEV107o0ELlFqr3O9Td+tV/t0eV9ly9YAbTY6n1XPnFXS5dsYYAZw6RHw==
+X-Gm-Message-State: AOJu0YxsC7zdakTzntbiRFnN2A7yTrR0x+IpR6ce6eGn5kHeqIBi1km+
+	zTVpRulbch3JsmzVDbCbbAAYoBkNgEA568YL6zdjVARnvFwNz1cqatOrR1AXUm0=
+X-Google-Smtp-Source: 
+ AGHT+IHBRMGvaJM98f86Z6m/RfVhK2XejjNGF3EvcRq/4x3oGM0DKpd2PbeCJdgmzHjLPVVbdsNzJg==
+X-Received: by 2002:a2e:9852:0:b0:2d8:a98d:18e with SMTP id
+ e18-20020a2e9852000000b002d8a98d018emr7955886ljj.8.1713874355700;
+        Tue, 23 Apr 2024 05:12:35 -0700 (PDT)
+Received: from [192.168.1.140] ([85.235.12.238])
+        by smtp.gmail.com with ESMTPSA id
+ x6-20020a2e7c06000000b002da179d8d25sm1628982ljc.64.2024.04.23.05.12.33
+        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
+        Tue, 23 Apr 2024 05:12:35 -0700 (PDT)
+From: Linus Walleij <linus.walleij@linaro.org>
+Date: Tue, 23 Apr 2024 14:12:33 +0200
+Subject: [PATCH v2] wifi: ath9k: Obtain system GPIOS from descriptors
+Precedence: bulk
+X-Mailing-List: linux-gpio@vger.kernel.org
+List-Id: <linux-gpio.vger.kernel.org>
+List-Subscribe: <mailto:linux-gpio+subscribe@vger.kernel.org>
+List-Unsubscribe: <mailto:linux-gpio+unsubscribe@vger.kernel.org>
+MIME-Version: 1.0
+Message-Id: <20240423-descriptors-wireless-v2-1-6d1d03b30bfa@linaro.org>
+X-B4-Tracking: v=1; b=H4sIALClJ2YC/22Nyw6CMBBFf4XM2hpanrLyPwyL0o4wCaFkxqCG9
+ N+txKXLc5Nz7g6CTCjQZTswbiQUlgTmlIGb7DKiIp8YTG7KXBujPIpjWh+BRT2JcUYRNbTeXir
+ v7FBUkNSV8U6vI3vrE08kSXgfL5v+rr9gof8HN61yhdo1rvJ125T1dabFcjgHHqGPMX4Ao4iiN
+ LkAAAA=
+To: Kalle Valo <kvalo@kernel.org>,
+  Andy Shevchenko <andriy.shevchenko@linux.intel.com>,
+  Arnd Bergmann <arnd@arndb.de>, Alban Bedel <albeu@free.fr>,
+  Bartosz Golaszewski <brgl@bgdev.pl>, =?utf-8?q?Toke_H=C3=B8iland-J=C3=B8rg?=
+	=?utf-8?q?ensen?= <toke@toke.dk>
+Cc: linux-wireless@vger.kernel.org, brcm80211-dev-list.pdl@broadcom.com,
+ linux-gpio@vger.kernel.org, Linus Walleij <linus.walleij@linaro.org>
+X-Mailer: b4 0.13.0
+
+The ath9k has an odd use of system-wide GPIOs: if the chip
+does not have internal GPIO capability, it will try to obtain a
+GPIO line from the system GPIO controller:
+
+  if (BIT(gpio) & ah->caps.gpio_mask)
+        ath9k_hw_gpio_cfg_wmac(...);
+  else if (AR_SREV_SOC(ah))
+        ath9k_hw_gpio_cfg_soc(ah, gpio, out, label);
+
+Where ath9k_hw_gpio_cfg_soc() will attempt to issue
+gpio_request_one() passing the local GPIO number of the controller
+(0..31) to gpio_request_one().
+
+This is somewhat peculiar and possibly even dangerous: there is
+nowadays no guarantee of the numbering of these system-wide
+GPIOs, and assuming that GPIO 0..31 as used by ath9k would
+correspond to GPIOs 0..31 on the system as a whole seems a bit
+wild.
+
+Register all 32 GPIOs at index 0..31 directly in the ATH79K
+GPIO driver and associate with WIFI if and only if we are probing
+ATH79K wifi from the AHB bus (used for SoCs).
+
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+Changes in v2:
+- Define all the descriptors directly in the ATH79K
+  GPIO driver in case the driver want to request them directly.
+- Link to v1: https://lore.kernel.org/r/20240131-descriptors-wireless-v1-0-e1c7c5d68746@linaro.org
+---
+ drivers/net/wireless/ath/ath9k/hw.c | 29 ++++++++++++-----------
+ drivers/net/wireless/ath/ath9k/hw.h |  3 ++-
+ 2 files changed, 32 insertions(+), 15 deletions(-)
+
+
+---
+base-commit: 4cece764965020c22cff7665b18a012006359095
+change-id: 20240122-descriptors-wireless-b8da95dcab35
+
+Best regards,
+
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -20,7 +20,7 @@
+ #include <linux/time.h>
+ #include <linux/bitops.h>
+ #include <linux/etherdevice.h>
+-#include <linux/gpio.h>
++#include <linux/gpio/consumer.h>
+ #include <linux/unaligned.h>
+ 
+ #include "hw.h"
+@@ -2727,19 +2727,25 @@ static void ath9k_hw_gpio_cfg_output_mux
+ static void ath9k_hw_gpio_cfg_soc(struct ath_hw *ah, u32 gpio, bool out,
+ 				  const char *label)
+ {
++	enum gpiod_flags flags = out ? GPIOD_OUT_LOW : GPIOD_IN;
++	struct gpio_desc *gpiod;
+ 	int err;
+ 
+-	if (ah->caps.gpio_requested & BIT(gpio))
++	if (ah->gpiods[gpio])
+ 		return;
+ 
+-	err = devm_gpio_request_one(ah->dev, gpio, out ? GPIOF_OUT_INIT_LOW : GPIOF_IN, label);
+-	if (err) {
++	/* Obtains a system specific GPIO descriptor from another GPIO controller */
++	gpiod = gpiod_get_index(NULL, "ath9k", gpio, flags);
++
++	if (IS_ERR(gpiod)) {
++		err = PTR_ERR(gpiod);
+ 		ath_err(ath9k_hw_common(ah), "request GPIO%d failed:%d\n",
+ 			gpio, err);
+ 		return;
+ 	}
+ 
+-	ah->caps.gpio_requested |= BIT(gpio);
++	gpiod_set_consumer_name(gpiod, label);
++	ah->gpiods[gpio] = gpiod;
+ }
+ 
+ static void ath9k_hw_gpio_cfg_wmac(struct ath_hw *ah, u32 gpio, bool out,
+@@ -2801,8 +2807,10 @@ void ath9k_hw_gpio_free(struct ath_hw *a
+ 
+ 	WARN_ON(gpio >= ah->caps.num_gpio_pins);
+ 
+-	if (ah->caps.gpio_requested & BIT(gpio))
+-		ah->caps.gpio_requested &= ~BIT(gpio);
++	if (ah->gpiods[gpio]) {
++		gpiod_put(ah->gpiods[gpio]);
++		ah->gpiods[gpio] = NULL;
++	}
+ }
+ EXPORT_SYMBOL(ath9k_hw_gpio_free);
+ 
+@@ -2830,8 +2838,8 @@ u32 ath9k_hw_gpio_get(struct ath_hw *ah,
+ 			val = REG_READ(ah, AR_GPIO_IN(ah)) & BIT(gpio);
+ 		else
+ 			val = MS_REG_READ(AR, gpio);
+-	} else if (BIT(gpio) & ah->caps.gpio_requested) {
+-		val = gpio_get_value(gpio) & BIT(gpio);
++	} else if (ah->gpiods[gpio]) {
++		val = gpiod_get_value(ah->gpiods[gpio]);
+ 	} else {
+ 		WARN_ON(1);
+ 	}
+@@ -2854,8 +2862,8 @@ void ath9k_hw_set_gpio(struct ath_hw *ah
+ 			AR7010_GPIO_OUT : AR_GPIO_IN_OUT(ah);
+ 
+ 		REG_RMW(ah, out_addr, val << gpio, BIT(gpio));
+-	} else if (BIT(gpio) & ah->caps.gpio_requested) {
+-		gpio_set_value(gpio, val);
++	} else if (ah->gpiods[gpio]) {
++		gpiod_set_value(ah->gpiods[gpio], val);
+ 	} else {
+ 		WARN_ON(1);
+ 	}
+--- a/drivers/net/wireless/ath/ath9k/hw.h
++++ b/drivers/net/wireless/ath/ath9k/hw.h
+@@ -19,6 +19,7 @@
+ 
+ #include <linux/if_ether.h>
+ #include <linux/delay.h>
++#include <linux/gpio/consumer.h>
+ #include <linux/io.h>
+ #include <linux/firmware.h>
+ 
+@@ -302,7 +303,6 @@ struct ath9k_hw_capabilities {
+ 	u8 max_rxchains;
+ 	u8 num_gpio_pins;
+ 	u32 gpio_mask;
+-	u32 gpio_requested;
+ 	u8 rx_hp_qdepth;
+ 	u8 rx_lp_qdepth;
+ 	u8 rx_status_len;
+@@ -783,6 +783,7 @@ struct ath_hw {
+ 	struct ath9k_hw_capabilities caps;
+ 	struct ath9k_channel channels[ATH9K_NUM_CHANNELS];
+ 	struct ath9k_channel *curchan;
++	struct gpio_desc *gpiods[32];
+ 
+ 	union {
+ 		struct ar5416_eeprom_def def;
diff --git a/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch b/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
index 9016da963b..78ad7623b2 100644
--- a/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
+++ b/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
@@ -8,7 +8,7 @@ This reverts commit 71f5137bf010c6faffab50c0ec15374c59c4a411.
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2975,7 +2975,8 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2983,7 +2983,8 @@ void ath9k_hw_apply_txpower(struct ath_h
  {
  	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
  	struct ieee80211_channel *channel;
@@ -18,7 +18,7 @@ This reverts commit 71f5137bf010c6faffab50c0ec15374c59c4a411.
  	u16 ctl = NO_CTL;
  
  	if (!chan)
-@@ -2987,9 +2988,14 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2995,9 +2996,14 @@ void ath9k_hw_apply_txpower(struct ath_h
  	channel = chan->chan;
  	chan_pwr = min_t(int, channel->max_power * 2, MAX_COMBINED_POWER);
  	new_pwr = min_t(int, chan_pwr, reg->power_limit);
diff --git a/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch b/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
index 5e5f3e4f10..21563bdaf5 100644
--- a/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
+++ b/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
@@ -11,7 +11,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2994,6 +2994,10 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -3002,6 +3002,10 @@ void ath9k_hw_apply_txpower(struct ath_h
  	if (ant_gain > max_gain)
  		ant_reduction = ant_gain - max_gain;
  
diff --git a/package/kernel/mac80211/patches/ath9k/509-ath9k-use-devm-for-irq-and-ioremap-resource.patch b/package/kernel/mac80211/patches/ath9k/509-ath9k-use-devm-for-irq-and-ioremap-resource.patch
new file mode 100644
index 0000000000..864238912a
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath9k/509-ath9k-use-devm-for-irq-and-ioremap-resource.patch
@@ -0,0 +1,50 @@
+From 454255e44bf48d8498ac3413389513138ab57bf6 Mon Sep 17 00:00:00 2001
+From: Rosen Penev <rosenp@gmail.com>
+Date: Sat, 4 Jan 2025 14:24:46 -0800
+Subject: [PATCH] wifi: ath9k: ahb: do ioremap resource in one step
+
+Simplifies probe slightly and adds extra error codes.
+
+Switching from devm_ioremap to the platform variant ends up calling
+devm_request_mem_region, which reserves the memory region for the
+various wmacs. Per board, there is only one wmac and after some fairly
+thorough analysis, there are no overlapping memory regions between wmacs
+and other devices on the ahb.
+
+Tested on a TP-Link Archer C7v2.
+
+Signed-off-by: Rosen Penev <rosenp@gmail.com>
+---
+ drivers/net/wireless/ath/ath9k/ahb.c | 13 +++----------
+ 1 file changed, 3 insertions(+), 10 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath9k/ahb.c
++++ b/drivers/net/wireless/ath/ath9k/ahb.c
+@@ -74,7 +74,6 @@ static int ath_ahb_probe(struct platform
+ 	void __iomem *mem;
+ 	struct ath_softc *sc;
+ 	struct ieee80211_hw *hw;
+-	struct resource *res;
+ 	const struct platform_device_id *id = platform_get_device_id(pdev);
+ 	int irq;
+ 	int ret = 0;
+@@ -86,16 +85,10 @@ static int ath_ahb_probe(struct platform
+ 		return -EINVAL;
+ 	}
+ 
+-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+-	if (res == NULL) {
+-		dev_err(&pdev->dev, "no memory resource found\n");
+-		return -ENXIO;
+-	}
+-
+-	mem = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+-	if (mem == NULL) {
++	mem = devm_platform_ioremap_resource(pdev, 0);
++	if (IS_ERR(mem)) {
+ 		dev_err(&pdev->dev, "ioremap failed\n");
+-		return -ENOMEM;
++		return PTR_ERR(mem);
+ 	}
+ 
+ 	irq = platform_get_irq(pdev, 0);
diff --git a/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch b/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch
index 6b60d3c089..9e3f867344 100644
--- a/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch
+++ b/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch
@@ -10,7 +10,7 @@
  	case AR5416_AR9100_DEVID:
 --- a/drivers/net/wireless/ath/ath9k/hw.h
 +++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -36,6 +36,7 @@
+@@ -37,6 +37,7 @@
  
  #define ATHEROS_VENDOR_ID	0x168c
  
diff --git a/package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch b/package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch
deleted file mode 100644
index 1055bd335c..0000000000
--- a/package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch
+++ /dev/null
@@ -1,64 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -15,6 +15,7 @@
-  */
- 
- #include "ath9k.h"
-+#include <linux/ath9k_platform.h>
- 
- /********************************/
- /*	 LED functions		*/
-@@ -108,6 +109,24 @@ int ath_create_gpio_led(struct ath_softc
- 	return ret;
- }
- 
-+static int ath_create_platform_led(struct ath_softc *sc,
-+				   const struct gpio_led *gpio)
-+{
-+	struct ath_led *led;
-+	int ret;
-+
-+	led = kzalloc(sizeof(*led), GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
-+
-+	led->gpio = gpio;
-+	ret = ath_add_led(sc, led);
-+	if (ret < 0)
-+		kfree(led);
-+
-+	return ret;
-+}
-+
- void ath_deinit_leds(struct ath_softc *sc)
- {
- 	struct ath_led *led;
-@@ -124,8 +143,10 @@ void ath_deinit_leds(struct ath_softc *s
- 
- void ath_init_leds(struct ath_softc *sc)
- {
-+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
- 	char led_name[32];
- 	const char *trigger;
-+	int i;
- 
- 	INIT_LIST_HEAD(&sc->leds);
- 
-@@ -134,6 +155,17 @@ void ath_init_leds(struct ath_softc *sc)
- 
- 	ath_fill_led_pin(sc);
- 
-+	if (pdata && pdata->leds && pdata->num_leds)
-+		for (i = 0; i < pdata->num_leds; i++) {
-+			if (pdata->leds[i].gpio == sc->sc_ah->led_pin)
-+				sc->sc_ah->led_pin = -1;
-+
-+			ath_create_platform_led(sc, &pdata->leds[i]);
-+		}
-+
-+	if (sc->sc_ah->led_pin < 0)
-+		return;
-+
- 	snprintf(led_name, sizeof(led_name), "ath9k-%s",
- 		 wiphy_name(sc->hw->wiphy));
- 
diff --git a/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch b/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch
index f08301c7f4..35d39a05c7 100644
--- a/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch
+++ b/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch
@@ -75,7 +75,7 @@
  struct ath9k_hw_version {
  	u32 magic;
  	u16 devid;
-@@ -810,6 +816,8 @@ struct ath_hw {
+@@ -811,6 +817,8 @@ struct ath_hw {
  	u32 ah_flags;
  	s16 nf_override;
  
@@ -84,7 +84,7 @@
  	bool reset_power_on;
  	bool htc_reset_init;
  
-@@ -1079,6 +1087,7 @@ void ath9k_hw_check_nav(struct ath_hw *a
+@@ -1080,6 +1088,7 @@ void ath9k_hw_check_nav(struct ath_hw *a
  bool ath9k_hw_check_alive(struct ath_hw *ah);
  
  bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
diff --git a/package/kernel/mac80211/patches/ath9k/547-ath9k_led_defstate_fix.patch b/package/kernel/mac80211/patches/ath9k/547-ath9k_led_defstate_fix.patch
index 5d84cf0c42..d633c051b0 100644
--- a/package/kernel/mac80211/patches/ath9k/547-ath9k_led_defstate_fix.patch
+++ b/package/kernel/mac80211/patches/ath9k/547-ath9k_led_defstate_fix.patch
@@ -13,7 +13,7 @@ Signed-off-by: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
 
 --- a/drivers/net/wireless/ath/ath9k/gpio.c
 +++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -74,8 +74,11 @@ static int ath_add_led(struct ath_softc
+@@ -73,8 +73,11 @@ static int ath_add_led(struct ath_softc
  	ath9k_hw_gpio_request_out(sc->sc_ah, gpio->gpio, gpio->name,
  				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
  
diff --git a/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch b/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch
index 9fb549cc19..288948c838 100644
--- a/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch
+++ b/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch
@@ -10,47 +10,32 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 ---
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -25,6 +25,7 @@
+@@ -25,6 +25,8 @@
  #include <linux/completion.h>
  #include <linux/time.h>
  #include <linux/hw_random.h>
 +#include <linux/gpio/driver.h>
++#include <linux/gpio/consumer.h>
  
  #include "common.h"
  #include "debug.h"
-@@ -991,6 +992,14 @@ struct ath_led {
- 	struct led_classdev cdev;
- };
- 
-+#ifdef CONFIG_GPIOLIB
-+struct ath9k_gpio_chip {
-+	struct ath_softc *sc;
-+	char label[32];
-+	struct gpio_chip gchip;
-+};
-+#endif
-+
- struct ath_softc {
- 	struct ieee80211_hw *hw;
- 	struct device *dev;
-@@ -1046,6 +1055,9 @@ struct ath_softc {
+@@ -1046,6 +1048,10 @@ struct ath_softc {
  #ifdef CPTCFG_MAC80211_LEDS
  	const char *led_default_trigger;
  	struct list_head leds;
 +#ifdef CONFIG_GPIOLIB
-+	struct ath9k_gpio_chip *gpiochip;
++	struct gpio_chip *gpiochip;
++	struct gpio_desc *gpiodesc;
 +#endif
  #endif
  
  #ifdef CPTCFG_ATH9K_DEBUGFS
 --- a/drivers/net/wireless/ath/ath9k/gpio.c
 +++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -16,13 +16,135 @@
+@@ -16,12 +16,120 @@
  
  #include "ath9k.h"
- #include <linux/ath9k_platform.h>
-+#include <linux/gpio.h>
-+
+ 
 +#ifdef CPTCFG_MAC80211_LEDS
 +
 +#ifdef CONFIG_GPIOLIB
@@ -62,10 +47,9 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +/* gpio_chip handler : set GPIO to input */
 +static int ath9k_gpio_pin_cfg_input(struct gpio_chip *chip, unsigned offset)
 +{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
++	struct ath_softc *sc = gpiochip_get_data(chip);
 +
-+	ath9k_hw_gpio_request_in(gc->sc->sc_ah, offset, "ath9k-gpio");
++	ath9k_hw_gpio_request_in(sc->sc_ah, offset, "ath9k-gpio");
 +
 +	return 0;
 +}
@@ -74,12 +58,11 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +static int ath9k_gpio_pin_cfg_output(struct gpio_chip *chip, unsigned offset,
 +				     int value)
 +{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
++	struct ath_softc *sc = gpiochip_get_data(chip);
 +
-+	ath9k_hw_gpio_request_out(gc->sc->sc_ah, offset, "ath9k-gpio",
++	ath9k_hw_gpio_request_out(sc->sc_ah, offset, "ath9k-gpio",
 +				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
-+	ath9k_hw_set_gpio(gc->sc->sc_ah, offset, value);
++	ath9k_hw_set_gpio(sc->sc_ah, offset, value);
 +
 +	return 0;
 +}
@@ -87,9 +70,8 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +/* gpio_chip handler : query GPIO direction (0=out, 1=in) */
 +static int ath9k_gpio_pin_get_dir(struct gpio_chip *chip, unsigned offset)
 +{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
-+	struct ath_hw *ah = gc->sc->sc_ah;
++	struct ath_softc *sc = gpiochip_get_data(chip);
++	struct ath_hw *ah = sc->sc_ah;
 +
 +	return !((REG_READ(ah, AR_GPIO_OE_OUT(ah)) >> (offset * 2)) & 3);
 +}
@@ -97,69 +79,59 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +/* gpio_chip handler : get GPIO pin value */
 +static int ath9k_gpio_pin_get(struct gpio_chip *chip, unsigned offset)
 +{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
++	struct ath_softc *sc = gpiochip_get_data(chip);
 +
-+	return ath9k_hw_gpio_get(gc->sc->sc_ah, offset);
++	return ath9k_hw_gpio_get(sc->sc_ah, offset);
 +}
 +
 +/* gpio_chip handler : set GPIO pin to value */
 +static void ath9k_gpio_pin_set(struct gpio_chip *chip, unsigned offset,
 +			       int value)
 +{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
++	struct ath_softc *sc = gpiochip_get_data(chip);
 +
-+	ath9k_hw_set_gpio(gc->sc->sc_ah, offset, value);
++	ath9k_hw_set_gpio(sc->sc_ah, offset, value);
 +}
 +
 +/* register GPIO chip */
 +static void ath9k_register_gpio_chip(struct ath_softc *sc)
 +{
-+	struct ath9k_gpio_chip *gc;
++	struct gpio_chip *gc = sc->gpiochip;
 +	struct ath_hw *ah = sc->sc_ah;
 +
-+	gc = kzalloc(sizeof(struct ath9k_gpio_chip), GFP_KERNEL);
++	gc = kzalloc(sizeof(struct gpio_chip), GFP_KERNEL);
 +	if (!gc)
 +		return;
 +
-+	gc->sc = sc;
-+	snprintf(gc->label, sizeof(gc->label), "ath9k-%s",
-+		 wiphy_name(sc->hw->wiphy));
-+#ifdef CONFIG_OF
-+	gc->gchip.parent = sc->dev;
-+#endif
-+	gc->gchip.label = gc->label;
-+	gc->gchip.base = -1;	/* determine base automatically */
-+	gc->gchip.ngpio = ah->caps.num_gpio_pins;
-+	gc->gchip.direction_input = ath9k_gpio_pin_cfg_input;
-+	gc->gchip.direction_output = ath9k_gpio_pin_cfg_output;
-+	gc->gchip.get_direction = ath9k_gpio_pin_get_dir;
-+	gc->gchip.get = ath9k_gpio_pin_get;
-+	gc->gchip.set = ath9k_gpio_pin_set;
-+
-+	if (gpiochip_add(&gc->gchip)) {
++	gc->label = kasprintf(GFP_KERNEL, "ath9k-%s",
++			wiphy_name(sc->hw->wiphy));
++	gc->parent = sc->dev;
++	gc->base = -1;	/* determine base automatically */
++	gc->ngpio = ah->caps.num_gpio_pins;
++	gc->direction_input = ath9k_gpio_pin_cfg_input;
++	gc->direction_output = ath9k_gpio_pin_cfg_output;
++	gc->get_direction = ath9k_gpio_pin_get_dir;
++	gc->get = ath9k_gpio_pin_get;
++	gc->set = ath9k_gpio_pin_set;
++
++	if (gpiochip_add_data(gc, sc)) {
++		kfree(gc->label);
 +		kfree(gc);
 +		return;
 +	}
-+
-+#ifdef CONFIG_OF
-+	gc->gchip.owner = NULL;
-+#endif
-+	sc->gpiochip = gc;
 +}
 +
 +/* remove GPIO chip */
 +static void ath9k_unregister_gpio_chip(struct ath_softc *sc)
 +{
-+	struct ath9k_gpio_chip *gc = sc->gpiochip;
++	struct gpio_chip *gc = sc->gpiochip;
 +
 +	if (!gc)
 +		return;
 +
-+	gpiochip_remove(&gc->gchip);
++	gpiochip_remove(gc);
++	kfree(gc->label);
 +	kfree(gc);
-+	sc->gpiochip = NULL;
 +}
 +
 +#else /* CONFIG_GPIOLIB */
@@ -173,7 +145,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +}
 +
 +#endif /* CONFIG_GPIOLIB */
- 
++
  /********************************/
  /*	 LED functions		*/
  /********************************/
@@ -183,27 +155,27 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  static void ath_fill_led_pin(struct ath_softc *sc)
  {
  	struct ath_hw *ah = sc->sc_ah;
-@@ -80,6 +202,12 @@ static int ath_add_led(struct ath_softc
+@@ -79,6 +187,12 @@ static int ath_add_led(struct ath_softc
  	else
  		ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
  
 +#ifdef CONFIG_GPIOLIB
 +	/* If there is GPIO chip configured, reserve LED pin */
 +	if (sc->gpiochip)
-+		gpio_request(sc->gpiochip->gchip.base + gpio->gpio, gpio->name);
++		sc->gpiodesc = gpiod_get(sc->dev, gpio->name, GPIOD_ASIS);
 +#endif
 +
  	return 0;
  }
  
-@@ -136,17 +264,24 @@ void ath_deinit_leds(struct ath_softc *s
+@@ -117,16 +231,23 @@ void ath_deinit_leds(struct ath_softc *s
  
  	while (!list_empty(&sc->leds)) {
  		led = list_first_entry(&sc->leds, struct ath_led, list);
 +#ifdef CONFIG_GPIOLIB
 +		/* If there is GPIO chip configured, free LED pin */
 +		if (sc->gpiochip)
-+			gpio_free(sc->gpiochip->gchip.base + led->gpio->gpio);
++			gpiod_put(sc->gpiodesc);
 +#endif
  		list_del(&led->list);
  		ath_led_brightness(&led->cdev, LED_OFF);
@@ -216,12 +188,11 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  void ath_init_leds(struct ath_softc *sc)
  {
- 	struct ath9k_platform_data *pdata = sc->dev->platform_data;
 +	struct device_node *np = sc->dev->of_node;
  	char led_name[32];
  	const char *trigger;
- 	int i;
-@@ -156,6 +291,15 @@ void ath_init_leds(struct ath_softc *sc)
+ 
+@@ -135,6 +256,15 @@ void ath_init_leds(struct ath_softc *sc)
  	if (AR_SREV_9100(sc->sc_ah))
  		return;
  
@@ -236,12 +207,4 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +
  	ath_fill_led_pin(sc);
  
- 	if (pdata && pdata->leds && pdata->num_leds)
-@@ -180,6 +324,7 @@ void ath_init_leds(struct ath_softc *sc)
- 	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger,
- 			   !sc->sc_ah->config.led_active_high);
- }
-+
- #endif
- 
- /*******************/
+ 	snprintf(led_name, sizeof(led_name), "ath9k-%s",
diff --git a/package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch b/package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch
deleted file mode 100644
index d164d89031..0000000000
--- a/package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch
+++ /dev/null
@@ -1,130 +0,0 @@
-From: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
-Subject: [PATCH v5 5/8] mac80211: ath9k: enable GPIO buttons
-
-Enable platform-defined GPIO button support for ath9k device.
-Key poller is activated for attached platform buttons.
-Requires ath9k GPIO chip access.
-
-Signed-off-by: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -1057,6 +1057,7 @@ struct ath_softc {
- 	struct list_head leds;
- #ifdef CONFIG_GPIOLIB
- 	struct ath9k_gpio_chip *gpiochip;
-+	struct platform_device *btnpdev;	/* gpio-keys-polled */
- #endif
- #endif
- 
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -17,6 +17,8 @@
- #include "ath9k.h"
- #include <linux/ath9k_platform.h>
- #include <linux/gpio.h>
-+#include <linux/platform_device.h>
-+#include <linux/gpio_keys.h>
- 
- #ifdef CPTCFG_MAC80211_LEDS
- 
-@@ -129,6 +131,67 @@ static void ath9k_unregister_gpio_chip(s
- 	sc->gpiochip = NULL;
- }
- 
-+/******************/
-+/*  GPIO Buttons  */
-+/******************/
-+
-+/* add GPIO buttons */
-+static void ath9k_init_buttons(struct ath_softc *sc)
-+{
-+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
-+	struct platform_device *pdev;
-+	struct gpio_keys_platform_data gkpdata;
-+	struct gpio_keys_button *bt;
-+	int i;
-+
-+	if (!sc->gpiochip)
-+		return;
-+
-+	if (!pdata || !pdata->btns || !pdata->num_btns)
-+		return;
-+
-+	bt = devm_kmemdup(sc->dev, pdata->btns,
-+			  pdata->num_btns * sizeof(struct gpio_keys_button),
-+			  GFP_KERNEL);
-+	if (!bt)
-+		return;
-+
-+	for (i = 0; i < pdata->num_btns; i++) {
-+		if (pdata->btns[i].gpio == sc->sc_ah->led_pin)
-+				sc->sc_ah->led_pin = -1;
-+
-+		ath9k_hw_gpio_request_in(sc->sc_ah, pdata->btns[i].gpio,
-+					 "ath9k-gpio");
-+		bt[i].gpio = sc->gpiochip->gchip.base + pdata->btns[i].gpio;
-+	}
-+
-+	memset(&gkpdata, 0, sizeof(struct gpio_keys_platform_data));
-+	gkpdata.buttons = bt;
-+	gkpdata.nbuttons = pdata->num_btns;
-+	gkpdata.poll_interval = pdata->btn_poll_interval;
-+
-+	pdev = platform_device_register_data(sc->dev, "gpio-keys-polled",
-+					     PLATFORM_DEVID_AUTO, &gkpdata,
-+					     sizeof(gkpdata));
-+	if (!IS_ERR_OR_NULL(pdev))
-+		sc->btnpdev = pdev;
-+	else {
-+		sc->btnpdev = NULL;
-+		devm_kfree(sc->dev, bt);
-+	}
-+}
-+
-+/* remove GPIO buttons */
-+static void ath9k_deinit_buttons(struct ath_softc *sc)
-+{
-+	if (!sc->gpiochip || !sc->btnpdev)
-+		return;
-+
-+	platform_device_unregister(sc->btnpdev);
-+
-+	sc->btnpdev = NULL;
-+}
-+
- #else /* CONFIG_GPIOLIB */
- 
- static inline void ath9k_register_gpio_chip(struct ath_softc *sc)
-@@ -139,6 +202,14 @@ static inline void ath9k_unregister_gpio
- {
- }
- 
-+static inline void ath9k_init_buttons(struct ath_softc *sc)
-+{
-+}
-+
-+static inline void ath9k_deinit_buttons(struct ath_softc *sc)
-+{
-+}
-+
- #endif /* CONFIG_GPIOLIB */
- 
- /********************************/
-@@ -262,6 +333,7 @@ void ath_deinit_leds(struct ath_softc *s
- {
- 	struct ath_led *led;
- 
-+	ath9k_deinit_buttons(sc);
- 	while (!list_empty(&sc->leds)) {
- 		led = list_first_entry(&sc->leds, struct ath_led, list);
- #ifdef CONFIG_GPIOLIB
-@@ -301,6 +373,7 @@ void ath_init_leds(struct ath_softc *sc)
- 	}
- 
- 	ath_fill_led_pin(sc);
-+	ath9k_init_buttons(sc);
- 
- 	if (pdata && pdata->leds && pdata->num_leds)
- 		for (i = 0; i < pdata->num_leds; i++) {
diff --git a/package/kernel/mac80211/patches/ath9k/550-ath9k-of.patch b/package/kernel/mac80211/patches/ath9k/550-ath9k-of.patch
new file mode 100644
index 0000000000..5cb70b40a7
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath9k/550-ath9k-of.patch
@@ -0,0 +1,155 @@
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -29,6 +29,11 @@
+ 
+ #include "ath9k.h"
+ 
++#ifdef CONFIG_ATH79
++#include <asm/mach-ath79/ath79.h>
++#include <asm/mach-ath79/ar71xx_regs.h>
++#endif
++ 
+ struct ath9k_eeprom_ctx {
+ 	struct completion complete;
+ 	struct ath_hw *ah;
+@@ -243,6 +248,81 @@ static unsigned int ath9k_reg_rmw(void *
+ 	return val;
+ }
+ 
++#ifdef CONFIG_ATH79
++#define QCA955X_DDR_CTL_CONFIG          0x108
++#define QCA955X_DDR_CTL_CONFIG_ACT_WMAC BIT(23)
++
++static int ar913x_wmac_reset(void)
++{
++	ath79_device_reset_set(AR913X_RESET_AMBA2WMAC);
++	mdelay(10);
++
++	ath79_device_reset_clear(AR913X_RESET_AMBA2WMAC);
++	mdelay(10);
++
++	return 0;
++}
++
++static int ar933x_wmac_reset(void)
++{
++	int retries = 20;
++
++	ath79_device_reset_set(AR933X_RESET_WMAC);
++	ath79_device_reset_clear(AR933X_RESET_WMAC);
++
++	while (1) {
++		u32 bootstrap;
++
++		bootstrap = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
++		if ((bootstrap & AR933X_BOOTSTRAP_EEPBUSY) == 0)
++			return 0;
++
++		if (retries-- == 0)
++			break;
++
++		udelay(10000);
++	}
++
++	pr_err("ar933x: WMAC reset timed out");
++	return -ETIMEDOUT;
++}
++
++static int qca955x_wmac_reset(void)
++{
++	int i;
++
++	/* Try to wait for WMAC DDR activity to stop */
++	for (i = 0; i < 10; i++) {
++		if (!(__raw_readl(ath79_ddr_base + QCA955X_DDR_CTL_CONFIG) &
++		    QCA955X_DDR_CTL_CONFIG_ACT_WMAC))
++			break;
++
++		udelay(10);
++	}
++
++	ath79_device_reset_set(QCA955X_RESET_RTC);
++	udelay(10);
++	ath79_device_reset_clear(QCA955X_RESET_RTC);
++	udelay(10);
++
++	return 0;
++}
++
++
++static int ar9330_get_soc_revision(void)
++{
++	if (ath79_soc_rev == 1)
++		return ath79_soc_rev;
++
++	return 0;
++}
++
++static int ath79_get_soc_revision(void)
++{
++	return ath79_soc_rev;
++}
++#endif
++
+ /**************************/
+ /*     Initialization     */
+ /**************************/
+@@ -670,6 +750,8 @@ static int ath9k_of_init(struct ath_soft
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 	enum ath_bus_type bus_type = common->bus_ops->ath_bus_type;
+ 	char eeprom_name[100];
++	u8 led_pin;
++	u32 mask;
+ 	int ret;
+ 
+ 	if (!of_device_is_available(np))
+@@ -677,6 +759,49 @@ static int ath9k_of_init(struct ath_soft
+ 
+ 	ath_dbg(common, CONFIG, "parsing configuration from OF node\n");
+ 
++	if (!of_property_read_u8(np, "qca,led-pin", &led_pin))
++		ah->led_pin = led_pin;
++
++	if (!of_property_read_u32(np, "qca,gpio-mask", &mask))
++		ah->caps.gpio_mask = mask;
++
++	if (of_property_read_bool(np, "qca,tx-gain-buffalo"))
++		ah->config.tx_gain_buffalo = true;
++
++#ifdef CONFIG_ATH79
++	if (ah->hw_version.devid == AR5416_AR9100_DEVID) {
++		ah->external_reset = ar913x_wmac_reset;
++		ah->external_reset();
++	} else if (ah->hw_version.devid == AR9300_DEVID_AR9330) {
++		ah->get_mac_revision = ar9330_get_soc_revision;
++		u32 t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
++		ah->is_clk_25mhz = !(t & AR933X_BOOTSTRAP_REF_CLK_40);
++		ah->external_reset = ar933x_wmac_reset;
++		ah->external_reset();
++	} else if (ah->hw_version.devid == AR9300_DEVID_AR9340) {
++		ah->get_mac_revision = ath79_get_soc_revision;
++		u32 t = ath79_reset_rr(AR934X_RESET_REG_BOOTSTRAP);
++		ah->is_clk_25mhz = !(t & AR933X_BOOTSTRAP_REF_CLK_40);
++	} else if (ah->hw_version.devid == AR9300_DEVID_AR953X) {
++		ah->get_mac_revision = ath79_get_soc_revision;
++		/*
++		 * QCA953x only supports 25MHz refclk.
++		 * Some vendors have an invalid bootstrap option
++		 * set, which would break the WMAC here.
++		 */
++		ah->is_clk_25mhz = true;
++	} else if (ah->hw_version.devid == AR9300_DEVID_QCA955X) {
++		u32 t = ath79_reset_rr(QCA955X_RESET_REG_BOOTSTRAP);
++		ah->is_clk_25mhz = !(t & QCA955X_BOOTSTRAP_REF_CLK_40);
++		ah->external_reset = qca955x_wmac_reset;
++		ah->external_reset();
++	} else if (ah->hw_version.devid == AR9300_DEVID_QCA956X) {
++		ah->get_mac_revision = ath79_get_soc_revision;
++		u32 t = ath79_reset_rr(QCA956X_RESET_REG_BOOTSTRAP);
++		ah->is_clk_25mhz = !(t & QCA956X_BOOTSTRAP_REF_CLK_40);
++	}
++#endif
++
+ 	if (of_property_read_bool(np, "qca,no-eeprom")) {
+ 		/* ath9k-eeprom-<bus>-<id>.bin */
+ 		scnprintf(eeprom_name, sizeof(eeprom_name),
diff --git a/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch b/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch
index 3ccd3fc487..5f32810fe9 100644
--- a/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch
+++ b/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch
@@ -30,7 +30,7 @@
  	ath_update_survey_stats(sc);
 --- /dev/null
 +++ b/drivers/net/wireless/ath/ath9k/hsr.c
-@@ -0,0 +1,247 @@
+@@ -0,0 +1,248 @@
 +/*
 + *
 + * The MIT License (MIT)
@@ -68,6 +68,7 @@
 +
 +#include "hw.h"
 +#include "ath9k.h"
++#include "hsr.h"
 +
 +#define HSR_GPIO_CSN 8
 +#define HSR_GPIO_CLK 6
@@ -280,7 +281,7 @@
 +}
 --- /dev/null
 +++ b/drivers/net/wireless/ath/ath9k/hsr.h
-@@ -0,0 +1,48 @@
+@@ -0,0 +1,50 @@
 +/*
 + * The MIT License (MIT)
 + *
@@ -308,6 +309,8 @@
 +#ifndef HSR_H
 +#define HSR_H
 +
++ struct ath_hw;
++
 +#ifdef CPTCFG_ATH9K_UBNTHSR
 +
 +void ath9k_hsr_init(struct ath_hw *ah);
diff --git a/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch b/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch
index 3adc8bb8d6..cb92f30aae 100644
--- a/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch
+++ b/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch
@@ -1,284 +1,68 @@
 --- a/drivers/net/wireless/ath/ath9k/ahb.c
 +++ b/drivers/net/wireless/ath/ath9k/ahb.c
-@@ -20,7 +20,15 @@
+@@ -20,6 +20,7 @@
  #include <linux/platform_device.h>
  #include <linux/module.h>
  #include <linux/mod_devicetable.h>
 +#include <linux/of_device.h>
  #include "ath9k.h"
-+#include <linux/ath9k_platform.h>
-+
-+#ifdef CONFIG_OF
-+#include <asm/mach-ath79/ath79.h>
-+#include <asm/mach-ath79/ar71xx_regs.h>
-+#include <linux/mtd/mtd.h>
-+#endif
  
  static const struct platform_device_id ath9k_platform_id_table[] = {
- 	{
-@@ -69,6 +77,192 @@ static const struct ath_bus_ops ath_ahb_
+@@ -69,21 +70,28 @@ static const struct ath_bus_ops ath_ahb_
  	.eeprom_read = ath_ahb_eeprom_read,
  };
  
-+#ifdef CONFIG_OF
-+
-+#define QCA955X_DDR_CTL_CONFIG          0x108
-+#define QCA955X_DDR_CTL_CONFIG_ACT_WMAC BIT(23)
-+
-+static int ar913x_wmac_reset(void)
-+{
-+	ath79_device_reset_set(AR913X_RESET_AMBA2WMAC);
-+	mdelay(10);
-+
-+	ath79_device_reset_clear(AR913X_RESET_AMBA2WMAC);
-+	mdelay(10);
-+
-+	return 0;
-+}
-+
-+static int ar933x_wmac_reset(void)
-+{
-+	int retries = 20;
-+
-+	ath79_device_reset_set(AR933X_RESET_WMAC);
-+	ath79_device_reset_clear(AR933X_RESET_WMAC);
-+
-+	while (1) {
-+		u32 bootstrap;
-+
-+		bootstrap = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
-+		if ((bootstrap & AR933X_BOOTSTRAP_EEPBUSY) == 0)
-+			return 0;
-+
-+		if (retries-- == 0)
-+			break;
-+
-+		udelay(10000);
-+	}
-+
-+	pr_err("ar933x: WMAC reset timed out");
-+	return -ETIMEDOUT;
-+}
-+
-+static int qca955x_wmac_reset(void)
-+{
-+	int i;
-+
-+	/* Try to wait for WMAC DDR activity to stop */
-+	for (i = 0; i < 10; i++) {
-+		if (!(__raw_readl(ath79_ddr_base + QCA955X_DDR_CTL_CONFIG) &
-+		    QCA955X_DDR_CTL_CONFIG_ACT_WMAC))
-+			break;
-+
-+		udelay(10);
-+	}
-+
-+	ath79_device_reset_set(QCA955X_RESET_RTC);
-+	udelay(10);
-+	ath79_device_reset_clear(QCA955X_RESET_RTC);
-+	udelay(10);
-+
-+	return 0;
-+}
-+
-+enum {
-+	AR913X_WMAC = 0,
-+	AR933X_WMAC,
-+	AR934X_WMAC,
-+	QCA953X_WMAC,
-+	QCA955X_WMAC,
-+	QCA956X_WMAC,
-+};
-+
-+static int ar9330_get_soc_revision(void)
-+{
-+	if (ath79_soc_rev == 1)
-+		return ath79_soc_rev;
-+
-+	return 0;
-+}
-+
-+static int ath79_get_soc_revision(void)
-+{
-+	return ath79_soc_rev;
-+}
-+
-+static const struct of_ath_ahb_data {
-+	u16 dev_id;
-+	u32 bootstrap_reg;
-+	u32 bootstrap_ref;
-+
-+	int (*soc_revision)(void);
-+	int (*wmac_reset)(void);
-+} of_ath_ahb_data[] = {
-+	[AR913X_WMAC] = {
-+		.dev_id = AR5416_AR9100_DEVID,
-+		.wmac_reset = ar913x_wmac_reset,
-+
-+	},
-+	[AR933X_WMAC] = {
-+		.dev_id = AR9300_DEVID_AR9330,
-+		.bootstrap_reg = AR933X_RESET_REG_BOOTSTRAP,
-+		.bootstrap_ref = AR933X_BOOTSTRAP_REF_CLK_40,
-+		.soc_revision = ar9330_get_soc_revision,
-+		.wmac_reset = ar933x_wmac_reset,
-+	},
-+	[AR934X_WMAC] = {
-+		.dev_id = AR9300_DEVID_AR9340,
-+		.bootstrap_reg = AR934X_RESET_REG_BOOTSTRAP,
-+		.bootstrap_ref = AR934X_BOOTSTRAP_REF_CLK_40,
-+		.soc_revision = ath79_get_soc_revision,
-+	},
-+	[QCA953X_WMAC] = {
-+		.dev_id = AR9300_DEVID_AR953X,
-+		.bootstrap_reg = QCA953X_RESET_REG_BOOTSTRAP,
-+		.bootstrap_ref = QCA953X_BOOTSTRAP_REF_CLK_40,
-+		.soc_revision = ath79_get_soc_revision,
-+	},
-+	[QCA955X_WMAC] = {
-+		.dev_id = AR9300_DEVID_QCA955X,
-+		.bootstrap_reg = QCA955X_RESET_REG_BOOTSTRAP,
-+		.bootstrap_ref = QCA955X_BOOTSTRAP_REF_CLK_40,
-+		.wmac_reset = qca955x_wmac_reset,
-+	},
-+	[QCA956X_WMAC] = {
-+		.dev_id = AR9300_DEVID_QCA956X,
-+		.bootstrap_reg = QCA956X_RESET_REG_BOOTSTRAP,
-+		.bootstrap_ref = QCA956X_BOOTSTRAP_REF_CLK_40,
-+		.soc_revision = ath79_get_soc_revision,
-+	},
-+};
-+
 +const struct of_device_id of_ath_ahb_match[] = {
-+	{ .compatible = "qca,ar9130-wmac", .data = &of_ath_ahb_data[AR913X_WMAC] },
-+	{ .compatible = "qca,ar9330-wmac", .data = &of_ath_ahb_data[AR933X_WMAC] },
-+	{ .compatible = "qca,ar9340-wmac", .data = &of_ath_ahb_data[AR934X_WMAC] },
-+	{ .compatible = "qca,qca9530-wmac", .data = &of_ath_ahb_data[QCA953X_WMAC] },
-+	{ .compatible = "qca,qca9550-wmac", .data = &of_ath_ahb_data[QCA955X_WMAC] },
-+	{ .compatible = "qca,qca9560-wmac", .data = &of_ath_ahb_data[QCA956X_WMAC] },
++	{ .compatible = "qca,ar9130-wmac", .data = (void *)AR5416_AR9100_DEVID },
++	{ .compatible = "qca,ar9330-wmac", .data = (void *)AR9300_DEVID_AR9330 },
++	{ .compatible = "qca,ar9340-wmac", .data = (void *)AR9300_DEVID_AR9340 },
++	{ .compatible = "qca,qca9530-wmac", .data = (void *)AR9300_DEVID_AR953X },
++	{ .compatible = "qca,qca9550-wmac", .data = (void *)AR9300_DEVID_QCA955X },
++	{ .compatible = "qca,qca9560-wmac", .data = (void *)AR9300_DEVID_QCA956X },
 +	{},
 +};
 +MODULE_DEVICE_TABLE(of, of_ath_ahb_match);
-+
-+static int of_ath_ahb_probe(struct platform_device *pdev)
-+{
-+	struct ath9k_platform_data *pdata;
-+	const struct of_device_id *match;
-+	const struct of_ath_ahb_data *data;
-+	u8 led_pin;
-+
-+	match = of_match_device(of_ath_ahb_match, &pdev->dev);
-+	data = (const struct of_ath_ahb_data *)match->data;
-+
-+	pdata = dev_get_platdata(&pdev->dev);
-+
-+	if (!of_property_read_u8(pdev->dev.of_node, "qca,led-pin", &led_pin))
-+		pdata->led_pin = led_pin;
-+	else
-+		pdata->led_pin = -1;
-+
-+	if (of_property_read_bool(pdev->dev.of_node, "qca,tx-gain-buffalo"))
-+		pdata->tx_gain_buffalo = true;
-+
-+	if (data->wmac_reset) {
-+		data->wmac_reset();
-+		pdata->external_reset = data->wmac_reset;
-+	}
-+
-+	if (data->dev_id == AR9300_DEVID_AR953X) {
-+		/*
-+		 * QCA953x only supports 25MHz refclk.
-+		 * Some vendors have an invalid bootstrap option
-+		 * set, which would break the WMAC here.
-+		 */
-+		pdata->is_clk_25mhz = true;
-+	} else if (data->bootstrap_reg && data->bootstrap_ref) {
-+		u32 t = ath79_reset_rr(data->bootstrap_reg);
-+		if (t & data->bootstrap_ref)
-+			pdata->is_clk_25mhz = false;
-+		else
-+			pdata->is_clk_25mhz = true;
-+	}
-+
-+	pdata->get_mac_revision = data->soc_revision;
-+
-+	return data->dev_id;
-+}
-+#endif
 +
  static int ath_ahb_probe(struct platform_device *pdev)
  {
- 	void __iomem *mem;
-@@ -80,6 +274,17 @@ static int ath_ahb_probe(struct platform
- 	int ret = 0;
+-	void __iomem *mem;
+-	struct ath_softc *sc;
++	const struct of_device_id *match;
+ 	struct ieee80211_hw *hw;
+-	const struct platform_device_id *id = platform_get_device_id(pdev);
+-	int irq;
+-	int ret = 0;
++	struct ath_softc *sc;
++	void __iomem *mem;
  	struct ath_hw *ah;
  	char hw_name[64];
+-
+-	if (!dev_get_platdata(&pdev->dev)) {
+-		dev_err(&pdev->dev, "no platform data specified\n");
+-		return -EINVAL;
+-	}
 +	u16 dev_id;
-+
-+	if (id)
-+		dev_id = id->driver_data;
-+
-+#ifdef CONFIG_OF
-+	if (pdev->dev.of_node)
-+		pdev->dev.platform_data = devm_kzalloc(&pdev->dev,
-+					sizeof(struct ath9k_platform_data),
-+					GFP_KERNEL);
-+#endif
++	int irq;
++	int ret;
  
- 	if (!dev_get_platdata(&pdev->dev)) {
- 		dev_err(&pdev->dev, "no platform data specified\n");
-@@ -118,17 +323,23 @@ static int ath_ahb_probe(struct platform
- 	sc->mem = mem;
- 	sc->irq = irq;
- 
-+#ifdef CONFIG_OF
-+	dev_id = of_ath_ahb_probe(pdev);
-+#endif
- 	ret = request_irq(irq, ath_isr, IRQF_SHARED, "ath9k", sc);
- 	if (ret) {
- 		dev_err(&pdev->dev, "request_irq failed\n");
+ 	mem = devm_platform_ioremap_resource(pdev, 0);
+ 	if (IS_ERR(mem)) {
+@@ -117,7 +125,9 @@ static int ath_ahb_probe(struct platform
  		goto err_free_hw;
  	}
  
 -	ret = ath9k_init_device(id->driver_data, sc, &ath_ahb_bus_ops);
++	match = of_match_device(of_ath_ahb_match, &pdev->dev);
++	dev_id = (uintptr_t)match->data;
 +	ret = ath9k_init_device(dev_id, sc, &ath_ahb_bus_ops);
  	if (ret) {
  		dev_err(&pdev->dev, "failed to initialize device\n");
  		goto err_irq;
- 	}
-+#ifdef CONFIG_OF
-+	pdev->dev.platform_data = NULL;
-+#endif
- 
- 	ah = sc->sc_ah;
- 	ath9k_hw_name(ah, hw_name, sizeof(hw_name));
-@@ -162,6 +373,9 @@ static struct platform_driver ath_ahb_dr
+@@ -155,6 +165,7 @@ static struct platform_driver ath_ahb_dr
  	.remove_new = ath_ahb_remove,
  	.driver		= {
  		.name	= "ath9k",
-+#ifdef CONFIG_OF
 +		.of_match_table = of_ath_ahb_match,
-+#endif
  	},
  	.id_table    = ath9k_platform_id_table,
  };
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -26,6 +26,7 @@
- #include <linux/time.h>
- #include <linux/hw_random.h>
- #include <linux/gpio/driver.h>
-+#include <linux/reset.h>
- 
- #include "common.h"
- #include "debug.h"
-@@ -1013,6 +1014,9 @@ struct ath_softc {
- 	struct ath_hw *sc_ah;
- 	void __iomem *mem;
- 	int irq;
-+#ifdef CONFIG_OF
-+	struct reset_control *reset;
-+#endif
- 	spinlock_t sc_serial_rw;
- 	spinlock_t sc_pm_lock;
- 	spinlock_t sc_pcu_lock;
diff --git a/package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch b/package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch
deleted file mode 100644
index 752a4980a4..0000000000
--- a/package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch
+++ /dev/null
@@ -1,25 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -696,6 +696,12 @@ static int ath9k_of_init(struct ath_soft
- 	return 0;
- }
- 
-+static void ath9k_of_gpio_mask(struct ath_softc *sc)
-+{
-+	of_property_read_u32(sc->dev->of_node, "qca,gpio-mask",
-+			     &sc->sc_ah->caps.gpio_mask);
-+}
-+
- static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
- 			    const struct ath_bus_ops *bus_ops)
- {
-@@ -804,6 +810,9 @@ static int ath9k_init_softc(u16 devid, s
- 	if (ret)
- 		goto err_hw;
- 
-+	/* GPIO mask quirk */
-+	ath9k_of_gpio_mask(sc);
-+
- 	ret = ath9k_init_queues(sc);
- 	if (ret)
- 		goto err_queues;
diff --git a/package/kernel/mac80211/patches/build/110-backport-include-fix-linux-acpi_amd_wbrf.h-inclusion.patch b/package/kernel/mac80211/patches/build/110-backport-include-fix-linux-acpi_amd_wbrf.h-inclusion.patch
new file mode 100644
index 0000000000..d8d3783ed6
--- /dev/null
+++ b/package/kernel/mac80211/patches/build/110-backport-include-fix-linux-acpi_amd_wbrf.h-inclusion.patch
@@ -0,0 +1,32 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 14 Jan 2025 11:42:25 +0100
+Subject: [PATCH] backport-include: fix linux/acpi_amd_wbrf.h inclusion
+
+Fix building for kernel >= 6.8 by adjusting incorrect guard usage,
+otherwise an #include_next header is masked and compilation will fail
+for net/mac80211/wbrf.c in the mac80211 kernel module.
+
+Fixes: 52cdcaab ("backport-include: backport linux/acpi_amd_wbrf.h")
+Reported-by: Tony Ambardar <itugrok@yahoo.com>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/backport-include/linux/acpi_amd_wbrf.h
++++ b/backport-include/linux/acpi_amd_wbrf.h
+@@ -4,8 +4,8 @@
+  * Copyright (C) 2023 Advanced Micro Devices
+  */
+ 
+-#ifndef _ACPI_AMD_WBRF_H
+-#define _ACPI_AMD_WBRF_H
++#ifndef __BACKPORT_ACPI_AMD_WBRF_H
++#define __BACKPORT_ACPI_AMD_WBRF_H
+ 
+ #if LINUX_VERSION_IS_GEQ(6,8,0)
+ #include_next <linux/acpi_amd_wbrf.h>
+@@ -83,4 +83,4 @@ int amd_wbrf_unregister_notifier(struct
+ }
+ 
+ #endif /* >=6,8,0 */
+-#endif /* _ACPI_AMD_WBRF_H */
++#endif /* __BACKPORT_ACPI_AMD_WBRF_H */
diff --git a/package/kernel/mac80211/patches/build/120-backport-fix-unaligned.h-header-location.patch b/package/kernel/mac80211/patches/build/120-backport-fix-unaligned.h-header-location.patch
new file mode 100644
index 0000000000..1fe6ab25fc
--- /dev/null
+++ b/package/kernel/mac80211/patches/build/120-backport-fix-unaligned.h-header-location.patch
@@ -0,0 +1,26 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Mon, 28 Apr 2025 22:03:18 +0800
+Subject: [PATCH] backport: fix unaligned.h header location
+
+unaligned.h was moved from include/asm-generic/ to include/linux/
+in 6.12-rc2 kernel.
+
+Link: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.12.y&id=5f60d5f6bbc12e782fac78110b0ee62698f3b576
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ backport-include/asm/unaligned.h | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/backport-include/asm/unaligned.h
++++ b/backport-include/asm/unaligned.h
+@@ -1,6 +1,10 @@
+ #ifndef __BACKPORT_ASM_GENERIC_UNALIGNED_H
+ #define __BACKPORT_ASM_GENERIC_UNALIGNED_H
++#if LINUX_VERSION_IS_GEQ(6,12,0)
++#include_next <linux/unaligned.h>
++#else
+ #include_next <asm/unaligned.h>
++#endif
+ 
+ #if LINUX_VERSION_IS_LESS(5,7,0)
+ static inline u32 __get_unaligned_be24(const u8 *p)
diff --git a/package/kernel/mac80211/patches/build/140-trace_backport.patch b/package/kernel/mac80211/patches/build/140-trace_backport.patch
index 8b77b7e83d..2d25f1c5c3 100644
--- a/package/kernel/mac80211/patches/build/140-trace_backport.patch
+++ b/package/kernel/mac80211/patches/build/140-trace_backport.patch
@@ -1,541 +1,694 @@
 --- a/drivers/bus/mhi/host/trace.h
 +++ b/drivers/bus/mhi/host/trace.h
-@@ -104,7 +104,7 @@ TRACE_EVENT(mhi_gen_tre,
+@@ -104,7 +104,11 @@ TRACE_EVENT(mhi_gen_tre,
  	),
  
  	TP_fast_assign(
--		__assign_str(name);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(name);
++#else
 +		__assign_str(name, mhi_cntrl->mhi_dev->name);
++#endif
  		__entry->ch_num = mhi_chan->chan;
  		__entry->wp = mhi_tre;
  		__entry->tre_ptr = le64_to_cpu(mhi_tre->ptr);
-@@ -132,7 +132,7 @@ TRACE_EVENT(mhi_intvec_states,
+@@ -132,7 +136,11 @@ TRACE_EVENT(mhi_intvec_states,
  	),
  
  	TP_fast_assign(
--		__assign_str(name);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(name);
++#else
 +		__assign_str(name, mhi_cntrl->mhi_dev->name);
++#endif
  		__entry->local_ee = mhi_cntrl->ee;
  		__entry->state = mhi_cntrl->dev_state;
  		__entry->dev_ee = dev_ee;
-@@ -159,7 +159,7 @@ TRACE_EVENT(mhi_tryset_pm_state,
+@@ -159,7 +167,11 @@ TRACE_EVENT(mhi_tryset_pm_state,
  	),
  
  	TP_fast_assign(
--		__assign_str(name);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(name);
++#else
 +		__assign_str(name, mhi_cntrl->mhi_dev->name);
++#endif
  		if (pm_state)
  			pm_state = __fls(pm_state);
  		__entry->pm_state = pm_state;
-@@ -185,7 +185,7 @@ DECLARE_EVENT_CLASS(mhi_process_event_ri
+@@ -185,7 +197,11 @@ DECLARE_EVENT_CLASS(mhi_process_event_ri
  	),
  
  	TP_fast_assign(
--		__assign_str(name);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(name);
++#else
 +		__assign_str(name, mhi_cntrl->mhi_dev->name);
++#endif
  		__entry->rp = rp;
  		__entry->ptr = le64_to_cpu(rp->ptr);
  		__entry->dword0 = le32_to_cpu(rp->dword[0]);
-@@ -227,7 +227,7 @@ DECLARE_EVENT_CLASS(mhi_update_channel_s
+@@ -227,7 +243,11 @@ DECLARE_EVENT_CLASS(mhi_update_channel_s
  	),
  
  	TP_fast_assign(
--		__assign_str(name);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(name);
++#else
 +		__assign_str(name, mhi_cntrl->mhi_dev->name);
++#endif
  		__entry->ch_num = mhi_chan->chan;
  		__entry->state = state;
  		__entry->reason = reason;
-@@ -266,7 +266,7 @@ TRACE_EVENT(mhi_pm_st_transition,
+@@ -266,7 +286,11 @@ TRACE_EVENT(mhi_pm_st_transition,
  	),
  
  	TP_fast_assign(
--		__assign_str(name);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(name);
++#else
 +		__assign_str(name, mhi_cntrl->mhi_dev->name);
++#endif
  		__entry->state = state;
  	),
  
 --- a/drivers/net/wireless/ath/ath10k/trace.h
 +++ b/drivers/net/wireless/ath/ath10k/trace.h
-@@ -55,8 +55,8 @@ DECLARE_EVENT_CLASS(ath10k_log_event,
+@@ -55,8 +55,13 @@ DECLARE_EVENT_CLASS(ath10k_log_event,
  		__vstring(msg, vaf->fmt, vaf->va)
  	),
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__assign_vstr(msg, vaf->fmt, vaf->va);
  	),
  	TP_printk(
-@@ -92,8 +92,8 @@ TRACE_EVENT(ath10k_log_dbg,
+@@ -92,8 +97,13 @@ TRACE_EVENT(ath10k_log_dbg,
  		__vstring(msg, vaf->fmt, vaf->va)
  	),
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->level = level;
  		__assign_vstr(msg, vaf->fmt, vaf->va);
  	),
-@@ -121,10 +121,10 @@ TRACE_EVENT(ath10k_log_dbg_dump,
+@@ -121,10 +131,17 @@ TRACE_EVENT(ath10k_log_dbg_dump,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
--		__assign_str(msg);
--		__assign_str(prefix);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
+ 		__assign_str(msg);
+ 		__assign_str(prefix);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
 +		__assign_str(msg, msg);
 +		__assign_str(prefix, prefix);
++#endif
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(buf), buf, buf_len);
  	),
-@@ -152,8 +152,8 @@ TRACE_EVENT(ath10k_wmi_cmd,
+@@ -152,8 +169,13 @@ TRACE_EVENT(ath10k_wmi_cmd,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->id = id;
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(buf), buf, buf_len);
-@@ -182,8 +182,8 @@ TRACE_EVENT(ath10k_wmi_event,
+@@ -182,8 +204,13 @@ TRACE_EVENT(ath10k_wmi_event,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->id = id;
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(buf), buf, buf_len);
-@@ -211,8 +211,8 @@ TRACE_EVENT(ath10k_htt_stats,
+@@ -211,8 +238,13 @@ TRACE_EVENT(ath10k_htt_stats,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(buf), buf, buf_len);
  	),
-@@ -239,8 +239,8 @@ TRACE_EVENT(ath10k_wmi_dbglog,
+@@ -239,8 +271,13 @@ TRACE_EVENT(ath10k_wmi_dbglog,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->hw_type = ar->hw_rev;
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(buf), buf, buf_len);
-@@ -269,8 +269,8 @@ TRACE_EVENT(ath10k_htt_pktlog,
+@@ -269,8 +306,13 @@ TRACE_EVENT(ath10k_htt_pktlog,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->hw_type = ar->hw_rev;
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(pktlog), buf, buf_len);
-@@ -301,8 +301,8 @@ TRACE_EVENT(ath10k_htt_tx,
+@@ -301,8 +343,13 @@ TRACE_EVENT(ath10k_htt_tx,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->msdu_id = msdu_id;
  		__entry->msdu_len = msdu_len;
  		__entry->vdev_id = vdev_id;
-@@ -332,8 +332,8 @@ TRACE_EVENT(ath10k_txrx_tx_unref,
+@@ -332,8 +379,13 @@ TRACE_EVENT(ath10k_txrx_tx_unref,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->msdu_id = msdu_id;
  	),
  
-@@ -358,8 +358,8 @@ DECLARE_EVENT_CLASS(ath10k_hdr_event,
+@@ -358,8 +410,13 @@ DECLARE_EVENT_CLASS(ath10k_hdr_event,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->len = ath10k_frm_hdr_len(data, len);
  		memcpy(__get_dynamic_array(data), data, __entry->len);
  	),
-@@ -386,8 +386,8 @@ DECLARE_EVENT_CLASS(ath10k_payload_event
+@@ -386,8 +443,13 @@ DECLARE_EVENT_CLASS(ath10k_payload_event
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->len = len - ath10k_frm_hdr_len(data, len);
  		memcpy(__get_dynamic_array(payload),
  		       data + ath10k_frm_hdr_len(data, len), __entry->len);
-@@ -435,8 +435,8 @@ TRACE_EVENT(ath10k_htt_rx_desc,
+@@ -435,8 +497,13 @@ TRACE_EVENT(ath10k_htt_rx_desc,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->hw_type = ar->hw_rev;
  		__entry->len = len;
  		memcpy(__get_dynamic_array(rxdesc), data, len);
-@@ -472,8 +472,8 @@ TRACE_EVENT(ath10k_wmi_diag_container,
+@@ -472,8 +539,13 @@ TRACE_EVENT(ath10k_wmi_diag_container,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->type = type;
  		__entry->timestamp = timestamp;
  		__entry->code = code;
-@@ -505,8 +505,8 @@ TRACE_EVENT(ath10k_wmi_diag,
+@@ -505,8 +577,13 @@ TRACE_EVENT(ath10k_wmi_diag,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->dev));
 +		__assign_str(driver, dev_driver_string(ar->dev));
++#endif
  		__entry->len = len;
  		memcpy(__get_dynamic_array(data), data, len);
  	),
 --- a/drivers/net/wireless/ath/ath11k/trace.h
 +++ b/drivers/net/wireless/ath/ath11k/trace.h
-@@ -48,8 +48,8 @@ TRACE_EVENT(ath11k_htt_pktlog,
+@@ -48,8 +48,13 @@ TRACE_EVENT(ath11k_htt_pktlog,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->ab->dev));
 +		__assign_str(driver, dev_driver_string(ar->ab->dev));
++#endif
  		__entry->buf_len = buf_len;
  		__entry->pktlog_checksum = pktlog_checksum;
  		memcpy(__get_dynamic_array(pktlog), buf, buf_len);
-@@ -77,8 +77,8 @@ TRACE_EVENT(ath11k_htt_ppdu_stats,
+@@ -77,8 +82,13 @@ TRACE_EVENT(ath11k_htt_ppdu_stats,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->ab->dev));
 +		__assign_str(driver, dev_driver_string(ar->ab->dev));
++#endif
  		__entry->len = len;
  		memcpy(__get_dynamic_array(ppdu), data, len);
  	),
-@@ -105,8 +105,8 @@ TRACE_EVENT(ath11k_htt_rxdesc,
+@@ -105,8 +115,13 @@ TRACE_EVENT(ath11k_htt_rxdesc,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->ab->dev));
 +		__assign_str(driver, dev_driver_string(ar->ab->dev));
++#endif
  		__entry->len = len;
  		__entry->log_type = log_type;
  		memcpy(__get_dynamic_array(rxdesc), data, len);
-@@ -130,8 +130,8 @@ DECLARE_EVENT_CLASS(ath11k_log_event,
+@@ -130,8 +145,13 @@ DECLARE_EVENT_CLASS(ath11k_log_event,
  		__vstring(msg, vaf->fmt, vaf->va)
  	),
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ab->dev));
 +		__assign_str(driver, dev_driver_string(ab->dev));
++#endif
  		__assign_vstr(msg, vaf->fmt, vaf->va);
  	),
  	TP_printk(
-@@ -171,8 +171,8 @@ TRACE_EVENT(ath11k_wmi_cmd,
+@@ -171,8 +191,13 @@ TRACE_EVENT(ath11k_wmi_cmd,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ab->dev));
 +		__assign_str(driver, dev_driver_string(ab->dev));
++#endif
  		__entry->id = id;
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(buf), buf, buf_len);
-@@ -201,8 +201,8 @@ TRACE_EVENT(ath11k_wmi_event,
+@@ -201,8 +226,13 @@ TRACE_EVENT(ath11k_wmi_event,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ab->dev));
 +		__assign_str(driver, dev_driver_string(ab->dev));
++#endif
  		__entry->id = id;
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(buf), buf, buf_len);
-@@ -230,8 +230,8 @@ TRACE_EVENT(ath11k_log_dbg,
+@@ -230,8 +260,13 @@ TRACE_EVENT(ath11k_log_dbg,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ab->dev));
 +		__assign_str(driver, dev_driver_string(ab->dev));
++#endif
  		__entry->level = level;
  		WARN_ON_ONCE(vsnprintf(__get_dynamic_array(msg),
  				       ATH11K_MSG_MAX, vaf->fmt,
-@@ -262,10 +262,10 @@ TRACE_EVENT(ath11k_log_dbg_dump,
+@@ -262,10 +297,17 @@ TRACE_EVENT(ath11k_log_dbg_dump,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
--		__assign_str(msg);
--		__assign_str(prefix);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
+ 		__assign_str(msg);
+ 		__assign_str(prefix);
++#else
 +		__assign_str(device, dev_name(ab->dev));
 +		__assign_str(driver, dev_driver_string(ab->dev));
 +		__assign_str(msg, msg);
 +		__assign_str(prefix, prefix);
++#endif
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(buf), buf, buf_len);
  	),
-@@ -292,8 +292,8 @@ TRACE_EVENT(ath11k_wmi_diag,
+@@ -292,8 +334,13 @@ TRACE_EVENT(ath11k_wmi_diag,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ab->dev));
 +		__assign_str(driver, dev_driver_string(ab->dev));
++#endif
  		__entry->len = len;
  		memcpy(__get_dynamic_array(data), data, len);
  	),
-@@ -318,8 +318,8 @@ TRACE_EVENT(ath11k_ps_timekeeper,
+@@ -318,8 +365,14 @@ TRACE_EVENT(ath11k_ps_timekeeper,
  			 __field(u32, peer_ps_timestamp)
  	),
  
 -	TP_fast_assign(__assign_str(device);
--		       __assign_str(driver);
-+	TP_fast_assign(__assign_str(device, dev_name(ar->ab->dev));
++	TP_fast_assign(
++#if LINUX_VERSION_IS_GEQ(6,10,0)
++		       __assign_str(device);
+ 		       __assign_str(driver);
++#else
++		       __assign_str(device, dev_name(ar->ab->dev));
 +		       __assign_str(driver, dev_driver_string(ar->ab->dev));
++#endif
  		       memcpy(__get_dynamic_array(peer_addr), peer_addr,
  			      ETH_ALEN);
  		       __entry->peer_ps_state = peer_ps_state;
 --- a/drivers/net/wireless/ath/ath12k/trace.h
 +++ b/drivers/net/wireless/ath/ath12k/trace.h
-@@ -36,8 +36,8 @@ TRACE_EVENT(ath12k_htt_pktlog,
+@@ -36,8 +36,13 @@ TRACE_EVENT(ath12k_htt_pktlog,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->ab->dev));
 +		__assign_str(driver, dev_driver_string(ar->ab->dev));
++#endif
  		__entry->buf_len = buf_len;
  		__entry->pktlog_checksum = pktlog_checksum;
  		memcpy(__get_dynamic_array(pktlog), buf, buf_len);
-@@ -73,8 +73,8 @@ TRACE_EVENT(ath12k_htt_ppdu_stats,
+@@ -73,8 +78,13 @@ TRACE_EVENT(ath12k_htt_ppdu_stats,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->ab->dev));
 +		__assign_str(driver, dev_driver_string(ar->ab->dev));
++#endif
  		__entry->len = len;
  		__entry->info = ar->pdev->timestamp.info;
  		__entry->sync_tstmp_lo_us = ar->pdev->timestamp.sync_timestamp_hi_us;
-@@ -117,8 +117,8 @@ TRACE_EVENT(ath12k_htt_rxdesc,
+@@ -117,8 +127,13 @@ TRACE_EVENT(ath12k_htt_rxdesc,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ar->ab->dev));
 +		__assign_str(driver, dev_driver_string(ar->ab->dev));
++#endif
  		__entry->len = len;
  		__entry->type = type;
  		__entry->info = ar->pdev->timestamp.info;
-@@ -153,8 +153,8 @@ TRACE_EVENT(ath12k_wmi_diag,
+@@ -153,8 +168,13 @@ TRACE_EVENT(ath12k_wmi_diag,
  	),
  
  	TP_fast_assign(
--		__assign_str(device);
--		__assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(device);
+ 		__assign_str(driver);
++#else
 +		__assign_str(device, dev_name(ab->dev));
 +		__assign_str(driver, dev_driver_string(ab->dev));
++#endif
  		__entry->len = len;
  		memcpy(__get_dynamic_array(data), data, len);
  	),
 --- a/drivers/net/wireless/ath/ath6kl/trace.h
 +++ b/drivers/net/wireless/ath/ath6kl/trace.h
-@@ -304,8 +304,8 @@ TRACE_EVENT(ath6kl_log_dbg_dump,
+@@ -304,8 +304,13 @@ TRACE_EVENT(ath6kl_log_dbg_dump,
  	),
  
  	TP_fast_assign(
--		__assign_str(msg);
--		__assign_str(prefix);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(msg);
+ 		__assign_str(prefix);
++#else
 +		__assign_str(msg, msg);
 +		__assign_str(prefix, prefix);
++#endif
  		__entry->buf_len = buf_len;
  		memcpy(__get_dynamic_array(buf), buf, buf_len);
  	),
 --- a/drivers/net/wireless/ath/trace.h
 +++ b/drivers/net/wireless/ath/trace.h
-@@ -44,8 +44,8 @@ TRACE_EVENT(ath_log,
+@@ -44,8 +44,13 @@ TRACE_EVENT(ath_log,
  	    ),
  
  	    TP_fast_assign(
--		    __assign_str(device);
--		    __assign_str(driver);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		    __assign_str(device);
+ 		    __assign_str(driver);
++#else
 +		    __assign_str(device, wiphy_name(wiphy));
 +		    __assign_str(driver, KBUILD_MODNAME);
++#endif
  		    __assign_vstr(msg, vaf->fmt, vaf->va);
  	    ),
  
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
-@@ -41,7 +41,7 @@ TRACE_EVENT(brcmf_err,
+@@ -41,7 +41,11 @@ TRACE_EVENT(brcmf_err,
  		__vstring(msg, vaf->fmt, vaf->va)
  	),
  	TP_fast_assign(
--		__assign_str(func);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(func);
++#else
 +		__assign_str(func, func);
++#endif
  		__assign_vstr(msg, vaf->fmt, vaf->va);
  	),
  	TP_printk("%s: %s", __get_str(func), __get_str(msg))
-@@ -57,7 +57,7 @@ TRACE_EVENT(brcmf_dbg,
+@@ -57,7 +61,11 @@ TRACE_EVENT(brcmf_dbg,
  	),
  	TP_fast_assign(
  		__entry->level = level;
--		__assign_str(func);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(func);
++#else
 +		__assign_str(func, func);
++#endif
  		__assign_vstr(msg, vaf->fmt, vaf->va);
  	),
  	TP_printk("%s: %s", __get_str(func), __get_str(msg))
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h
-@@ -81,7 +81,7 @@ TRACE_EVENT(brcms_macintstatus,
+@@ -81,7 +81,11 @@ TRACE_EVENT(brcms_macintstatus,
  		__field(u32, mask)
  	),
  	TP_fast_assign(
--		__assign_str(dev);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(dev);
++#else
 +		__assign_str(dev, dev_name(dev));
++#endif
  		__entry->in_isr = in_isr;
  		__entry->macintstatus = macintstatus;
  		__entry->mask = mask;
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h
-@@ -71,7 +71,7 @@ TRACE_EVENT(brcms_dbg,
+@@ -71,7 +71,11 @@ TRACE_EVENT(brcms_dbg,
  	),
  	TP_fast_assign(
  		__entry->level = level;
--		__assign_str(func);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(func);
++#else
 +		__assign_str(func, func);
++#endif
  		__assign_vstr(msg, vaf->fmt, vaf->va);
  	),
  	TP_printk("%s: %s", __get_str(func), __get_str(msg))
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h
-@@ -31,7 +31,7 @@ TRACE_EVENT(brcms_txdesc,
+@@ -31,7 +31,11 @@ TRACE_EVENT(brcms_txdesc,
  		__dynamic_array(u8, txh, txh_len)
  	),
  	TP_fast_assign(
--		__assign_str(dev);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(dev);
++#else
 +		__assign_str(dev, dev_name(dev));
++#endif
  		memcpy(__get_dynamic_array(txh), txh, txh_len);
  	),
  	TP_printk("[%s] txdesc", __get_str(dev))
-@@ -54,7 +54,7 @@ TRACE_EVENT(brcms_txstatus,
+@@ -54,7 +58,11 @@ TRACE_EVENT(brcms_txstatus,
  		__field(u16, ackphyrxsh)
  	),
  	TP_fast_assign(
--		__assign_str(dev);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(dev);
++#else
 +		__assign_str(dev, dev_name(dev));
++#endif
  		__entry->framelen = framelen;
  		__entry->frameid = frameid;
  		__entry->status = status;
-@@ -85,7 +85,7 @@ TRACE_EVENT(brcms_ampdu_session,
+@@ -85,7 +93,11 @@ TRACE_EVENT(brcms_ampdu_session,
  		__field(u16, dma_len)
  	),
  	TP_fast_assign(
--		__assign_str(dev);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(dev);
++#else
 +		__assign_str(dev, dev_name(dev));
++#endif
  		__entry->max_ampdu_len = max_ampdu_len;
  		__entry->max_ampdu_frames = max_ampdu_frames;
  		__entry->ampdu_len = ampdu_len;
 --- a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h
 +++ b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h
-@@ -57,7 +57,7 @@ TRACE_EVENT(iwlwifi_dbg,
+@@ -57,7 +57,11 @@ TRACE_EVENT(iwlwifi_dbg,
  	),
  	TP_fast_assign(
  		__entry->level = level;
--		__assign_str(function);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(function);
++#else
 +		__assign_str(function, function);
++#endif
  		__assign_vstr(msg, vaf->fmt, vaf->va);
  	),
  	TP_printk("%s", __get_str(msg))
 --- a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h
 +++ b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h
-@@ -87,7 +87,7 @@ static inline void trace_ ## name(proto)
+@@ -87,7 +87,11 @@ static inline void trace_ ## name(proto)
  #endif
  
  #define DEV_ENTRY	__string(dev, dev_name(dev))
--#define DEV_ASSIGN	__assign_str(dev)
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ #define DEV_ASSIGN	__assign_str(dev)
++#else
 +#define DEV_ASSIGN	__assign_str(dev, dev_name(dev))
++#endif
  
  #include "iwl-devtrace-io.h"
  #include "iwl-devtrace-ucode.h"
 --- a/include/trace/events/qrtr.h
 +++ b/include/trace/events/qrtr.h
-@@ -102,7 +102,7 @@ TRACE_EVENT(qrtr_ns_message,
+@@ -102,7 +102,11 @@ TRACE_EVENT(qrtr_ns_message,
  	),
  
  	TP_fast_assign(
--		__assign_str(ctrl_pkt_str);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(ctrl_pkt_str);
++#else
 +		__assign_str(ctrl_pkt_str, ctrl_pkt_str);
++#endif
  		__entry->sq_node = sq_node;
  		__entry->sq_port = sq_port;
  	),
 --- a/net/mac80211/trace.h
 +++ b/net/mac80211/trace.h
-@@ -33,7 +33,7 @@
+@@ -31,9 +31,15 @@
+ #define VIF_ENTRY	__field(enum nl80211_iftype, vif_type) __field(void *, sdata)	\
+ 			__field(bool, p2p)						\
  			__string(vif_name, sdata->name)
++#if LINUX_VERSION_IS_GEQ(6,10,0)
  #define VIF_ASSIGN	__entry->vif_type = sdata->vif.type; __entry->sdata = sdata;	\
  			__entry->p2p = sdata->vif.p2p;					\
--			__assign_str(vif_name)
+ 			__assign_str(vif_name)
++#else
++#define VIF_ASSIGN	__entry->vif_type = sdata->vif.type; __entry->sdata = sdata;	\
++			__entry->p2p = sdata->vif.p2p;					\
 +			__assign_str(vif_name, sdata->name)
++#endif
  #define VIF_PR_FMT	" vif:%s(%d%s)"
  #define VIF_PR_ARG	__get_str(vif_name), __entry->vif_type, __entry->p2p ? "/p2p" : ""
  
 --- a/net/wireless/trace.h
 +++ b/net/wireless/trace.h
-@@ -446,7 +446,7 @@ TRACE_EVENT(rdev_add_virtual_intf,
+@@ -446,7 +446,11 @@ TRACE_EVENT(rdev_add_virtual_intf,
  	),
  	TP_fast_assign(
  		WIPHY_ASSIGN;
--		__assign_str(vir_intf_name);
++#if LINUX_VERSION_IS_GEQ(6,10,0)
+ 		__assign_str(vir_intf_name);
++#else
 +		__assign_str(vir_intf_name, name ? name : "<noname>");
++#endif
  		__entry->type = type;
  	),
  	TP_printk(WIPHY_PR_FMT ", virtual intf name: %s, type: %d",
diff --git a/package/kernel/mac80211/patches/rt2x00/602-01-wifi-rt2x00-Add-support-for-loading-EEPROM-from-user.patch b/package/kernel/mac80211/patches/rt2x00/602-01-wifi-rt2x00-Add-support-for-loading-EEPROM-from-user.patch
index f3c8ddd4f6..cc3aa56618 100644
--- a/package/kernel/mac80211/patches/rt2x00/602-01-wifi-rt2x00-Add-support-for-loading-EEPROM-from-user.patch
+++ b/package/kernel/mac80211/patches/rt2x00/602-01-wifi-rt2x00-Add-support-for-loading-EEPROM-from-user.patch
@@ -108,6 +108,20 @@ Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
  
  	/*
  	 * Capabilities
+@@ -1505,4 +1506,13 @@ void rt2x00lib_remove_dev(struct rt2x00_
+ int rt2x00lib_suspend(struct rt2x00_dev *rt2x00dev);
+ int rt2x00lib_resume(struct rt2x00_dev *rt2x00dev);
+ 
++/*
++ * EEPROM file handlers.
++ */
++#ifdef CPTCFG_RT2X00_LIB_EEPROM
++int rt2x00lib_read_eeprom(struct rt2x00_dev *rt2x00dev);
++#else
++#define rt2x00lib_read_eeprom	NULL
++#endif /* CPTCFG_RT2X00_LIB_EEPROM */
++ 
+ #endif /* RT2X00_H */
 --- /dev/null
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
 @@ -0,0 +1,77 @@
@@ -210,19 +224,3 @@ Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
  	if (rt2800pci_efuse_detect(rt2x00dev))
  		retval = rt2800pci_read_eeprom_efuse(rt2x00dev);
  	else
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -270,4 +270,13 @@ void rt2800_get_txwi_rxwi_size(struct rt
- 			       unsigned short *rxwi_size);
- void rt2800_pre_reset_hw(struct rt2x00_dev *rt2x00dev);
- 
-+/*
-+ * EEPROM file handlers.
-+ */
-+#ifdef CPTCFG_RT2X00_LIB_EEPROM
-+int rt2x00lib_read_eeprom(struct rt2x00_dev *rt2x00dev);
-+#else
-+#define rt2x00lib_read_eeprom	NULL
-+#endif /* CPTCFG_RT2X00_LIB_EEPROM */
-+
- #endif /* RT2800LIB_H */
diff --git a/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch
index 88a72fd03e..a92de13594 100644
--- a/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch
+++ b/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch
@@ -31,7 +31,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  	mutex_unlock(&rt2x00dev->csr_mutex);
  }
  
-+void rt6352_enable_pa_pin(struct rt2x00_dev *rt2x00dev, int enable)
++static void rt6352_enable_pa_pin(struct rt2x00_dev *rt2x00dev, int enable)
 +{
 +	if (!rt2x00dev->pinctrl)
 +		return;
diff --git a/package/kernel/mac80211/patches/rt2x00/997-rt2x00-change-remove-to-remove_new.patch b/package/kernel/mac80211/patches/rt2x00/997-rt2x00-change-remove-to-remove_new.patch
new file mode 100644
index 0000000000..f1a7267b1a
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/997-rt2x00-change-remove-to-remove_new.patch
@@ -0,0 +1,42 @@
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+@@ -273,7 +273,7 @@ static struct platform_driver rt2800soc_
+ 		.of_match_table	= rt2880_wmac_match,
+ 	},
+ 	.probe		= rt2800soc_probe,
+-	.remove		= rt2x00soc_remove,
++	.remove_new	= rt2x00soc_remove,
+ 	.suspend	= rt2x00soc_suspend,
+ 	.resume		= rt2x00soc_resume,
+ };
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
+@@ -124,7 +124,7 @@ exit_free_device:
+ }
+ EXPORT_SYMBOL_GPL(rt2x00soc_probe);
+ 
+-int rt2x00soc_remove(struct platform_device *pdev)
++void rt2x00soc_remove(struct platform_device *pdev)
+ {
+ 	struct ieee80211_hw *hw = platform_get_drvdata(pdev);
+ 	struct rt2x00_dev *rt2x00dev = hw->priv;
+@@ -135,8 +135,6 @@ int rt2x00soc_remove(struct platform_dev
+ 	rt2x00lib_remove_dev(rt2x00dev);
+ 	rt2x00soc_free_reg(rt2x00dev);
+ 	ieee80211_free_hw(hw);
+-
+-	return 0;
+ }
+ EXPORT_SYMBOL_GPL(rt2x00soc_remove);
+ 
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h
+@@ -17,7 +17,7 @@
+  * SoC driver handlers.
+  */
+ int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops);
+-int rt2x00soc_remove(struct platform_device *pdev);
++void rt2x00soc_remove(struct platform_device *pdev);
+ #ifdef CONFIG_PM
+ int rt2x00soc_suspend(struct platform_device *pdev, pm_message_t state);
+ int rt2x00soc_resume(struct platform_device *pdev);
diff --git a/package/kernel/mac80211/patches/subsys/306-wifi-mac80211-call-rate_control_rate_update-for-link.patch b/package/kernel/mac80211/patches/subsys/306-wifi-mac80211-call-rate_control_rate_update-for-link.patch
new file mode 100644
index 0000000000..0ccdfb9fb5
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/306-wifi-mac80211-call-rate_control_rate_update-for-link.patch
@@ -0,0 +1,548 @@
+From: Johannes Berg <johannes.berg@intel.com>
+Date: Mon, 7 Oct 2024 15:00:54 +0300
+Subject: [PATCH] wifi: mac80211: call rate_control_rate_update() for link STA
+
+In order to update the right link information, call the update
+rate_control_rate_update() with the right link_sta, and then
+pass that through to the driver's sta_rc_update() method. The
+software rate control still doesn't support it, but that'll be
+skipped by not having a rate control ref.
+
+Since it now operates on a link sta, rename the driver method.
+
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: Miri Korenblit <miriam.rachel.korenblit@intel.com>
+Link: https://patch.msgid.link/20241007144851.5851b6b5fd41.Ibdf50d96afa4b761dd9b9dfd54a1147e77a75329@changeid
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/drivers/net/wireless/ath/ath10k/mac.c
++++ b/drivers/net/wireless/ath/ath10k/mac.c
+@@ -8507,9 +8507,10 @@ exit:
+ 
+ static void ath10k_sta_rc_update(struct ieee80211_hw *hw,
+ 				 struct ieee80211_vif *vif,
+-				 struct ieee80211_sta *sta,
++				 struct ieee80211_link_sta *link_sta,
+ 				 u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct ath10k *ar = hw->priv;
+ 	struct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;
+ 	struct ath10k_vif *arvif = (void *)vif->drv_priv;
+@@ -9450,7 +9451,7 @@ static const struct ieee80211_ops ath10k
+ 	.reconfig_complete		= ath10k_reconfig_complete,
+ 	.get_survey			= ath10k_get_survey,
+ 	.set_bitrate_mask		= ath10k_mac_op_set_bitrate_mask,
+-	.sta_rc_update			= ath10k_sta_rc_update,
++	.link_sta_rc_update		= ath10k_sta_rc_update,
+ 	.offset_tsf			= ath10k_offset_tsf,
+ 	.ampdu_action			= ath10k_ampdu_action,
+ 	.get_et_sset_count		= ath10k_debug_get_et_sset_count,
+--- a/drivers/net/wireless/ath/ath11k/mac.c
++++ b/drivers/net/wireless/ath/ath11k/mac.c
+@@ -5079,9 +5079,10 @@ static void ath11k_mac_op_sta_set_4addr(
+ 
+ static void ath11k_mac_op_sta_rc_update(struct ieee80211_hw *hw,
+ 					struct ieee80211_vif *vif,
+-					struct ieee80211_sta *sta,
++					struct ieee80211_link_sta *link_sta,
+ 					u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct ath11k *ar = hw->priv;
+ 	struct ath11k_sta *arsta = ath11k_sta_to_arsta(sta);
+ 	struct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);
+@@ -9708,7 +9709,7 @@ static const struct ieee80211_ops ath11k
+ 	.sta_state                      = ath11k_mac_op_sta_state,
+ 	.sta_set_4addr                  = ath11k_mac_op_sta_set_4addr,
+ 	.sta_set_txpwr			= ath11k_mac_op_sta_set_txpwr,
+-	.sta_rc_update			= ath11k_mac_op_sta_rc_update,
++	.link_sta_rc_update		= ath11k_mac_op_sta_rc_update,
+ 	.conf_tx                        = ath11k_mac_op_conf_tx,
+ 	.set_antenna			= ath11k_mac_op_set_antenna,
+ 	.get_antenna			= ath11k_mac_op_get_antenna,
+--- a/drivers/net/wireless/ath/ath12k/mac.c
++++ b/drivers/net/wireless/ath/ath12k/mac.c
+@@ -4740,9 +4740,10 @@ out:
+ 
+ static void ath12k_mac_op_sta_rc_update(struct ieee80211_hw *hw,
+ 					struct ieee80211_vif *vif,
+-					struct ieee80211_sta *sta,
++					struct ieee80211_link_sta *link_sta,
+ 					u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct ath12k *ar;
+ 	struct ath12k_sta *arsta = ath12k_sta_to_arsta(sta);
+ 	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+@@ -8684,7 +8685,7 @@ static const struct ieee80211_ops ath12k
+ 	.set_rekey_data	                = ath12k_mac_op_set_rekey_data,
+ 	.sta_state                      = ath12k_mac_op_sta_state,
+ 	.sta_set_txpwr			= ath12k_mac_op_sta_set_txpwr,
+-	.sta_rc_update			= ath12k_mac_op_sta_rc_update,
++	.link_sta_rc_update		= ath12k_mac_op_sta_rc_update,
+ 	.conf_tx                        = ath12k_mac_op_conf_tx,
+ 	.set_antenna			= ath12k_mac_op_set_antenna,
+ 	.get_antenna			= ath12k_mac_op_get_antenna,
+--- a/drivers/net/wireless/ath/ath9k/htc_drv_main.c
++++ b/drivers/net/wireless/ath/ath9k/htc_drv_main.c
+@@ -1357,8 +1357,10 @@ static int ath9k_htc_sta_remove(struct i
+ 
+ static void ath9k_htc_sta_rc_update(struct ieee80211_hw *hw,
+ 				    struct ieee80211_vif *vif,
+-				    struct ieee80211_sta *sta, u32 changed)
++				    struct ieee80211_link_sta *link_sta,
++				    u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;
+ 
+ 	if (!(changed & IEEE80211_RC_SUPP_RATES_CHANGED))
+@@ -1883,7 +1885,7 @@ struct ieee80211_ops ath9k_htc_ops = {
+ 	.sta_add            = ath9k_htc_sta_add,
+ 	.sta_remove         = ath9k_htc_sta_remove,
+ 	.conf_tx            = ath9k_htc_conf_tx,
+-	.sta_rc_update      = ath9k_htc_sta_rc_update,
++	.link_sta_rc_update = ath9k_htc_sta_rc_update,
+ 	.bss_info_changed   = ath9k_htc_bss_info_changed,
+ 	.set_key            = ath9k_htc_set_key,
+ 	.get_tsf            = ath9k_htc_get_tsf,
+--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
++++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
+@@ -4248,8 +4248,9 @@ int iwl_mvm_mac_set_rts_threshold(struct
+ }
+ 
+ void iwl_mvm_sta_rc_update(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+-			   struct ieee80211_sta *sta, u32 changed)
++			   struct ieee80211_link_sta *link_sta, u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ 
+ 	if (changed & (IEEE80211_RC_BW_CHANGED |
+@@ -6574,7 +6575,7 @@ const struct ieee80211_ops iwl_mvm_hw_op
+ 	.allow_buffered_frames = iwl_mvm_mac_allow_buffered_frames,
+ 	.release_buffered_frames = iwl_mvm_mac_release_buffered_frames,
+ 	.set_rts_threshold = iwl_mvm_mac_set_rts_threshold,
+-	.sta_rc_update = iwl_mvm_sta_rc_update,
++	.link_sta_rc_update = iwl_mvm_sta_rc_update,
+ 	.conf_tx = iwl_mvm_mac_conf_tx,
+ 	.mgd_prepare_tx = iwl_mvm_mac_mgd_prepare_tx,
+ 	.mgd_complete_tx = iwl_mvm_mac_mgd_complete_tx,
+--- a/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac80211.c
++++ b/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac80211.c
+@@ -1413,7 +1413,7 @@ const struct ieee80211_ops iwl_mvm_mld_h
+ 	.allow_buffered_frames = iwl_mvm_mac_allow_buffered_frames,
+ 	.release_buffered_frames = iwl_mvm_mac_release_buffered_frames,
+ 	.set_rts_threshold = iwl_mvm_mac_set_rts_threshold,
+-	.sta_rc_update = iwl_mvm_sta_rc_update,
++	.link_sta_rc_update = iwl_mvm_sta_rc_update,
+ 	.conf_tx = iwl_mvm_mld_mac_conf_tx,
+ 	.mgd_prepare_tx = iwl_mvm_mac_mgd_prepare_tx,
+ 	.mgd_complete_tx = iwl_mvm_mac_mgd_complete_tx,
+--- a/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
++++ b/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
+@@ -2914,7 +2914,7 @@ iwl_mvm_mac_release_buffered_frames(stru
+ 				    bool more_data);
+ int iwl_mvm_mac_set_rts_threshold(struct ieee80211_hw *hw, u32 value);
+ void iwl_mvm_sta_rc_update(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+-			   struct ieee80211_sta *sta, u32 changed);
++			   struct ieee80211_link_sta *link_sta, u32 changed);
+ void iwl_mvm_mac_mgd_prepare_tx(struct ieee80211_hw *hw,
+ 				struct ieee80211_vif *vif,
+ 				struct ieee80211_prep_tx_info *info);
+--- a/drivers/net/wireless/mediatek/mt76/mt7915/main.c
++++ b/drivers/net/wireless/mediatek/mt76/mt7915/main.c
+@@ -1163,9 +1163,10 @@ static void mt7915_sta_rc_work(void *dat
+ 
+ static void mt7915_sta_rc_update(struct ieee80211_hw *hw,
+ 				 struct ieee80211_vif *vif,
+-				 struct ieee80211_sta *sta,
++				 struct ieee80211_link_sta *link_sta,
+ 				 u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct mt7915_phy *phy = mt7915_hw_phy(hw);
+ 	struct mt7915_dev *dev = phy->dev;
+ 	struct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;
+@@ -1709,7 +1710,7 @@ const struct ieee80211_ops mt7915_ops =
+ 	.stop_ap = mt7915_stop_ap,
+ 	.sta_state = mt76_sta_state,
+ 	.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,
+-	.sta_rc_update = mt7915_sta_rc_update,
++	.link_sta_rc_update = mt7915_sta_rc_update,
+ 	.set_key = mt7915_set_key,
+ 	.ampdu_action = mt7915_ampdu_action,
+ 	.set_rts_threshold = mt7915_set_rts_threshold,
+--- a/drivers/net/wireless/mediatek/mt76/mt7996/main.c
++++ b/drivers/net/wireless/mediatek/mt76/mt7996/main.c
+@@ -1060,9 +1060,10 @@ static void mt7996_sta_rc_work(void *dat
+ 
+ static void mt7996_sta_rc_update(struct ieee80211_hw *hw,
+ 				 struct ieee80211_vif *vif,
+-				 struct ieee80211_sta *sta,
++				 struct ieee80211_link_sta *link_sta,
+ 				 u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+ 	struct mt7996_dev *dev = phy->dev;
+ 
+@@ -1472,7 +1473,7 @@ const struct ieee80211_ops mt7996_ops =
+ 	.sta_add = mt7996_sta_add,
+ 	.sta_remove = mt7996_sta_remove,
+ 	.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,
+-	.sta_rc_update = mt7996_sta_rc_update,
++	.link_sta_rc_update = mt7996_sta_rc_update,
+ 	.set_key = mt7996_set_key,
+ 	.ampdu_action = mt7996_ampdu_action,
+ 	.set_rts_threshold = mt7996_set_rts_threshold,
+--- a/drivers/net/wireless/realtek/rtw88/mac80211.c
++++ b/drivers/net/wireless/realtek/rtw88/mac80211.c
+@@ -928,8 +928,10 @@ static int rtw_ops_set_sar_specs(struct
+ 
+ static void rtw_ops_sta_rc_update(struct ieee80211_hw *hw,
+ 				  struct ieee80211_vif *vif,
+-				  struct ieee80211_sta *sta, u32 changed)
++				  struct ieee80211_link_sta *link_sta,
++				  u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct rtw_dev *rtwdev = hw->priv;
+ 	struct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;
+ 
+@@ -973,7 +975,7 @@ const struct ieee80211_ops rtw_ops = {
+ 	.reconfig_complete	= rtw_reconfig_complete,
+ 	.hw_scan		= rtw_ops_hw_scan,
+ 	.cancel_hw_scan		= rtw_ops_cancel_hw_scan,
+-	.sta_rc_update		= rtw_ops_sta_rc_update,
++	.link_sta_rc_update	= rtw_ops_sta_rc_update,
+ 	.set_sar_specs          = rtw_ops_set_sar_specs,
+ #ifdef CONFIG_PM
+ 	.suspend		= rtw_ops_suspend,
+--- a/drivers/net/wireless/realtek/rtw89/mac80211.c
++++ b/drivers/net/wireless/realtek/rtw89/mac80211.c
+@@ -1290,8 +1290,10 @@ out:
+ 
+ static void rtw89_ops_sta_rc_update(struct ieee80211_hw *hw,
+ 				    struct ieee80211_vif *vif,
+-				    struct ieee80211_sta *sta, u32 changed)
++				    struct ieee80211_link_sta *link_sta,
++				    u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct rtw89_dev *rtwdev = hw->priv;
+ 
+ 	rtw89_phy_ra_update_sta(rtwdev, sta, changed);
+@@ -1594,7 +1596,7 @@ const struct ieee80211_ops rtw89_ops = {
+ 	.remain_on_channel		= rtw89_ops_remain_on_channel,
+ 	.cancel_remain_on_channel	= rtw89_ops_cancel_remain_on_channel,
+ 	.set_sar_specs		= rtw89_ops_set_sar_specs,
+-	.sta_rc_update		= rtw89_ops_sta_rc_update,
++	.link_sta_rc_update	= rtw89_ops_sta_rc_update,
+ 	.set_tid_config		= rtw89_ops_set_tid_config,
+ #ifdef CONFIG_PM
+ 	.suspend		= rtw89_ops_suspend,
+--- a/drivers/net/wireless/ti/wlcore/main.c
++++ b/drivers/net/wireless/ti/wlcore/main.c
+@@ -5789,9 +5789,10 @@ static int wlcore_op_cancel_remain_on_ch
+ 
+ static void wlcore_op_sta_rc_update(struct ieee80211_hw *hw,
+ 				    struct ieee80211_vif *vif,
+-				    struct ieee80211_sta *sta,
++				    struct ieee80211_link_sta *link_sta,
+ 				    u32 changed)
+ {
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	struct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);
+ 
+ 	wl1271_debug(DEBUG_MAC80211, "mac80211 sta_rc_update");
+@@ -6052,7 +6053,7 @@ static const struct ieee80211_ops wl1271
+ 	.assign_vif_chanctx = wlcore_op_assign_vif_chanctx,
+ 	.unassign_vif_chanctx = wlcore_op_unassign_vif_chanctx,
+ 	.switch_vif_chanctx = wlcore_op_switch_vif_chanctx,
+-	.sta_rc_update = wlcore_op_sta_rc_update,
++	.link_sta_rc_update = wlcore_op_sta_rc_update,
+ 	.sta_statistics = wlcore_op_sta_statistics,
+ 	.get_expected_throughput = wlcore_op_get_expected_throughput,
+ 	CFG80211_TESTMODE_CMD(wl1271_tm_cmd)
+--- a/drivers/net/wireless/virtual/mac80211_hwsim.c
++++ b/drivers/net/wireless/virtual/mac80211_hwsim.c
+@@ -2594,10 +2594,11 @@ static void mac80211_hwsim_link_info_cha
+ static void
+ mac80211_hwsim_sta_rc_update(struct ieee80211_hw *hw,
+ 			     struct ieee80211_vif *vif,
+-			     struct ieee80211_sta *sta,
++			     struct ieee80211_link_sta *link_sta,
+ 			     u32 changed)
+ {
+ 	struct mac80211_hwsim_data *data = hw->priv;
++	struct ieee80211_sta *sta = link_sta->sta;
+ 	u32 bw = U32_MAX;
+ 	int link_id;
+ 
+@@ -2607,7 +2608,6 @@ mac80211_hwsim_sta_rc_update(struct ieee
+ 	     link_id++) {
+ 		enum nl80211_chan_width confbw = NL80211_CHAN_WIDTH_20_NOHT;
+ 		struct ieee80211_bss_conf *vif_conf;
+-		struct ieee80211_link_sta *link_sta;
+ 
+ 		link_sta = rcu_dereference(sta->link[link_id]);
+ 
+@@ -2659,7 +2659,7 @@ static int mac80211_hwsim_sta_add(struct
+ 
+ 	hwsim_check_magic(vif);
+ 	hwsim_set_sta_magic(sta);
+-	mac80211_hwsim_sta_rc_update(hw, vif, sta, 0);
++	mac80211_hwsim_sta_rc_update(hw, vif, &sta->deflink, 0);
+ 
+ 	if (sta->valid_links) {
+ 		WARN(hweight16(sta->valid_links) > 1,
+@@ -3961,7 +3961,7 @@ out:
+ 	.link_info_changed = mac80211_hwsim_link_info_changed,  \
+ 	.tx_last_beacon = mac80211_hwsim_tx_last_beacon,	\
+ 	.sta_notify = mac80211_hwsim_sta_notify,		\
+-	.sta_rc_update = mac80211_hwsim_sta_rc_update,		\
++	.link_sta_rc_update = mac80211_hwsim_sta_rc_update,	\
+ 	.conf_tx = mac80211_hwsim_conf_tx,			\
+ 	.get_survey = mac80211_hwsim_get_survey,		\
+ 	CFG80211_TESTMODE_CMD(mac80211_hwsim_testmode_cmd)	\
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -4075,8 +4075,8 @@ struct ieee80211_prep_tx_info {
+  *	in @sta_state.
+  *	The callback can sleep.
+  *
+- * @sta_rc_update: Notifies the driver of changes to the bitrates that can be
+- *	used to transmit to the station. The changes are advertised with bits
++ * @link_sta_rc_update: Notifies the driver of changes to the bitrates that can
++ *	be used to transmit to the station. The changes are advertised with bits
+  *	from &enum ieee80211_rate_control_changed and the values are reflected
+  *	in the station data. This callback should only be used when the driver
+  *	uses hardware rate control (%IEEE80211_HW_HAS_RATE_CONTROL) since
+@@ -4560,10 +4560,10 @@ struct ieee80211_ops {
+ 	void (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,
+ 				   struct ieee80211_vif *vif,
+ 				   struct ieee80211_sta *sta);
+-	void (*sta_rc_update)(struct ieee80211_hw *hw,
+-			      struct ieee80211_vif *vif,
+-			      struct ieee80211_sta *sta,
+-			      u32 changed);
++	void (*link_sta_rc_update)(struct ieee80211_hw *hw,
++				   struct ieee80211_vif *vif,
++				   struct ieee80211_link_sta *link_sta,
++				   u32 changed);
+ 	void (*sta_rate_tbl_update)(struct ieee80211_hw *hw,
+ 				    struct ieee80211_vif *vif,
+ 				    struct ieee80211_sta *sta);
+--- a/net/mac80211/chan.c
++++ b/net/mac80211/chan.c
+@@ -467,7 +467,7 @@ static void ieee80211_chan_bw_change(str
+ 				continue;
+ 
+ 			link_sta->pub->bandwidth = new_sta_bw;
+-			rate_control_rate_update(local, sband, sta, link_id,
++			rate_control_rate_update(local, sband, link_sta,
+ 						 IEEE80211_RC_BW_CHANGED);
+ 		}
+ 	}
+--- a/net/mac80211/driver-ops.c
++++ b/net/mac80211/driver-ops.c
+@@ -181,9 +181,10 @@ int drv_sta_set_txpwr(struct ieee80211_l
+ 	return ret;
+ }
+ 
+-void drv_sta_rc_update(struct ieee80211_local *local,
+-		       struct ieee80211_sub_if_data *sdata,
+-		       struct ieee80211_sta *sta, u32 changed)
++void drv_link_sta_rc_update(struct ieee80211_local *local,
++			    struct ieee80211_sub_if_data *sdata,
++			    struct ieee80211_link_sta *link_sta,
++			    u32 changed)
+ {
+ 	sdata = get_bss_sdata(sdata);
+ 	if (!check_sdata_in_driver(sdata))
+@@ -193,10 +194,10 @@ void drv_sta_rc_update(struct ieee80211_
+ 		(sdata->vif.type != NL80211_IFTYPE_ADHOC &&
+ 		 sdata->vif.type != NL80211_IFTYPE_MESH_POINT));
+ 
+-	trace_drv_sta_rc_update(local, sdata, sta, changed);
+-	if (local->ops->sta_rc_update)
+-		local->ops->sta_rc_update(&local->hw, &sdata->vif,
+-					  sta, changed);
++	trace_drv_link_sta_rc_update(local, sdata, link_sta, changed);
++	if (local->ops->link_sta_rc_update)
++		local->ops->link_sta_rc_update(&local->hw, &sdata->vif,
++					       link_sta, changed);
+ 
+ 	trace_drv_return_void(local);
+ }
+--- a/net/mac80211/driver-ops.h
++++ b/net/mac80211/driver-ops.h
+@@ -594,9 +594,9 @@ int drv_sta_set_txpwr(struct ieee80211_l
+ 		      struct ieee80211_sub_if_data *sdata,
+ 		      struct sta_info *sta);
+ 
+-void drv_sta_rc_update(struct ieee80211_local *local,
+-		       struct ieee80211_sub_if_data *sdata,
+-		       struct ieee80211_sta *sta, u32 changed);
++void drv_link_sta_rc_update(struct ieee80211_local *local,
++			    struct ieee80211_sub_if_data *sdata,
++			    struct ieee80211_link_sta *link_sta, u32 changed);
+ 
+ static inline void drv_sta_rate_tbl_update(struct ieee80211_local *local,
+ 					   struct ieee80211_sub_if_data *sdata,
+--- a/net/mac80211/ibss.c
++++ b/net/mac80211/ibss.c
+@@ -1072,7 +1072,8 @@ static void ieee80211_update_sta_info(st
+ 		if (sta->sta.deflink.rx_nss != rx_nss)
+ 			changed |= IEEE80211_RC_NSS_CHANGED;
+ 
+-		drv_sta_rc_update(local, sdata, &sta->sta, changed);
++		drv_link_sta_rc_update(local, sdata, &sta->sta.deflink,
++				       changed);
+ 	}
+ 
+ 	rcu_read_unlock();
+--- a/net/mac80211/mesh_plink.c
++++ b/net/mac80211/mesh_plink.c
+@@ -489,7 +489,7 @@ static void mesh_sta_info_init(struct ie
+ 	if (!test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
+ 		rate_control_rate_init(sta);
+ 	else
+-		rate_control_rate_update(local, sband, sta, 0, changed);
++		rate_control_rate_update(local, sband, &sta->deflink, changed);
+ out:
+ 	spin_unlock_bh(&sta->mesh->plink_lock);
+ }
+--- a/net/mac80211/rate.c
++++ b/net/mac80211/rate.c
+@@ -93,16 +93,15 @@ void rate_control_tx_status(struct ieee8
+ 
+ void rate_control_rate_update(struct ieee80211_local *local,
+ 			      struct ieee80211_supported_band *sband,
+-			      struct sta_info *sta, unsigned int link_id,
++			      struct link_sta_info *link_sta,
+ 			      u32 changed)
+ {
+ 	struct rate_control_ref *ref = local->rate_ctrl;
++	struct sta_info *sta = link_sta->sta;
+ 	struct ieee80211_sta *ista = &sta->sta;
+ 	void *priv_sta = sta->rate_ctrl_priv;
+ 	struct ieee80211_chanctx_conf *chanctx_conf;
+ 
+-	WARN_ON(link_id != 0);
+-
+ 	if (ref && ref->ops->rate_update) {
+ 		rcu_read_lock();
+ 
+@@ -120,7 +119,8 @@ void rate_control_rate_update(struct iee
+ 	}
+ 
+ 	if (sta->uploaded)
+-		drv_sta_rc_update(local, sta->sdata, &sta->sta, changed);
++		drv_link_sta_rc_update(local, sta->sdata, link_sta->pub,
++				       changed);
+ }
+ 
+ int ieee80211_rate_control_register(const struct rate_control_ops *ops)
+--- a/net/mac80211/rate.h
++++ b/net/mac80211/rate.h
+@@ -32,8 +32,7 @@ void rate_control_tx_status(struct ieee8
+ void rate_control_rate_init(struct sta_info *sta);
+ void rate_control_rate_update(struct ieee80211_local *local,
+ 			      struct ieee80211_supported_band *sband,
+-			      struct sta_info *sta,
+-			      unsigned int link_id,
++			      struct link_sta_info *link_sta,
+ 			      u32 changed);
+ 
+ static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,
+--- a/net/mac80211/rx.c
++++ b/net/mac80211/rx.c
+@@ -3568,7 +3568,7 @@ ieee80211_rx_h_action(struct ieee80211_r
+ 
+ 			sband = rx->local->hw.wiphy->bands[status->band];
+ 
+-			rate_control_rate_update(local, sband, rx->sta, 0,
++			rate_control_rate_update(local, sband, rx->link_sta,
+ 						 IEEE80211_RC_SMPS_CHANGED);
+ 			cfg80211_sta_opmode_change_notify(sdata->dev,
+ 							  rx->sta->addr,
+@@ -3605,7 +3605,7 @@ ieee80211_rx_h_action(struct ieee80211_r
+ 				ieee80211_sta_rx_bw_to_chan_width(rx->link_sta);
+ 			sta_opmode.changed = STA_OPMODE_MAX_BW_CHANGED;
+ 
+-			rate_control_rate_update(local, sband, rx->sta, 0,
++			rate_control_rate_update(local, sband, rx->link_sta,
+ 						 IEEE80211_RC_BW_CHANGED);
+ 			cfg80211_sta_opmode_change_notify(sdata->dev,
+ 							  rx->sta->addr,
+--- a/net/mac80211/tdls.c
++++ b/net/mac80211/tdls.c
+@@ -1342,7 +1342,8 @@ static void iee80211_tdls_recalc_chanctx
+ 			bw = min(bw, ieee80211_sta_cap_rx_bw(&sta->deflink));
+ 			if (bw != sta->sta.deflink.bandwidth) {
+ 				sta->sta.deflink.bandwidth = bw;
+-				rate_control_rate_update(local, sband, sta, 0,
++				rate_control_rate_update(local, sband,
++							 &sta->deflink,
+ 							 IEEE80211_RC_BW_CHANGED);
+ 				/*
+ 				 * if a TDLS peer BW was updated, we need to
+--- a/net/mac80211/trace.h
++++ b/net/mac80211/trace.h
+@@ -945,31 +945,34 @@ TRACE_EVENT(drv_sta_set_txpwr,
+ 	)
+ );
+ 
+-TRACE_EVENT(drv_sta_rc_update,
++TRACE_EVENT(drv_link_sta_rc_update,
+ 	TP_PROTO(struct ieee80211_local *local,
+ 		 struct ieee80211_sub_if_data *sdata,
+-		 struct ieee80211_sta *sta,
++		 struct ieee80211_link_sta *link_sta,
+ 		 u32 changed),
+ 
+-	TP_ARGS(local, sdata, sta, changed),
++	TP_ARGS(local, sdata, link_sta, changed),
+ 
+ 	TP_STRUCT__entry(
+ 		LOCAL_ENTRY
+ 		VIF_ENTRY
+ 		STA_ENTRY
+ 		__field(u32, changed)
++		__field(u32, link_id)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		LOCAL_ASSIGN;
+ 		VIF_ASSIGN;
+-		STA_ASSIGN;
++		STA_NAMED_ASSIGN(link_sta->sta);
+ 		__entry->changed = changed;
++		__entry->link_id = link_sta->link_id;
+ 	),
+ 
+ 	TP_printk(
+-		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT " changed: 0x%x",
+-		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->changed
++		LOCAL_PR_FMT  VIF_PR_FMT  STA_PR_FMT " (link %d) changed: 0x%x",
++		LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG, __entry->link_id,
++		__entry->changed
+ 	)
+ );
+ 
+--- a/net/mac80211/vht.c
++++ b/net/mac80211/vht.c
+@@ -766,8 +766,7 @@ void ieee80211_vht_handle_opmode(struct
+ 
+ 	if (changed > 0) {
+ 		ieee80211_recalc_min_chandef(sdata, link_sta->link_id);
+-		rate_control_rate_update(local, sband, link_sta->sta,
+-					 link_sta->link_id, changed);
++		rate_control_rate_update(local, sband, link_sta, changed);
+ 	}
+ }
+ 
diff --git a/package/kernel/mac80211/patches/subsys/334-wifi-cfg80211-pass-net_device-to-.set_monitor_channel.patch b/package/kernel/mac80211/patches/subsys/334-wifi-cfg80211-pass-net_device-to-.set_monitor_channel.patch
index ef8a36a9af..626f2facaf 100644
--- a/package/kernel/mac80211/patches/subsys/334-wifi-cfg80211-pass-net_device-to-.set_monitor_channel.patch
+++ b/package/kernel/mac80211/patches/subsys/334-wifi-cfg80211-pass-net_device-to-.set_monitor_channel.patch
@@ -126,7 +126,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  }
 --- a/net/wireless/trace.h
 +++ b/net/wireless/trace.h
-@@ -1318,19 +1318,21 @@ TRACE_EVENT(rdev_libertas_set_mesh_chann
+@@ -1322,19 +1322,21 @@ TRACE_EVENT(rdev_libertas_set_mesh_chann
  );
  
  TRACE_EVENT(rdev_set_monitor_channel,

diff --git a/package/kernel/nat46/Makefile b/package/kernel/nat46/Makefile
index 296ef5a058..f793997508 100644
--- a/package/kernel/nat46/Makefile
+++ b/package/kernel/nat46/Makefile
@@ -3,11 +3,11 @@ include $(INCLUDE_DIR)/kernel.mk
 
 PKG_NAME:=nat46
 
-PKG_MIRROR_HASH:=09b93f31d10030d3b4f326066b544b70b1f60236d0482f27c384ed93b298c0a6
+PKG_MIRROR_HASH:=35d7987eed7f05e5f7d1d2e111a8c9f5d019ccf11eb839dfe0bd2e2c46b6199a
 PKG_SOURCE_URL:=https://github.com/ayourtch/nat46.git
-PKG_SOURCE_DATE:=2022-09-19
+PKG_SOURCE_DATE:=2025-04-23
 PKG_SOURCE_PROTO:=git
-PKG_SOURCE_VERSION:=4c5beee236841724219598fabb1edc93d4f08ce5
+PKG_SOURCE_VERSION:=04923c51039e8ca270c6f1dde3f04f3b36958089
 
 PKG_MAINTAINER:=Hans Dedecker <dedeckeh@gmail.com>
 PKG_LICENSE:=GPL-2.0
diff --git a/package/kernel/qca-nss-dp/Makefile b/package/kernel/qca-nss-dp/Makefile
index a917f0518c..eee9c767ce 100644
--- a/package/kernel/qca-nss-dp/Makefile
+++ b/package/kernel/qca-nss-dp/Makefile
@@ -3,11 +3,11 @@ include $(TOPDIR)/rules.mk
 PKG_NAME:=qca-nss-dp
 PKG_RELEASE:=1
 
-PKG_SOURCE_URL:=https://git.codelinaro.org/clo/qsdk/oss/lklm/nss-dp.git
+PKG_SOURCE_URL:=https://github.com/openwrt/qca-nss-dp.git
 PKG_SOURCE_PROTO:=git
-PKG_SOURCE_DATE:=2024-04-16
-PKG_SOURCE_VERSION:=5bf8b91e9fc209f175f9a58723b03055ace3d581
-PKG_MIRROR_HASH:=e86b04ea674c18fb69cd09a45ccab50317b85117e40d76c8457052c2e55d7c18
+PKG_SOURCE_DATE:=2025-05-12
+PKG_SOURCE_VERSION:=07b87bf513ffe58ce8dd00eb2edf68b5b9bde518
+PKG_MIRROR_HASH:=795ffccf1f4d61b6a5e0a6964ce21efa7b7b3c73b31b93140c56af7d970293b9
 
 PKG_BUILD_PARALLEL:=1
 PKG_FLAGS:=nonshared
diff --git a/package/kernel/qca-nss-dp/patches/0001-nss-dp-Drop-_nocache-variants-of-ioremap.patch b/package/kernel/qca-nss-dp/patches/0001-nss-dp-Drop-_nocache-variants-of-ioremap.patch
deleted file mode 100644
index c998874d4e..0000000000
--- a/package/kernel/qca-nss-dp/patches/0001-nss-dp-Drop-_nocache-variants-of-ioremap.patch
+++ /dev/null
@@ -1,48 +0,0 @@
-From 946381fd6fdabedf2b5a1d8647a49e3da8f1894e Mon Sep 17 00:00:00 2001
-From: Baruch Siach <baruch@tkos.co.il>
-Date: Fri, 23 Jun 2023 11:28:02 +0200
-Subject: [PATCH 1/8] nss-dp: Drop _nocache variants of ioremap()
-
-ioremap_nocache was made equivelant to ioremap and was dropped.
-
-Signed-off-by: Baruch Siach <baruch@tkos.co.il>
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c | 2 +-
- hal/gmac_ops/syn/gmac/syn_if.c               | 2 +-
- hal/soc_ops/ipq50xx/nss_ipq50xx.c            | 2 +-
- 3 files changed, 3 insertions(+), 3 deletions(-)
-
---- a/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-@@ -279,7 +279,7 @@ int edma_init(void)
- 	/*
- 	 * Remap register resource
- 	 */
--	edma_hw.reg_base = ioremap_nocache((edma_hw.reg_resource)->start,
-+	edma_hw.reg_base = ioremap((edma_hw.reg_resource)->start,
- 				resource_size(edma_hw.reg_resource));
- 	if (!edma_hw.reg_base) {
- 		pr_warn("Unable to remap EDMA register memory.\n");
---- a/hal/gmac_ops/syn/gmac/syn_if.c
-+++ b/hal/gmac_ops/syn/gmac/syn_if.c
-@@ -806,7 +806,7 @@ static void *syn_init(struct nss_gmac_ha
- 	 * Populate the mac base addresses
- 	 */
- 	shd->nghd.mac_base =
--		devm_ioremap_nocache(&dp_priv->pdev->dev, res->start,
-+		devm_ioremap(&dp_priv->pdev->dev, res->start,
- 							resource_size(res));
- 	if (!shd->nghd.mac_base) {
- 		netdev_dbg(ndev, "ioremap fail.\n");
---- a/hal/soc_ops/ipq50xx/nss_ipq50xx.c
-+++ b/hal/soc_ops/ipq50xx/nss_ipq50xx.c
-@@ -89,7 +89,7 @@ static void nss_dp_hal_tcsr_set(void)
- 			pr_err("%s: SCM TCSR write error: %d\n", __func__, err);
- 		}
- 	} else {
--		tcsr_addr = ioremap_nocache((tcsr_base + TCSR_GMAC_AXI_CACHE_OVERRIDE_OFFSET),
-+		tcsr_addr = ioremap((tcsr_base + TCSR_GMAC_AXI_CACHE_OVERRIDE_OFFSET),
- 						TCSR_GMAC_AXI_CACHE_OVERRIDE_REG_SIZE);
- 		if (!tcsr_addr) {
- 			pr_err("%s: ioremap failed\n", __func__);
diff --git a/package/kernel/qca-nss-dp/patches/0002-edma_tx_rx-support-newer-kernels-time-stamping-API.patch b/package/kernel/qca-nss-dp/patches/0002-edma_tx_rx-support-newer-kernels-time-stamping-API.patch
deleted file mode 100644
index d091311b97..0000000000
--- a/package/kernel/qca-nss-dp/patches/0002-edma_tx_rx-support-newer-kernels-time-stamping-API.patch
+++ /dev/null
@@ -1,47 +0,0 @@
-From 3357c64b3fc63fe003d5ef02ba7f6abca64d80bf Mon Sep 17 00:00:00 2001
-From: Baruch Siach <baruch@tkos.co.il>
-Date: Mon, 3 May 2021 20:07:36 +0300
-Subject: [PATCH 2/8] edma_tx_rx: support newer kernels time stamping API
-
-Timestamping API has changed in kernel 5.6, so update the implementation
-for newer kernels.
-
-Signed-off-by: Baruch Siach <baruch@tkos.co.il>
----
- hal/dp_ops/edma_dp/edma_v1/edma_tx_rx.c | 11 +++++++++++
- 1 file changed, 11 insertions(+)
-
---- a/hal/dp_ops/edma_dp/edma_v1/edma_tx_rx.c
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_tx_rx.c
-@@ -227,10 +227,16 @@ void nss_phy_tstamp_rx_buf(__attribute__
- 	 * set to the correct PTP class value by calling ptp_classify_raw
- 	 * in drv->rxtstamp function.
- 	 */
-+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
- 	if (ndev && ndev->phydev && ndev->phydev->drv &&
- 			ndev->phydev->drv->rxtstamp)
- 		if(ndev->phydev->drv->rxtstamp(ndev->phydev, skb, 0))
- 			return;
-+#else
-+	if (ndev && phy_has_rxtstamp(ndev->phydev))
-+		if (phy_rxtstamp(ndev->phydev, skb, 0))
-+			return;
-+#endif
- 
- 	netif_receive_skb(skb);
- }
-@@ -248,9 +254,14 @@ void nss_phy_tstamp_tx_buf(struct net_de
- 	 * set to the correct PTP class value by calling ptp_classify_raw
- 	 * in the drv->txtstamp function.
- 	 */
-+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
- 	if (ndev && ndev->phydev && ndev->phydev->drv &&
- 			ndev->phydev->drv->txtstamp)
- 		ndev->phydev->drv->txtstamp(ndev->phydev, skb, 0);
-+#else
-+	if (ndev && phy_has_txtstamp(ndev->phydev))
-+		phy_txtstamp(ndev->phydev, skb, 0);
-+#endif
- }
- EXPORT_SYMBOL(nss_phy_tstamp_tx_buf);
- 
diff --git a/package/kernel/qca-nss-dp/patches/0003-EDMA-Fix-NAPI-packet-counting.patch b/package/kernel/qca-nss-dp/patches/0003-EDMA-Fix-NAPI-packet-counting.patch
deleted file mode 100644
index a2268010d4..0000000000
--- a/package/kernel/qca-nss-dp/patches/0003-EDMA-Fix-NAPI-packet-counting.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From c36420c219bf0e03842a11f69193c802eb42030a Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Thu, 20 May 2021 14:56:46 +0200
-Subject: [PATCH 3/8] EDMA: Fix NAPI packet counting
-
-There is a bug in the NAPI packet counting that will
-cause NAPI over budget warnings.
-
-Signed-off-by: Baruch Siach <baruch@tkos.co.il>
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- hal/dp_ops/edma_dp/edma_v1/edma_tx_rx.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/hal/dp_ops/edma_dp/edma_v1/edma_tx_rx.c
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_tx_rx.c
-@@ -459,12 +459,12 @@ int edma_napi(struct napi_struct *napi,
- 
- 	for (i = 0; i < ehw->txcmpl_rings; i++) {
- 		txcmpl_ring = &ehw->txcmpl_ring[i];
--		work_done += edma_clean_tx(ehw, txcmpl_ring);
-+		edma_clean_tx(ehw, txcmpl_ring);
- 	}
- 
- 	for (i = 0; i < ehw->rxfill_rings; i++) {
- 		rxfill_ring = &ehw->rxfill_ring[i];
--		work_done += edma_alloc_rx_buffer(ehw, rxfill_ring);
-+		edma_alloc_rx_buffer(ehw, rxfill_ring);
- 	}
- 
- 	/*
diff --git a/package/kernel/qca-nss-dp/patches/0004-EDMA-Use-NAPI_POLL_WEIGHT-as-NAPI-weight.patch b/package/kernel/qca-nss-dp/patches/0004-EDMA-Use-NAPI_POLL_WEIGHT-as-NAPI-weight.patch
deleted file mode 100644
index 84fb02a92a..0000000000
--- a/package/kernel/qca-nss-dp/patches/0004-EDMA-Use-NAPI_POLL_WEIGHT-as-NAPI-weight.patch
+++ /dev/null
@@ -1,41 +0,0 @@
-From 158032d3d4e5089afa2aa38c27c6e222ac427820 Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Thu, 20 May 2021 14:57:46 +0200
-Subject: [PATCH 4/8] EDMA: Use NAPI_POLL_WEIGHT as NAPI weight
-
-Currently a weight of 100 is used by the EDMA, according
-to upstream max of 64 should be used and that is used for
-almost any driver.
-
-They also introduced NAPI_POLL_WEIGHT define which equals
-to 64.
-
-So use NAPI_POLL_WEIGHT as the weight.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c | 2 +-
- hal/dp_ops/edma_dp/edma_v1/edma_data_plane.h | 1 -
- 2 files changed, 1 insertion(+), 2 deletions(-)
-
---- a/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-@@ -845,7 +845,7 @@ static int edma_register_netdevice(struc
- 	 */
- 	if (!edma_hw.napi_added) {
- 		netif_napi_add(netdev, &edma_hw.napi, edma_napi,
--				EDMA_NAPI_WORK);
-+				NAPI_POLL_WEIGHT);
- 		/*
- 		 * Register the interrupt handlers and enable interrupts
- 		 */
---- a/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.h
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.h
-@@ -26,7 +26,6 @@
- #define EDMA_RX_PREHDR_SIZE		(sizeof(struct edma_rx_preheader))
- #define EDMA_TX_PREHDR_SIZE		(sizeof(struct edma_tx_preheader))
- #define EDMA_RING_SIZE			128
--#define EDMA_NAPI_WORK			100
- #define EDMA_START_GMACS		NSS_DP_HAL_START_IFNUM
- #define EDMA_MAX_GMACS			NSS_DP_HAL_MAX_PORTS
- #define EDMA_TX_PKT_MIN_SIZE		33	/* IPQ807x EDMA needs a minimum packet size of 33 bytes */
diff --git a/package/kernel/qca-nss-dp/patches/0005-nss-dp-adapt-to-netif_napi_add-changes.patch b/package/kernel/qca-nss-dp/patches/0005-nss-dp-adapt-to-netif_napi_add-changes.patch
deleted file mode 100644
index d5b0f62478..0000000000
--- a/package/kernel/qca-nss-dp/patches/0005-nss-dp-adapt-to-netif_napi_add-changes.patch
+++ /dev/null
@@ -1,46 +0,0 @@
-From e46c4d526d77916c00fff4fff3237b9c9d0d774d Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Fri, 23 Jun 2023 12:04:11 +0200
-Subject: [PATCH 5/8] nss-dp: adapt to netif_napi_add() changes
-
-netif_napi_add() removed the weight argument and just uses the default
-NAPI_POLL_WEIGHT in background, so for those requiring custom weight use
-netif_napi_add_weight() instead.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c | 4 ++++
- hal/dp_ops/syn_gmac_dp/syn_dp.c              | 5 +++++
- 2 files changed, 9 insertions(+)
-
---- a/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-@@ -844,8 +844,12 @@ static int edma_register_netdevice(struc
- 	 * NAPI add
- 	 */
- 	if (!edma_hw.napi_added) {
-+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
- 		netif_napi_add(netdev, &edma_hw.napi, edma_napi,
- 				NAPI_POLL_WEIGHT);
-+#else
-+		netif_napi_add(netdev, &edma_hw.napi, edma_napi);
-+#endif
- 		/*
- 		 * Register the interrupt handlers and enable interrupts
- 		 */
---- a/hal/dp_ops/syn_gmac_dp/syn_dp.c
-+++ b/hal/dp_ops/syn_gmac_dp/syn_dp.c
-@@ -189,8 +189,13 @@ static int syn_dp_if_init(struct nss_dp_
- 	}
- 
- 	if (!dev_info->napi_added) {
-+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
- 		netif_napi_add(netdev, &rx_info->napi_rx, syn_dp_napi_poll_rx, SYN_DP_NAPI_BUDGET_RX);
- 		netif_napi_add(netdev, &tx_info->napi_tx, syn_dp_napi_poll_tx, SYN_DP_NAPI_BUDGET_TX);
-+#else
-+		netif_napi_add_weight(netdev, &rx_info->napi_rx, syn_dp_napi_poll_rx, SYN_DP_NAPI_BUDGET_RX);
-+		netif_napi_add_weight(netdev, &tx_info->napi_tx, syn_dp_napi_poll_tx, SYN_DP_NAPI_BUDGET_TX);
-+#endif
- 
- 		/*
- 		 * Requesting irq. Set IRQ_DISABLE_UNLAZY flag, this flag
diff --git a/package/kernel/qca-nss-dp/patches/0006-nss_dp_main-Use-a-phy-handle-property-to-connect-to-.patch b/package/kernel/qca-nss-dp/patches/0006-nss_dp_main-Use-a-phy-handle-property-to-connect-to-.patch
deleted file mode 100644
index 518e961760..0000000000
--- a/package/kernel/qca-nss-dp/patches/0006-nss_dp_main-Use-a-phy-handle-property-to-connect-to-.patch
+++ /dev/null
@@ -1,183 +0,0 @@
-From 5b05b1d7a2d2001d9711856608f61abaf7b9a9a5 Mon Sep 17 00:00:00 2001
-From: Alexandru Gagniuc <mr.nuke.me@gmail.com>
-Date: Fri, 23 Jun 2023 13:34:56 +0200
-Subject: [PATCH 6/8] nss_dp_main: Use a 'phy-handle' property to connect to
- the PHY
-
-The original method of connecting a PHY to the ethernet controller
-requires the "qcom,link-poll", and "qcom,phy-mdio-addr" devicetree
-properties. This is redundant. The PHY node already contains the MDIO
-address, and attaching a PHY implies "link-poll".
-
-Allow using a "phy-handle" property. Remove the following properties,
-as they are no longer used:
-    * "qcom,link-poll"
-    * "qcom,phy-mdio-addr"
-    * "mdio-bus"
-    * "qcom,forced-speed"
-    * "qcom,forced-duplex"
-
-Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- include/nss_dp_dev.h |  5 +--
- nss_dp_main.c        | 91 +++++++-------------------------------------
- 2 files changed, 14 insertions(+), 82 deletions(-)
-
---- a/include/nss_dp_dev.h
-+++ b/include/nss_dp_dev.h
-@@ -225,13 +225,10 @@ struct nss_dp_dev {
- 	unsigned long drv_flags;	/* Driver specific feature flags */
- 
- 	/* Phy related stuff */
-+	struct device_node *phy_node;	/* Phy device OF node */
- 	struct phy_device *phydev;	/* Phy device */
- 	struct mii_bus *miibus;		/* MII bus */
- 	uint32_t phy_mii_type;		/* RGMII/SGMII/QSGMII */
--	uint32_t phy_mdio_addr;		/* Mdio address */
--	bool link_poll;			/* Link polling enable? */
--	uint32_t forced_speed;		/* Forced speed? */
--	uint32_t forced_duplex;		/* Forced duplex? */
- 	uint32_t link_state;		/* Current link state */
- 	uint32_t pause;			/* Current flow control settings */
- 
---- a/nss_dp_main.c
-+++ b/nss_dp_main.c
-@@ -436,7 +436,7 @@ static int nss_dp_open(struct net_device
- 
- 	netif_start_queue(netdev);
- 
--	if (!dp_priv->link_poll) {
-+	if (!dp_priv->phydev) {
- 		/* Notify data plane link is up */
- 		if (dp_priv->data_plane_ops->link_state(dp_priv->dpc, 1)) {
- 			netdev_dbg(netdev, "Data plane set link failed\n");
-@@ -633,6 +633,12 @@ static int32_t nss_dp_of_get_pdata(struc
- 		return -EFAULT;
- 	}
- 
-+	dp_priv->phy_node = of_parse_phandle(np, "phy-handle", 0);
-+	if (!dp_priv->phy_node) {
-+		pr_err("%s: error parsing phy-handle\n", np->name);
-+		return -EFAULT;
-+	}
-+
- 	if (of_property_read_u32(np, "qcom,mactype", &hal_pdata->mactype)) {
- 		pr_err("%s: error reading mactype\n", np->name);
- 		return -EFAULT;
-@@ -653,18 +659,6 @@ static int32_t nss_dp_of_get_pdata(struc
- 		return -EFAULT;
- #endif
- 
--	dp_priv->link_poll = of_property_read_bool(np, "qcom,link-poll");
--	if (of_property_read_u32(np, "qcom,phy-mdio-addr",
--		&dp_priv->phy_mdio_addr) && dp_priv->link_poll) {
--		pr_err("%s: mdio addr required if link polling is enabled\n",
--				np->name);
--		return -EFAULT;
--	}
--
--	of_property_read_u32(np, "qcom,forced-speed", &dp_priv->forced_speed);
--	of_property_read_u32(np, "qcom,forced-duplex", &dp_priv->forced_duplex);
--
--
- #if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
- 	maddr = (uint8_t *)of_get_mac_address(np);
- #if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 4, 0))
-@@ -753,56 +747,6 @@ static int32_t nss_dp_of_get_pdata(struc
- 	return 0;
- }
- 
--/*
-- * nss_dp_mdio_attach()
-- */
--static struct mii_bus *nss_dp_mdio_attach(struct platform_device *pdev)
--{
--	struct device_node *mdio_node;
--	struct platform_device *mdio_plat;
--#if (LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0))
--	struct ipq40xx_mdio_data *mdio_data;
--#endif
--
--	/*
--	 * Find mii_bus using "mdio-bus" handle.
--	 */
--	mdio_node = of_parse_phandle(pdev->dev.of_node, "mdio-bus", 0);
--	if (mdio_node) {
--		return of_mdio_find_bus(mdio_node);
--	}
--
--	mdio_node = of_find_compatible_node(NULL, NULL, "qcom,qca-mdio");
--	if (!mdio_node) {
--		mdio_node = of_find_compatible_node(NULL, NULL,
--							"qcom,ipq40xx-mdio");
--		if (!mdio_node) {
--			dev_err(&pdev->dev, "cannot find mdio node by phandle\n");
--			return NULL;
--		}
--	}
--
--	mdio_plat = of_find_device_by_node(mdio_node);
--	if (!mdio_plat) {
--		dev_err(&pdev->dev, "cannot find platform device from mdio node\n");
--		of_node_put(mdio_node);
--		return NULL;
--	}
--
--#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0))
--	return dev_get_drvdata(&mdio_plat->dev);
--#else
--	mdio_data = dev_get_drvdata(&mdio_plat->dev);
--	if (!mdio_data) {
--		dev_err(&pdev->dev, "cannot get mii bus reference from device data\n");
--		of_node_put(mdio_node);
--		return NULL;
--	}
--
--	return mdio_data->mii_bus;
--#endif
--}
--
- #ifdef CONFIG_NET_SWITCHDEV
- /*
-  * nss_dp_is_phy_dev()
-@@ -861,7 +805,6 @@ static int32_t nss_dp_probe(struct platf
- 	struct device_node *np = pdev->dev.of_node;
- 	struct nss_gmac_hal_platform_data gmac_hal_pdata;
- 	int32_t ret = 0;
--	uint8_t phy_id[MII_BUS_ID_SIZE + 3];
- #if defined(NSS_DP_PPE_SUPPORT)
- 	uint32_t vsi_id;
- 	fal_port_t port_id;
-@@ -940,22 +883,16 @@ static int32_t nss_dp_probe(struct platf
- 
- 	dp_priv->drv_flags |= NSS_DP_PRIV_FLAG(INIT_DONE);
- 
--	if (dp_priv->link_poll) {
--		dp_priv->miibus = nss_dp_mdio_attach(pdev);
--		if (!dp_priv->miibus) {
--			netdev_dbg(netdev, "failed to find miibus\n");
--			goto phy_setup_fail;
--		}
--		snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT,
--				dp_priv->miibus->id, dp_priv->phy_mdio_addr);
-+	if (dp_priv->phy_node) {
- 
--		dp_priv->phydev = phy_connect(netdev, phy_id,
--				&nss_dp_adjust_link,
--				dp_priv->phy_mii_type);
--		if (IS_ERR(dp_priv->phydev)) {
--			netdev_dbg(netdev, "failed to connect to phy device\n");
--			goto phy_setup_fail;
--		}
-+		dp_priv->phydev = of_phy_connect(netdev, dp_priv->phy_node,
-+		        &nss_dp_adjust_link, 0,
-+		        dp_priv->phy_mii_type);
-+		if (!(dp_priv->phydev)) {
-+			netdev_err(netdev, "failed to connect to phy device\n");
-+ 			goto phy_setup_fail;
-+ 		}
-+ 		phy_attached_info(dp_priv->phydev);
- 	}
- 
- #if defined(NSS_DP_PPE_SUPPORT)
diff --git a/package/kernel/qca-nss-dp/patches/0007-nss-dp-edma-v1-use-NAPI-GRO-by-default.patch b/package/kernel/qca-nss-dp/patches/0007-nss-dp-edma-v1-use-NAPI-GRO-by-default.patch
deleted file mode 100644
index 6fbe75dc1c..0000000000
--- a/package/kernel/qca-nss-dp/patches/0007-nss-dp-edma-v1-use-NAPI-GRO-by-default.patch
+++ /dev/null
@@ -1,56 +0,0 @@
-From c2df713569fe3bb671d1444c7bf758681081053c Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Thu, 23 Jun 2022 14:18:50 +0200
-Subject: [PATCH 7/8] nss-dp: edma-v1: use NAPI GRO by default
-
-Utilize napi_gro_receive instead of plain netif_receive_skb on EDMA v1.
-
-Usually it provides quite a lot of RX speed improvements, however in some
-cases it may lead to decreased performance as there is no checksum
-offloading implemented.
-
-In cases where reduced performance is experienced its possible to disable
-GRO by using ethtool.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c | 10 ++++++----
- hal/dp_ops/edma_dp/edma_v1/edma_tx_rx.c      |  8 ++++++--
- 2 files changed, 12 insertions(+), 6 deletions(-)
-
---- a/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-@@ -597,10 +597,12 @@ drop:
-  */
- static void edma_if_set_features(struct nss_dp_data_plane_ctx *dpc)
- {
--	/*
--	 * TODO - add flags to support HIGHMEM/cksum offload VLAN
--	 * the features are enabled.
--	 */
-+	struct net_device *netdev = dpc->dev;
-+
-+	netdev->features |= NETIF_F_GRO;
-+	netdev->hw_features |= NETIF_F_GRO;
-+	netdev->vlan_features |= NETIF_F_GRO;
-+	netdev->wanted_features |= NETIF_F_GRO;
- }
- 
- /* TODO - check if this is needed */
---- a/hal/dp_ops/edma_dp/edma_v1/edma_tx_rx.c
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_tx_rx.c
-@@ -410,8 +410,12 @@ static uint32_t edma_clean_rx(struct edm
- 		if (unlikely(EDMA_RXPH_SERVICE_CODE_GET(rxph) ==
- 					NSS_PTP_EVENT_SERVICE_CODE))
- 			nss_phy_tstamp_rx_buf(ndev, skb);
--		else
--			netif_receive_skb(skb);
-+		else {
-+			if (likely(ndev->features & NETIF_F_GRO))
-+				napi_gro_receive(&ehw->napi, skb);
-+			else
-+				netif_receive_skb(skb);
-+		}
- 
- next_rx_desc:
- 		/*
diff --git a/package/kernel/qca-nss-dp/patches/0008-nss-dp-allow-setting-netdev-name-from-DTS.patch b/package/kernel/qca-nss-dp/patches/0008-nss-dp-allow-setting-netdev-name-from-DTS.patch
deleted file mode 100644
index d70284dfb5..0000000000
--- a/package/kernel/qca-nss-dp/patches/0008-nss-dp-allow-setting-netdev-name-from-DTS.patch
+++ /dev/null
@@ -1,50 +0,0 @@
-From 53b044f7a21d5cd65ada90a228910e6efbad00fa Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Sun, 4 Dec 2022 18:41:36 +0100
-Subject: [PATCH 8/8] nss-dp: allow setting netdev name from DTS
-
-Allow reading the desired netdev name from DTS like DSA allows and then
-set it as the netdev name during registration.
-
-If label is not defined, simply fallback to kernel ethN enumeration.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- nss_dp_main.c | 17 ++++++++++++++---
- 1 file changed, 14 insertions(+), 3 deletions(-)
-
---- a/nss_dp_main.c
-+++ b/nss_dp_main.c
-@@ -804,18 +804,29 @@ static int32_t nss_dp_probe(struct platf
- 	struct nss_dp_dev *dp_priv;
- 	struct device_node *np = pdev->dev.of_node;
- 	struct nss_gmac_hal_platform_data gmac_hal_pdata;
-+	const char *name = of_get_property(np, "label", NULL);
- 	int32_t ret = 0;
-+	int assign_type;
- #if defined(NSS_DP_PPE_SUPPORT)
- 	uint32_t vsi_id;
- 	fal_port_t port_id;
- #endif
- 
-+	if (name) {
-+		assign_type = NET_NAME_PREDICTABLE;
-+	} else {
-+		name = "eth%d";
-+		assign_type = NET_NAME_ENUM;
-+	}
-+
- 	/* TODO: See if we need to do some SoC level common init */
- 
--	netdev = alloc_etherdev_mqs(sizeof(struct nss_dp_dev),
--			NSS_DP_NETDEV_TX_QUEUE_NUM, NSS_DP_NETDEV_RX_QUEUE_NUM);
-+	netdev = alloc_netdev_mqs(sizeof(struct nss_dp_dev),
-+				  name, assign_type,
-+				  ether_setup,
-+				  NSS_DP_NETDEV_TX_QUEUE_NUM, NSS_DP_NETDEV_RX_QUEUE_NUM);
- 	if (!netdev) {
--		pr_info("alloc_etherdev() failed\n");
-+		dev_err(&pdev->dev, "alloc_netdev_mqs() failed\n");
- 		return -ENOMEM;
- 	}
- 
diff --git a/package/kernel/qca-nss-dp/patches/0009-nss-dp-switchdev-fix-FDB-roaming.patch b/package/kernel/qca-nss-dp/patches/0009-nss-dp-switchdev-fix-FDB-roaming.patch
deleted file mode 100644
index 7fccfac76d..0000000000
--- a/package/kernel/qca-nss-dp/patches/0009-nss-dp-switchdev-fix-FDB-roaming.patch
+++ /dev/null
@@ -1,111 +0,0 @@
-From 25ca3308edb67aa0c6c70b83edf0e22b8ae7533f Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Thu, 29 Jun 2023 13:52:58 +0200
-Subject: [PATCH] nss-dp: switchdev: fix FDB roaming
-
-Try and solve the roaming issue by trying to replicate what NSS bridge
-module is doing, but by utilizing switchdev FDB notifiers instead of
-adding new notifiers to the bridge code.
-
-We register a new non-blocking switchdev notifier and simply wait for
-notification, and then process the SWITCHDEV_FDB_DEL_TO_DEVICE
-notifications.
-
-Those tell us that a certain FDB entry should be removed, then a VSI ID
-is fetched for the physical PPE port and using that VSI ID and the
-notification provided MAC adress existing FDB entry gets removed.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- nss_dp_switchdev.c | 73 +++++++++++++++++++++++++++++++++++++++++++++-
- 1 file changed, 72 insertions(+), 1 deletion(-)
-
---- a/nss_dp_switchdev.c
-+++ b/nss_dp_switchdev.c
-@@ -29,6 +29,8 @@
- #include "nss_dp_dev.h"
- #include "fal/fal_stp.h"
- #include "fal/fal_ctrlpkt.h"
-+#include "fal/fal_fdb.h"
-+#include "ref/ref_vsi.h"
- 
- #define NSS_DP_SWITCH_ID		0
- #define NSS_DP_SW_ETHTYPE_PID		0 /* PPE ethtype profile ID for slow protocols */
-@@ -534,7 +536,76 @@ static struct notifier_block *nss_dp_sw_
- 
- #else
- 
--static struct notifier_block *nss_dp_sw_ev_nb;
-+/*
-+ * nss_dp_switchdev_fdb_del_event
-+ *
-+ * Used for EDMA v1 to remove old MAC in order to preventing having
-+ * duplicate MAC entries in FDB thus and avoid roaming issues.
-+ */
-+
-+static int nss_dp_switchdev_fdb_del_event(struct net_device *netdev,
-+					  struct switchdev_notifier_fdb_info *fdb_info)
-+{
-+	struct nss_dp_dev *dp_priv = (struct nss_dp_dev *)netdev_priv(netdev);
-+	fal_fdb_entry_t entry;
-+	a_uint32_t vsi_id;
-+	sw_error_t rv;
-+
-+	netdev_dbg(netdev, "FDB DEL %pM port %d\n", fdb_info->addr, dp_priv->macid);
-+
-+	rv = ppe_port_vsi_get(NSS_DP_SWITCH_ID, dp_priv->macid, &vsi_id);
-+	if (rv) {
-+		netdev_err(netdev, "cannot get VSI ID for port %d\n", dp_priv->macid);
-+		return notifier_from_errno(rv);
-+	}
-+
-+	memset(&entry, 0, sizeof(entry));
-+	memcpy(&entry.addr, fdb_info->addr, ETH_ALEN);
-+	entry.fid = vsi_id;
-+
-+	rv = fal_fdb_entry_del_bymac(NSS_DP_SWITCH_ID, &entry);
-+	if (rv) {
-+		netdev_err(netdev, "FDB entry delete failed with MAC %pM and fid %d\n",
-+			   &entry.addr, entry.fid);
-+		return notifier_from_errno(rv);
-+	}
-+
-+	return notifier_from_errno(rv);
-+}
-+
-+/*
-+ * nss_dp_switchdev_event_nb
-+ *
-+ * Non blocking switchdev event for netdevice.
-+ * Used for EDMA v1 to remove old MAC and avoid roaming issues.
-+ */
-+static int nss_dp_switchdev_event_nb(struct notifier_block *unused,
-+		unsigned long event, void *ptr)
-+{
-+	struct net_device *dev = switchdev_notifier_info_to_dev(ptr);
-+
-+	/*
-+	 * Handle switchdev event only for physical devices
-+	 */
-+	if (!nss_dp_is_phy_dev(dev)) {
-+		return NOTIFY_DONE;
-+	}
-+
-+	switch (event) {
-+	case SWITCHDEV_FDB_DEL_TO_DEVICE:
-+		return nss_dp_switchdev_fdb_del_event(dev, ptr);
-+	default:
-+		netdev_dbg(dev, "Switchdev event %lu is not supported\n", event);
-+	}
-+
-+	return NOTIFY_DONE;
-+}
-+
-+static struct notifier_block nss_dp_switchdev_notifier_nb = {
-+	.notifier_call = nss_dp_switchdev_event_nb,
-+};
-+
-+static struct notifier_block *nss_dp_sw_ev_nb = &nss_dp_switchdev_notifier_nb;
- 
- /*
-  * nss_dp_bridge_attr_set()
diff --git a/package/kernel/qca-nss-dp/patches/0011-01-edma_v1-rework-hw_reset-logic-to-permit-rmmod-and-in.patch b/package/kernel/qca-nss-dp/patches/0011-01-edma_v1-rework-hw_reset-logic-to-permit-rmmod-and-in.patch
deleted file mode 100644
index 7e2a593657..0000000000
--- a/package/kernel/qca-nss-dp/patches/0011-01-edma_v1-rework-hw_reset-logic-to-permit-rmmod-and-in.patch
+++ /dev/null
@@ -1,43 +0,0 @@
-From c318c90b824c59539bf2e33618e381293398616c Mon Sep 17 00:00:00 2001
-From: Christian Marangi <ansuelsmth@gmail.com>
-Date: Tue, 16 Apr 2024 15:02:49 +0200
-Subject: [PATCH 1/6] edma_v1: rework hw_reset logic to permit rmmod and insmod
-
-Rework hw_reset logic for edma v1 to permit rmmod and insmod by using
-get_exclusive_released variant (assuming the reset control was released)
-and manually acquire and release it.
-
-This permits rmmod and insmod without triggering warning or receiving
--EBUSY errors.
-
-Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
----
- hal/dp_ops/edma_dp/edma_v1/edma_cfg.c | 6 +++++-
- 1 file changed, 5 insertions(+), 1 deletion(-)
-
---- a/hal/dp_ops/edma_dp/edma_v1/edma_cfg.c
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_cfg.c
-@@ -719,18 +719,22 @@ int edma_hw_reset(struct edma_hw *ehw)
- 	struct reset_control *rst;
- 	struct platform_device *pdev = ehw->pdev;
- 
--	rst = devm_reset_control_get(&pdev->dev, EDMA_HW_RESET_ID);
-+	rst = devm_reset_control_get_exclusive_released(&pdev->dev, EDMA_HW_RESET_ID);
- 	if (IS_ERR(rst)) {
- 		pr_warn("DTS Node: %s does not exist\n", EDMA_HW_RESET_ID);
- 		return -EINVAL;
- 	}
- 
-+	reset_control_acquire(rst);
-+
- 	reset_control_assert(rst);
- 	udelay(100);
- 
- 	reset_control_deassert(rst);
- 	udelay(100);
- 
-+	reset_control_release(rst);
-+
- 	pr_info("EDMA HW Reset completed succesfully\n");
- 
- 	return 0;
diff --git a/package/kernel/qca-nss-dp/patches/0011-02-nss_dp_switchdev-correctly-unregister-notifier-on-dp.patch b/package/kernel/qca-nss-dp/patches/0011-02-nss_dp_switchdev-correctly-unregister-notifier-on-dp.patch
deleted file mode 100644
index 5abf178d38..0000000000
--- a/package/kernel/qca-nss-dp/patches/0011-02-nss_dp_switchdev-correctly-unregister-notifier-on-dp.patch
+++ /dev/null
@@ -1,59 +0,0 @@
-From 079bfe441b274a8c06474be82e4ccc88599a5e0e Mon Sep 17 00:00:00 2001
-From: Christian Marangi <ansuelsmth@gmail.com>
-Date: Tue, 16 Apr 2024 16:08:46 +0200
-Subject: [PATCH 2/6] nss_dp_switchdev: correctly unregister notifier on
- dp_remove
-
-Correctly unregister notifier on dp_remove to fix kernel panic on system
-reboot.
-
-Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
----
- include/nss_dp_dev.h |  1 +
- nss_dp_main.c        |  4 ++++
- nss_dp_switchdev.c   | 13 +++++++++++++
- 3 files changed, 18 insertions(+)
-
---- a/include/nss_dp_dev.h
-+++ b/include/nss_dp_dev.h
-@@ -349,6 +349,7 @@ void nss_dp_set_ethtool_ops(struct net_d
-  */
- #ifdef CONFIG_NET_SWITCHDEV
- void nss_dp_switchdev_setup(struct net_device *dev);
-+void nss_dp_switchdev_remove(struct net_device *dev);
- bool nss_dp_is_phy_dev(struct net_device *dev);
- #endif
- 
---- a/nss_dp_main.c
-+++ b/nss_dp_main.c
-@@ -970,6 +970,10 @@ static int nss_dp_remove(struct platform
- 		if (!dp_priv)
- 			continue;
- 
-+		#ifdef CONFIG_NET_SWITCHDEV
-+			nss_dp_switchdev_remove(dp_priv->netdev);
-+		#endif
-+
- 		dp_ops = dp_priv->data_plane_ops;
- 		hal_ops = dp_priv->gmac_hal_ops;
- 
---- a/nss_dp_switchdev.c
-+++ b/nss_dp_switchdev.c
-@@ -648,4 +648,17 @@ void nss_dp_switchdev_setup(struct net_d
- 
- 	switch_init_done = true;
- }
-+
-+void nss_dp_switchdev_remove(struct net_device *dev)
-+{
-+	if (!switch_init_done)
-+		return;
-+
-+	if (nss_dp_sw_ev_nb)
-+		unregister_switchdev_notifier(nss_dp_sw_ev_nb);
-+
-+	unregister_switchdev_blocking_notifier(&nss_dp_switchdev_notifier);
-+
-+	switch_init_done = false;
-+}
- #endif
diff --git a/package/kernel/qca-nss-dp/patches/0011-03-nss_dp_main-swap-dp_exit-function-call.patch b/package/kernel/qca-nss-dp/patches/0011-03-nss_dp_main-swap-dp_exit-function-call.patch
deleted file mode 100644
index 08088954fb..0000000000
--- a/package/kernel/qca-nss-dp/patches/0011-03-nss_dp_main-swap-dp_exit-function-call.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-From ab7b1a361d51157118e1a61ce6530a59bcef4b61 Mon Sep 17 00:00:00 2001
-From: Christian Marangi <ansuelsmth@gmail.com>
-Date: Tue, 16 Apr 2024 16:10:09 +0200
-Subject: [PATCH 3/6] nss_dp_main: swap dp_exit function call
-
-First unregister nss_dp platform devices then cleanup the HAL.
-
-This is to fix kernel panic by cleaning data that needs to be used by
-platform driver unregister functions.
-
-Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
----
- nss_dp_main.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/nss_dp_main.c
-+++ b/nss_dp_main.c
-@@ -1161,6 +1161,8 @@ int __init nss_dp_init(void)
-  */
- void __exit nss_dp_exit(void)
- {
-+	platform_driver_unregister(&nss_dp_drv);
-+
- 	/*
- 	 * TODO Move this to soc_ops
- 	 */
-@@ -1168,8 +1170,6 @@ void __exit nss_dp_exit(void)
- 		nss_dp_hal_cleanup();
- 		dp_global_ctx.common_init_done = false;
- 	}
--
--	platform_driver_unregister(&nss_dp_drv);
- }
- 
- module_init(nss_dp_init);
diff --git a/package/kernel/qca-nss-dp/patches/0011-04-nss_dp_main-call-unregister_netdev-first-in-dp_remov.patch b/package/kernel/qca-nss-dp/patches/0011-04-nss_dp_main-call-unregister_netdev-first-in-dp_remov.patch
deleted file mode 100644
index f8daa525fe..0000000000
--- a/package/kernel/qca-nss-dp/patches/0011-04-nss_dp_main-call-unregister_netdev-first-in-dp_remov.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-From 33dd3aa6d0f9cd240d63f53a49157ae44ebccf87 Mon Sep 17 00:00:00 2001
-From: Christian Marangi <ansuelsmth@gmail.com>
-Date: Tue, 16 Apr 2024 16:12:11 +0200
-Subject: [PATCH 4/6] nss_dp_main: call unregister_netdev first in dp_remove
- and carrifer_off
-
-In dp_remove move unregister_netdev up before calling exit and deinit
-and first call netif_carrier_off to stop any traffic from happening and
-prevent kernel panics for napi in the middle of transfer.
-
-Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
----
- nss_dp_main.c | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
---- a/nss_dp_main.c
-+++ b/nss_dp_main.c
-@@ -977,6 +977,9 @@ static int nss_dp_remove(struct platform
- 		dp_ops = dp_priv->data_plane_ops;
- 		hal_ops = dp_priv->gmac_hal_ops;
- 
-+		netif_carrier_off(dp_priv->netdev);
-+		unregister_netdev(dp_priv->netdev);
-+
- 		if (dp_priv->phydev)
- 			phy_disconnect(dp_priv->phydev);
- 
-@@ -988,7 +991,6 @@ static int nss_dp_remove(struct platform
- #endif
- 		hal_ops->exit(dp_priv->gmac_hal_ctx);
- 		dp_ops->deinit(dp_priv->dpc);
--		unregister_netdev(dp_priv->netdev);
- 		free_netdev(dp_priv->netdev);
- 		dp_global_ctx.nss_dp[i] = NULL;
- 	}
diff --git a/package/kernel/qca-nss-dp/patches/0011-05-nss_dp_main-use-phy_detach-instead-of-disconnect-in-.patch b/package/kernel/qca-nss-dp/patches/0011-05-nss_dp_main-use-phy_detach-instead-of-disconnect-in-.patch
deleted file mode 100644
index 1633e009ea..0000000000
--- a/package/kernel/qca-nss-dp/patches/0011-05-nss_dp_main-use-phy_detach-instead-of-disconnect-in-.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From 655b07b701271bc00952fe64aeb14f993a48a50e Mon Sep 17 00:00:00 2001
-From: Christian Marangi <ansuelsmth@gmail.com>
-Date: Tue, 16 Apr 2024 16:17:36 +0200
-Subject: [PATCH 5/6] nss_dp_main: use phy_detach instead of disconnect in
- dp_remove
-
-Use phy_detach instead of disconnect in dp_remove. On Module remove, phy
-are already disconnected but they need to be detached to be correctly
-reattached later with an insmod.
-
-Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
----
- nss_dp_main.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/nss_dp_main.c
-+++ b/nss_dp_main.c
-@@ -981,7 +981,7 @@ static int nss_dp_remove(struct platform
- 		unregister_netdev(dp_priv->netdev);
- 
- 		if (dp_priv->phydev)
--			phy_disconnect(dp_priv->phydev);
-+			phy_detach(dp_priv->phydev);
- 
- #if defined(NSS_DP_PPE_SUPPORT)
- 		/*
diff --git a/package/kernel/qca-nss-dp/patches/0011-06-edma_v1-skip-edma_disable_port-in-edma_cleanup-subse.patch b/package/kernel/qca-nss-dp/patches/0011-06-edma_v1-skip-edma_disable_port-in-edma_cleanup-subse.patch
deleted file mode 100644
index ad784e557f..0000000000
--- a/package/kernel/qca-nss-dp/patches/0011-06-edma_v1-skip-edma_disable_port-in-edma_cleanup-subse.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-From c7c59c6097d94dbab8fc68dae798017bdbc5b3b9 Mon Sep 17 00:00:00 2001
-From: Christian Marangi <ansuelsmth@gmail.com>
-Date: Tue, 16 Apr 2024 16:22:32 +0200
-Subject: [PATCH 6/6] edma_v1: skip edma_disable_port in edma_cleanup
- subsequent run
-
-Skip edma_disable_port in edma_cleanup subsequent run as it will cause
-the kernel panic as the regs are already freed by previous run of
-edma_cleanup. It's use it's not clear but the call is already done in
-the first run of edma_cleanup. Maybe an oversight never dropped?
-
-Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
----
- hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c | 12 +++++++++---
- 1 file changed, 9 insertions(+), 3 deletions(-)
-
---- a/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-+++ b/hal/dp_ops/edma_dp/edma_v1/edma_data_plane.c
-@@ -326,9 +326,15 @@ void edma_cleanup(bool is_dp_override)
- 		 * Disable EDMA only at module exit time, since NSS firmware
- 		 * depends on this setting.
- 		 */
--		if (!is_dp_override) {
--			edma_disable_port();
--		}
-+		/* This call will make the kernel panic as reg used by
-+		 * edma_disable_port are already freed by previous call of
-+		 * edma_cleanup. Logic is not clear of WHY this is called.
-+		 * Keep this here for reference if someone EVER wants
-+		 * to investigate.
-+		 */
-+		// if (!is_dp_override) {
-+		// 	edma_disable_port();
-+		// }
- 		return;
- 	}
- 
diff --git a/package/kernel/qca-ssdk/Makefile b/package/kernel/qca-ssdk/Makefile
index 16b2b4477d..33282858bc 100644
--- a/package/kernel/qca-ssdk/Makefile
+++ b/package/kernel/qca-ssdk/Makefile
@@ -1,13 +1,13 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=qca-ssdk
-PKG_RELEASE:=3
+PKG_RELEASE:=1
 
-PKG_SOURCE_URL:=https://git.codelinaro.org/clo/qsdk/oss/lklm/qca-ssdk.git
+PKG_SOURCE_URL:=https://github.com/openwrt/qca-ssdk.git
 PKG_SOURCE_PROTO:=git
-PKG_SOURCE_DATE:=2024-06-13
-PKG_SOURCE_VERSION:=c451136ba69d51d60f770365b6d6d60ff2801998
-PKG_MIRROR_HASH:=4c54f2d77b5abeb96bddceb4a9eb58aa2c8fb12b58d5d666196224a35ac107dc
+PKG_SOURCE_DATE:=2025-05-12
+PKG_SOURCE_VERSION:=709382c7aefbd07643db24edb514322f078c5181
+PKG_MIRROR_HASH:=9b2967b6e6fea45138fd09a7f40f03210edb66c661faed9ce4003e5301341611
 
 PKG_FLAGS:=nonshared
 PKG_BUILD_PARALLEL:=1
@@ -34,6 +34,12 @@ GCC_VERSION=$(shell echo "$(CONFIG_GCC_VERSION)" | sed 's/[^0-9.]*\([0-9.]*\).*/
 
 LNX_CONFIG_OPTS = LNX_MAKEOPTS='$(KERNEL_MAKEOPTS)' PRJ_PATH=$(PKG_BUILD_DIR) MODULE_TYPE=KSLIB modules
 
+EXTRA_CFLAGS:= \
+	-fno-stack-protector \
+	-Wno-missing-prototypes \
+	-Wno-missing-declarations \
+	-I$(STAGING_DIR)/usr/include
+
 MAKE_FLAGS+= \
 	TARGET_NAME=$(CONFIG_TARGET_NAME) \
 	TOOL_PATH=$(firstword $(TOOLCHAIN_BIN_DIRS)) \
@@ -43,13 +49,13 @@ MAKE_FLAGS+= \
 	ARCH=$(LINUX_KARCH) \
 	TARGET_SUFFIX=$(CONFIG_TARGET_SUFFIX) \
 	GCC_VERSION=$(GCC_VERSION) \
-	EXTRA_CFLAGS="-fno-stack-protector -I$(STAGING_DIR)/usr/include" \
+	EXTRA_CFLAGS="$(EXTRA_CFLAGS)" \
 	SoC=$(CONFIG_TARGET_SUBTARGET) \
 	SHELL="$(BASH)" \
 	PTP_FEATURE=disable SWCONFIG_FEATURE=disable \
 	ISISC_ENABLE=disable MHT_ENABLE=disable \
 	IN_QCA803X_PHY=FALSE IN_QCA808X_PHY=FALSE \
-	IN_MALIBU_PHY=FALSE \
+	IN_MALIBU_PHY=FALSE IN_MP_PHY=FALSE \
 	$(LNX_CONFIG_OPTS)
 
 ifeq ($(CONFIG_TARGET_SUBTARGET), "ipq807x")
@@ -57,9 +63,13 @@ ifeq ($(CONFIG_TARGET_SUBTARGET), "ipq807x")
 endif
 
 ifeq ($(CONFIG_TARGET_SUBTARGET), "ipq60xx")
-    MAKE_FLAGS+= CHIP_TYPE=CPPE
+    MAKE_FLAGS+= CHIP_TYPE=CPPE \
+                 IN_AQUANTIA_PHY=TRUE
 endif
 
+ifeq ($(CONFIG_TARGET_SUBTARGET), "ipq50xx")
+    MAKE_FLAGS+= CHIP_TYPE=MP
+endif
 
 define Build/Compile
 	+$(MAKE) $(PKG_JOBS) $(MAKE_FLAGS) -C $(PKG_BUILD_DIR) $(LNX_CONFIG_OPTS)
diff --git a/package/kernel/qca-ssdk/patches/0003-Revert-qca-ssdk-enable-invoking-fdb-del-function-for.patch b/package/kernel/qca-ssdk/patches/0003-Revert-qca-ssdk-enable-invoking-fdb-del-function-for.patch
deleted file mode 100644
index e69edbd3a3..0000000000
--- a/package/kernel/qca-ssdk/patches/0003-Revert-qca-ssdk-enable-invoking-fdb-del-function-for.patch
+++ /dev/null
@@ -1,30 +0,0 @@
-From 73c0992a36bc13e9bb373f98ba246dfc1e29a393 Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Tue, 7 Nov 2023 14:21:43 +0100
-Subject: [PATCH 3/3] Revert "[qca-ssdk]: enable invoking fdb del function for
- kernel6.1"
-
-This reverts commit a86765ee6a87145f64344f4872cfe8c5e629dd62.
-
-Upstream kernel does not have this call present at all, we currently
-also dont use it, so revert the commit enabling it.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- src/ref/ref_acl.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/src/ref/ref_acl.c
-+++ b/src/ref/ref_acl.c
-@@ -229,7 +229,11 @@ _ref_acl_mac_entry_create_rule(a_uint32_
- 		eth_dev = dev_get_by_name(&init_net, entry->ifname);
- 		if (eth_dev)
- 		{
-+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
-+			// TODO: replace with corresponding ver
-+#else
- 			br_fdb_delete_by_netdev(eth_dev, entry->src_mac.uc, 0);
-+#endif
- 			dev_put(eth_dev);
- 		}
- 	}
diff --git a/package/kernel/qca-ssdk/patches/0004-SSDK-set-OF-node-for-the-SFP-PHY.patch b/package/kernel/qca-ssdk/patches/0004-SSDK-set-OF-node-for-the-SFP-PHY.patch
deleted file mode 100644
index 2cd167c8dd..0000000000
--- a/package/kernel/qca-ssdk/patches/0004-SSDK-set-OF-node-for-the-SFP-PHY.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From 00d3c54c611143f57b632e4cd3b42b0a94d82307 Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Sun, 25 Jun 2023 11:24:09 +0200
-Subject: [PATCH 3/3] SSDK: set OF node for the SFP PHY
-
-Currently, SSDK is creating a fake SFP PHY which has no OF node populated,
-thus making it impossible to pass it to NSS-DP so port can actually work.
-
-We eliminated QCA-s connecting of the PHY by manually creating a string
-and then matching by name and instead only support passing the PHY as
-phandle via phy-handle.
-
-So, lets just use the switch port node to which the SFP is connected to
-anyway and set it as the PHY device OF node so we can pass it to NSS-DP.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- include/hsl/phy/hsl_phy.h |  6 ++++++
- src/hsl/phy/hsl_phy.c     | 14 ++++++++++++++
- src/hsl/phy/sfp_phy.c     |  7 +++++++
- src/init/ssdk_dts.c       |  7 +++++++
- 4 files changed, 34 insertions(+)
-
---- a/include/hsl/phy/hsl_phy.h
-+++ b/include/hsl/phy/hsl_phy.h
-@@ -584,6 +584,7 @@ typedef struct {
- 	a_bool_t port_link_status[SW_MAX_NR_PORT];
- 	a_uint32_t port_mode[SW_MAX_NR_PORT];
- 	a_uint32_t combo_phy_type[SW_MAX_NR_PORT];
-+	struct device_node *port_node[SW_MAX_NR_PORT];
- } phy_info_t;
- /*qca808x_end*/
- #define MALIBU5PORT_PHY         0x004DD0B1
-@@ -1038,3 +1039,8 @@ hsl_phydev_eee_update(a_uint32_t dev_id,
- #endif				/* __cplusplus */
- #endif				/* _HSL_PHY_H_ */
- /*qca808x_end*/
-+
-+struct device_node*
-+hsl_port_node_get(a_uint32_t dev_id, a_uint32_t port_id);
-+void
-+hsl_port_node_set(a_uint32_t dev_id, a_uint32_t port_id, struct device_node *port_node);
---- a/src/hsl/phy/hsl_phy.c
-+++ b/src/hsl/phy/hsl_phy.c
-@@ -3433,3 +3433,17 @@ hsl_phy_modify_debug(a_uint32_t dev_id,
- 	return rv;
- }
- /*qca808x_end*/
-+
-+struct device_node*
-+hsl_port_node_get(a_uint32_t dev_id, a_uint32_t port_id)
-+{
-+	return phy_info[dev_id]->port_node[port_id];
-+}
-+
-+void
-+hsl_port_node_set(a_uint32_t dev_id, a_uint32_t port_id, struct device_node *port_node)
-+{
-+	phy_info[dev_id]->port_node[port_id] = port_node;
-+
-+	return;
-+}
---- a/src/hsl/phy/sfp_phy.c
-+++ b/src/hsl/phy/sfp_phy.c
-@@ -335,6 +335,13 @@ int sfp_phy_device_setup(a_uint32_t dev_
- 	phy_device_register(phydev);
- 
- 	phydev->priv = priv;
-+	/*
-+	 * Set the PHY OF node in order to be able to later connect the
-+	 * fake SFP PHY by passing it as a phandle in phy-handle.
-+	 */
-+	phydev->mdio.dev.of_node = hsl_port_node_get(dev_id, port);
-+	if (!phydev->mdio.dev.of_node)
-+		return SW_NOT_FOUND;
- #if defined(IN_PHY_I2C_MODE)
- 	if (hsl_port_phy_access_type_get(dev_id, port) == PHY_I2C_ACCESS) {
- 		if(phydev->drv)
---- a/src/init/ssdk_dts.c
-+++ b/src/init/ssdk_dts.c
-@@ -784,6 +784,13 @@ static sw_error_t ssdk_dt_parse_phy_info
- 			}
- 		}
- 		hsl_port_feature_set(dev_id, port_id, phy_features | PHY_F_INIT);
-+
-+		/*
-+		* Save the port node so it can be passed as the
-+		* fake SFP PHY OF node in order to be able to
-+		* pass the SFP phy via phy-handle
-+		*/
-+		hsl_port_node_set(dev_id, port_id, port_node);
- 	}
- 
- 	return rv;
diff --git a/package/kernel/qca-ssdk/patches/102-qca-ssdk-support-selecting-PCS-channel-for-PORT3-on-.patch b/package/kernel/qca-ssdk/patches/102-qca-ssdk-support-selecting-PCS-channel-for-PORT3-on-.patch
deleted file mode 100644
index abd25d2214..0000000000
--- a/package/kernel/qca-ssdk/patches/102-qca-ssdk-support-selecting-PCS-channel-for-PORT3-on-.patch
+++ /dev/null
@@ -1,135 +0,0 @@
-From 0116bb7359bd99c09bcad1b2051652cd1a04be3f Mon Sep 17 00:00:00 2001
-From: Mantas Pucka <mantas@8devices.com>
-Date: Mon, 12 Feb 2024 14:23:04 +0200
-Subject: [PATCH] qca-ssdk: support selecting PCS channel for PORT3 on IPQ6018
-
-When QCA8072 is used in PSGMII mode with IPQ6018, PCS used for second
-PHY port would overlap with one used by SGMII+ port. SoC has register
-to select different PCS in such case.
-
-Original code used PHY_ID for this decision, which also had other
-issues, but is no longer viable since we moved to upstream QCA807x
-driver.
-
-Introduce DT property port3_pcs_channel to allow describing this in DT.
-Default value is <2>, and for some QCA8072 designs <4> would be needed.
-
-Signed-off-by: Mantas Pucka <mantas@8devices.com>
----
- include/init/ssdk_dts.h            |  2 ++
- src/adpt/cppe/adpt_cppe_portctrl.c |  4 ++--
- src/adpt/hppe/adpt_hppe_uniphy.c   |  7 +------
- src/init/ssdk_dts.c                | 27 +++++++++++++++++++++++++++
- 4 files changed, 32 insertions(+), 8 deletions(-)
-
---- a/include/init/ssdk_dts.h
-+++ b/include/init/ssdk_dts.h
-@@ -99,6 +99,7 @@ typedef struct
- 	a_uint32_t emu_chip_ver; /*only valid when is_emulation is true*/
- 	a_uint32_t clk_mode;
- 	a_uint32_t pcie_hw_base;
-+	a_uint32_t port3_pcs_channel;
- 	led_ctrl_pattern_t source_pattern[SSDK_MAX_PORT_NUM][PORT_LED_SOURCE_MAX];
- } ssdk_dt_cfg;
- 
-@@ -161,6 +162,7 @@ a_uint32_t ssdk_device_id_get(a_uint32_t
- struct device_node *ssdk_dts_node_get(a_uint32_t dev_id);
- struct clk *ssdk_dts_essclk_get(a_uint32_t dev_id);
- struct clk *ssdk_dts_cmnclk_get(a_uint32_t dev_id);
-+a_uint32_t ssdk_dts_port3_pcs_channel_get(a_uint32_t dev_id);
- 
- int ssdk_switch_device_num_init(void);
- void ssdk_switch_device_num_exit(void);
---- a/src/adpt/cppe/adpt_cppe_portctrl.c
-+++ b/src/adpt/cppe/adpt_cppe_portctrl.c
-@@ -33,6 +33,7 @@
- #include "hsl_phy.h"
- #include "hsl_port_prop.h"
- #include "hppe_init.h"
-+#include "ssdk_dts.h"
- #include "adpt.h"
- #include "adpt_hppe.h"
- #include "adpt_cppe_portctrl.h"
-@@ -60,8 +61,7 @@ _adpt_cppe_port_mux_mac_set(a_uint32_t d
- 		case SSDK_PHYSICAL_PORT3:
- 		case SSDK_PHYSICAL_PORT4:
- 			if (mode0 == PORT_WRAPPER_PSGMII) {
--				if (hsl_port_phyid_get(dev_id,
--					SSDK_PHYSICAL_PORT3) == MALIBU2PORT_PHY) {
-+				if (ssdk_dts_port3_pcs_channel_get(dev_id) == 4) {
- 					cppe_port_mux_ctrl.bf.port3_pcs_sel =
- 						CPPE_PORT3_PCS_SEL_PCS0_CHANNEL4;
- 					cppe_port_mux_ctrl.bf.port4_pcs_sel =
---- a/src/adpt/hppe/adpt_hppe_uniphy.c
-+++ b/src/adpt/hppe/adpt_hppe_uniphy.c
-@@ -1160,9 +1160,6 @@ __adpt_hppe_uniphy_psgmii_mode_set(a_uin
- {
- 	a_uint32_t i;
- 	sw_error_t rv = SW_OK;
--#if defined(CPPE)
--	a_uint32_t phy_type = 0;
--#endif
- 
- 	union uniphy_mode_ctrl_u uniphy_mode_ctrl;
- 
-@@ -1172,9 +1169,7 @@ __adpt_hppe_uniphy_psgmii_mode_set(a_uin
- 	SSDK_DEBUG("uniphy %d is psgmii mode\n", uniphy_index);
- #if defined(CPPE)
- 	if (adpt_ppe_type_get(dev_id) == CPPE_TYPE) {
--		phy_type = hsl_port_phyid_get(dev_id,
--				SSDK_PHYSICAL_PORT3);
--		if (phy_type == MALIBU2PORT_PHY) {
-+		if (ssdk_dts_port3_pcs_channel_get(dev_id) == 4) {
- 			SSDK_INFO("cypress uniphy %d is qca8072 psgmii mode\n", uniphy_index);
- 			rv = __adpt_cppe_uniphy_mode_set(dev_id, uniphy_index,
- 				PORT_WRAPPER_PSGMII);
---- a/src/init/ssdk_dts.c
-+++ b/src/init/ssdk_dts.c
-@@ -272,6 +272,13 @@ struct clk *ssdk_dts_cmnclk_get(a_uint32
- 	return cfg->cmnblk_clk;
- }
- 
-+a_uint32_t ssdk_dts_port3_pcs_channel_get(a_uint32_t dev_id)
-+{
-+	ssdk_dt_cfg* cfg = ssdk_dt_global.ssdk_dt_switch_nodes[dev_id];
-+
-+	return cfg->port3_pcs_channel;
-+}
-+
- #if defined(CONFIG_OF) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
- static void ssdk_dt_parse_mac_mode(a_uint32_t dev_id,
- 		struct device_node *switch_node, ssdk_init_cfg *cfg)
-@@ -305,6 +312,25 @@ static void ssdk_dt_parse_mac_mode(a_uin
- 
- 	return;
- }
-+
-+static void ssdk_dt_parse_port3_pcs_channel(a_uint32_t dev_id,
-+		struct device_node *switch_node, ssdk_init_cfg *cfg)
-+{
-+	const __be32 *port3_pcs_channel;
-+	a_uint32_t len = 0;
-+
-+	port3_pcs_channel = of_get_property(switch_node, "port3_pcs_channel", &len);
-+	if (!port3_pcs_channel) {
-+		ssdk_dt_global.ssdk_dt_switch_nodes[dev_id]->port3_pcs_channel = 2;
-+	}
-+	else {
-+		ssdk_dt_global.ssdk_dt_switch_nodes[dev_id]->port3_pcs_channel =
-+			be32_to_cpup(port3_pcs_channel);
-+	}
-+
-+	return;
-+}
-+
- #ifdef IN_UNIPHY
- static void ssdk_dt_parse_uniphy(a_uint32_t dev_id)
- {
-@@ -1354,6 +1380,7 @@ sw_error_t ssdk_dt_parse(ssdk_init_cfg *
- 	rv = ssdk_dt_parse_access_mode(switch_node, ssdk_dt_priv);
- 	SW_RTN_ON_ERROR(rv);
- 	ssdk_dt_parse_mac_mode(*dev_id, switch_node, cfg);
-+	ssdk_dt_parse_port3_pcs_channel(*dev_id, switch_node, cfg);
- 	ssdk_dt_parse_mdio(*dev_id, switch_node, cfg);
- 	ssdk_dt_parse_port_bmp(*dev_id, switch_node, cfg);
- 	ssdk_dt_parse_interrupt(*dev_id, switch_node);
diff --git a/package/kernel/qca-ssdk/patches/103-hsl_phy-add-support-for-AQR114C-B0-PHY.patch b/package/kernel/qca-ssdk/patches/103-hsl_phy-add-support-for-AQR114C-B0-PHY.patch
deleted file mode 100644
index f144591d8d..0000000000
--- a/package/kernel/qca-ssdk/patches/103-hsl_phy-add-support-for-AQR114C-B0-PHY.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From ab3b663842f66d0ed290696cee9edb9070a36e8f Mon Sep 17 00:00:00 2001
-From: Paweł Owoc <frut3k7@gmail.com>
-Date: Wed, 7 May 2024 10:37:44 +0100
-Subject: [PATCH] hsl_phy: add support for AQR114C-B0 PHY
-
-Add support for AQR114C-B0 PHY.
-
-Signed-off-by: Paweł Owoc <frut3k7@gmail.com>
----
- include/hsl/phy/hsl_phy.h | 1 +
- src/hsl/phy/hsl_phy.c     | 1 +
- 2 files changed, 2 insertions(+)
-
---- a/include/hsl/phy/hsl_phy.h
-+++ b/include/hsl/phy/hsl_phy.h
-@@ -613,6 +613,7 @@ typedef struct {
- #define AQUANTIA_PHY_113C_B0    0x31c31C12
- #define AQUANTIA_PHY_113C_B1    0x31c31C13
- #define AQUANTIA_PHY_112C       0x03a1b792
-+#define AQUANTIA_PHY_114C_B0    0x31c31c22
- #define MVL_PHY_X3410           0x31c31DD3
- 
- #define PHY_805XV2              0x004DD082
---- a/src/hsl/phy/hsl_phy.c
-+++ b/src/hsl/phy/hsl_phy.c
-@@ -271,6 +271,7 @@ phy_type_t hsl_phytype_get_by_phyid(a_ui
- 		case AQUANTIA_PHY_113C_B0:
- 		case AQUANTIA_PHY_113C_B1:
- 		case AQUANTIA_PHY_112C:
-+		case AQUANTIA_PHY_114C_B0:
- 		case MVL_PHY_X3410:
- 			phytype = AQUANTIA_PHY_CHIP;
- 			break;
diff --git a/package/kernel/qca-ssdk/patches/200-allow-parallel-build.patch b/package/kernel/qca-ssdk/patches/200-allow-parallel-build.patch
deleted file mode 100644
index 2a3735a736..0000000000
--- a/package/kernel/qca-ssdk/patches/200-allow-parallel-build.patch
+++ /dev/null
@@ -1,50 +0,0 @@
---- a/Makefile
-+++ b/Makefile
-@@ -1,17 +1,19 @@
--include ./config
--
- ifndef PRJ_PATH
-   PRJ_PATH=$(shell pwd)
- endif
- export PRJ_PATH
- 
--include ./make/config.mk
--include ./make/tools.mk
--include ./make/$(OS)_opt.mk
-+include $(PRJ_PATH)/config
-+
-+include $(PRJ_PATH)/make/config.mk
-+include $(PRJ_PATH)/make/tools.mk
-+include $(PRJ_PATH)/make/$(OS)_opt.mk
- 
- SUB_DIR=$(patsubst %/, %, $(dir $(wildcard src/*/Makefile)))
- SUB_LIB=$(subst src/, , $(SUB_DIR))
- 
-+include $(PRJ_PATH)/Makefile.modules
-+
- ####################################################################
- # 			SSDK-Style Makefile
- ####################################################################
-@@ -27,11 +29,7 @@ all: $(BIN_DIR) kslib
- # 			LNX Modules-Style Makefile
- ####################################################################
- modules: $(BIN_DIR) kslib_c
--	mkdir -p ./temp/;cp * ./temp -a;cd ./temp;cp ../Makefile.modules ./Makefile;
--	make -C $(SYS_PATH) M=$(PRJ_PATH)/temp $(LNX_MAKEOPTS) modules
--	cp $(PRJ_PATH)/temp/Module.symvers $(PRJ_PATH)/Module.symvers;
--	cp temp/*.ko build/bin;
--	rm -Rf ./temp/*.o ./temp/*.ko ./temp/*.a
-+	@$(MAKE) -C $(SYS_PATH) M=$(PRJ_PATH) $(LNX_MAKEOPTS) modules
- 	@echo "---Build [SSDK-$(VERSION)] at $(BUILD_DATE) finished."
- 
- kslib_c:
---- a/make/linux_opt.mk
-+++ b/make/linux_opt.mk
-@@ -782,6 +782,6 @@ LOCAL_CFLAGS += $(CPU_CFLAG) -D"KBUILD_M
- ####################################################################
- # 			cflags for LNX Modules-Style Makefile
- ####################################################################
--LNX_LOCAL_CFLAGS += $(MODULE_INC) $(MODULE_CFLAG) ${EXTRA_INC} -DFALLTHROUGH
-+LNX_LOCAL_CFLAGS = $(MODULE_INC) $(MODULE_CFLAG) ${EXTRA_INC} -DFALLTHROUGH
- export LNX_LOCAL_CFLAGS
- 
diff --git a/package/kernel/rtl8812au-ct/Makefile b/package/kernel/rtl8812au-ct/Makefile
index a994f35052..c6d09e50b8 100644
--- a/package/kernel/rtl8812au-ct/Makefile
+++ b/package/kernel/rtl8812au-ct/Makefile
@@ -1,7 +1,7 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=rtl8812au-ct
-PKG_RELEASE=1
+PKG_RELEASE=2
 
 PKG_LICENSE:=GPLv2
 PKG_LICENSE_FILES:=
@@ -41,6 +41,7 @@ NOSTDINC_FLAGS := \
 	-I$(STAGING_DIR)/usr/include/mac80211/uapi \
 	-include backport/backport.h \
 	-Wno-error=address \
+	-Wno-error=missing-prototypes \
 	-Wno-error=stringop-overread
 
 NOSTDINC_FLAGS+=-DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT -DBUILD_OPENWRT
diff --git a/package/kernel/rtl8812au-ct/patches/005-fix-netdevice-notifier.patch b/package/kernel/rtl8812au-ct/patches/005-fix-netdevice-notifier.patch
new file mode 100644
index 0000000000..6bc0cb59e8
--- /dev/null
+++ b/package/kernel/rtl8812au-ct/patches/005-fix-netdevice-notifier.patch
@@ -0,0 +1,37 @@
+From 010badc96adbafed214d9cba0236a8a832dbfc77 Mon Sep 17 00:00:00 2001
+From: Liangbin Lian <jjm2473@gmail.com>
+Date: Mon, 21 Aug 2023 10:26:28 +0800
+Subject: [PATCH] fix netdevice notifier
+
+rtw_ndev_notifier_call should ignore network devices created by other drivers,
+and it does so, but when CONFIG_WIRELESS_EXT=n, it does not behave as expected.
+
+---
+ os_dep/linux/os_intfs.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+--- a/os_dep/linux/os_intfs.c
++++ b/os_dep/linux/os_intfs.c
+@@ -746,6 +746,8 @@ u16 rtw_recv_select_queue(struct sk_buff
+ }
+ 
+ #endif
++int rtw_ndev_init(struct net_device *dev);
++
+ static int rtw_ndev_notifier_call(struct notifier_block * nb, unsigned long state, void *ptr)
+ {
+ #if (LINUX_VERSION_CODE>=KERNEL_VERSION(3,11,0))
+@@ -761,6 +763,13 @@ static int rtw_ndev_notifier_call(struct
+ 	if (dev->do_ioctl != rtw_ioctl)
+ #endif
+ 		return NOTIFY_DONE;
++#else
++#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
++	if (dev->netdev_ops->ndo_init != rtw_ndev_init)
++#else
++	if (dev->init != rtw_ndev_init)
++#endif
++		return NOTIFY_DONE;
+ #endif
+ 
+ 	DBG_871X_LEVEL(_drv_info_, FUNC_NDEV_FMT" state:%lu\n", FUNC_NDEV_ARG(dev), state);
diff --git a/package/kernel/rtl8812au-ct/patches/010-fix-usb_driver-.shutdown-callback.patch b/package/kernel/rtl8812au-ct/patches/010-fix-usb_driver-.shutdown-callback.patch
new file mode 100644
index 0000000000..66b3d674cb
--- /dev/null
+++ b/package/kernel/rtl8812au-ct/patches/010-fix-usb_driver-.shutdown-callback.patch
@@ -0,0 +1,47 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Tue, 29 Apr 2025 01:49:40 +0800
+Subject: [PATCH] fix usb_driver .shutdown callback
+
+Update API to fix build error on 6.12 kernel:
+
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/rtl8812au-ct-2022.10.26~9b2b203a/os_dep/linux/usb_intf.c:393:17: error: 'struct usb_driver' has no member named 'drvwrap'
+  393 |         .usbdrv.drvwrap.driver.shutdown = rtw_dev_shutdown,
+      |                 ^~~~~~~
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/rtl8812au-ct-2022.10.26~9b2b203a/os_dep/linux/usb_intf.c:393:43: error: initialization of 'const char *' from incompatible pointer type 'void (*)(struct device *)' [-Werror=incompatible-pointer-types]
+  393 |         .usbdrv.drvwrap.driver.shutdown = rtw_dev_shutdown,
+      |                                           ^~~~~~~~~~~~~~~~
+
+Link: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.11.y&id=a5f81642a7228489292f842a106e33c558121e8b
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ os_dep/linux/usb_intf.c | 9 ++++++++-
+ 1 file changed, 8 insertions(+), 1 deletion(-)
+
+--- a/os_dep/linux/usb_intf.c
++++ b/os_dep/linux/usb_intf.c
+@@ -49,9 +49,14 @@ static int rtw_resume(struct usb_interfa
+ static int rtw_drv_init(struct usb_interface *pusb_intf,const struct usb_device_id *pdid);
+ static void rtw_dev_remove(struct usb_interface *pusb_intf);
+ 
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0))
++static void rtw_dev_shutdown(struct usb_interface *usb_intf)
++{
++#else
+ static void rtw_dev_shutdown(struct device *dev)
+ {
+ 	struct usb_interface *usb_intf = container_of(dev, struct usb_interface, dev);
++#endif
+ 	struct dvobj_priv *dvobj = NULL;
+ 	_adapter *adapter = NULL;
+ 	int i;
+@@ -389,7 +394,9 @@ struct rtw_usb_drv usb_drv = {
+ 	.usbdrv.supports_autosuspend = 1,
+ #endif
+ 
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0))
++	.usbdrv.shutdown = rtw_dev_shutdown,
++#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19))
+ 	.usbdrv.drvwrap.driver.shutdown = rtw_dev_shutdown,
+ #else
+ 	.usbdrv.driver.shutdown = rtw_dev_shutdown,
diff --git a/package/kernel/rtl8812au-ct/patches/011-fix-sprintf-overlaps-destination-object-warning.patch b/package/kernel/rtl8812au-ct/patches/011-fix-sprintf-overlaps-destination-object-warning.patch
new file mode 100644
index 0000000000..d36b8f82dc
--- /dev/null
+++ b/package/kernel/rtl8812au-ct/patches/011-fix-sprintf-overlaps-destination-object-warning.patch
@@ -0,0 +1,28 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Tue, 29 Apr 2025 00:21:50 +0800
+Subject: [PATCH] fix sprintf() overlaps destination object warning
+
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/rtl8812au-ct-2022.10.26~9b2b203a/core/rtw_mp.c: In function 'mp_query_psd':
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/rtl8812au-ct-2022.10.26~9b2b203a/core/rtw_mp.c:1874:17: error: 'sprintf' argument 3 overlaps destination object 'data' [-Werror=restrict]
+ 1874 |                 sprintf(data, "%s%x ", data, psd_data);
+      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+/workspaces/openwrt/build_dir/target-x86_64_musl/linux-x86_64/rtl8812au-ct-2022.10.26~9b2b203a/core/rtw_mp.c:1839:41: note: destination object referenced by 'restrict'-qualified argument 1 was declared here
+ 1839 | u32 mp_query_psd(PADAPTER pAdapter, u8 *data)
+      |                                     ~~~~^~~~
+
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ core/rtw_mp.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/core/rtw_mp.c
++++ b/core/rtw_mp.c
+@@ -1871,7 +1871,7 @@ u32 mp_query_psd(PADAPTER pAdapter, u8 *
+ 		} else {
+ 			psd_data = rtw_GetPSDData(pAdapter, i);
+ 		}
+-		sprintf(data, "%s%x ", data, psd_data);
++		sprintf(data + strlen(data), "%x ", psd_data);
+ 		i++;
+ 	}
+ 
diff --git a/package/kernel/rtl8812au-ct/patches/099-cut-linkid-linux-version-code-conditionals.patch b/package/kernel/rtl8812au-ct/patches/099-cut-linkid-linux-version-code-conditionals.patch
index bb644a9ace..41a7fa2a8e 100644
--- a/package/kernel/rtl8812au-ct/patches/099-cut-linkid-linux-version-code-conditionals.patch
+++ b/package/kernel/rtl8812au-ct/patches/099-cut-linkid-linux-version-code-conditionals.patch
@@ -72,7 +72,7 @@ This reverts commit a027da58e8d8e95827f97222ca321cd0b2d377dd.
  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
                                          , bool unicast, bool multicast
  #endif
-@@ -4033,11 +4018,7 @@ static int cfg80211_rtw_change_beacon(st
+@@ -4046,11 +4031,7 @@ static int cfg80211_rtw_change_beacon(st
  	return ret;
  }
  
diff --git a/package/kernel/rtl8812au-ct/patches/100-api_update.patch b/package/kernel/rtl8812au-ct/patches/100-api_update.patch
index e7ca4b05f3..ca888d6963 100644
--- a/package/kernel/rtl8812au-ct/patches/100-api_update.patch
+++ b/package/kernel/rtl8812au-ct/patches/100-api_update.patch
@@ -44,7 +44,7 @@
  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
                                          , bool unicast, bool multicast
  #endif
-@@ -4018,7 +4021,8 @@ static int cfg80211_rtw_change_beacon(st
+@@ -4031,7 +4034,8 @@ static int cfg80211_rtw_change_beacon(st
  	return ret;
  }
  
diff --git a/package/kernel/trelay/src/trelay.c b/package/kernel/trelay/src/trelay.c
index 1f14747597..8b3bef2a8e 100644
--- a/package/kernel/trelay/src/trelay.c
+++ b/package/kernel/trelay/src/trelay.c
@@ -35,7 +35,7 @@ struct trelay {
 	char name[];
 };
 
-rx_handler_result_t trelay_handle_frame(struct sk_buff **pskb)
+static rx_handler_result_t trelay_handle_frame(struct sk_buff **pskb)
 {
 	struct net_device *dev;
 	struct sk_buff *skb = *pskb;
diff --git a/package/kernel/ubootenv-nvram/src/ubootenv-nvram.c b/package/kernel/ubootenv-nvram/src/ubootenv-nvram.c
index 106e41231c..ba1d7973f1 100644
--- a/package/kernel/ubootenv-nvram/src/ubootenv-nvram.c
+++ b/package/kernel/ubootenv-nvram/src/ubootenv-nvram.c
@@ -132,18 +132,17 @@ static int ubootenv_probe(struct platform_device *pdev)
 	return misc_register(&data->misc);
 }
 
-static int ubootenv_remove(struct platform_device *pdev)
+static void ubootenv_remove(struct platform_device *pdev)
 {
 	struct ubootenv_drvdata *data = platform_get_drvdata(pdev);
 
 	data->env = NULL;
 	misc_deregister(&data->misc);
-	return 0;
 }
 
 static struct platform_driver ubootenv_driver = {
 	.probe = ubootenv_probe,
-	.remove = ubootenv_remove,
+	.remove_new = ubootenv_remove,
 	.driver = {
 		.name           = NAME,
 		.of_match_table = of_ubootenv_match,
diff --git a/target/linux/airoha/patches-6.6/108-pwm-airoha-Add-support-for-EN7581-SoC.patch b/target/linux/airoha/patches-6.6/108-pwm-airoha-Add-support-for-EN7581-SoC.patch
index 8f83c696c4..0b114d5f53 100644
--- a/target/linux/airoha/patches-6.6/108-pwm-airoha-Add-support-for-EN7581-SoC.patch
+++ b/target/linux/airoha/patches-6.6/108-pwm-airoha-Add-support-for-EN7581-SoC.patch
@@ -48,7 +48,7 @@ Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
  obj-$(CONFIG_PWM_ATMEL_HLCDC_PWM)	+= pwm-atmel-hlcdc.o
 --- /dev/null
 +++ b/drivers/pwm/pwm-airoha.c
-@@ -0,0 +1,400 @@
+@@ -0,0 +1,388 @@
 +// SPDX-License-Identifier: GPL-2.0
 +/*
 + * Copyright 2022 Markus Gothe <markus.gothe@genexis.eu>
@@ -414,18 +414,7 @@ Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
 +	if (IS_ERR(pc->regmap))
 +		return PTR_ERR(pc->regmap);
 +
-+	platform_set_drvdata(pdev, pc);
-+
-+	return pwmchip_add(&pc->chip);
-+}
-+
-+static int airoha_pwm_remove(struct platform_device *pdev)
-+{
-+	struct airoha_pwm *pc = platform_get_drvdata(pdev);
-+
-+	pwmchip_remove(&pc->chip);
-+
-+	return 0;
++	return devm_pwmchip_add(&pdev->dev, &pc->chip);
 +}
 +
 +static const struct of_device_id airoha_pwm_of_match[] = {
@@ -440,7 +429,6 @@ Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
 +		.of_match_table = airoha_pwm_of_match,
 +	},
 +	.probe = airoha_pwm_probe,
-+	.remove = airoha_pwm_remove,
 +};
 +module_platform_driver(airoha_pwm_driver);
 +
diff --git a/target/linux/apm821xx/image/nand.mk b/target/linux/apm821xx/image/nand.mk
index 7b3945183e..ced313f087 100644
--- a/target/linux/apm821xx/image/nand.mk
+++ b/target/linux/apm821xx/image/nand.mk
@@ -96,7 +96,7 @@ define Device/netgear_wndr4700
   DEVICE_PACKAGES := badblocks block-mount e2fsprogs kmod-hwmon-drivetemp \
 	kmod-dm kmod-fs-ext4 kmod-fs-vfat kmod-usb-ledtrig-usbport \
 	kmod-md-mod kmod-nls-cp437 kmod-nls-iso8859-1 kmod-nls-iso8859-15 \
-	kmod-nls-utf8 kmod-usb3 kmod-usb-dwc2 kmod-usb-storage \
+	kmod-nls-utf8 kmod-usb-xhci-pci-renesas kmod-usb-dwc2 kmod-usb-storage \
 	partx-utils kmod-ata-dwc
   BOARD_NAME := wndr4700
   PAGESIZE := 2048
diff --git a/target/linux/apm821xx/nand/profiles/00-default.mk b/target/linux/apm821xx/nand/profiles/00-default.mk
index 8fcc479cff..9b301866c9 100644
--- a/target/linux/apm821xx/nand/profiles/00-default.mk
+++ b/target/linux/apm821xx/nand/profiles/00-default.mk
@@ -8,7 +8,7 @@ define Profile/Default
   PACKAGES := badblocks block-mount e2fsprogs \
 	kmod-dm kmod-fs-ext4 kmod-fs-vfat kmod-usb-ledtrig-usbport \
 	kmod-md-mod kmod-nls-cp437 kmod-nls-iso8859-1 kmod-nls-iso8859-15 \
-	kmod-nls-utf8 kmod-usb3 kmod-usb-dwc2 kmod-usb-storage \
+	kmod-nls-utf8 kmod-usb-xhci-pci-renesas kmod-usb-dwc2 kmod-usb-storage \
 	kmod-spi-gpio partx-utils
 endef
 
diff --git a/target/linux/ath79/files/drivers/mfd/rb4xx-cpld.c b/target/linux/ath79/files/drivers/mfd/rb4xx-cpld.c
index 148157aa7b..b99a15bb46 100644
--- a/target/linux/ath79/files/drivers/mfd/rb4xx-cpld.c
+++ b/target/linux/ath79/files/drivers/mfd/rb4xx-cpld.c
@@ -162,7 +162,7 @@ static struct spi_driver rb4xx_cpld_driver = {
 	.driver = {
 		.name = "rb4xx-cpld",
 		.bus = &spi_bus_type,
-		.of_match_table = of_match_ptr(rb4xx_cpld_dt_match),
+		.of_match_table = rb4xx_cpld_dt_match,
 	},
 };
 
diff --git a/target/linux/ath79/files/drivers/mtd/nand/raw/ar934x_nand.c b/target/linux/ath79/files/drivers/mtd/nand/raw/ar934x_nand.c
index 029142ca61..c1670b61a5 100644
--- a/target/linux/ath79/files/drivers/mtd/nand/raw/ar934x_nand.c
+++ b/target/linux/ath79/files/drivers/mtd/nand/raw/ar934x_nand.c
@@ -1452,7 +1452,7 @@ err_free_buf:
 	return ret;
 }
 
-static int ar934x_nfc_remove(struct platform_device *pdev)
+static void ar934x_nfc_remove(struct platform_device *pdev)
 {
 	struct ar934x_nfc *nfc;
 
@@ -1462,8 +1462,6 @@ static int ar934x_nfc_remove(struct platform_device *pdev)
 		nand_cleanup(&nfc->nand_chip);
 		ar934x_nfc_free_buf(nfc);
 	}
-
-	return 0;
 }
 
 static const struct of_device_id ar934x_nfc_match[] = {
@@ -1475,7 +1473,7 @@ MODULE_DEVICE_TABLE(of, ar934x_nfc_match);
 
 static struct platform_driver ar934x_nfc_driver = {
 	.probe		= ar934x_nfc_probe,
-	.remove		= ar934x_nfc_remove,
+	.remove_new	= ar934x_nfc_remove,
 	.driver = {
 		.name	= AR934X_NFC_DRIVER_NAME,
 		.of_match_table = ar934x_nfc_match,
diff --git a/target/linux/ath79/files/drivers/mtd/nand/raw/nand_rb4xx.c b/target/linux/ath79/files/drivers/mtd/nand/raw/nand_rb4xx.c
index e42631525c..51a6fa99c6 100644
--- a/target/linux/ath79/files/drivers/mtd/nand/raw/nand_rb4xx.c
+++ b/target/linux/ath79/files/drivers/mtd/nand/raw/nand_rb4xx.c
@@ -214,14 +214,12 @@ static int rb4xx_nand_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int rb4xx_nand_remove(struct platform_device *pdev)
+static void rb4xx_nand_remove(struct platform_device *pdev)
 {
 	struct rb4xx_nand *nand = platform_get_drvdata(pdev);
 
 	mtd_device_unregister(nand_to_mtd(&nand->chip));
 	nand_cleanup(&nand->chip);
-
-	return 0;
 }
 
 static const struct platform_device_id rb4xx_nand_id_table[] = {
@@ -232,7 +230,7 @@ MODULE_DEVICE_TABLE(platform, rb4xx_nand_id_table);
 
 static struct platform_driver rb4xx_nand_driver = {
 	.probe = rb4xx_nand_probe,
-	.remove = rb4xx_nand_remove,
+	.remove_new = rb4xx_nand_remove,
 	.id_table = rb4xx_nand_id_table,
 	.driver = {
 		.name = "rb4xx-nand",
diff --git a/target/linux/ath79/files/drivers/mtd/nand/raw/rb91x_nand.c b/target/linux/ath79/files/drivers/mtd/nand/raw/rb91x_nand.c
index cf2809bfa3..8a154c3514 100644
--- a/target/linux/ath79/files/drivers/mtd/nand/raw/rb91x_nand.c
+++ b/target/linux/ath79/files/drivers/mtd/nand/raw/rb91x_nand.c
@@ -335,13 +335,11 @@ static int rb91x_nand_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int rb91x_nand_remove(struct platform_device *pdev)
+static void rb91x_nand_remove(struct platform_device *pdev)
 {
 	struct rb91x_nand_drvdata *drvdata = platform_get_drvdata(pdev);
 
 	rb91x_nand_release(drvdata);
-
-	return 0;
 }
 
 static const struct of_device_id rb91x_nand_match[] = {
@@ -353,7 +351,7 @@ MODULE_DEVICE_TABLE(of, rb91x_nand_match);
 
 static struct platform_driver rb91x_nand_driver = {
 	.probe	= rb91x_nand_probe,
-	.remove	= rb91x_nand_remove,
+	.remove_new	= rb91x_nand_remove,
 	.driver	= {
 		.name	= "rb91x-nand",
 		.of_match_table = rb91x_nand_match,
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_legacy_mdio.c b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_legacy_mdio.c
index fda561a374..9ccba74720 100644
--- a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_legacy_mdio.c
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_legacy_mdio.c
@@ -221,12 +221,11 @@ static int ag71xx_mdio_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int ag71xx_mdio_remove(struct platform_device *pdev)
+static void ag71xx_mdio_remove(struct platform_device *pdev)
 {
 	struct ag71xx_mdio *am = platform_get_drvdata(pdev);
 
 	mdiobus_unregister(am->mii_bus);
-	return 0;
 }
 
 static const struct of_device_id ag71xx_mdio_match[] = {
@@ -239,7 +238,7 @@ static const struct of_device_id ag71xx_mdio_match[] = {
 
 static struct platform_driver ag71xx_mdio_driver = {
 	.probe		= ag71xx_mdio_probe,
-	.remove		= ag71xx_mdio_remove,
+	.remove_new	= ag71xx_mdio_remove,
 	.driver = {
 		.name	 = "ag71xx-legacy-mdio",
 		.of_match_table = ag71xx_mdio_match,
diff --git a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
index c6fcea1abd..f2d1e35828 100644
--- a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
+++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
@@ -1731,20 +1731,20 @@ err_phy_disconnect:
 	return err;
 }
 
-static int ag71xx_remove(struct platform_device *pdev)
+static void ag71xx_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
 	struct ag71xx *ag;
 
 	if (!dev)
-		return 0;
+		return;
 
 	ag = netdev_priv(dev);
 	ag71xx_debugfs_exit(ag);
 	ag71xx_phy_disconnect(ag);
 	unregister_netdev(dev);
 	platform_set_drvdata(pdev, NULL);
-	return 0;
+
 }
 
 static const struct of_device_id ag71xx_match[] = {
@@ -1763,7 +1763,7 @@ static const struct of_device_id ag71xx_match[] = {
 
 static struct platform_driver ag71xx_driver = {
 	.probe		= ag71xx_probe,
-	.remove		= ag71xx_remove,
+	.remove_new	= ag71xx_remove,
 	.driver = {
 		.name	= AG71XX_DRV_NAME,
 		.of_match_table = ag71xx_match,
diff --git a/target/linux/ath79/patches-6.6/311-MIPS-pci-ar71xx-convert-to-OF.patch b/target/linux/ath79/patches-6.6/311-MIPS-pci-ar71xx-convert-to-OF.patch
index 9a315aed0b..8842f16511 100644
--- a/target/linux/ath79/patches-6.6/311-MIPS-pci-ar71xx-convert-to-OF.patch
+++ b/target/linux/ath79/patches-6.6/311-MIPS-pci-ar71xx-convert-to-OF.patch
@@ -200,7 +200,7 @@ Signed-off-by: John Crispin <john@phrozen.org>
  	.probe = ar71xx_pci_probe,
  	.driver = {
  		.name = "ar71xx-pci",
-+		.of_match_table = of_match_ptr(ar71xx_pci_ids),
++		.of_match_table = ar71xx_pci_ids,
  	},
  };
  
diff --git a/target/linux/ath79/patches-6.6/313-MIPS-pci-ar724x-convert-to-OF.patch b/target/linux/ath79/patches-6.6/313-MIPS-pci-ar724x-convert-to-OF.patch
index 7927c1cbf5..b8c106d6ab 100644
--- a/target/linux/ath79/patches-6.6/313-MIPS-pci-ar724x-convert-to-OF.patch
+++ b/target/linux/ath79/patches-6.6/313-MIPS-pci-ar724x-convert-to-OF.patch
@@ -207,7 +207,7 @@ Signed-off-by: John Crispin <john@phrozen.org>
  	.probe = ar724x_pci_probe,
  	.driver = {
  		.name = "ar724x-pci",
-+		.of_match_table = of_match_ptr(ar724x_pci_ids),
++		.of_match_table = ar724x_pci_ids,
  	},
  };
  
diff --git a/target/linux/bmips/files/drivers/net/ethernet/broadcom/bcm6348-enet.c b/target/linux/bmips/files/drivers/net/ethernet/broadcom/bcm6348-enet.c
index 5e5259a492..ca184e575b 100644
--- a/target/linux/bmips/files/drivers/net/ethernet/broadcom/bcm6348-enet.c
+++ b/target/linux/bmips/files/drivers/net/ethernet/broadcom/bcm6348-enet.c
@@ -285,7 +285,7 @@ MODULE_DEVICE_TABLE(of, bcm6348_emac_of_match);
 static struct platform_driver bcm6348_iudma_driver = {
 	.driver = {
 		.name = "bcm6348-iudma",
-		.of_match_table = of_match_ptr(bcm6348_iudma_of_match),
+		.of_match_table = bcm6348_iudma_of_match,
 	},
 	.probe	= bcm6348_iudma_probe,
 };
@@ -1675,7 +1675,7 @@ out_disable_clk:
 	return ret;
 }
 
-static int bcm6348_emac_remove(struct platform_device *pdev)
+static void bcm6348_emac_remove(struct platform_device *pdev)
 {
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct bcm6348_emac *emac = netdev_priv(ndev);
@@ -1688,8 +1688,6 @@ static int bcm6348_emac_remove(struct platform_device *pdev)
 
 	for (i = 0; i < emac->num_clocks; i++)
 		clk_disable_unprepare(emac->clock[i]);
-
-	return 0;
 }
 
 static const struct of_device_id bcm6348_emac_of_match[] = {
@@ -1703,10 +1701,10 @@ MODULE_DEVICE_TABLE(of, bcm6348_emac_of_match);
 static struct platform_driver bcm6348_emac_driver = {
 	.driver = {
 		.name = "bcm6348-emac",
-		.of_match_table = of_match_ptr(bcm6348_emac_of_match),
+		.of_match_table = bcm6348_emac_of_match,
 	},
 	.probe	= bcm6348_emac_probe,
-	.remove	= bcm6348_emac_remove,
+	.remove_new	= bcm6348_emac_remove,
 };
 
 int bcm6348_iudma_drivers_register(struct platform_device *pdev)
diff --git a/target/linux/bmips/files/drivers/net/ethernet/broadcom/bcm6368-enetsw.c b/target/linux/bmips/files/drivers/net/ethernet/broadcom/bcm6368-enetsw.c
index 7031a74490..97ca6a81d8 100644
--- a/target/linux/bmips/files/drivers/net/ethernet/broadcom/bcm6368-enetsw.c
+++ b/target/linux/bmips/files/drivers/net/ethernet/broadcom/bcm6368-enetsw.c
@@ -1100,7 +1100,7 @@ out_disable_clk:
 	return ret;
 }
 
-static int bcm6368_enetsw_remove(struct platform_device *pdev)
+static void bcm6368_enetsw_remove(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct net_device *ndev = platform_get_drvdata(pdev);
@@ -1118,8 +1118,6 @@ static int bcm6368_enetsw_remove(struct platform_device *pdev)
 
 	for (i = 0; i < priv->num_clocks; i++)
 		clk_disable_unprepare(priv->clock[i]);
-
-	return 0;
 }
 
 static const struct of_device_id bcm6368_enetsw_of_match[] = {
@@ -1135,10 +1133,10 @@ MODULE_DEVICE_TABLE(of, bcm6368_enetsw_of_match);
 static struct platform_driver bcm6368_enetsw_driver = {
 	.driver = {
 		.name = "bcm6368-enetsw",
-		.of_match_table = of_match_ptr(bcm6368_enetsw_of_match),
+		.of_match_table = bcm6368_enetsw_of_match,
 	},
 	.probe	= bcm6368_enetsw_probe,
-	.remove	= bcm6368_enetsw_remove,
+	.remove_new	= bcm6368_enetsw_remove,
 };
 module_platform_driver(bcm6368_enetsw_driver);
 
diff --git a/target/linux/generic/backport-6.12/410-v6.13-01-block-add-support-for-defining-read-only-partitions.patch b/target/linux/generic/backport-6.12/410-v6.13-01-block-add-support-for-defining-read-only-partitions.patch
new file mode 100644
index 0000000000..d40a483fd3
--- /dev/null
+++ b/target/linux/generic/backport-6.12/410-v6.13-01-block-add-support-for-defining-read-only-partitions.patch
@@ -0,0 +1,53 @@
+From 03cb793b26834ddca170ba87057c8f883772dd45 Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Thu, 3 Oct 2024 00:11:41 +0200
+Subject: [PATCH 1/5] block: add support for defining read-only partitions
+
+Add support for defining read-only partitions and complete support for
+it in the cmdline partition parser as the additional "ro" after a
+partition is scanned but never actually applied.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+Reviewed-by: Christoph Hellwig <hch@lst.de>
+Link: https://lore.kernel.org/r/20241002221306.4403-2-ansuelsmth@gmail.com
+Signed-off-by: Jens Axboe <axboe@kernel.dk>
+---
+ block/blk.h                | 1 +
+ block/partitions/cmdline.c | 3 +++
+ block/partitions/core.c    | 3 +++
+ 3 files changed, 7 insertions(+)
+
+--- a/block/blk.h
++++ b/block/blk.h
+@@ -555,6 +555,7 @@ void blk_free_ext_minor(unsigned int min
+ #define ADDPART_FLAG_NONE	0
+ #define ADDPART_FLAG_RAID	1
+ #define ADDPART_FLAG_WHOLEDISK	2
++#define ADDPART_FLAG_READONLY	4
+ int bdev_add_partition(struct gendisk *disk, int partno, sector_t start,
+ 		sector_t length);
+ int bdev_del_partition(struct gendisk *disk, int partno);
+--- a/block/partitions/cmdline.c
++++ b/block/partitions/cmdline.c
+@@ -237,6 +237,9 @@ static int add_part(int slot, struct cmd
+ 	put_partition(state, slot, subpart->from >> 9,
+ 		      subpart->size >> 9);
+ 
++	if (subpart->flags & PF_RDONLY)
++		state->parts[slot].flags |= ADDPART_FLAG_READONLY;
++
+ 	info = &state->parts[slot].info;
+ 
+ 	strscpy(info->volname, subpart->name, sizeof(info->volname));
+--- a/block/partitions/core.c
++++ b/block/partitions/core.c
+@@ -373,6 +373,9 @@ static struct block_device *add_partitio
+ 			goto out_del;
+ 	}
+ 
++	if (flags & ADDPART_FLAG_READONLY)
++		bdev_set_flag(bdev, BD_READ_ONLY);
++
+ 	/* everything is up and running, commence */
+ 	err = xa_insert(&disk->part_tbl, partno, bdev, GFP_KERNEL);
+ 	if (err)
diff --git a/target/linux/generic/backport-6.12/410-v6.13-03-block-introduce-add_disk_fwnode.patch b/target/linux/generic/backport-6.12/410-v6.13-03-block-introduce-add_disk_fwnode.patch
new file mode 100644
index 0000000000..b9fabe6742
--- /dev/null
+++ b/target/linux/generic/backport-6.12/410-v6.13-03-block-introduce-add_disk_fwnode.patch
@@ -0,0 +1,94 @@
+From e5f587242b6072ffab4f4a084a459a59f3035873 Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Thu, 3 Oct 2024 00:11:43 +0200
+Subject: [PATCH 3/5] block: introduce add_disk_fwnode()
+
+Introduce add_disk_fwnode() as a replacement of device_add_disk() that
+permits to pass and attach a fwnode to disk dev.
+
+This variant can be useful for eMMC that might have the partition table
+for the disk defined in DT. A parser can later make use of the attached
+fwnode to parse the related table and init the hardcoded partition for
+the disk.
+
+device_add_disk() is converted to a simple wrapper of add_disk_fwnode()
+with the fwnode entry set as NULL.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+Reviewed-by: Christoph Hellwig <hch@lst.de>
+Link: https://lore.kernel.org/r/20241002221306.4403-4-ansuelsmth@gmail.com
+Signed-off-by: Jens Axboe <axboe@kernel.dk>
+---
+ block/genhd.c          | 28 ++++++++++++++++++++++++----
+ include/linux/blkdev.h |  3 +++
+ 2 files changed, 27 insertions(+), 4 deletions(-)
+
+--- a/block/genhd.c
++++ b/block/genhd.c
+@@ -383,16 +383,18 @@ int disk_scan_partitions(struct gendisk
+ }
+ 
+ /**
+- * device_add_disk - add disk information to kernel list
++ * add_disk_fwnode - add disk information to kernel list with fwnode
+  * @parent: parent device for the disk
+  * @disk: per-device partitioning information
+  * @groups: Additional per-device sysfs groups
++ * @fwnode: attached disk fwnode
+  *
+  * This function registers the partitioning information in @disk
+- * with the kernel.
++ * with the kernel. Also attach a fwnode to the disk device.
+  */
+-int __must_check device_add_disk(struct device *parent, struct gendisk *disk,
+-				 const struct attribute_group **groups)
++int __must_check add_disk_fwnode(struct device *parent, struct gendisk *disk,
++				 const struct attribute_group **groups,
++				 struct fwnode_handle *fwnode)
+ 
+ {
+ 	struct device *ddev = disk_to_dev(disk);
+@@ -452,6 +454,8 @@ int __must_check device_add_disk(struct
+ 	ddev->parent = parent;
+ 	ddev->groups = groups;
+ 	dev_set_name(ddev, "%s", disk->disk_name);
++	if (fwnode)
++		device_set_node(ddev, fwnode);
+ 	if (!(disk->flags & GENHD_FL_HIDDEN))
+ 		ddev->devt = MKDEV(disk->major, disk->first_minor);
+ 	ret = device_add(ddev);
+@@ -553,6 +557,22 @@ out_exit_elevator:
+ 		elevator_exit(disk->queue);
+ 	return ret;
+ }
++EXPORT_SYMBOL_GPL(add_disk_fwnode);
++
++/**
++ * device_add_disk - add disk information to kernel list
++ * @parent: parent device for the disk
++ * @disk: per-device partitioning information
++ * @groups: Additional per-device sysfs groups
++ *
++ * This function registers the partitioning information in @disk
++ * with the kernel.
++ */
++int __must_check device_add_disk(struct device *parent, struct gendisk *disk,
++				 const struct attribute_group **groups)
++{
++	return add_disk_fwnode(parent, disk, groups, NULL);
++}
+ EXPORT_SYMBOL(device_add_disk);
+ 
+ static void blk_report_disk_dead(struct gendisk *disk, bool surprise)
+--- a/include/linux/blkdev.h
++++ b/include/linux/blkdev.h
+@@ -734,6 +734,9 @@ static inline unsigned int blk_queue_dep
+ #define for_each_bio(_bio)		\
+ 	for (; _bio; _bio = _bio->bi_next)
+ 
++int __must_check add_disk_fwnode(struct device *parent, struct gendisk *disk,
++				 const struct attribute_group **groups,
++				 struct fwnode_handle *fwnode);
+ int __must_check device_add_disk(struct device *parent, struct gendisk *disk,
+ 				 const struct attribute_group **groups);
+ static inline int __must_check add_disk(struct gendisk *disk)
diff --git a/target/linux/generic/backport-6.12/410-v6.13-04-mmc-block-attach-partitions-fwnode-if-found-in-mmc-c.patch b/target/linux/generic/backport-6.12/410-v6.13-04-mmc-block-attach-partitions-fwnode-if-found-in-mmc-c.patch
new file mode 100644
index 0000000000..0bdeaa85e4
--- /dev/null
+++ b/target/linux/generic/backport-6.12/410-v6.13-04-mmc-block-attach-partitions-fwnode-if-found-in-mmc-c.patch
@@ -0,0 +1,104 @@
+From 45ff6c340ddfc2dade74d5b7a8962c778ab7042c Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Thu, 3 Oct 2024 00:11:44 +0200
+Subject: [PATCH 4/5] mmc: block: attach partitions fwnode if found in mmc-card
+
+Attach partitions fwnode if found in mmc-card and register disk with it.
+
+This permits block partition to reference the node and register a
+partition table defined in DT for the special case for embedded device
+that doesn't have a partition table flashed but have an hardcoded
+partition table passed from the system.
+
+JEDEC BOOT partition boot0/boot1 are supported but in DT we refer with
+the JEDEC name of boot1 and boot2 to better adhere to documentation.
+
+Also JEDEC GP partition gp0/1/2/3 are supported but in DT we refer with
+the JEDEC name of gp1/2/3/4 to better adhere to documentration.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
+Link: https://lore.kernel.org/r/20241002221306.4403-5-ansuelsmth@gmail.com
+Signed-off-by: Jens Axboe <axboe@kernel.dk>
+---
+ drivers/mmc/core/block.c | 55 +++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 54 insertions(+), 1 deletion(-)
+
+--- a/drivers/mmc/core/block.c
++++ b/drivers/mmc/core/block.c
+@@ -2517,6 +2517,56 @@ static inline int mmc_blk_readonly(struc
+ 	       !(card->csd.cmdclass & CCC_BLOCK_WRITE);
+ }
+ 
++/*
++ * Search for a declared partitions node for the disk in mmc-card related node.
++ *
++ * This is to permit support for partition table defined in DT in special case
++ * where a partition table is not written in the disk and is expected to be
++ * passed from the running system.
++ *
++ * For the user disk, "partitions" node is searched.
++ * For the special HW disk, "partitions-" node with the appended name is used
++ * following this conversion table (to adhere to JEDEC naming)
++ * - boot0 -> partitions-boot1
++ * - boot1 -> partitions-boot2
++ * - gp0 -> partitions-gp1
++ * - gp1 -> partitions-gp2
++ * - gp2 -> partitions-gp3
++ * - gp3 -> partitions-gp4
++ */
++static struct fwnode_handle *mmc_blk_get_partitions_node(struct device *mmc_dev,
++							 const char *subname)
++{
++	const char *node_name = "partitions";
++
++	if (subname) {
++		mmc_dev = mmc_dev->parent;
++
++		/*
++		 * Check if we are allocating a BOOT disk boot0/1 disk.
++		 * In DT we use the JEDEC naming boot1/2.
++		 */
++		if (!strcmp(subname, "boot0"))
++			node_name = "partitions-boot1";
++		if (!strcmp(subname, "boot1"))
++			node_name = "partitions-boot2";
++		/*
++		 * Check if we are allocating a GP disk gp0/1/2/3 disk.
++		 * In DT we use the JEDEC naming gp1/2/3/4.
++		 */
++		if (!strcmp(subname, "gp0"))
++			node_name = "partitions-gp1";
++		if (!strcmp(subname, "gp1"))
++			node_name = "partitions-gp2";
++		if (!strcmp(subname, "gp2"))
++			node_name = "partitions-gp3";
++		if (!strcmp(subname, "gp3"))
++			node_name = "partitions-gp4";
++	}
++
++	return device_get_named_child_node(mmc_dev, node_name);
++}
++
+ static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,
+ 					      struct device *parent,
+ 					      sector_t size,
+@@ -2525,6 +2575,7 @@ static struct mmc_blk_data *mmc_blk_allo
+ 					      int area_type,
+ 					      unsigned int part_type)
+ {
++	struct fwnode_handle *disk_fwnode;
+ 	struct mmc_blk_data *md;
+ 	int devidx, ret;
+ 	char cap_str[10];
+@@ -2626,7 +2677,9 @@ static struct mmc_blk_data *mmc_blk_allo
+ 	/* used in ->open, must be set before add_disk: */
+ 	if (area_type == MMC_BLK_DATA_AREA_MAIN)
+ 		dev_set_drvdata(&card->dev, md);
+-	ret = device_add_disk(md->parent, md->disk, mmc_disk_attr_groups);
++	disk_fwnode = mmc_blk_get_partitions_node(parent, subname);
++	ret = add_disk_fwnode(md->parent, md->disk, mmc_disk_attr_groups,
++			      disk_fwnode);
+ 	if (ret)
+ 		goto err_put_disk;
+ 	return md;
diff --git a/target/linux/generic/backport-6.12/410-v6.13-05-block-add-support-for-partition-table-defined-in-OF.patch b/target/linux/generic/backport-6.12/410-v6.13-05-block-add-support-for-partition-table-defined-in-OF.patch
new file mode 100644
index 0000000000..d260be168c
--- /dev/null
+++ b/target/linux/generic/backport-6.12/410-v6.13-05-block-add-support-for-partition-table-defined-in-OF.patch
@@ -0,0 +1,200 @@
+From 884555b557e5e6d41c866e2cd8d7b32f50ec974b Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Thu, 3 Oct 2024 00:11:45 +0200
+Subject: [PATCH 5/5] block: add support for partition table defined in OF
+
+Add support for partition table defined in Device Tree. Similar to how
+it's done with MTD, add support for defining a fixed partition table in
+device tree.
+
+A common scenario for this is fixed block (eMMC) embedded devices that
+have no MBR or GPT partition table to save storage space. Bootloader
+access the block device with absolute address of data.
+
+This is to complete the functionality with an equivalent implementation
+with providing partition table with bootargs, for case where the booargs
+can't be modified and tweaking the Device Tree is the only solution to
+have an usabe partition table.
+
+The implementation follow the fixed-partitions parser used on MTD
+devices where a "partitions" node is expected to be declared with
+"fixed-partitions" compatible in the OF node of the disk device
+(mmc-card for eMMC for example) and each child node declare a label
+and a reg with offset and size. If label is not declared, the node name
+is used as fallback. Eventually is also possible to declare the read-only
+property to flag the partition as read-only.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+Reviewed-by: Christoph Hellwig <hch@lst.de>
+Link: https://lore.kernel.org/r/20241002221306.4403-6-ansuelsmth@gmail.com
+Signed-off-by: Jens Axboe <axboe@kernel.dk>
+---
+ block/partitions/Kconfig  |   9 ++++
+ block/partitions/Makefile |   1 +
+ block/partitions/check.h  |   1 +
+ block/partitions/core.c   |   3 ++
+ block/partitions/of.c     | 110 ++++++++++++++++++++++++++++++++++++++
+ 5 files changed, 124 insertions(+)
+ create mode 100644 block/partitions/of.c
+
+--- a/block/partitions/Kconfig
++++ b/block/partitions/Kconfig
+@@ -270,4 +270,13 @@ config CMDLINE_PARTITION
+ 	  Say Y here if you want to read the partition table from bootargs.
+ 	  The format for the command line is just like mtdparts.
+ 
++config OF_PARTITION
++	bool "Device Tree partition support" if PARTITION_ADVANCED
++	depends on OF
++	help
++	  Say Y here if you want to enable support for partition table
++	  defined in Device Tree. (mainly for eMMC)
++	  The format for the device tree node is just like MTD fixed-partition
++	  schema.
++
+ endmenu
+--- a/block/partitions/Makefile
++++ b/block/partitions/Makefile
+@@ -12,6 +12,7 @@ obj-$(CONFIG_CMDLINE_PARTITION) += cmdli
+ obj-$(CONFIG_MAC_PARTITION) += mac.o
+ obj-$(CONFIG_LDM_PARTITION) += ldm.o
+ obj-$(CONFIG_MSDOS_PARTITION) += msdos.o
++obj-$(CONFIG_OF_PARTITION) += of.o
+ obj-$(CONFIG_OSF_PARTITION) += osf.o
+ obj-$(CONFIG_SGI_PARTITION) += sgi.o
+ obj-$(CONFIG_SUN_PARTITION) += sun.o
+--- a/block/partitions/check.h
++++ b/block/partitions/check.h
+@@ -62,6 +62,7 @@ int karma_partition(struct parsed_partit
+ int ldm_partition(struct parsed_partitions *state);
+ int mac_partition(struct parsed_partitions *state);
+ int msdos_partition(struct parsed_partitions *state);
++int of_partition(struct parsed_partitions *state);
+ int osf_partition(struct parsed_partitions *state);
+ int sgi_partition(struct parsed_partitions *state);
+ int sun_partition(struct parsed_partitions *state);
+--- a/block/partitions/core.c
++++ b/block/partitions/core.c
+@@ -43,6 +43,9 @@ static int (*const check_part[])(struct
+ #ifdef CONFIG_CMDLINE_PARTITION
+ 	cmdline_partition,
+ #endif
++#ifdef CONFIG_OF_PARTITION
++	of_partition,		/* cmdline have priority to OF */
++#endif
+ #ifdef CONFIG_EFI_PARTITION
+ 	efi_partition,		/* this must come before msdos */
+ #endif
+--- /dev/null
++++ b/block/partitions/of.c
+@@ -0,0 +1,110 @@
++// SPDX-License-Identifier: GPL-2.0
++
++#include <linux/blkdev.h>
++#include <linux/major.h>
++#include <linux/of.h>
++#include <linux/string.h>
++#include "check.h"
++
++static int validate_of_partition(struct device_node *np, int slot)
++{
++	u64 offset, size;
++	int len;
++
++	const __be32 *reg = of_get_property(np, "reg", &len);
++	int a_cells = of_n_addr_cells(np);
++	int s_cells = of_n_size_cells(np);
++
++	/* Make sure reg len match the expected addr and size cells */
++	if (len / sizeof(*reg) != a_cells + s_cells)
++		return -EINVAL;
++
++	/* Validate offset conversion from bytes to sectors */
++	offset = of_read_number(reg, a_cells);
++	if (offset % SECTOR_SIZE)
++		return -EINVAL;
++
++	/* Validate size conversion from bytes to sectors */
++	size = of_read_number(reg + a_cells, s_cells);
++	if (!size || size % SECTOR_SIZE)
++		return -EINVAL;
++
++	return 0;
++}
++
++static void add_of_partition(struct parsed_partitions *state, int slot,
++			     struct device_node *np)
++{
++	struct partition_meta_info *info;
++	char tmp[sizeof(info->volname) + 4];
++	const char *partname;
++	int len;
++
++	const __be32 *reg = of_get_property(np, "reg", &len);
++	int a_cells = of_n_addr_cells(np);
++	int s_cells = of_n_size_cells(np);
++
++	/* Convert bytes to sector size */
++	u64 offset = of_read_number(reg, a_cells) / SECTOR_SIZE;
++	u64 size = of_read_number(reg + a_cells, s_cells) / SECTOR_SIZE;
++
++	put_partition(state, slot, offset, size);
++
++	if (of_property_read_bool(np, "read-only"))
++		state->parts[slot].flags |= ADDPART_FLAG_READONLY;
++
++	/*
++	 * Follow MTD label logic, search for label property,
++	 * fallback to node name if not found.
++	 */
++	info = &state->parts[slot].info;
++	partname = of_get_property(np, "label", &len);
++	if (!partname)
++		partname = of_get_property(np, "name", &len);
++	strscpy(info->volname, partname, sizeof(info->volname));
++
++	snprintf(tmp, sizeof(tmp), "(%s)", info->volname);
++	strlcat(state->pp_buf, tmp, PAGE_SIZE);
++}
++
++int of_partition(struct parsed_partitions *state)
++{
++	struct device *ddev = disk_to_dev(state->disk);
++	struct device_node *np;
++	int slot;
++
++	struct device_node *partitions_np = of_node_get(ddev->of_node);
++
++	if (!partitions_np ||
++	    !of_device_is_compatible(partitions_np, "fixed-partitions"))
++		return 0;
++
++	slot = 1;
++	/* Validate parition offset and size */
++	for_each_child_of_node(partitions_np, np) {
++		if (validate_of_partition(np, slot)) {
++			of_node_put(np);
++			of_node_put(partitions_np);
++
++			return -1;
++		}
++
++		slot++;
++	}
++
++	slot = 1;
++	for_each_child_of_node(partitions_np, np) {
++		if (slot >= state->limit) {
++			of_node_put(np);
++			break;
++		}
++
++		add_of_partition(state, slot, np);
++
++		slot++;
++	}
++
++	strlcat(state->pp_buf, "\n", PAGE_SIZE);
++
++	return 1;
++}
diff --git a/target/linux/generic/backport-6.12/412-v6.14-mtd-spinand-add-support-for-FORESEE-F35SQA001G.patch b/target/linux/generic/backport-6.12/412-v6.14-mtd-spinand-add-support-for-FORESEE-F35SQA001G.patch
new file mode 100644
index 0000000000..84b3b2afee
--- /dev/null
+++ b/target/linux/generic/backport-6.12/412-v6.14-mtd-spinand-add-support-for-FORESEE-F35SQA001G.patch
@@ -0,0 +1,38 @@
+From ae461cde5c559675fc4c0ba351c7c31ace705f56 Mon Sep 17 00:00:00 2001
+From: Bohdan Chubuk <chbgdn@gmail.com>
+Date: Sun, 10 Nov 2024 22:50:47 +0200
+Subject: [PATCH] mtd: spinand: add support for FORESEE F35SQA001G
+
+Add support for FORESEE F35SQA001G SPI NAND.
+
+Similar to F35SQA002G, but differs in capacity.
+Datasheet:
+  -  https://cdn.ozdisan.com/ETicaret_Dosya/704795_871495.pdf
+
+Tested on Xiaomi AX3000T flashed with OpenWRT.
+
+Signed-off-by: Bohdan Chubuk <chbgdn@gmail.com>
+Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/mtd/nand/spi/foresee.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/mtd/nand/spi/foresee.c
++++ b/drivers/mtd/nand/spi/foresee.c
+@@ -81,6 +81,16 @@ static const struct spinand_info foresee
+ 		     SPINAND_HAS_QE_BIT,
+ 		     SPINAND_ECCINFO(&f35sqa002g_ooblayout,
+ 				     f35sqa002g_ecc_get_status)),
++	SPINAND_INFO("F35SQA001G",
++		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x71, 0x71),
++		     NAND_MEMORG(1, 2048, 64, 64, 1024, 20, 1, 1, 1),
++		     NAND_ECCREQ(1, 512),
++		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
++					      &write_cache_variants,
++					      &update_cache_variants),
++		     SPINAND_HAS_QE_BIT,
++		     SPINAND_ECCINFO(&f35sqa002g_ooblayout,
++				     f35sqa002g_ecc_get_status)),
+ };
+ 
+ static const struct spinand_manufacturer_ops foresee_spinand_manuf_ops = {
diff --git a/target/linux/generic/backport-6.12/413-01-v6.14-mtd-rawnand-qcom-cleanup-qcom_nandc-driver.patch b/target/linux/generic/backport-6.12/413-01-v6.14-mtd-rawnand-qcom-cleanup-qcom_nandc-driver.patch
new file mode 100644
index 0000000000..8c5457a507
--- /dev/null
+++ b/target/linux/generic/backport-6.12/413-01-v6.14-mtd-rawnand-qcom-cleanup-qcom_nandc-driver.patch
@@ -0,0 +1,1013 @@
+From 8c52932da5e6756fa66f52f0720da283fba13aa6 Mon Sep 17 00:00:00 2001
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Wed, 20 Nov 2024 14:45:00 +0530
+Subject: [PATCH 1/4] mtd: rawnand: qcom: cleanup qcom_nandc driver
+
+Perform a global cleanup of the Qualcomm NAND
+controller driver with the following improvements:
+
+- Remove register value indirection API
+
+- Remove set_reg() API
+
+- Convert read_loc_first & read_loc_last macro to functions
+
+- Rename multiple variables
+
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/mtd/nand/raw/qcom_nandc.c | 516 ++++++++++++++----------------
+ 1 file changed, 234 insertions(+), 282 deletions(-)
+
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -189,17 +189,6 @@
+ #define	ECC_BCH_4BIT	BIT(2)
+ #define	ECC_BCH_8BIT	BIT(3)
+ 
+-#define nandc_set_read_loc_first(chip, reg, cw_offset, read_size, is_last_read_loc)	\
+-nandc_set_reg(chip, reg,			\
+-	      ((cw_offset) << READ_LOCATION_OFFSET) |		\
+-	      ((read_size) << READ_LOCATION_SIZE) |			\
+-	      ((is_last_read_loc) << READ_LOCATION_LAST))
+-
+-#define nandc_set_read_loc_last(chip, reg, cw_offset, read_size, is_last_read_loc)	\
+-nandc_set_reg(chip, reg,			\
+-	      ((cw_offset) << READ_LOCATION_OFFSET) |		\
+-	      ((read_size) << READ_LOCATION_SIZE) |			\
+-	      ((is_last_read_loc) << READ_LOCATION_LAST))
+ /*
+  * Returns the actual register address for all NAND_DEV_ registers
+  * (i.e. NAND_DEV_CMD0, NAND_DEV_CMD1, NAND_DEV_CMD2 and NAND_DEV_CMD_VLD)
+@@ -257,8 +246,6 @@ nandc_set_reg(chip, reg,			\
+  * @tx_sgl_start - start index in data sgl for tx.
+  * @rx_sgl_pos - current index in data sgl for rx.
+  * @rx_sgl_start - start index in data sgl for rx.
+- * @wait_second_completion - wait for second DMA desc completion before making
+- *			     the NAND transfer completion.
+  */
+ struct bam_transaction {
+ 	struct bam_cmd_element *bam_ce;
+@@ -275,7 +262,6 @@ struct bam_transaction {
+ 	u32 tx_sgl_start;
+ 	u32 rx_sgl_pos;
+ 	u32 rx_sgl_start;
+-	bool wait_second_completion;
+ };
+ 
+ /*
+@@ -471,9 +457,9 @@ struct qcom_op {
+ 	unsigned int data_instr_idx;
+ 	unsigned int rdy_timeout_ms;
+ 	unsigned int rdy_delay_ns;
+-	u32 addr1_reg;
+-	u32 addr2_reg;
+-	u32 cmd_reg;
++	__le32 addr1_reg;
++	__le32 addr2_reg;
++	__le32 cmd_reg;
+ 	u8 flag;
+ };
+ 
+@@ -549,17 +535,17 @@ struct qcom_nand_host {
+  * among different NAND controllers.
+  * @ecc_modes - ecc mode for NAND
+  * @dev_cmd_reg_start - NAND_DEV_CMD_* registers starting offset
+- * @is_bam - whether NAND controller is using BAM
+- * @is_qpic - whether NAND CTRL is part of qpic IP
+- * @qpic_v2 - flag to indicate QPIC IP version 2
++ * @supports_bam - whether NAND controller is using Bus Access Manager (BAM)
++ * @nandc_part_of_qpic - whether NAND controller is part of qpic IP
++ * @qpic_version2 - flag to indicate QPIC IP version 2
+  * @use_codeword_fixup - whether NAND has different layout for boot partitions
+  */
+ struct qcom_nandc_props {
+ 	u32 ecc_modes;
+ 	u32 dev_cmd_reg_start;
+-	bool is_bam;
+-	bool is_qpic;
+-	bool qpic_v2;
++	bool supports_bam;
++	bool nandc_part_of_qpic;
++	bool qpic_version2;
+ 	bool use_codeword_fixup;
+ };
+ 
+@@ -613,19 +599,11 @@ static void clear_bam_transaction(struct
+ {
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+ 
+-	if (!nandc->props->is_bam)
++	if (!nandc->props->supports_bam)
+ 		return;
+ 
+-	bam_txn->bam_ce_pos = 0;
+-	bam_txn->bam_ce_start = 0;
+-	bam_txn->cmd_sgl_pos = 0;
+-	bam_txn->cmd_sgl_start = 0;
+-	bam_txn->tx_sgl_pos = 0;
+-	bam_txn->tx_sgl_start = 0;
+-	bam_txn->rx_sgl_pos = 0;
+-	bam_txn->rx_sgl_start = 0;
++	memset(&bam_txn->bam_ce_pos, 0, sizeof(u32) * 8);
+ 	bam_txn->last_data_desc = NULL;
+-	bam_txn->wait_second_completion = false;
+ 
+ 	sg_init_table(bam_txn->cmd_sgl, nandc->max_cwperpage *
+ 		      QPIC_PER_CW_CMD_SGL);
+@@ -640,46 +618,35 @@ static void qpic_bam_dma_done(void *data
+ {
+ 	struct bam_transaction *bam_txn = data;
+ 
+-	/*
+-	 * In case of data transfer with NAND, 2 callbacks will be generated.
+-	 * One for command channel and another one for data channel.
+-	 * If current transaction has data descriptors
+-	 * (i.e. wait_second_completion is true), then set this to false
+-	 * and wait for second DMA descriptor completion.
+-	 */
+-	if (bam_txn->wait_second_completion)
+-		bam_txn->wait_second_completion = false;
+-	else
+-		complete(&bam_txn->txn_done);
++	complete(&bam_txn->txn_done);
+ }
+ 
+-static inline struct qcom_nand_host *to_qcom_nand_host(struct nand_chip *chip)
++static struct qcom_nand_host *to_qcom_nand_host(struct nand_chip *chip)
+ {
+ 	return container_of(chip, struct qcom_nand_host, chip);
+ }
+ 
+-static inline struct qcom_nand_controller *
++static struct qcom_nand_controller *
+ get_qcom_nand_controller(struct nand_chip *chip)
+ {
+ 	return container_of(chip->controller, struct qcom_nand_controller,
+ 			    controller);
+ }
+ 
+-static inline u32 nandc_read(struct qcom_nand_controller *nandc, int offset)
++static u32 nandc_read(struct qcom_nand_controller *nandc, int offset)
+ {
+ 	return ioread32(nandc->base + offset);
+ }
+ 
+-static inline void nandc_write(struct qcom_nand_controller *nandc, int offset,
+-			       u32 val)
++static void nandc_write(struct qcom_nand_controller *nandc, int offset,
++			u32 val)
+ {
+ 	iowrite32(val, nandc->base + offset);
+ }
+ 
+-static inline void nandc_read_buffer_sync(struct qcom_nand_controller *nandc,
+-					  bool is_cpu)
++static void nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
+ {
+-	if (!nandc->props->is_bam)
++	if (!nandc->props->supports_bam)
+ 		return;
+ 
+ 	if (is_cpu)
+@@ -694,93 +661,90 @@ static inline void nandc_read_buffer_syn
+ 					   DMA_FROM_DEVICE);
+ }
+ 
+-static __le32 *offset_to_nandc_reg(struct nandc_regs *regs, int offset)
+-{
+-	switch (offset) {
+-	case NAND_FLASH_CMD:
+-		return &regs->cmd;
+-	case NAND_ADDR0:
+-		return &regs->addr0;
+-	case NAND_ADDR1:
+-		return &regs->addr1;
+-	case NAND_FLASH_CHIP_SELECT:
+-		return &regs->chip_sel;
+-	case NAND_EXEC_CMD:
+-		return &regs->exec;
+-	case NAND_FLASH_STATUS:
+-		return &regs->clrflashstatus;
+-	case NAND_DEV0_CFG0:
+-		return &regs->cfg0;
+-	case NAND_DEV0_CFG1:
+-		return &regs->cfg1;
+-	case NAND_DEV0_ECC_CFG:
+-		return &regs->ecc_bch_cfg;
+-	case NAND_READ_STATUS:
+-		return &regs->clrreadstatus;
+-	case NAND_DEV_CMD1:
+-		return &regs->cmd1;
+-	case NAND_DEV_CMD1_RESTORE:
+-		return &regs->orig_cmd1;
+-	case NAND_DEV_CMD_VLD:
+-		return &regs->vld;
+-	case NAND_DEV_CMD_VLD_RESTORE:
+-		return &regs->orig_vld;
+-	case NAND_EBI2_ECC_BUF_CFG:
+-		return &regs->ecc_buf_cfg;
+-	case NAND_READ_LOCATION_0:
+-		return &regs->read_location0;
+-	case NAND_READ_LOCATION_1:
+-		return &regs->read_location1;
+-	case NAND_READ_LOCATION_2:
+-		return &regs->read_location2;
+-	case NAND_READ_LOCATION_3:
+-		return &regs->read_location3;
+-	case NAND_READ_LOCATION_LAST_CW_0:
+-		return &regs->read_location_last0;
+-	case NAND_READ_LOCATION_LAST_CW_1:
+-		return &regs->read_location_last1;
+-	case NAND_READ_LOCATION_LAST_CW_2:
+-		return &regs->read_location_last2;
+-	case NAND_READ_LOCATION_LAST_CW_3:
+-		return &regs->read_location_last3;
+-	default:
+-		return NULL;
+-	}
+-}
+-
+-static void nandc_set_reg(struct nand_chip *chip, int offset,
+-			  u32 val)
+-{
+-	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+-	struct nandc_regs *regs = nandc->regs;
+-	__le32 *reg;
+-
+-	reg = offset_to_nandc_reg(regs, offset);
+-
+-	if (reg)
+-		*reg = cpu_to_le32(val);
+-}
+-
+-/* Helper to check the code word, whether it is last cw or not */
++/* Helper to check whether this is the last CW or not */
+ static bool qcom_nandc_is_last_cw(struct nand_ecc_ctrl *ecc, int cw)
+ {
+ 	return cw == (ecc->steps - 1);
+ }
+ 
++/**
++ * nandc_set_read_loc_first() - to set read location first register
++ * @chip:		NAND Private Flash Chip Data
++ * @reg_base:		location register base
++ * @cw_offset:		code word offset
++ * @read_size:		code word read length
++ * @is_last_read_loc:	is this the last read location
++ *
++ * This function will set location register value
++ */
++static void nandc_set_read_loc_first(struct nand_chip *chip,
++				     int reg_base, u32 cw_offset,
++				     u32 read_size, u32 is_last_read_loc)
++{
++	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
++	__le32 locreg_val;
++	u32 val = (((cw_offset) << READ_LOCATION_OFFSET) |
++		  ((read_size) << READ_LOCATION_SIZE) |
++		  ((is_last_read_loc) << READ_LOCATION_LAST));
++
++	locreg_val = cpu_to_le32(val);
++
++	if (reg_base == NAND_READ_LOCATION_0)
++		nandc->regs->read_location0 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_1)
++		nandc->regs->read_location1 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_2)
++		nandc->regs->read_location2 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_3)
++		nandc->regs->read_location3 = locreg_val;
++}
++
++/**
++ * nandc_set_read_loc_last - to set read location last register
++ * @chip:		NAND Private Flash Chip Data
++ * @reg_base:		location register base
++ * @cw_offset:		code word offset
++ * @read_size:		code word read length
++ * @is_last_read_loc:	is this the last read location
++ *
++ * This function will set location last register value
++ */
++static void nandc_set_read_loc_last(struct nand_chip *chip,
++				    int reg_base, u32 cw_offset,
++				    u32 read_size, u32 is_last_read_loc)
++{
++	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
++	__le32 locreg_val;
++	u32 val = (((cw_offset) << READ_LOCATION_OFFSET) |
++		  ((read_size) << READ_LOCATION_SIZE) |
++		  ((is_last_read_loc) << READ_LOCATION_LAST));
++
++	locreg_val = cpu_to_le32(val);
++
++	if (reg_base == NAND_READ_LOCATION_LAST_CW_0)
++		nandc->regs->read_location_last0 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_LAST_CW_1)
++		nandc->regs->read_location_last1 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_LAST_CW_2)
++		nandc->regs->read_location_last2 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_LAST_CW_3)
++		nandc->regs->read_location_last3 = locreg_val;
++}
++
+ /* helper to configure location register values */
+ static void nandc_set_read_loc(struct nand_chip *chip, int cw, int reg,
+-			       int cw_offset, int read_size, int is_last_read_loc)
++			       u32 cw_offset, u32 read_size, u32 is_last_read_loc)
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 	struct nand_ecc_ctrl *ecc = &chip->ecc;
+ 	int reg_base = NAND_READ_LOCATION_0;
+ 
+-	if (nandc->props->qpic_v2 && qcom_nandc_is_last_cw(ecc, cw))
++	if (nandc->props->qpic_version2 && qcom_nandc_is_last_cw(ecc, cw))
+ 		reg_base = NAND_READ_LOCATION_LAST_CW_0;
+ 
+ 	reg_base += reg * 4;
+ 
+-	if (nandc->props->qpic_v2 && qcom_nandc_is_last_cw(ecc, cw))
++	if (nandc->props->qpic_version2 && qcom_nandc_is_last_cw(ecc, cw))
+ 		return nandc_set_read_loc_last(chip, reg_base, cw_offset,
+ 				read_size, is_last_read_loc);
+ 	else
+@@ -792,12 +756,13 @@ static void nandc_set_read_loc(struct na
+ static void set_address(struct qcom_nand_host *host, u16 column, int page)
+ {
+ 	struct nand_chip *chip = &host->chip;
++	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+ 	if (chip->options & NAND_BUSWIDTH_16)
+ 		column >>= 1;
+ 
+-	nandc_set_reg(chip, NAND_ADDR0, page << 16 | column);
+-	nandc_set_reg(chip, NAND_ADDR1, page >> 16 & 0xff);
++	nandc->regs->addr0 = cpu_to_le32(page << 16 | column);
++	nandc->regs->addr1 = cpu_to_le32(page >> 16 & 0xff);
+ }
+ 
+ /*
+@@ -811,41 +776,43 @@ static void set_address(struct qcom_nand
+ static void update_rw_regs(struct qcom_nand_host *host, int num_cw, bool read, int cw)
+ {
+ 	struct nand_chip *chip = &host->chip;
+-	u32 cmd, cfg0, cfg1, ecc_bch_cfg;
++	__le32 cmd, cfg0, cfg1, ecc_bch_cfg;
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+ 	if (read) {
+ 		if (host->use_ecc)
+-			cmd = OP_PAGE_READ_WITH_ECC | PAGE_ACC | LAST_PAGE;
++			cmd = cpu_to_le32(OP_PAGE_READ_WITH_ECC | PAGE_ACC | LAST_PAGE);
+ 		else
+-			cmd = OP_PAGE_READ | PAGE_ACC | LAST_PAGE;
++			cmd = cpu_to_le32(OP_PAGE_READ | PAGE_ACC | LAST_PAGE);
+ 	} else {
+-		cmd = OP_PROGRAM_PAGE | PAGE_ACC | LAST_PAGE;
++		cmd = cpu_to_le32(OP_PROGRAM_PAGE | PAGE_ACC | LAST_PAGE);
+ 	}
+ 
+ 	if (host->use_ecc) {
+-		cfg0 = (host->cfg0 & ~(7U << CW_PER_PAGE)) |
+-				(num_cw - 1) << CW_PER_PAGE;
++		cfg0 = cpu_to_le32((host->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE);
+ 
+-		cfg1 = host->cfg1;
+-		ecc_bch_cfg = host->ecc_bch_cfg;
++		cfg1 = cpu_to_le32(host->cfg1);
++		ecc_bch_cfg = cpu_to_le32(host->ecc_bch_cfg);
+ 	} else {
+-		cfg0 = (host->cfg0_raw & ~(7U << CW_PER_PAGE)) |
+-				(num_cw - 1) << CW_PER_PAGE;
++		cfg0 = cpu_to_le32((host->cfg0_raw & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE);
+ 
+-		cfg1 = host->cfg1_raw;
+-		ecc_bch_cfg = 1 << ECC_CFG_ECC_DISABLE;
++		cfg1 = cpu_to_le32(host->cfg1_raw);
++		ecc_bch_cfg = cpu_to_le32(1 << ECC_CFG_ECC_DISABLE);
+ 	}
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, cmd);
+-	nandc_set_reg(chip, NAND_DEV0_CFG0, cfg0);
+-	nandc_set_reg(chip, NAND_DEV0_CFG1, cfg1);
+-	nandc_set_reg(chip, NAND_DEV0_ECC_CFG, ecc_bch_cfg);
+-	if (!nandc->props->qpic_v2)
+-		nandc_set_reg(chip, NAND_EBI2_ECC_BUF_CFG, host->ecc_buf_cfg);
+-	nandc_set_reg(chip, NAND_FLASH_STATUS, host->clrflashstatus);
+-	nandc_set_reg(chip, NAND_READ_STATUS, host->clrreadstatus);
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
++	nandc->regs->cmd = cmd;
++	nandc->regs->cfg0 = cfg0;
++	nandc->regs->cfg1 = cfg1;
++	nandc->regs->ecc_bch_cfg = ecc_bch_cfg;
++
++	if (!nandc->props->qpic_version2)
++		nandc->regs->ecc_buf_cfg = cpu_to_le32(host->ecc_buf_cfg);
++
++	nandc->regs->clrflashstatus = cpu_to_le32(host->clrflashstatus);
++	nandc->regs->clrreadstatus = cpu_to_le32(host->clrreadstatus);
++	nandc->regs->exec = cpu_to_le32(1);
+ 
+ 	if (read)
+ 		nandc_set_read_loc(chip, cw, 0, 0, host->use_ecc ?
+@@ -1121,7 +1088,7 @@ static int read_reg_dma(struct qcom_nand
+ 	if (first == NAND_DEV_CMD_VLD || first == NAND_DEV_CMD1)
+ 		first = dev_cmd_reg_addr(nandc, first);
+ 
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		return prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
+ 					     num_regs, flags);
+ 
+@@ -1136,25 +1103,16 @@ static int read_reg_dma(struct qcom_nand
+  * write_reg_dma:	prepares a descriptor to write a given number of
+  *			contiguous registers
+  *
++ * @vaddr:		contiguous memory from where register value will
++ *			be written
+  * @first:		offset of the first register in the contiguous block
+  * @num_regs:		number of registers to write
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int write_reg_dma(struct qcom_nand_controller *nandc, int first,
+-			 int num_regs, unsigned int flags)
++static int write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
++			 int first, int num_regs, unsigned int flags)
+ {
+ 	bool flow_control = false;
+-	struct nandc_regs *regs = nandc->regs;
+-	void *vaddr;
+-
+-	vaddr = offset_to_nandc_reg(regs, first);
+-
+-	if (first == NAND_ERASED_CW_DETECT_CFG) {
+-		if (flags & NAND_ERASED_CW_SET)
+-			vaddr = &regs->erased_cw_detect_cfg_set;
+-		else
+-			vaddr = &regs->erased_cw_detect_cfg_clr;
+-	}
+ 
+ 	if (first == NAND_EXEC_CMD)
+ 		flags |= NAND_BAM_NWD;
+@@ -1165,7 +1123,7 @@ static int write_reg_dma(struct qcom_nan
+ 	if (first == NAND_DEV_CMD_VLD_RESTORE || first == NAND_DEV_CMD_VLD)
+ 		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD);
+ 
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		return prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
+ 					     num_regs, flags);
+ 
+@@ -1188,7 +1146,7 @@ static int write_reg_dma(struct qcom_nan
+ static int read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+ 			 const u8 *vaddr, int size, unsigned int flags)
+ {
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		return prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
+ 
+ 	return prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
+@@ -1206,7 +1164,7 @@ static int read_data_dma(struct qcom_nan
+ static int write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+ 			  const u8 *vaddr, int size, unsigned int flags)
+ {
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		return prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
+ 
+ 	return prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
+@@ -1220,13 +1178,14 @@ static void config_nand_page_read(struct
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, NAND_ADDR0, 2, 0);
+-	write_reg_dma(nandc, NAND_DEV0_CFG0, 3, 0);
+-	if (!nandc->props->qpic_v2)
+-		write_reg_dma(nandc, NAND_EBI2_ECC_BUF_CFG, 1, 0);
+-	write_reg_dma(nandc, NAND_ERASED_CW_DETECT_CFG, 1, 0);
+-	write_reg_dma(nandc, NAND_ERASED_CW_DETECT_CFG, 1,
+-		      NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
++	write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	if (!nandc->props->qpic_version2)
++		write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1, 0);
++	write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_clr,
++		      NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_set,
++		      NAND_ERASED_CW_DETECT_CFG, 1, NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
+ }
+ 
+ /*
+@@ -1239,16 +1198,16 @@ config_nand_cw_read(struct nand_chip *ch
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 	struct nand_ecc_ctrl *ecc = &chip->ecc;
+ 
+-	int reg = NAND_READ_LOCATION_0;
++	__le32 *reg = &nandc->regs->read_location0;
+ 
+-	if (nandc->props->qpic_v2 && qcom_nandc_is_last_cw(ecc, cw))
+-		reg = NAND_READ_LOCATION_LAST_CW_0;
++	if (nandc->props->qpic_version2 && qcom_nandc_is_last_cw(ecc, cw))
++		reg = &nandc->regs->read_location_last0;
+ 
+-	if (nandc->props->is_bam)
+-		write_reg_dma(nandc, reg, 4, NAND_BAM_NEXT_SGL);
++	if (nandc->props->supports_bam)
++		write_reg_dma(nandc, reg, NAND_READ_LOCATION_0, 4, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	if (use_ecc) {
+ 		read_reg_dma(nandc, NAND_FLASH_STATUS, 2, 0);
+@@ -1279,10 +1238,10 @@ static void config_nand_page_write(struc
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, NAND_ADDR0, 2, 0);
+-	write_reg_dma(nandc, NAND_DEV0_CFG0, 3, 0);
+-	if (!nandc->props->qpic_v2)
+-		write_reg_dma(nandc, NAND_EBI2_ECC_BUF_CFG, 1,
++	write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
++	write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	if (!nandc->props->qpic_version2)
++		write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1,
+ 			      NAND_BAM_NEXT_SGL);
+ }
+ 
+@@ -1294,13 +1253,13 @@ static void config_nand_cw_write(struct
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_STATUS, 1, 0);
+-	write_reg_dma(nandc, NAND_READ_STATUS, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->clrflashstatus, NAND_FLASH_STATUS, 1, 0);
++	write_reg_dma(nandc, &nandc->regs->clrreadstatus, NAND_READ_STATUS, 1, NAND_BAM_NEXT_SGL);
+ }
+ 
+ /* helpers to submit/free our list of dma descriptors */
+@@ -1311,7 +1270,7 @@ static int submit_descs(struct qcom_nand
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+ 	int ret = 0;
+ 
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		if (bam_txn->rx_sgl_pos > bam_txn->rx_sgl_start) {
+ 			ret = prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
+ 			if (ret)
+@@ -1336,14 +1295,9 @@ static int submit_descs(struct qcom_nand
+ 	list_for_each_entry(desc, &nandc->desc_list, node)
+ 		cookie = dmaengine_submit(desc->dma_desc);
+ 
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		bam_txn->last_cmd_desc->callback = qpic_bam_dma_done;
+ 		bam_txn->last_cmd_desc->callback_param = bam_txn;
+-		if (bam_txn->last_data_desc) {
+-			bam_txn->last_data_desc->callback = qpic_bam_dma_done;
+-			bam_txn->last_data_desc->callback_param = bam_txn;
+-			bam_txn->wait_second_completion = true;
+-		}
+ 
+ 		dma_async_issue_pending(nandc->tx_chan);
+ 		dma_async_issue_pending(nandc->rx_chan);
+@@ -1365,7 +1319,7 @@ err_unmap_free_desc:
+ 	list_for_each_entry_safe(desc, n, &nandc->desc_list, node) {
+ 		list_del(&desc->node);
+ 
+-		if (nandc->props->is_bam)
++		if (nandc->props->supports_bam)
+ 			dma_unmap_sg(nandc->dev, desc->bam_sgl,
+ 				     desc->sgl_cnt, desc->dir);
+ 		else
+@@ -1382,7 +1336,7 @@ err_unmap_free_desc:
+ static void clear_read_regs(struct qcom_nand_controller *nandc)
+ {
+ 	nandc->reg_read_pos = 0;
+-	nandc_read_buffer_sync(nandc, false);
++	nandc_dev_to_mem(nandc, false);
+ }
+ 
+ /*
+@@ -1446,7 +1400,7 @@ static int check_flash_errors(struct qco
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 	int i;
+ 
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < cw_cnt; i++) {
+ 		u32 flash = le32_to_cpu(nandc->reg_read_buf[i]);
+@@ -1476,7 +1430,7 @@ qcom_nandc_read_cw_raw(struct mtd_info *
+ 	clear_read_regs(nandc);
+ 	host->use_ecc = false;
+ 
+-	if (nandc->props->qpic_v2)
++	if (nandc->props->qpic_version2)
+ 		raw_cw = ecc->steps - 1;
+ 
+ 	clear_bam_transaction(nandc);
+@@ -1497,7 +1451,7 @@ qcom_nandc_read_cw_raw(struct mtd_info *
+ 		oob_size2 = host->ecc_bytes_hw + host->spare_bytes;
+ 	}
+ 
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		nandc_set_read_loc(chip, cw, 0, read_loc, data_size1, 0);
+ 		read_loc += data_size1;
+ 
+@@ -1621,7 +1575,7 @@ static int parse_read_errors(struct qcom
+ 	u8 *data_buf_start = data_buf, *oob_buf_start = oob_buf;
+ 
+ 	buf = (struct read_stats *)nandc->reg_read_buf;
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < ecc->steps; i++, buf++) {
+ 		u32 flash, buffer, erased_cw;
+@@ -1734,7 +1688,7 @@ static int read_page_ecc(struct qcom_nan
+ 			oob_size = host->ecc_bytes_hw + host->spare_bytes;
+ 		}
+ 
+-		if (nandc->props->is_bam) {
++		if (nandc->props->supports_bam) {
+ 			if (data_buf && oob_buf) {
+ 				nandc_set_read_loc(chip, i, 0, 0, data_size, 0);
+ 				nandc_set_read_loc(chip, i, 1, data_size,
+@@ -2455,14 +2409,14 @@ static int qcom_nand_attach_chip(struct
+ 
+ 	mtd_set_ooblayout(mtd, &qcom_nand_ooblayout_ops);
+ 	/* Free the initially allocated BAM transaction for reading the ONFI params */
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		free_bam_transaction(nandc);
+ 
+ 	nandc->max_cwperpage = max_t(unsigned int, nandc->max_cwperpage,
+ 				     cwperpage);
+ 
+ 	/* Now allocate the BAM transaction based on updated max_cwperpage */
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		nandc->bam_txn = alloc_bam_transaction(nandc);
+ 		if (!nandc->bam_txn) {
+ 			dev_err(nandc->dev,
+@@ -2522,7 +2476,7 @@ static int qcom_nand_attach_chip(struct
+ 				| ecc_mode << ECC_MODE
+ 				| host->ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_BCH;
+ 
+-	if (!nandc->props->qpic_v2)
++	if (!nandc->props->qpic_version2)
+ 		host->ecc_buf_cfg = 0x203 << NUM_STEPS;
+ 
+ 	host->clrflashstatus = FS_READY_BSY_N;
+@@ -2556,7 +2510,7 @@ static int qcom_op_cmd_mapping(struct na
+ 		cmd = OP_FETCH_ID;
+ 		break;
+ 	case NAND_CMD_PARAM:
+-		if (nandc->props->qpic_v2)
++		if (nandc->props->qpic_version2)
+ 			cmd = OP_PAGE_READ_ONFI_READ;
+ 		else
+ 			cmd = OP_PAGE_READ;
+@@ -2609,7 +2563,7 @@ static int qcom_parse_instructions(struc
+ 			if (ret < 0)
+ 				return ret;
+ 
+-			q_op->cmd_reg = ret;
++			q_op->cmd_reg = cpu_to_le32(ret);
+ 			q_op->rdy_delay_ns = instr->delay_ns;
+ 			break;
+ 
+@@ -2619,10 +2573,10 @@ static int qcom_parse_instructions(struc
+ 			addrs = &instr->ctx.addr.addrs[offset];
+ 
+ 			for (i = 0; i < min_t(unsigned int, 4, naddrs); i++)
+-				q_op->addr1_reg |= addrs[i] << (i * 8);
++				q_op->addr1_reg |= cpu_to_le32(addrs[i] << (i * 8));
+ 
+ 			if (naddrs > 4)
+-				q_op->addr2_reg |= addrs[4];
++				q_op->addr2_reg |= cpu_to_le32(addrs[4]);
+ 
+ 			q_op->rdy_delay_ns = instr->delay_ns;
+ 			break;
+@@ -2663,7 +2617,7 @@ static int qcom_wait_rdy_poll(struct nan
+ 	unsigned long start = jiffies + msecs_to_jiffies(time_ms);
+ 	u32 flash;
+ 
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 
+ 	do {
+ 		flash = le32_to_cpu(nandc->reg_read_buf[0]);
+@@ -2706,11 +2660,11 @@ static int qcom_read_status_exec(struct
+ 	clear_read_regs(nandc);
+ 	clear_bam_transaction(nandc);
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, q_op.cmd_reg);
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
++	nandc->regs->cmd = q_op.cmd_reg;
++	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	ret = submit_descs(nandc);
+@@ -2719,7 +2673,7 @@ static int qcom_read_status_exec(struct
+ 		goto err_out;
+ 	}
+ 
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < num_cw; i++) {
+ 		flash_status = le32_to_cpu(nandc->reg_read_buf[i]);
+@@ -2763,16 +2717,14 @@ static int qcom_read_id_type_exec(struct
+ 	clear_read_regs(nandc);
+ 	clear_bam_transaction(nandc);
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, q_op.cmd_reg);
+-	nandc_set_reg(chip, NAND_ADDR0, q_op.addr1_reg);
+-	nandc_set_reg(chip, NAND_ADDR1, q_op.addr2_reg);
+-	nandc_set_reg(chip, NAND_FLASH_CHIP_SELECT,
+-		      nandc->props->is_bam ? 0 : DM_EN);
++	nandc->regs->cmd = q_op.cmd_reg;
++	nandc->regs->addr0 = q_op.addr1_reg;
++	nandc->regs->addr1 = q_op.addr2_reg;
++	nandc->regs->chip_sel = cpu_to_le32(nandc->props->supports_bam ? 0 : DM_EN);
++	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
+-
+-	write_reg_dma(nandc, NAND_FLASH_CMD, 4, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 4, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	read_reg_dma(nandc, NAND_READ_ID, 1, NAND_BAM_NEXT_SGL);
+ 
+@@ -2786,7 +2738,7 @@ static int qcom_read_id_type_exec(struct
+ 	op_id = q_op.data_instr_idx;
+ 	len = nand_subop_get_data_len(subop, op_id);
+ 
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 	memcpy(instr->ctx.data.buf.in, nandc->reg_read_buf, len);
+ 
+ err_out:
+@@ -2807,15 +2759,14 @@ static int qcom_misc_cmd_type_exec(struc
+ 
+ 	if (q_op.flag == OP_PROGRAM_PAGE) {
+ 		goto wait_rdy;
+-	} else if (q_op.cmd_reg == OP_BLOCK_ERASE) {
+-		q_op.cmd_reg |= PAGE_ACC | LAST_PAGE;
+-		nandc_set_reg(chip, NAND_ADDR0, q_op.addr1_reg);
+-		nandc_set_reg(chip, NAND_ADDR1, q_op.addr2_reg);
+-		nandc_set_reg(chip, NAND_DEV0_CFG0,
+-			      host->cfg0_raw & ~(7 << CW_PER_PAGE));
+-		nandc_set_reg(chip, NAND_DEV0_CFG1, host->cfg1_raw);
++	} else if (q_op.cmd_reg == cpu_to_le32(OP_BLOCK_ERASE)) {
++		q_op.cmd_reg |= cpu_to_le32(PAGE_ACC | LAST_PAGE);
++		nandc->regs->addr0 = q_op.addr1_reg;
++		nandc->regs->addr1 = q_op.addr2_reg;
++		nandc->regs->cfg0 = cpu_to_le32(host->cfg0_raw & ~(7 << CW_PER_PAGE));
++		nandc->regs->cfg1 = cpu_to_le32(host->cfg1_raw);
+ 		instrs = 3;
+-	} else if (q_op.cmd_reg != OP_RESET_DEVICE) {
++	} else if (q_op.cmd_reg != cpu_to_le32(OP_RESET_DEVICE)) {
+ 		return 0;
+ 	}
+ 
+@@ -2826,14 +2777,14 @@ static int qcom_misc_cmd_type_exec(struc
+ 	clear_read_regs(nandc);
+ 	clear_bam_transaction(nandc);
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, q_op.cmd_reg);
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
++	nandc->regs->cmd = q_op.cmd_reg;
++	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_CMD, instrs, NAND_BAM_NEXT_SGL);
+-	if (q_op.cmd_reg == OP_BLOCK_ERASE)
+-		write_reg_dma(nandc, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, instrs, NAND_BAM_NEXT_SGL);
++	if (q_op.cmd_reg == cpu_to_le32(OP_BLOCK_ERASE))
++		write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	ret = submit_descs(nandc);
+@@ -2864,7 +2815,7 @@ static int qcom_param_page_type_exec(str
+ 	if (ret)
+ 		return ret;
+ 
+-	q_op.cmd_reg |= PAGE_ACC | LAST_PAGE;
++	q_op.cmd_reg |= cpu_to_le32(PAGE_ACC | LAST_PAGE);
+ 
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+@@ -2872,38 +2823,38 @@ static int qcom_param_page_type_exec(str
+ 	clear_read_regs(nandc);
+ 	clear_bam_transaction(nandc);
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, q_op.cmd_reg);
++	nandc->regs->cmd = q_op.cmd_reg;
++	nandc->regs->addr0 = 0;
++	nandc->regs->addr1 = 0;
++
++	nandc->regs->cfg0 = cpu_to_le32(0 << CW_PER_PAGE |
++					512 << UD_SIZE_BYTES |
++					5 << NUM_ADDR_CYCLES |
++					0 << SPARE_SIZE_BYTES);
++
++	nandc->regs->cfg1 = cpu_to_le32(7 << NAND_RECOVERY_CYCLES |
++					0 << CS_ACTIVE_BSY |
++					17 << BAD_BLOCK_BYTE_NUM |
++					1 << BAD_BLOCK_IN_SPARE_AREA |
++					2 << WR_RD_BSY_GAP |
++					0 << WIDE_FLASH |
++					1 << DEV0_CFG1_ECC_DISABLE);
+ 
+-	nandc_set_reg(chip, NAND_ADDR0, 0);
+-	nandc_set_reg(chip, NAND_ADDR1, 0);
+-	nandc_set_reg(chip, NAND_DEV0_CFG0, 0 << CW_PER_PAGE
+-					| 512 << UD_SIZE_BYTES
+-					| 5 << NUM_ADDR_CYCLES
+-					| 0 << SPARE_SIZE_BYTES);
+-	nandc_set_reg(chip, NAND_DEV0_CFG1, 7 << NAND_RECOVERY_CYCLES
+-					| 0 << CS_ACTIVE_BSY
+-					| 17 << BAD_BLOCK_BYTE_NUM
+-					| 1 << BAD_BLOCK_IN_SPARE_AREA
+-					| 2 << WR_RD_BSY_GAP
+-					| 0 << WIDE_FLASH
+-					| 1 << DEV0_CFG1_ECC_DISABLE);
+-	if (!nandc->props->qpic_v2)
+-		nandc_set_reg(chip, NAND_EBI2_ECC_BUF_CFG, 1 << ECC_CFG_ECC_DISABLE);
++	if (!nandc->props->qpic_version2)
++		nandc->regs->ecc_buf_cfg = cpu_to_le32(1 << ECC_CFG_ECC_DISABLE);
+ 
+ 	/* configure CMD1 and VLD for ONFI param probing in QPIC v1 */
+-	if (!nandc->props->qpic_v2) {
+-		nandc_set_reg(chip, NAND_DEV_CMD_VLD,
+-			      (nandc->vld & ~READ_START_VLD));
+-		nandc_set_reg(chip, NAND_DEV_CMD1,
+-			      (nandc->cmd1 & ~(0xFF << READ_ADDR))
+-			      | NAND_CMD_PARAM << READ_ADDR);
++	if (!nandc->props->qpic_version2) {
++		nandc->regs->vld = cpu_to_le32((nandc->vld & ~READ_START_VLD));
++		nandc->regs->cmd1 = cpu_to_le32((nandc->cmd1 & ~(0xFF << READ_ADDR))
++				    | NAND_CMD_PARAM << READ_ADDR);
+ 	}
+ 
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
+-
+-	if (!nandc->props->qpic_v2) {
+-		nandc_set_reg(chip, NAND_DEV_CMD1_RESTORE, nandc->cmd1);
+-		nandc_set_reg(chip, NAND_DEV_CMD_VLD_RESTORE, nandc->vld);
++	nandc->regs->exec = cpu_to_le32(1);
++
++	if (!nandc->props->qpic_version2) {
++		nandc->regs->orig_cmd1 = cpu_to_le32(nandc->cmd1);
++		nandc->regs->orig_vld = cpu_to_le32(nandc->vld);
+ 	}
+ 
+ 	instr = q_op.data_instr;
+@@ -2912,9 +2863,9 @@ static int qcom_param_page_type_exec(str
+ 
+ 	nandc_set_read_loc(chip, 0, 0, 0, len, 1);
+ 
+-	if (!nandc->props->qpic_v2) {
+-		write_reg_dma(nandc, NAND_DEV_CMD_VLD, 1, 0);
+-		write_reg_dma(nandc, NAND_DEV_CMD1, 1, NAND_BAM_NEXT_SGL);
++	if (!nandc->props->qpic_version2) {
++		write_reg_dma(nandc, &nandc->regs->vld, NAND_DEV_CMD_VLD, 1, 0);
++		write_reg_dma(nandc, &nandc->regs->cmd1, NAND_DEV_CMD1, 1, NAND_BAM_NEXT_SGL);
+ 	}
+ 
+ 	nandc->buf_count = len;
+@@ -2926,9 +2877,10 @@ static int qcom_param_page_type_exec(str
+ 		      nandc->buf_count, 0);
+ 
+ 	/* restore CMD1 and VLD regs */
+-	if (!nandc->props->qpic_v2) {
+-		write_reg_dma(nandc, NAND_DEV_CMD1_RESTORE, 1, 0);
+-		write_reg_dma(nandc, NAND_DEV_CMD_VLD_RESTORE, 1, NAND_BAM_NEXT_SGL);
++	if (!nandc->props->qpic_version2) {
++		write_reg_dma(nandc, &nandc->regs->orig_cmd1, NAND_DEV_CMD1_RESTORE, 1, 0);
++		write_reg_dma(nandc, &nandc->regs->orig_vld, NAND_DEV_CMD_VLD_RESTORE, 1,
++			      NAND_BAM_NEXT_SGL);
+ 	}
+ 
+ 	ret = submit_descs(nandc);
+@@ -3017,7 +2969,7 @@ static const struct nand_controller_ops
+ 
+ static void qcom_nandc_unalloc(struct qcom_nand_controller *nandc)
+ {
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		if (!dma_mapping_error(nandc->dev, nandc->reg_read_dma))
+ 			dma_unmap_single(nandc->dev, nandc->reg_read_dma,
+ 					 MAX_REG_RD *
+@@ -3070,7 +3022,7 @@ static int qcom_nandc_alloc(struct qcom_
+ 	if (!nandc->reg_read_buf)
+ 		return -ENOMEM;
+ 
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		nandc->reg_read_dma =
+ 			dma_map_single(nandc->dev, nandc->reg_read_buf,
+ 				       MAX_REG_RD *
+@@ -3151,15 +3103,15 @@ static int qcom_nandc_setup(struct qcom_
+ 	u32 nand_ctrl;
+ 
+ 	/* kill onenand */
+-	if (!nandc->props->is_qpic)
++	if (!nandc->props->nandc_part_of_qpic)
+ 		nandc_write(nandc, SFLASHC_BURST_CFG, 0);
+ 
+-	if (!nandc->props->qpic_v2)
++	if (!nandc->props->qpic_version2)
+ 		nandc_write(nandc, dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD),
+ 			    NAND_DEV_CMD_VLD_VAL);
+ 
+ 	/* enable ADM or BAM DMA */
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		nand_ctrl = nandc_read(nandc, NAND_CTRL);
+ 
+ 		/*
+@@ -3176,7 +3128,7 @@ static int qcom_nandc_setup(struct qcom_
+ 	}
+ 
+ 	/* save the original values of these registers */
+-	if (!nandc->props->qpic_v2) {
++	if (!nandc->props->qpic_version2) {
+ 		nandc->cmd1 = nandc_read(nandc, dev_cmd_reg_addr(nandc, NAND_DEV_CMD1));
+ 		nandc->vld = NAND_DEV_CMD_VLD_VAL;
+ 	}
+@@ -3349,7 +3301,7 @@ static int qcom_nandc_parse_dt(struct pl
+ 	struct device_node *np = nandc->dev->of_node;
+ 	int ret;
+ 
+-	if (!nandc->props->is_bam) {
++	if (!nandc->props->supports_bam) {
+ 		ret = of_property_read_u32(np, "qcom,cmd-crci",
+ 					   &nandc->cmd_crci);
+ 		if (ret) {
+@@ -3474,30 +3426,30 @@ static void qcom_nandc_remove(struct pla
+ 
+ static const struct qcom_nandc_props ipq806x_nandc_props = {
+ 	.ecc_modes = (ECC_RS_4BIT | ECC_BCH_8BIT),
+-	.is_bam = false,
++	.supports_bam = false,
+ 	.use_codeword_fixup = true,
+ 	.dev_cmd_reg_start = 0x0,
+ };
+ 
+ static const struct qcom_nandc_props ipq4019_nandc_props = {
+ 	.ecc_modes = (ECC_BCH_4BIT | ECC_BCH_8BIT),
+-	.is_bam = true,
+-	.is_qpic = true,
++	.supports_bam = true,
++	.nandc_part_of_qpic = true,
+ 	.dev_cmd_reg_start = 0x0,
+ };
+ 
+ static const struct qcom_nandc_props ipq8074_nandc_props = {
+ 	.ecc_modes = (ECC_BCH_4BIT | ECC_BCH_8BIT),
+-	.is_bam = true,
+-	.is_qpic = true,
++	.supports_bam = true,
++	.nandc_part_of_qpic = true,
+ 	.dev_cmd_reg_start = 0x7000,
+ };
+ 
+ static const struct qcom_nandc_props sdx55_nandc_props = {
+ 	.ecc_modes = (ECC_BCH_4BIT | ECC_BCH_8BIT),
+-	.is_bam = true,
+-	.is_qpic = true,
+-	.qpic_v2 = true,
++	.supports_bam = true,
++	.nandc_part_of_qpic = true,
++	.qpic_version2 = true,
+ 	.dev_cmd_reg_start = 0x7000,
+ };
+ 
diff --git a/target/linux/generic/backport-6.12/413-02-v6.14-mtd-rawnand-qcom-Add-qcom-prefix-to-common-api.patch b/target/linux/generic/backport-6.12/413-02-v6.14-mtd-rawnand-qcom-Add-qcom-prefix-to-common-api.patch
new file mode 100644
index 0000000000..078a56cf16
--- /dev/null
+++ b/target/linux/generic/backport-6.12/413-02-v6.14-mtd-rawnand-qcom-Add-qcom-prefix-to-common-api.patch
@@ -0,0 +1,880 @@
+From 1d479f5b345e0c3650fec4dddeef9fc6fab30c8b Mon Sep 17 00:00:00 2001
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Wed, 20 Nov 2024 14:45:01 +0530
+Subject: [PATCH 2/4] mtd: rawnand: qcom: Add qcom prefix to common api
+
+Add qcom prefix to all the api which will be commonly
+used by spi nand driver and raw nand driver.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@oss.qualcomm.com>
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/mtd/nand/raw/qcom_nandc.c | 320 +++++++++++++++---------------
+ 1 file changed, 160 insertions(+), 160 deletions(-)
+
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -53,7 +53,7 @@
+ #define	NAND_READ_LOCATION_LAST_CW_2	0xf48
+ #define	NAND_READ_LOCATION_LAST_CW_3	0xf4c
+ 
+-/* dummy register offsets, used by write_reg_dma */
++/* dummy register offsets, used by qcom_write_reg_dma */
+ #define	NAND_DEV_CMD1_RESTORE		0xdead
+ #define	NAND_DEV_CMD_VLD_RESTORE	0xbeef
+ 
+@@ -211,7 +211,7 @@
+ 
+ /*
+  * Flags used in DMA descriptor preparation helper functions
+- * (i.e. read_reg_dma/write_reg_dma/read_data_dma/write_data_dma)
++ * (i.e. qcom_read_reg_dma/qcom_write_reg_dma/qcom_read_data_dma/qcom_write_data_dma)
+  */
+ /* Don't set the EOT in current tx BAM sgl */
+ #define NAND_BAM_NO_EOT			BIT(0)
+@@ -550,7 +550,7 @@ struct qcom_nandc_props {
+ };
+ 
+ /* Frees the BAM transaction memory */
+-static void free_bam_transaction(struct qcom_nand_controller *nandc)
++static void qcom_free_bam_transaction(struct qcom_nand_controller *nandc)
+ {
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+ 
+@@ -559,7 +559,7 @@ static void free_bam_transaction(struct
+ 
+ /* Allocates and Initializes the BAM transaction */
+ static struct bam_transaction *
+-alloc_bam_transaction(struct qcom_nand_controller *nandc)
++qcom_alloc_bam_transaction(struct qcom_nand_controller *nandc)
+ {
+ 	struct bam_transaction *bam_txn;
+ 	size_t bam_txn_size;
+@@ -595,7 +595,7 @@ alloc_bam_transaction(struct qcom_nand_c
+ }
+ 
+ /* Clears the BAM transaction indexes */
+-static void clear_bam_transaction(struct qcom_nand_controller *nandc)
++static void qcom_clear_bam_transaction(struct qcom_nand_controller *nandc)
+ {
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+ 
+@@ -614,7 +614,7 @@ static void clear_bam_transaction(struct
+ }
+ 
+ /* Callback for DMA descriptor completion */
+-static void qpic_bam_dma_done(void *data)
++static void qcom_qpic_bam_dma_done(void *data)
+ {
+ 	struct bam_transaction *bam_txn = data;
+ 
+@@ -644,7 +644,7 @@ static void nandc_write(struct qcom_nand
+ 	iowrite32(val, nandc->base + offset);
+ }
+ 
+-static void nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
++static void qcom_nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
+ {
+ 	if (!nandc->props->supports_bam)
+ 		return;
+@@ -824,9 +824,9 @@ static void update_rw_regs(struct qcom_n
+  * for BAM. This descriptor will be added in the NAND DMA descriptor queue
+  * which will be submitted to DMA engine.
+  */
+-static int prepare_bam_async_desc(struct qcom_nand_controller *nandc,
+-				  struct dma_chan *chan,
+-				  unsigned long flags)
++static int qcom_prepare_bam_async_desc(struct qcom_nand_controller *nandc,
++				       struct dma_chan *chan,
++				       unsigned long flags)
+ {
+ 	struct desc_info *desc;
+ 	struct scatterlist *sgl;
+@@ -903,9 +903,9 @@ static int prepare_bam_async_desc(struct
+  * NAND_BAM_NEXT_SGL will be used for starting the separate SGL
+  * after the current command element.
+  */
+-static int prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
+-				 int reg_off, const void *vaddr,
+-				 int size, unsigned int flags)
++static int qcom_prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
++				      int reg_off, const void *vaddr,
++				      int size, unsigned int flags)
+ {
+ 	int bam_ce_size;
+ 	int i, ret;
+@@ -943,9 +943,9 @@ static int prep_bam_dma_desc_cmd(struct
+ 		bam_txn->bam_ce_start = bam_txn->bam_ce_pos;
+ 
+ 		if (flags & NAND_BAM_NWD) {
+-			ret = prepare_bam_async_desc(nandc, nandc->cmd_chan,
+-						     DMA_PREP_FENCE |
+-						     DMA_PREP_CMD);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
++							  DMA_PREP_FENCE |
++							  DMA_PREP_CMD);
+ 			if (ret)
+ 				return ret;
+ 		}
+@@ -958,9 +958,8 @@ static int prep_bam_dma_desc_cmd(struct
+  * Prepares the data descriptor for BAM DMA which will be used for NAND
+  * data reads and writes.
+  */
+-static int prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
+-				  const void *vaddr,
+-				  int size, unsigned int flags)
++static int qcom_prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
++				       const void *vaddr, int size, unsigned int flags)
+ {
+ 	int ret;
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+@@ -979,8 +978,8 @@ static int prep_bam_dma_desc_data(struct
+ 		 * is not set, form the DMA descriptor
+ 		 */
+ 		if (!(flags & NAND_BAM_NO_EOT)) {
+-			ret = prepare_bam_async_desc(nandc, nandc->tx_chan,
+-						     DMA_PREP_INTERRUPT);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
++							  DMA_PREP_INTERRUPT);
+ 			if (ret)
+ 				return ret;
+ 		}
+@@ -989,9 +988,9 @@ static int prep_bam_dma_desc_data(struct
+ 	return 0;
+ }
+ 
+-static int prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read,
+-			     int reg_off, const void *vaddr, int size,
+-			     bool flow_control)
++static int qcom_prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read,
++				  int reg_off, const void *vaddr, int size,
++				  bool flow_control)
+ {
+ 	struct desc_info *desc;
+ 	struct dma_async_tx_descriptor *dma_desc;
+@@ -1069,15 +1068,15 @@ err:
+ }
+ 
+ /*
+- * read_reg_dma:	prepares a descriptor to read a given number of
++ * qcom_read_reg_dma:	prepares a descriptor to read a given number of
+  *			contiguous registers to the reg_read_buf pointer
+  *
+  * @first:		offset of the first register in the contiguous block
+  * @num_regs:		number of registers to read
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int read_reg_dma(struct qcom_nand_controller *nandc, int first,
+-			int num_regs, unsigned int flags)
++static int qcom_read_reg_dma(struct qcom_nand_controller *nandc, int first,
++			     int num_regs, unsigned int flags)
+ {
+ 	bool flow_control = false;
+ 	void *vaddr;
+@@ -1089,18 +1088,18 @@ static int read_reg_dma(struct qcom_nand
+ 		first = dev_cmd_reg_addr(nandc, first);
+ 
+ 	if (nandc->props->supports_bam)
+-		return prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
++		return qcom_prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
+ 					     num_regs, flags);
+ 
+ 	if (first == NAND_READ_ID || first == NAND_FLASH_STATUS)
+ 		flow_control = true;
+ 
+-	return prep_adm_dma_desc(nandc, true, first, vaddr,
++	return qcom_prep_adm_dma_desc(nandc, true, first, vaddr,
+ 				 num_regs * sizeof(u32), flow_control);
+ }
+ 
+ /*
+- * write_reg_dma:	prepares a descriptor to write a given number of
++ * qcom_write_reg_dma:	prepares a descriptor to write a given number of
+  *			contiguous registers
+  *
+  * @vaddr:		contiguous memory from where register value will
+@@ -1109,8 +1108,8 @@ static int read_reg_dma(struct qcom_nand
+  * @num_regs:		number of registers to write
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
+-			 int first, int num_regs, unsigned int flags)
++static int qcom_write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
++			      int first, int num_regs, unsigned int flags)
+ {
+ 	bool flow_control = false;
+ 
+@@ -1124,18 +1123,18 @@ static int write_reg_dma(struct qcom_nan
+ 		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD);
+ 
+ 	if (nandc->props->supports_bam)
+-		return prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
++		return qcom_prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
+ 					     num_regs, flags);
+ 
+ 	if (first == NAND_FLASH_CMD)
+ 		flow_control = true;
+ 
+-	return prep_adm_dma_desc(nandc, false, first, vaddr,
++	return qcom_prep_adm_dma_desc(nandc, false, first, vaddr,
+ 				 num_regs * sizeof(u32), flow_control);
+ }
+ 
+ /*
+- * read_data_dma:	prepares a DMA descriptor to transfer data from the
++ * qcom_read_data_dma:	prepares a DMA descriptor to transfer data from the
+  *			controller's internal buffer to the buffer 'vaddr'
+  *
+  * @reg_off:		offset within the controller's data buffer
+@@ -1143,17 +1142,17 @@ static int write_reg_dma(struct qcom_nan
+  * @size:		DMA transaction size in bytes
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+-			 const u8 *vaddr, int size, unsigned int flags)
++static int qcom_read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
++			      const u8 *vaddr, int size, unsigned int flags)
+ {
+ 	if (nandc->props->supports_bam)
+-		return prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
++		return qcom_prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
+ 
+-	return prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
++	return qcom_prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
+ }
+ 
+ /*
+- * write_data_dma:	prepares a DMA descriptor to transfer data from
++ * qcom_write_data_dma:	prepares a DMA descriptor to transfer data from
+  *			'vaddr' to the controller's internal buffer
+  *
+  * @reg_off:		offset within the controller's data buffer
+@@ -1161,13 +1160,13 @@ static int read_data_dma(struct qcom_nan
+  * @size:		DMA transaction size in bytes
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+-			  const u8 *vaddr, int size, unsigned int flags)
++static int qcom_write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
++			       const u8 *vaddr, int size, unsigned int flags)
+ {
+ 	if (nandc->props->supports_bam)
+-		return prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
++		return qcom_prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
+ 
+-	return prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
++	return qcom_prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
+ }
+ 
+ /*
+@@ -1178,14 +1177,14 @@ static void config_nand_page_read(struct
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
+-	write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
+ 	if (!nandc->props->qpic_version2)
+-		write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1, 0);
+-	write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_clr,
+-		      NAND_ERASED_CW_DETECT_CFG, 1, 0);
+-	write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_set,
+-		      NAND_ERASED_CW_DETECT_CFG, 1, NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1, NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
+ }
+ 
+ /*
+@@ -1204,17 +1203,17 @@ config_nand_cw_read(struct nand_chip *ch
+ 		reg = &nandc->regs->read_location_last0;
+ 
+ 	if (nandc->props->supports_bam)
+-		write_reg_dma(nandc, reg, NAND_READ_LOCATION_0, 4, NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, reg, NAND_READ_LOCATION_0, 4, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	if (use_ecc) {
+-		read_reg_dma(nandc, NAND_FLASH_STATUS, 2, 0);
+-		read_reg_dma(nandc, NAND_ERASED_CW_DETECT_STATUS, 1,
+-			     NAND_BAM_NEXT_SGL);
++		qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 2, 0);
++		qcom_read_reg_dma(nandc, NAND_ERASED_CW_DETECT_STATUS, 1,
++				  NAND_BAM_NEXT_SGL);
+ 	} else {
+-		read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++		qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 	}
+ }
+ 
+@@ -1238,11 +1237,11 @@ static void config_nand_page_write(struc
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
+-	write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
+ 	if (!nandc->props->qpic_version2)
+-		write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1,
+-			      NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1,
++				   NAND_BAM_NEXT_SGL);
+ }
+ 
+ /*
+@@ -1253,17 +1252,18 @@ static void config_nand_cw_write(struct
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+-	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, &nandc->regs->clrflashstatus, NAND_FLASH_STATUS, 1, 0);
+-	write_reg_dma(nandc, &nandc->regs->clrreadstatus, NAND_READ_STATUS, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->clrflashstatus, NAND_FLASH_STATUS, 1, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->clrreadstatus, NAND_READ_STATUS, 1,
++			   NAND_BAM_NEXT_SGL);
+ }
+ 
+ /* helpers to submit/free our list of dma descriptors */
+-static int submit_descs(struct qcom_nand_controller *nandc)
++static int qcom_submit_descs(struct qcom_nand_controller *nandc)
+ {
+ 	struct desc_info *desc, *n;
+ 	dma_cookie_t cookie = 0;
+@@ -1272,21 +1272,21 @@ static int submit_descs(struct qcom_nand
+ 
+ 	if (nandc->props->supports_bam) {
+ 		if (bam_txn->rx_sgl_pos > bam_txn->rx_sgl_start) {
+-			ret = prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
+ 			if (ret)
+ 				goto err_unmap_free_desc;
+ 		}
+ 
+ 		if (bam_txn->tx_sgl_pos > bam_txn->tx_sgl_start) {
+-			ret = prepare_bam_async_desc(nandc, nandc->tx_chan,
+-						   DMA_PREP_INTERRUPT);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
++							  DMA_PREP_INTERRUPT);
+ 			if (ret)
+ 				goto err_unmap_free_desc;
+ 		}
+ 
+ 		if (bam_txn->cmd_sgl_pos > bam_txn->cmd_sgl_start) {
+-			ret = prepare_bam_async_desc(nandc, nandc->cmd_chan,
+-						   DMA_PREP_CMD);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
++							  DMA_PREP_CMD);
+ 			if (ret)
+ 				goto err_unmap_free_desc;
+ 		}
+@@ -1296,7 +1296,7 @@ static int submit_descs(struct qcom_nand
+ 		cookie = dmaengine_submit(desc->dma_desc);
+ 
+ 	if (nandc->props->supports_bam) {
+-		bam_txn->last_cmd_desc->callback = qpic_bam_dma_done;
++		bam_txn->last_cmd_desc->callback = qcom_qpic_bam_dma_done;
+ 		bam_txn->last_cmd_desc->callback_param = bam_txn;
+ 
+ 		dma_async_issue_pending(nandc->tx_chan);
+@@ -1314,7 +1314,7 @@ static int submit_descs(struct qcom_nand
+ err_unmap_free_desc:
+ 	/*
+ 	 * Unmap the dma sg_list and free the desc allocated by both
+-	 * prepare_bam_async_desc() and prep_adm_dma_desc() functions.
++	 * qcom_prepare_bam_async_desc() and qcom_prep_adm_dma_desc() functions.
+ 	 */
+ 	list_for_each_entry_safe(desc, n, &nandc->desc_list, node) {
+ 		list_del(&desc->node);
+@@ -1333,10 +1333,10 @@ err_unmap_free_desc:
+ }
+ 
+ /* reset the register read buffer for next NAND operation */
+-static void clear_read_regs(struct qcom_nand_controller *nandc)
++static void qcom_clear_read_regs(struct qcom_nand_controller *nandc)
+ {
+ 	nandc->reg_read_pos = 0;
+-	nandc_dev_to_mem(nandc, false);
++	qcom_nandc_dev_to_mem(nandc, false);
+ }
+ 
+ /*
+@@ -1400,7 +1400,7 @@ static int check_flash_errors(struct qco
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 	int i;
+ 
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < cw_cnt; i++) {
+ 		u32 flash = le32_to_cpu(nandc->reg_read_buf[i]);
+@@ -1427,13 +1427,13 @@ qcom_nandc_read_cw_raw(struct mtd_info *
+ 	nand_read_page_op(chip, page, 0, NULL, 0);
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+-	clear_read_regs(nandc);
++	qcom_clear_read_regs(nandc);
+ 	host->use_ecc = false;
+ 
+ 	if (nandc->props->qpic_version2)
+ 		raw_cw = ecc->steps - 1;
+ 
+-	clear_bam_transaction(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 	set_address(host, host->cw_size * cw, page);
+ 	update_rw_regs(host, 1, true, raw_cw);
+ 	config_nand_page_read(chip);
+@@ -1466,18 +1466,18 @@ qcom_nandc_read_cw_raw(struct mtd_info *
+ 
+ 	config_nand_cw_read(chip, false, raw_cw);
+ 
+-	read_data_dma(nandc, reg_off, data_buf, data_size1, 0);
++	qcom_read_data_dma(nandc, reg_off, data_buf, data_size1, 0);
+ 	reg_off += data_size1;
+ 
+-	read_data_dma(nandc, reg_off, oob_buf, oob_size1, 0);
++	qcom_read_data_dma(nandc, reg_off, oob_buf, oob_size1, 0);
+ 	reg_off += oob_size1;
+ 
+-	read_data_dma(nandc, reg_off, data_buf + data_size1, data_size2, 0);
++	qcom_read_data_dma(nandc, reg_off, data_buf + data_size1, data_size2, 0);
+ 	reg_off += data_size2;
+ 
+-	read_data_dma(nandc, reg_off, oob_buf + oob_size1, oob_size2, 0);
++	qcom_read_data_dma(nandc, reg_off, oob_buf + oob_size1, oob_size2, 0);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to read raw cw %d\n", cw);
+ 		return ret;
+@@ -1575,7 +1575,7 @@ static int parse_read_errors(struct qcom
+ 	u8 *data_buf_start = data_buf, *oob_buf_start = oob_buf;
+ 
+ 	buf = (struct read_stats *)nandc->reg_read_buf;
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < ecc->steps; i++, buf++) {
+ 		u32 flash, buffer, erased_cw;
+@@ -1704,8 +1704,8 @@ static int read_page_ecc(struct qcom_nan
+ 		config_nand_cw_read(chip, true, i);
+ 
+ 		if (data_buf)
+-			read_data_dma(nandc, FLASH_BUF_ACC, data_buf,
+-				      data_size, 0);
++			qcom_read_data_dma(nandc, FLASH_BUF_ACC, data_buf,
++					   data_size, 0);
+ 
+ 		/*
+ 		 * when ecc is enabled, the controller doesn't read the real
+@@ -1720,8 +1720,8 @@ static int read_page_ecc(struct qcom_nan
+ 			for (j = 0; j < host->bbm_size; j++)
+ 				*oob_buf++ = 0xff;
+ 
+-			read_data_dma(nandc, FLASH_BUF_ACC + data_size,
+-				      oob_buf, oob_size, 0);
++			qcom_read_data_dma(nandc, FLASH_BUF_ACC + data_size,
++					   oob_buf, oob_size, 0);
+ 		}
+ 
+ 		if (data_buf)
+@@ -1730,7 +1730,7 @@ static int read_page_ecc(struct qcom_nan
+ 			oob_buf += oob_size;
+ 	}
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to read page/oob\n");
+ 		return ret;
+@@ -1751,7 +1751,7 @@ static int copy_last_cw(struct qcom_nand
+ 	int size;
+ 	int ret;
+ 
+-	clear_read_regs(nandc);
++	qcom_clear_read_regs(nandc);
+ 
+ 	size = host->use_ecc ? host->cw_data : host->cw_size;
+ 
+@@ -1763,9 +1763,9 @@ static int copy_last_cw(struct qcom_nand
+ 
+ 	config_nand_single_cw_page_read(chip, host->use_ecc, ecc->steps - 1);
+ 
+-	read_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer, size, 0);
++	qcom_read_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer, size, 0);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret)
+ 		dev_err(nandc->dev, "failed to copy last codeword\n");
+ 
+@@ -1851,14 +1851,14 @@ static int qcom_nandc_read_page(struct n
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = true;
+-	clear_read_regs(nandc);
++	qcom_clear_read_regs(nandc);
+ 	set_address(host, 0, page);
+ 	update_rw_regs(host, ecc->steps, true, 0);
+ 
+ 	data_buf = buf;
+ 	oob_buf = oob_required ? chip->oob_poi : NULL;
+ 
+-	clear_bam_transaction(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	return read_page_ecc(host, data_buf, oob_buf, page);
+ }
+@@ -1899,8 +1899,8 @@ static int qcom_nandc_read_oob(struct na
+ 	if (host->nr_boot_partitions)
+ 		qcom_nandc_codeword_fixup(host, page);
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	host->use_ecc = true;
+ 	set_address(host, 0, page);
+@@ -1927,8 +1927,8 @@ static int qcom_nandc_write_page(struct
+ 	set_address(host, 0, page);
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	data_buf = (u8 *)buf;
+ 	oob_buf = chip->oob_poi;
+@@ -1949,8 +1949,8 @@ static int qcom_nandc_write_page(struct
+ 			oob_size = ecc->bytes;
+ 		}
+ 
+-		write_data_dma(nandc, FLASH_BUF_ACC, data_buf, data_size,
+-			       i == (ecc->steps - 1) ? NAND_BAM_NO_EOT : 0);
++		qcom_write_data_dma(nandc, FLASH_BUF_ACC, data_buf, data_size,
++				    i == (ecc->steps - 1) ? NAND_BAM_NO_EOT : 0);
+ 
+ 		/*
+ 		 * when ECC is enabled, we don't really need to write anything
+@@ -1962,8 +1962,8 @@ static int qcom_nandc_write_page(struct
+ 		if (qcom_nandc_is_last_cw(ecc, i)) {
+ 			oob_buf += host->bbm_size;
+ 
+-			write_data_dma(nandc, FLASH_BUF_ACC + data_size,
+-				       oob_buf, oob_size, 0);
++			qcom_write_data_dma(nandc, FLASH_BUF_ACC + data_size,
++					    oob_buf, oob_size, 0);
+ 		}
+ 
+ 		config_nand_cw_write(chip);
+@@ -1972,7 +1972,7 @@ static int qcom_nandc_write_page(struct
+ 		oob_buf += oob_size;
+ 	}
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to write page\n");
+ 		return ret;
+@@ -1997,8 +1997,8 @@ static int qcom_nandc_write_page_raw(str
+ 		qcom_nandc_codeword_fixup(host, page);
+ 
+ 	nand_prog_page_begin_op(chip, page, 0, NULL, 0);
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	data_buf = (u8 *)buf;
+ 	oob_buf = chip->oob_poi;
+@@ -2024,28 +2024,28 @@ static int qcom_nandc_write_page_raw(str
+ 			oob_size2 = host->ecc_bytes_hw + host->spare_bytes;
+ 		}
+ 
+-		write_data_dma(nandc, reg_off, data_buf, data_size1,
+-			       NAND_BAM_NO_EOT);
++		qcom_write_data_dma(nandc, reg_off, data_buf, data_size1,
++				    NAND_BAM_NO_EOT);
+ 		reg_off += data_size1;
+ 		data_buf += data_size1;
+ 
+-		write_data_dma(nandc, reg_off, oob_buf, oob_size1,
+-			       NAND_BAM_NO_EOT);
++		qcom_write_data_dma(nandc, reg_off, oob_buf, oob_size1,
++				    NAND_BAM_NO_EOT);
+ 		reg_off += oob_size1;
+ 		oob_buf += oob_size1;
+ 
+-		write_data_dma(nandc, reg_off, data_buf, data_size2,
+-			       NAND_BAM_NO_EOT);
++		qcom_write_data_dma(nandc, reg_off, data_buf, data_size2,
++				    NAND_BAM_NO_EOT);
+ 		reg_off += data_size2;
+ 		data_buf += data_size2;
+ 
+-		write_data_dma(nandc, reg_off, oob_buf, oob_size2, 0);
++		qcom_write_data_dma(nandc, reg_off, oob_buf, oob_size2, 0);
+ 		oob_buf += oob_size2;
+ 
+ 		config_nand_cw_write(chip);
+ 	}
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to write raw page\n");
+ 		return ret;
+@@ -2075,7 +2075,7 @@ static int qcom_nandc_write_oob(struct n
+ 		qcom_nandc_codeword_fixup(host, page);
+ 
+ 	host->use_ecc = true;
+-	clear_bam_transaction(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	/* calculate the data and oob size for the last codeword/step */
+ 	data_size = ecc->size - ((ecc->steps - 1) << 2);
+@@ -2090,11 +2090,11 @@ static int qcom_nandc_write_oob(struct n
+ 	update_rw_regs(host, 1, false, 0);
+ 
+ 	config_nand_page_write(chip);
+-	write_data_dma(nandc, FLASH_BUF_ACC,
+-		       nandc->data_buffer, data_size + oob_size, 0);
++	qcom_write_data_dma(nandc, FLASH_BUF_ACC,
++			    nandc->data_buffer, data_size + oob_size, 0);
+ 	config_nand_cw_write(chip);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to write oob\n");
+ 		return ret;
+@@ -2121,7 +2121,7 @@ static int qcom_nandc_block_bad(struct n
+ 	 */
+ 	host->use_ecc = false;
+ 
+-	clear_bam_transaction(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 	ret = copy_last_cw(host, page);
+ 	if (ret)
+ 		goto err;
+@@ -2148,8 +2148,8 @@ static int qcom_nandc_block_markbad(stru
+ 	struct nand_ecc_ctrl *ecc = &chip->ecc;
+ 	int page, ret;
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	/*
+ 	 * to mark the BBM as bad, we flash the entire last codeword with 0s.
+@@ -2166,11 +2166,11 @@ static int qcom_nandc_block_markbad(stru
+ 	update_rw_regs(host, 1, false, ecc->steps - 1);
+ 
+ 	config_nand_page_write(chip);
+-	write_data_dma(nandc, FLASH_BUF_ACC,
+-		       nandc->data_buffer, host->cw_size, 0);
++	qcom_write_data_dma(nandc, FLASH_BUF_ACC,
++			    nandc->data_buffer, host->cw_size, 0);
+ 	config_nand_cw_write(chip);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to update BBM\n");
+ 		return ret;
+@@ -2410,14 +2410,14 @@ static int qcom_nand_attach_chip(struct
+ 	mtd_set_ooblayout(mtd, &qcom_nand_ooblayout_ops);
+ 	/* Free the initially allocated BAM transaction for reading the ONFI params */
+ 	if (nandc->props->supports_bam)
+-		free_bam_transaction(nandc);
++		qcom_free_bam_transaction(nandc);
+ 
+ 	nandc->max_cwperpage = max_t(unsigned int, nandc->max_cwperpage,
+ 				     cwperpage);
+ 
+ 	/* Now allocate the BAM transaction based on updated max_cwperpage */
+ 	if (nandc->props->supports_bam) {
+-		nandc->bam_txn = alloc_bam_transaction(nandc);
++		nandc->bam_txn = qcom_alloc_bam_transaction(nandc);
+ 		if (!nandc->bam_txn) {
+ 			dev_err(nandc->dev,
+ 				"failed to allocate bam transaction\n");
+@@ -2617,7 +2617,7 @@ static int qcom_wait_rdy_poll(struct nan
+ 	unsigned long start = jiffies + msecs_to_jiffies(time_ms);
+ 	u32 flash;
+ 
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 
+ 	do {
+ 		flash = le32_to_cpu(nandc->reg_read_buf[0]);
+@@ -2657,23 +2657,23 @@ static int qcom_read_status_exec(struct
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = false;
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	nandc->regs->cmd = q_op.cmd_reg;
+ 	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+-	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure in submitting status descriptor\n");
+ 		goto err_out;
+ 	}
+ 
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < num_cw; i++) {
+ 		flash_status = le32_to_cpu(nandc->reg_read_buf[i]);
+@@ -2714,8 +2714,8 @@ static int qcom_read_id_type_exec(struct
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = false;
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	nandc->regs->cmd = q_op.cmd_reg;
+ 	nandc->regs->addr0 = q_op.addr1_reg;
+@@ -2723,12 +2723,12 @@ static int qcom_read_id_type_exec(struct
+ 	nandc->regs->chip_sel = cpu_to_le32(nandc->props->supports_bam ? 0 : DM_EN);
+ 	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 4, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 4, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+-	read_reg_dma(nandc, NAND_READ_ID, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(nandc, NAND_READ_ID, 1, NAND_BAM_NEXT_SGL);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure in submitting read id descriptor\n");
+ 		goto err_out;
+@@ -2738,7 +2738,7 @@ static int qcom_read_id_type_exec(struct
+ 	op_id = q_op.data_instr_idx;
+ 	len = nand_subop_get_data_len(subop, op_id);
+ 
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 	memcpy(instr->ctx.data.buf.in, nandc->reg_read_buf, len);
+ 
+ err_out:
+@@ -2774,20 +2774,20 @@ static int qcom_misc_cmd_type_exec(struc
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = false;
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	nandc->regs->cmd = q_op.cmd_reg;
+ 	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, instrs, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, instrs, NAND_BAM_NEXT_SGL);
+ 	if (q_op.cmd_reg == cpu_to_le32(OP_BLOCK_ERASE))
+-		write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+-	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure in submitting misc descriptor\n");
+ 		goto err_out;
+@@ -2820,8 +2820,8 @@ static int qcom_param_page_type_exec(str
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = false;
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	nandc->regs->cmd = q_op.cmd_reg;
+ 	nandc->regs->addr0 = 0;
+@@ -2864,8 +2864,8 @@ static int qcom_param_page_type_exec(str
+ 	nandc_set_read_loc(chip, 0, 0, 0, len, 1);
+ 
+ 	if (!nandc->props->qpic_version2) {
+-		write_reg_dma(nandc, &nandc->regs->vld, NAND_DEV_CMD_VLD, 1, 0);
+-		write_reg_dma(nandc, &nandc->regs->cmd1, NAND_DEV_CMD1, 1, NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->vld, NAND_DEV_CMD_VLD, 1, 0);
++		qcom_write_reg_dma(nandc, &nandc->regs->cmd1, NAND_DEV_CMD1, 1, NAND_BAM_NEXT_SGL);
+ 	}
+ 
+ 	nandc->buf_count = len;
+@@ -2873,17 +2873,17 @@ static int qcom_param_page_type_exec(str
+ 
+ 	config_nand_single_cw_page_read(chip, false, 0);
+ 
+-	read_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer,
+-		      nandc->buf_count, 0);
++	qcom_read_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer,
++			   nandc->buf_count, 0);
+ 
+ 	/* restore CMD1 and VLD regs */
+ 	if (!nandc->props->qpic_version2) {
+-		write_reg_dma(nandc, &nandc->regs->orig_cmd1, NAND_DEV_CMD1_RESTORE, 1, 0);
+-		write_reg_dma(nandc, &nandc->regs->orig_vld, NAND_DEV_CMD_VLD_RESTORE, 1,
+-			      NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->orig_cmd1, NAND_DEV_CMD1_RESTORE, 1, 0);
++		qcom_write_reg_dma(nandc, &nandc->regs->orig_vld, NAND_DEV_CMD_VLD_RESTORE, 1,
++				   NAND_BAM_NEXT_SGL);
+ 	}
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure in submitting param page descriptor\n");
+ 		goto err_out;
+@@ -3067,7 +3067,7 @@ static int qcom_nandc_alloc(struct qcom_
+ 		 * maximum codeword size
+ 		 */
+ 		nandc->max_cwperpage = 1;
+-		nandc->bam_txn = alloc_bam_transaction(nandc);
++		nandc->bam_txn = qcom_alloc_bam_transaction(nandc);
+ 		if (!nandc->bam_txn) {
+ 			dev_err(nandc->dev,
+ 				"failed to allocate bam transaction\n");
diff --git a/target/linux/generic/backport-6.12/413-03-v6.14-mtd-nand-Add-qpic_common-API-file.patch b/target/linux/generic/backport-6.12/413-03-v6.14-mtd-nand-Add-qpic_common-API-file.patch
new file mode 100644
index 0000000000..26211461c1
--- /dev/null
+++ b/target/linux/generic/backport-6.12/413-03-v6.14-mtd-nand-Add-qpic_common-API-file.patch
@@ -0,0 +1,2436 @@
+From fdf3ee5c6e5278dab4f60b998b47ed2d510bf80f Mon Sep 17 00:00:00 2001
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Wed, 20 Nov 2024 14:45:02 +0530
+Subject: [PATCH 3/4] mtd: nand: Add qpic_common API file
+
+Add qpic_common.c file which hold all the common
+qpic APIs which will be used by both qpic raw nand
+driver and qpic spi nand driver.
+
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/mtd/nand/Makefile            |    2 +-
+ drivers/mtd/nand/qpic_common.c       |  759 ++++++++++++++++++
+ drivers/mtd/nand/raw/qcom_nandc.c    | 1092 +-------------------------
+ include/linux/mtd/nand-qpic-common.h |  468 +++++++++++
+ 4 files changed, 1240 insertions(+), 1081 deletions(-)
+ create mode 100644 drivers/mtd/nand/qpic_common.c
+ create mode 100644 include/linux/mtd/nand-qpic-common.h
+
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -3,7 +3,7 @@
+ nandcore-objs := core.o bbt.o
+ obj-$(CONFIG_MTD_NAND_CORE) += nandcore.o
+ obj-$(CONFIG_MTD_NAND_ECC_MEDIATEK) += ecc-mtk.o
+-
++obj-$(CONFIG_MTD_NAND_QCOM) += qpic_common.o
+ obj-y	+= onenand/
+ obj-y	+= raw/
+ obj-y	+= spi/
+--- /dev/null
++++ b/drivers/mtd/nand/qpic_common.c
+@@ -0,0 +1,759 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
++ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved
++ */
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/dmaengine.h>
++#include <linux/dma-mapping.h>
++#include <linux/dma/qcom_adm.h>
++#include <linux/dma/qcom_bam_dma.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/mtd/nand-qpic-common.h>
++
++/**
++ * qcom_free_bam_transaction() - Frees the BAM transaction memory
++ * @nandc: qpic nand controller
++ *
++ * This function frees the bam transaction memory
++ */
++void qcom_free_bam_transaction(struct qcom_nand_controller *nandc)
++{
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++
++	kfree(bam_txn);
++}
++EXPORT_SYMBOL(qcom_free_bam_transaction);
++
++/**
++ * qcom_alloc_bam_transaction() - allocate BAM transaction
++ * @nandc: qpic nand controller
++ *
++ * This function will allocate and initialize the BAM transaction structure
++ */
++struct bam_transaction *
++qcom_alloc_bam_transaction(struct qcom_nand_controller *nandc)
++{
++	struct bam_transaction *bam_txn;
++	size_t bam_txn_size;
++	unsigned int num_cw = nandc->max_cwperpage;
++	void *bam_txn_buf;
++
++	bam_txn_size =
++		sizeof(*bam_txn) + num_cw *
++		((sizeof(*bam_txn->bam_ce) * QPIC_PER_CW_CMD_ELEMENTS) +
++		(sizeof(*bam_txn->cmd_sgl) * QPIC_PER_CW_CMD_SGL) +
++		(sizeof(*bam_txn->data_sgl) * QPIC_PER_CW_DATA_SGL));
++
++	bam_txn_buf = kzalloc(bam_txn_size, GFP_KERNEL);
++	if (!bam_txn_buf)
++		return NULL;
++
++	bam_txn = bam_txn_buf;
++	bam_txn_buf += sizeof(*bam_txn);
++
++	bam_txn->bam_ce = bam_txn_buf;
++	bam_txn_buf +=
++		sizeof(*bam_txn->bam_ce) * QPIC_PER_CW_CMD_ELEMENTS * num_cw;
++
++	bam_txn->cmd_sgl = bam_txn_buf;
++	bam_txn_buf +=
++		sizeof(*bam_txn->cmd_sgl) * QPIC_PER_CW_CMD_SGL * num_cw;
++
++	bam_txn->data_sgl = bam_txn_buf;
++
++	init_completion(&bam_txn->txn_done);
++
++	return bam_txn;
++}
++EXPORT_SYMBOL(qcom_alloc_bam_transaction);
++
++/**
++ * qcom_clear_bam_transaction() - Clears the BAM transaction
++ * @nandc: qpic nand controller
++ *
++ * This function will clear the BAM transaction indexes.
++ */
++void qcom_clear_bam_transaction(struct qcom_nand_controller *nandc)
++{
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++
++	if (!nandc->props->supports_bam)
++		return;
++
++	memset(&bam_txn->bam_ce_pos, 0, sizeof(u32) * 8);
++	bam_txn->last_data_desc = NULL;
++
++	sg_init_table(bam_txn->cmd_sgl, nandc->max_cwperpage *
++		      QPIC_PER_CW_CMD_SGL);
++	sg_init_table(bam_txn->data_sgl, nandc->max_cwperpage *
++		      QPIC_PER_CW_DATA_SGL);
++
++	reinit_completion(&bam_txn->txn_done);
++}
++EXPORT_SYMBOL(qcom_clear_bam_transaction);
++
++/**
++ * qcom_qpic_bam_dma_done() - Callback for DMA descriptor completion
++ * @data: data pointer
++ *
++ * This function is a callback for DMA descriptor completion
++ */
++void qcom_qpic_bam_dma_done(void *data)
++{
++	struct bam_transaction *bam_txn = data;
++
++	complete(&bam_txn->txn_done);
++}
++EXPORT_SYMBOL(qcom_qpic_bam_dma_done);
++
++/**
++ * qcom_nandc_dev_to_mem() - Check for dma sync for cpu or device
++ * @nandc: qpic nand controller
++ * @is_cpu: cpu or Device
++ *
++ * This function will check for dma sync for cpu or device
++ */
++inline void qcom_nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
++{
++	if (!nandc->props->supports_bam)
++		return;
++
++	if (is_cpu)
++		dma_sync_single_for_cpu(nandc->dev, nandc->reg_read_dma,
++					MAX_REG_RD *
++					sizeof(*nandc->reg_read_buf),
++					DMA_FROM_DEVICE);
++	else
++		dma_sync_single_for_device(nandc->dev, nandc->reg_read_dma,
++					   MAX_REG_RD *
++					   sizeof(*nandc->reg_read_buf),
++					   DMA_FROM_DEVICE);
++}
++EXPORT_SYMBOL(qcom_nandc_dev_to_mem);
++
++/**
++ * qcom_prepare_bam_async_desc() - Prepare DMA descriptor
++ * @nandc: qpic nand controller
++ * @chan: dma channel
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function maps the scatter gather list for DMA transfer and forms the
++ * DMA descriptor for BAM.This descriptor will be added in the NAND DMA
++ * descriptor queue which will be submitted to DMA engine.
++ */
++int qcom_prepare_bam_async_desc(struct qcom_nand_controller *nandc,
++				struct dma_chan *chan, unsigned long flags)
++{
++	struct desc_info *desc;
++	struct scatterlist *sgl;
++	unsigned int sgl_cnt;
++	int ret;
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++	enum dma_transfer_direction dir_eng;
++	struct dma_async_tx_descriptor *dma_desc;
++
++	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
++	if (!desc)
++		return -ENOMEM;
++
++	if (chan == nandc->cmd_chan) {
++		sgl = &bam_txn->cmd_sgl[bam_txn->cmd_sgl_start];
++		sgl_cnt = bam_txn->cmd_sgl_pos - bam_txn->cmd_sgl_start;
++		bam_txn->cmd_sgl_start = bam_txn->cmd_sgl_pos;
++		dir_eng = DMA_MEM_TO_DEV;
++		desc->dir = DMA_TO_DEVICE;
++	} else if (chan == nandc->tx_chan) {
++		sgl = &bam_txn->data_sgl[bam_txn->tx_sgl_start];
++		sgl_cnt = bam_txn->tx_sgl_pos - bam_txn->tx_sgl_start;
++		bam_txn->tx_sgl_start = bam_txn->tx_sgl_pos;
++		dir_eng = DMA_MEM_TO_DEV;
++		desc->dir = DMA_TO_DEVICE;
++	} else {
++		sgl = &bam_txn->data_sgl[bam_txn->rx_sgl_start];
++		sgl_cnt = bam_txn->rx_sgl_pos - bam_txn->rx_sgl_start;
++		bam_txn->rx_sgl_start = bam_txn->rx_sgl_pos;
++		dir_eng = DMA_DEV_TO_MEM;
++		desc->dir = DMA_FROM_DEVICE;
++	}
++
++	sg_mark_end(sgl + sgl_cnt - 1);
++	ret = dma_map_sg(nandc->dev, sgl, sgl_cnt, desc->dir);
++	if (ret == 0) {
++		dev_err(nandc->dev, "failure in mapping desc\n");
++		kfree(desc);
++		return -ENOMEM;
++	}
++
++	desc->sgl_cnt = sgl_cnt;
++	desc->bam_sgl = sgl;
++
++	dma_desc = dmaengine_prep_slave_sg(chan, sgl, sgl_cnt, dir_eng,
++					   flags);
++
++	if (!dma_desc) {
++		dev_err(nandc->dev, "failure in prep desc\n");
++		dma_unmap_sg(nandc->dev, sgl, sgl_cnt, desc->dir);
++		kfree(desc);
++		return -EINVAL;
++	}
++
++	desc->dma_desc = dma_desc;
++
++	/* update last data/command descriptor */
++	if (chan == nandc->cmd_chan)
++		bam_txn->last_cmd_desc = dma_desc;
++	else
++		bam_txn->last_data_desc = dma_desc;
++
++	list_add_tail(&desc->node, &nandc->desc_list);
++
++	return 0;
++}
++EXPORT_SYMBOL(qcom_prepare_bam_async_desc);
++
++/**
++ * qcom_prep_bam_dma_desc_cmd() - Prepares the command descriptor for BAM DMA
++ * @nandc: qpic nand controller
++ * @read: read or write type
++ * @reg_off: offset within the controller's data buffer
++ * @vaddr: virtual address of the buffer we want to write to
++ * @size: DMA transaction size in bytes
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares the command descriptor for BAM DMA
++ * which will be used for NAND register reads and writes.
++ */
++int qcom_prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
++			       int reg_off, const void *vaddr,
++			       int size, unsigned int flags)
++{
++	int bam_ce_size;
++	int i, ret;
++	struct bam_cmd_element *bam_ce_buffer;
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++
++	bam_ce_buffer = &bam_txn->bam_ce[bam_txn->bam_ce_pos];
++
++	/* fill the command desc */
++	for (i = 0; i < size; i++) {
++		if (read)
++			bam_prep_ce(&bam_ce_buffer[i],
++				    nandc_reg_phys(nandc, reg_off + 4 * i),
++				    BAM_READ_COMMAND,
++				    reg_buf_dma_addr(nandc,
++						     (__le32 *)vaddr + i));
++		else
++			bam_prep_ce_le32(&bam_ce_buffer[i],
++					 nandc_reg_phys(nandc, reg_off + 4 * i),
++					 BAM_WRITE_COMMAND,
++					 *((__le32 *)vaddr + i));
++	}
++
++	bam_txn->bam_ce_pos += size;
++
++	/* use the separate sgl after this command */
++	if (flags & NAND_BAM_NEXT_SGL) {
++		bam_ce_buffer = &bam_txn->bam_ce[bam_txn->bam_ce_start];
++		bam_ce_size = (bam_txn->bam_ce_pos -
++				bam_txn->bam_ce_start) *
++				sizeof(struct bam_cmd_element);
++		sg_set_buf(&bam_txn->cmd_sgl[bam_txn->cmd_sgl_pos],
++			   bam_ce_buffer, bam_ce_size);
++		bam_txn->cmd_sgl_pos++;
++		bam_txn->bam_ce_start = bam_txn->bam_ce_pos;
++
++		if (flags & NAND_BAM_NWD) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
++							  DMA_PREP_FENCE | DMA_PREP_CMD);
++			if (ret)
++				return ret;
++		}
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(qcom_prep_bam_dma_desc_cmd);
++
++/**
++ * qcom_prep_bam_dma_desc_data() - Prepares the data descriptor for BAM DMA
++ * @nandc: qpic nand controller
++ * @read: read or write type
++ * @vaddr: virtual address of the buffer we want to write to
++ * @size: DMA transaction size in bytes
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares the data descriptor for BAM DMA which
++ * will be used for NAND data reads and writes.
++ */
++int qcom_prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
++				const void *vaddr, int size, unsigned int flags)
++{
++	int ret;
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++
++	if (read) {
++		sg_set_buf(&bam_txn->data_sgl[bam_txn->rx_sgl_pos],
++			   vaddr, size);
++		bam_txn->rx_sgl_pos++;
++	} else {
++		sg_set_buf(&bam_txn->data_sgl[bam_txn->tx_sgl_pos],
++			   vaddr, size);
++		bam_txn->tx_sgl_pos++;
++
++		/*
++		 * BAM will only set EOT for DMA_PREP_INTERRUPT so if this flag
++		 * is not set, form the DMA descriptor
++		 */
++		if (!(flags & NAND_BAM_NO_EOT)) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
++							  DMA_PREP_INTERRUPT);
++			if (ret)
++				return ret;
++		}
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(qcom_prep_bam_dma_desc_data);
++
++/**
++ * qcom_prep_adm_dma_desc() - Prepare descriptor for adma
++ * @nandc: qpic nand controller
++ * @read: read or write type
++ * @reg_off: offset within the controller's data buffer
++ * @vaddr: virtual address of the buffer we want to write to
++ * @size: adm dma transaction size in bytes
++ * @flow_control: flow controller
++ *
++ * This function will prepare descriptor for adma
++ */
++int qcom_prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read,
++			   int reg_off, const void *vaddr, int size,
++			   bool flow_control)
++{
++	struct qcom_adm_peripheral_config periph_conf = {};
++	struct dma_async_tx_descriptor *dma_desc;
++	struct dma_slave_config slave_conf = {0};
++	enum dma_transfer_direction dir_eng;
++	struct desc_info *desc;
++	struct scatterlist *sgl;
++	int ret;
++
++	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
++	if (!desc)
++		return -ENOMEM;
++
++	sgl = &desc->adm_sgl;
++
++	sg_init_one(sgl, vaddr, size);
++
++	if (read) {
++		dir_eng = DMA_DEV_TO_MEM;
++		desc->dir = DMA_FROM_DEVICE;
++	} else {
++		dir_eng = DMA_MEM_TO_DEV;
++		desc->dir = DMA_TO_DEVICE;
++	}
++
++	ret = dma_map_sg(nandc->dev, sgl, 1, desc->dir);
++	if (!ret) {
++		ret = -ENOMEM;
++		goto err;
++	}
++
++	slave_conf.device_fc = flow_control;
++	if (read) {
++		slave_conf.src_maxburst = 16;
++		slave_conf.src_addr = nandc->base_dma + reg_off;
++		if (nandc->data_crci) {
++			periph_conf.crci = nandc->data_crci;
++			slave_conf.peripheral_config = &periph_conf;
++			slave_conf.peripheral_size = sizeof(periph_conf);
++		}
++	} else {
++		slave_conf.dst_maxburst = 16;
++		slave_conf.dst_addr = nandc->base_dma + reg_off;
++		if (nandc->cmd_crci) {
++			periph_conf.crci = nandc->cmd_crci;
++			slave_conf.peripheral_config = &periph_conf;
++			slave_conf.peripheral_size = sizeof(periph_conf);
++		}
++	}
++
++	ret = dmaengine_slave_config(nandc->chan, &slave_conf);
++	if (ret) {
++		dev_err(nandc->dev, "failed to configure dma channel\n");
++		goto err;
++	}
++
++	dma_desc = dmaengine_prep_slave_sg(nandc->chan, sgl, 1, dir_eng, 0);
++	if (!dma_desc) {
++		dev_err(nandc->dev, "failed to prepare desc\n");
++		ret = -EINVAL;
++		goto err;
++	}
++
++	desc->dma_desc = dma_desc;
++
++	list_add_tail(&desc->node, &nandc->desc_list);
++
++	return 0;
++err:
++	kfree(desc);
++
++	return ret;
++}
++EXPORT_SYMBOL(qcom_prep_adm_dma_desc);
++
++/**
++ * qcom_read_reg_dma() - read a given number of registers to the reg_read_buf pointer
++ * @nandc: qpic nand controller
++ * @first: offset of the first register in the contiguous block
++ * @num_regs: number of registers to read
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares a descriptor to read a given number of
++ * contiguous registers to the reg_read_buf pointer.
++ */
++int qcom_read_reg_dma(struct qcom_nand_controller *nandc, int first,
++		      int num_regs, unsigned int flags)
++{
++	bool flow_control = false;
++	void *vaddr;
++
++	vaddr = nandc->reg_read_buf + nandc->reg_read_pos;
++	nandc->reg_read_pos += num_regs;
++
++	if (first == NAND_DEV_CMD_VLD || first == NAND_DEV_CMD1)
++		first = dev_cmd_reg_addr(nandc, first);
++
++	if (nandc->props->supports_bam)
++		return qcom_prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
++					     num_regs, flags);
++
++	if (first == NAND_READ_ID || first == NAND_FLASH_STATUS)
++		flow_control = true;
++
++	return qcom_prep_adm_dma_desc(nandc, true, first, vaddr,
++				      num_regs * sizeof(u32), flow_control);
++}
++EXPORT_SYMBOL(qcom_read_reg_dma);
++
++/**
++ * qcom_write_reg_dma() - write a given number of registers
++ * @nandc: qpic nand controller
++ * @vaddr: contiguous memory from where register value will
++ *	   be written
++ * @first: offset of the first register in the contiguous block
++ * @num_regs: number of registers to write
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares a descriptor to write a given number of
++ * contiguous registers
++ */
++int qcom_write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
++		       int first, int num_regs, unsigned int flags)
++{
++	bool flow_control = false;
++
++	if (first == NAND_EXEC_CMD)
++		flags |= NAND_BAM_NWD;
++
++	if (first == NAND_DEV_CMD1_RESTORE || first == NAND_DEV_CMD1)
++		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD1);
++
++	if (first == NAND_DEV_CMD_VLD_RESTORE || first == NAND_DEV_CMD_VLD)
++		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD);
++
++	if (nandc->props->supports_bam)
++		return qcom_prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
++						  num_regs, flags);
++
++	if (first == NAND_FLASH_CMD)
++		flow_control = true;
++
++	return qcom_prep_adm_dma_desc(nandc, false, first, vaddr,
++				      num_regs * sizeof(u32), flow_control);
++}
++EXPORT_SYMBOL(qcom_write_reg_dma);
++
++/**
++ * qcom_read_data_dma() - transfer data
++ * @nandc: qpic nand controller
++ * @reg_off: offset within the controller's data buffer
++ * @vaddr: virtual address of the buffer we want to write to
++ * @size: DMA transaction size in bytes
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares a DMA descriptor to transfer data from the
++ * controller's internal buffer to the buffer 'vaddr'
++ */
++int qcom_read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
++		       const u8 *vaddr, int size, unsigned int flags)
++{
++	if (nandc->props->supports_bam)
++		return qcom_prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
++
++	return qcom_prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
++}
++EXPORT_SYMBOL(qcom_read_data_dma);
++
++/**
++ * qcom_write_data_dma() - transfer data
++ * @nandc: qpic nand controller
++ * @reg_off: offset within the controller's data buffer
++ * @vaddr: virtual address of the buffer we want to read from
++ * @size: DMA transaction size in bytes
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares a DMA descriptor to transfer data from
++ * 'vaddr' to the controller's internal buffer
++ */
++int qcom_write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
++			const u8 *vaddr, int size, unsigned int flags)
++{
++	if (nandc->props->supports_bam)
++		return qcom_prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
++
++	return qcom_prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
++}
++EXPORT_SYMBOL(qcom_write_data_dma);
++
++/**
++ * qcom_submit_descs() - submit dma descriptor
++ * @nandc: qpic nand controller
++ *
++ * This function will submit all the prepared dma descriptor
++ * cmd or data descriptor
++ */
++int qcom_submit_descs(struct qcom_nand_controller *nandc)
++{
++	struct desc_info *desc, *n;
++	dma_cookie_t cookie = 0;
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++	int ret = 0;
++
++	if (nandc->props->supports_bam) {
++		if (bam_txn->rx_sgl_pos > bam_txn->rx_sgl_start) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
++			if (ret)
++				goto err_unmap_free_desc;
++		}
++
++		if (bam_txn->tx_sgl_pos > bam_txn->tx_sgl_start) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
++							  DMA_PREP_INTERRUPT);
++			if (ret)
++				goto err_unmap_free_desc;
++		}
++
++		if (bam_txn->cmd_sgl_pos > bam_txn->cmd_sgl_start) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
++							  DMA_PREP_CMD);
++			if (ret)
++				goto err_unmap_free_desc;
++		}
++	}
++
++	list_for_each_entry(desc, &nandc->desc_list, node)
++		cookie = dmaengine_submit(desc->dma_desc);
++
++	if (nandc->props->supports_bam) {
++		bam_txn->last_cmd_desc->callback = qcom_qpic_bam_dma_done;
++		bam_txn->last_cmd_desc->callback_param = bam_txn;
++
++		dma_async_issue_pending(nandc->tx_chan);
++		dma_async_issue_pending(nandc->rx_chan);
++		dma_async_issue_pending(nandc->cmd_chan);
++
++		if (!wait_for_completion_timeout(&bam_txn->txn_done,
++						 QPIC_NAND_COMPLETION_TIMEOUT))
++			ret = -ETIMEDOUT;
++	} else {
++		if (dma_sync_wait(nandc->chan, cookie) != DMA_COMPLETE)
++			ret = -ETIMEDOUT;
++	}
++
++err_unmap_free_desc:
++	/*
++	 * Unmap the dma sg_list and free the desc allocated by both
++	 * qcom_prepare_bam_async_desc() and qcom_prep_adm_dma_desc() functions.
++	 */
++	list_for_each_entry_safe(desc, n, &nandc->desc_list, node) {
++		list_del(&desc->node);
++
++		if (nandc->props->supports_bam)
++			dma_unmap_sg(nandc->dev, desc->bam_sgl,
++				     desc->sgl_cnt, desc->dir);
++		else
++			dma_unmap_sg(nandc->dev, &desc->adm_sgl, 1,
++				     desc->dir);
++
++		kfree(desc);
++	}
++
++	return ret;
++}
++EXPORT_SYMBOL(qcom_submit_descs);
++
++/**
++ * qcom_clear_read_regs() - reset the read register buffer
++ * @nandc: qpic nand controller
++ *
++ * This function reset the register read buffer for next NAND operation
++ */
++void qcom_clear_read_regs(struct qcom_nand_controller *nandc)
++{
++	nandc->reg_read_pos = 0;
++	qcom_nandc_dev_to_mem(nandc, false);
++}
++EXPORT_SYMBOL(qcom_clear_read_regs);
++
++/**
++ * qcom_nandc_unalloc() - unallocate qpic nand controller
++ * @nandc: qpic nand controller
++ *
++ * This function will unallocate memory alloacted for qpic nand controller
++ */
++void qcom_nandc_unalloc(struct qcom_nand_controller *nandc)
++{
++	if (nandc->props->supports_bam) {
++		if (!dma_mapping_error(nandc->dev, nandc->reg_read_dma))
++			dma_unmap_single(nandc->dev, nandc->reg_read_dma,
++					 MAX_REG_RD *
++					 sizeof(*nandc->reg_read_buf),
++					 DMA_FROM_DEVICE);
++
++		if (nandc->tx_chan)
++			dma_release_channel(nandc->tx_chan);
++
++		if (nandc->rx_chan)
++			dma_release_channel(nandc->rx_chan);
++
++		if (nandc->cmd_chan)
++			dma_release_channel(nandc->cmd_chan);
++	} else {
++		if (nandc->chan)
++			dma_release_channel(nandc->chan);
++	}
++}
++EXPORT_SYMBOL(qcom_nandc_unalloc);
++
++/**
++ * qcom_nandc_alloc() - Allocate qpic nand controller
++ * @nandc: qpic nand controller
++ *
++ * This function will allocate memory for qpic nand controller
++ */
++int qcom_nandc_alloc(struct qcom_nand_controller *nandc)
++{
++	int ret;
++
++	ret = dma_set_coherent_mask(nandc->dev, DMA_BIT_MASK(32));
++	if (ret) {
++		dev_err(nandc->dev, "failed to set DMA mask\n");
++		return ret;
++	}
++
++	/*
++	 * we use the internal buffer for reading ONFI params, reading small
++	 * data like ID and status, and preforming read-copy-write operations
++	 * when writing to a codeword partially. 532 is the maximum possible
++	 * size of a codeword for our nand controller
++	 */
++	nandc->buf_size = 532;
++
++	nandc->data_buffer = devm_kzalloc(nandc->dev, nandc->buf_size, GFP_KERNEL);
++	if (!nandc->data_buffer)
++		return -ENOMEM;
++
++	nandc->regs = devm_kzalloc(nandc->dev, sizeof(*nandc->regs), GFP_KERNEL);
++	if (!nandc->regs)
++		return -ENOMEM;
++
++	nandc->reg_read_buf = devm_kcalloc(nandc->dev, MAX_REG_RD,
++					   sizeof(*nandc->reg_read_buf),
++					   GFP_KERNEL);
++	if (!nandc->reg_read_buf)
++		return -ENOMEM;
++
++	if (nandc->props->supports_bam) {
++		nandc->reg_read_dma =
++			dma_map_single(nandc->dev, nandc->reg_read_buf,
++				       MAX_REG_RD *
++				       sizeof(*nandc->reg_read_buf),
++				       DMA_FROM_DEVICE);
++		if (dma_mapping_error(nandc->dev, nandc->reg_read_dma)) {
++			dev_err(nandc->dev, "failed to DMA MAP reg buffer\n");
++			return -EIO;
++		}
++
++		nandc->tx_chan = dma_request_chan(nandc->dev, "tx");
++		if (IS_ERR(nandc->tx_chan)) {
++			ret = PTR_ERR(nandc->tx_chan);
++			nandc->tx_chan = NULL;
++			dev_err_probe(nandc->dev, ret,
++				      "tx DMA channel request failed\n");
++			goto unalloc;
++		}
++
++		nandc->rx_chan = dma_request_chan(nandc->dev, "rx");
++		if (IS_ERR(nandc->rx_chan)) {
++			ret = PTR_ERR(nandc->rx_chan);
++			nandc->rx_chan = NULL;
++			dev_err_probe(nandc->dev, ret,
++				      "rx DMA channel request failed\n");
++			goto unalloc;
++		}
++
++		nandc->cmd_chan = dma_request_chan(nandc->dev, "cmd");
++		if (IS_ERR(nandc->cmd_chan)) {
++			ret = PTR_ERR(nandc->cmd_chan);
++			nandc->cmd_chan = NULL;
++			dev_err_probe(nandc->dev, ret,
++				      "cmd DMA channel request failed\n");
++			goto unalloc;
++		}
++
++		/*
++		 * Initially allocate BAM transaction to read ONFI param page.
++		 * After detecting all the devices, this BAM transaction will
++		 * be freed and the next BAM transaction will be allocated with
++		 * maximum codeword size
++		 */
++		nandc->max_cwperpage = 1;
++		nandc->bam_txn = qcom_alloc_bam_transaction(nandc);
++		if (!nandc->bam_txn) {
++			dev_err(nandc->dev,
++				"failed to allocate bam transaction\n");
++			ret = -ENOMEM;
++			goto unalloc;
++		}
++	} else {
++		nandc->chan = dma_request_chan(nandc->dev, "rxtx");
++		if (IS_ERR(nandc->chan)) {
++			ret = PTR_ERR(nandc->chan);
++			nandc->chan = NULL;
++			dev_err_probe(nandc->dev, ret,
++				      "rxtx DMA channel request failed\n");
++			return ret;
++		}
++	}
++
++	INIT_LIST_HEAD(&nandc->desc_list);
++	INIT_LIST_HEAD(&nandc->host_list);
++
++	return 0;
++unalloc:
++	qcom_nandc_unalloc(nandc);
++	return ret;
++}
++EXPORT_SYMBOL(qcom_nandc_alloc);
++
++MODULE_DESCRIPTION("QPIC controller common api");
++MODULE_LICENSE("GPL");
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -15,417 +15,7 @@
+ #include <linux/of.h>
+ #include <linux/platform_device.h>
+ #include <linux/slab.h>
+-
+-/* NANDc reg offsets */
+-#define	NAND_FLASH_CMD			0x00
+-#define	NAND_ADDR0			0x04
+-#define	NAND_ADDR1			0x08
+-#define	NAND_FLASH_CHIP_SELECT		0x0c
+-#define	NAND_EXEC_CMD			0x10
+-#define	NAND_FLASH_STATUS		0x14
+-#define	NAND_BUFFER_STATUS		0x18
+-#define	NAND_DEV0_CFG0			0x20
+-#define	NAND_DEV0_CFG1			0x24
+-#define	NAND_DEV0_ECC_CFG		0x28
+-#define	NAND_AUTO_STATUS_EN		0x2c
+-#define	NAND_DEV1_CFG0			0x30
+-#define	NAND_DEV1_CFG1			0x34
+-#define	NAND_READ_ID			0x40
+-#define	NAND_READ_STATUS		0x44
+-#define	NAND_DEV_CMD0			0xa0
+-#define	NAND_DEV_CMD1			0xa4
+-#define	NAND_DEV_CMD2			0xa8
+-#define	NAND_DEV_CMD_VLD		0xac
+-#define	SFLASHC_BURST_CFG		0xe0
+-#define	NAND_ERASED_CW_DETECT_CFG	0xe8
+-#define	NAND_ERASED_CW_DETECT_STATUS	0xec
+-#define	NAND_EBI2_ECC_BUF_CFG		0xf0
+-#define	FLASH_BUF_ACC			0x100
+-
+-#define	NAND_CTRL			0xf00
+-#define	NAND_VERSION			0xf08
+-#define	NAND_READ_LOCATION_0		0xf20
+-#define	NAND_READ_LOCATION_1		0xf24
+-#define	NAND_READ_LOCATION_2		0xf28
+-#define	NAND_READ_LOCATION_3		0xf2c
+-#define	NAND_READ_LOCATION_LAST_CW_0	0xf40
+-#define	NAND_READ_LOCATION_LAST_CW_1	0xf44
+-#define	NAND_READ_LOCATION_LAST_CW_2	0xf48
+-#define	NAND_READ_LOCATION_LAST_CW_3	0xf4c
+-
+-/* dummy register offsets, used by qcom_write_reg_dma */
+-#define	NAND_DEV_CMD1_RESTORE		0xdead
+-#define	NAND_DEV_CMD_VLD_RESTORE	0xbeef
+-
+-/* NAND_FLASH_CMD bits */
+-#define	PAGE_ACC			BIT(4)
+-#define	LAST_PAGE			BIT(5)
+-
+-/* NAND_FLASH_CHIP_SELECT bits */
+-#define	NAND_DEV_SEL			0
+-#define	DM_EN				BIT(2)
+-
+-/* NAND_FLASH_STATUS bits */
+-#define	FS_OP_ERR			BIT(4)
+-#define	FS_READY_BSY_N			BIT(5)
+-#define	FS_MPU_ERR			BIT(8)
+-#define	FS_DEVICE_STS_ERR		BIT(16)
+-#define	FS_DEVICE_WP			BIT(23)
+-
+-/* NAND_BUFFER_STATUS bits */
+-#define	BS_UNCORRECTABLE_BIT		BIT(8)
+-#define	BS_CORRECTABLE_ERR_MSK		0x1f
+-
+-/* NAND_DEVn_CFG0 bits */
+-#define	DISABLE_STATUS_AFTER_WRITE	4
+-#define	CW_PER_PAGE			6
+-#define	UD_SIZE_BYTES			9
+-#define	UD_SIZE_BYTES_MASK		GENMASK(18, 9)
+-#define	ECC_PARITY_SIZE_BYTES_RS	19
+-#define	SPARE_SIZE_BYTES		23
+-#define	SPARE_SIZE_BYTES_MASK		GENMASK(26, 23)
+-#define	NUM_ADDR_CYCLES			27
+-#define	STATUS_BFR_READ			30
+-#define	SET_RD_MODE_AFTER_STATUS	31
+-
+-/* NAND_DEVn_CFG0 bits */
+-#define	DEV0_CFG1_ECC_DISABLE		0
+-#define	WIDE_FLASH			1
+-#define	NAND_RECOVERY_CYCLES		2
+-#define	CS_ACTIVE_BSY			5
+-#define	BAD_BLOCK_BYTE_NUM		6
+-#define	BAD_BLOCK_IN_SPARE_AREA		16
+-#define	WR_RD_BSY_GAP			17
+-#define	ENABLE_BCH_ECC			27
+-
+-/* NAND_DEV0_ECC_CFG bits */
+-#define	ECC_CFG_ECC_DISABLE		0
+-#define	ECC_SW_RESET			1
+-#define	ECC_MODE			4
+-#define	ECC_PARITY_SIZE_BYTES_BCH	8
+-#define	ECC_NUM_DATA_BYTES		16
+-#define	ECC_NUM_DATA_BYTES_MASK		GENMASK(25, 16)
+-#define	ECC_FORCE_CLK_OPEN		30
+-
+-/* NAND_DEV_CMD1 bits */
+-#define	READ_ADDR			0
+-
+-/* NAND_DEV_CMD_VLD bits */
+-#define	READ_START_VLD			BIT(0)
+-#define	READ_STOP_VLD			BIT(1)
+-#define	WRITE_START_VLD			BIT(2)
+-#define	ERASE_START_VLD			BIT(3)
+-#define	SEQ_READ_START_VLD		BIT(4)
+-
+-/* NAND_EBI2_ECC_BUF_CFG bits */
+-#define	NUM_STEPS			0
+-
+-/* NAND_ERASED_CW_DETECT_CFG bits */
+-#define	ERASED_CW_ECC_MASK		1
+-#define	AUTO_DETECT_RES			0
+-#define	MASK_ECC			BIT(ERASED_CW_ECC_MASK)
+-#define	RESET_ERASED_DET		BIT(AUTO_DETECT_RES)
+-#define	ACTIVE_ERASED_DET		(0 << AUTO_DETECT_RES)
+-#define	CLR_ERASED_PAGE_DET		(RESET_ERASED_DET | MASK_ECC)
+-#define	SET_ERASED_PAGE_DET		(ACTIVE_ERASED_DET | MASK_ECC)
+-
+-/* NAND_ERASED_CW_DETECT_STATUS bits */
+-#define	PAGE_ALL_ERASED			BIT(7)
+-#define	CODEWORD_ALL_ERASED		BIT(6)
+-#define	PAGE_ERASED			BIT(5)
+-#define	CODEWORD_ERASED			BIT(4)
+-#define	ERASED_PAGE			(PAGE_ALL_ERASED | PAGE_ERASED)
+-#define	ERASED_CW			(CODEWORD_ALL_ERASED | CODEWORD_ERASED)
+-
+-/* NAND_READ_LOCATION_n bits */
+-#define READ_LOCATION_OFFSET		0
+-#define READ_LOCATION_SIZE		16
+-#define READ_LOCATION_LAST		31
+-
+-/* Version Mask */
+-#define	NAND_VERSION_MAJOR_MASK		0xf0000000
+-#define	NAND_VERSION_MAJOR_SHIFT	28
+-#define	NAND_VERSION_MINOR_MASK		0x0fff0000
+-#define	NAND_VERSION_MINOR_SHIFT	16
+-
+-/* NAND OP_CMDs */
+-#define	OP_PAGE_READ			0x2
+-#define	OP_PAGE_READ_WITH_ECC		0x3
+-#define	OP_PAGE_READ_WITH_ECC_SPARE	0x4
+-#define	OP_PAGE_READ_ONFI_READ		0x5
+-#define	OP_PROGRAM_PAGE			0x6
+-#define	OP_PAGE_PROGRAM_WITH_ECC	0x7
+-#define	OP_PROGRAM_PAGE_SPARE		0x9
+-#define	OP_BLOCK_ERASE			0xa
+-#define	OP_CHECK_STATUS			0xc
+-#define	OP_FETCH_ID			0xb
+-#define	OP_RESET_DEVICE			0xd
+-
+-/* Default Value for NAND_DEV_CMD_VLD */
+-#define NAND_DEV_CMD_VLD_VAL		(READ_START_VLD | WRITE_START_VLD | \
+-					 ERASE_START_VLD | SEQ_READ_START_VLD)
+-
+-/* NAND_CTRL bits */
+-#define	BAM_MODE_EN			BIT(0)
+-
+-/*
+- * the NAND controller performs reads/writes with ECC in 516 byte chunks.
+- * the driver calls the chunks 'step' or 'codeword' interchangeably
+- */
+-#define	NANDC_STEP_SIZE			512
+-
+-/*
+- * the largest page size we support is 8K, this will have 16 steps/codewords
+- * of 512 bytes each
+- */
+-#define	MAX_NUM_STEPS			(SZ_8K / NANDC_STEP_SIZE)
+-
+-/* we read at most 3 registers per codeword scan */
+-#define	MAX_REG_RD			(3 * MAX_NUM_STEPS)
+-
+-/* ECC modes supported by the controller */
+-#define	ECC_NONE	BIT(0)
+-#define	ECC_RS_4BIT	BIT(1)
+-#define	ECC_BCH_4BIT	BIT(2)
+-#define	ECC_BCH_8BIT	BIT(3)
+-
+-/*
+- * Returns the actual register address for all NAND_DEV_ registers
+- * (i.e. NAND_DEV_CMD0, NAND_DEV_CMD1, NAND_DEV_CMD2 and NAND_DEV_CMD_VLD)
+- */
+-#define dev_cmd_reg_addr(nandc, reg) ((nandc)->props->dev_cmd_reg_start + (reg))
+-
+-/* Returns the NAND register physical address */
+-#define nandc_reg_phys(chip, offset) ((chip)->base_phys + (offset))
+-
+-/* Returns the dma address for reg read buffer */
+-#define reg_buf_dma_addr(chip, vaddr) \
+-	((chip)->reg_read_dma + \
+-	((u8 *)(vaddr) - (u8 *)(chip)->reg_read_buf))
+-
+-#define QPIC_PER_CW_CMD_ELEMENTS	32
+-#define QPIC_PER_CW_CMD_SGL		32
+-#define QPIC_PER_CW_DATA_SGL		8
+-
+-#define QPIC_NAND_COMPLETION_TIMEOUT	msecs_to_jiffies(2000)
+-
+-/*
+- * Flags used in DMA descriptor preparation helper functions
+- * (i.e. qcom_read_reg_dma/qcom_write_reg_dma/qcom_read_data_dma/qcom_write_data_dma)
+- */
+-/* Don't set the EOT in current tx BAM sgl */
+-#define NAND_BAM_NO_EOT			BIT(0)
+-/* Set the NWD flag in current BAM sgl */
+-#define NAND_BAM_NWD			BIT(1)
+-/* Finish writing in the current BAM sgl and start writing in another BAM sgl */
+-#define NAND_BAM_NEXT_SGL		BIT(2)
+-/*
+- * Erased codeword status is being used two times in single transfer so this
+- * flag will determine the current value of erased codeword status register
+- */
+-#define NAND_ERASED_CW_SET		BIT(4)
+-
+-#define MAX_ADDRESS_CYCLE		5
+-
+-/*
+- * This data type corresponds to the BAM transaction which will be used for all
+- * NAND transfers.
+- * @bam_ce - the array of BAM command elements
+- * @cmd_sgl - sgl for NAND BAM command pipe
+- * @data_sgl - sgl for NAND BAM consumer/producer pipe
+- * @last_data_desc - last DMA desc in data channel (tx/rx).
+- * @last_cmd_desc - last DMA desc in command channel.
+- * @txn_done - completion for NAND transfer.
+- * @bam_ce_pos - the index in bam_ce which is available for next sgl
+- * @bam_ce_start - the index in bam_ce which marks the start position ce
+- *		   for current sgl. It will be used for size calculation
+- *		   for current sgl
+- * @cmd_sgl_pos - current index in command sgl.
+- * @cmd_sgl_start - start index in command sgl.
+- * @tx_sgl_pos - current index in data sgl for tx.
+- * @tx_sgl_start - start index in data sgl for tx.
+- * @rx_sgl_pos - current index in data sgl for rx.
+- * @rx_sgl_start - start index in data sgl for rx.
+- */
+-struct bam_transaction {
+-	struct bam_cmd_element *bam_ce;
+-	struct scatterlist *cmd_sgl;
+-	struct scatterlist *data_sgl;
+-	struct dma_async_tx_descriptor *last_data_desc;
+-	struct dma_async_tx_descriptor *last_cmd_desc;
+-	struct completion txn_done;
+-	u32 bam_ce_pos;
+-	u32 bam_ce_start;
+-	u32 cmd_sgl_pos;
+-	u32 cmd_sgl_start;
+-	u32 tx_sgl_pos;
+-	u32 tx_sgl_start;
+-	u32 rx_sgl_pos;
+-	u32 rx_sgl_start;
+-};
+-
+-/*
+- * This data type corresponds to the nand dma descriptor
+- * @dma_desc - low level DMA engine descriptor
+- * @list - list for desc_info
+- *
+- * @adm_sgl - sgl which will be used for single sgl dma descriptor. Only used by
+- *	      ADM
+- * @bam_sgl - sgl which will be used for dma descriptor. Only used by BAM
+- * @sgl_cnt - number of SGL in bam_sgl. Only used by BAM
+- * @dir - DMA transfer direction
+- */
+-struct desc_info {
+-	struct dma_async_tx_descriptor *dma_desc;
+-	struct list_head node;
+-
+-	union {
+-		struct scatterlist adm_sgl;
+-		struct {
+-			struct scatterlist *bam_sgl;
+-			int sgl_cnt;
+-		};
+-	};
+-	enum dma_data_direction dir;
+-};
+-
+-/*
+- * holds the current register values that we want to write. acts as a contiguous
+- * chunk of memory which we use to write the controller registers through DMA.
+- */
+-struct nandc_regs {
+-	__le32 cmd;
+-	__le32 addr0;
+-	__le32 addr1;
+-	__le32 chip_sel;
+-	__le32 exec;
+-
+-	__le32 cfg0;
+-	__le32 cfg1;
+-	__le32 ecc_bch_cfg;
+-
+-	__le32 clrflashstatus;
+-	__le32 clrreadstatus;
+-
+-	__le32 cmd1;
+-	__le32 vld;
+-
+-	__le32 orig_cmd1;
+-	__le32 orig_vld;
+-
+-	__le32 ecc_buf_cfg;
+-	__le32 read_location0;
+-	__le32 read_location1;
+-	__le32 read_location2;
+-	__le32 read_location3;
+-	__le32 read_location_last0;
+-	__le32 read_location_last1;
+-	__le32 read_location_last2;
+-	__le32 read_location_last3;
+-
+-	__le32 erased_cw_detect_cfg_clr;
+-	__le32 erased_cw_detect_cfg_set;
+-};
+-
+-/*
+- * NAND controller data struct
+- *
+- * @dev:			parent device
+- *
+- * @base:			MMIO base
+- *
+- * @core_clk:			controller clock
+- * @aon_clk:			another controller clock
+- *
+- * @regs:			a contiguous chunk of memory for DMA register
+- *				writes. contains the register values to be
+- *				written to controller
+- *
+- * @props:			properties of current NAND controller,
+- *				initialized via DT match data
+- *
+- * @controller:			base controller structure
+- * @host_list:			list containing all the chips attached to the
+- *				controller
+- *
+- * @chan:			dma channel
+- * @cmd_crci:			ADM DMA CRCI for command flow control
+- * @data_crci:			ADM DMA CRCI for data flow control
+- *
+- * @desc_list:			DMA descriptor list (list of desc_infos)
+- *
+- * @data_buffer:		our local DMA buffer for page read/writes,
+- *				used when we can't use the buffer provided
+- *				by upper layers directly
+- * @reg_read_buf:		local buffer for reading back registers via DMA
+- *
+- * @base_phys:			physical base address of controller registers
+- * @base_dma:			dma base address of controller registers
+- * @reg_read_dma:		contains dma address for register read buffer
+- *
+- * @buf_size/count/start:	markers for chip->legacy.read_buf/write_buf
+- *				functions
+- * @max_cwperpage:		maximum QPIC codewords required. calculated
+- *				from all connected NAND devices pagesize
+- *
+- * @reg_read_pos:		marker for data read in reg_read_buf
+- *
+- * @cmd1/vld:			some fixed controller register values
+- *
+- * @exec_opwrite:		flag to select correct number of code word
+- *				while reading status
+- */
+-struct qcom_nand_controller {
+-	struct device *dev;
+-
+-	void __iomem *base;
+-
+-	struct clk *core_clk;
+-	struct clk *aon_clk;
+-
+-	struct nandc_regs *regs;
+-	struct bam_transaction *bam_txn;
+-
+-	const struct qcom_nandc_props *props;
+-
+-	struct nand_controller controller;
+-	struct list_head host_list;
+-
+-	union {
+-		/* will be used only by QPIC for BAM DMA */
+-		struct {
+-			struct dma_chan *tx_chan;
+-			struct dma_chan *rx_chan;
+-			struct dma_chan *cmd_chan;
+-		};
+-
+-		/* will be used only by EBI2 for ADM DMA */
+-		struct {
+-			struct dma_chan *chan;
+-			unsigned int cmd_crci;
+-			unsigned int data_crci;
+-		};
+-	};
+-
+-	struct list_head desc_list;
+-
+-	u8		*data_buffer;
+-	__le32		*reg_read_buf;
+-
+-	phys_addr_t base_phys;
+-	dma_addr_t base_dma;
+-	dma_addr_t reg_read_dma;
+-
+-	int		buf_size;
+-	int		buf_count;
+-	int		buf_start;
+-	unsigned int	max_cwperpage;
+-
+-	int reg_read_pos;
+-
+-	u32 cmd1, vld;
+-	bool exec_opwrite;
+-};
++#include <linux/mtd/nand-qpic-common.h>
+ 
+ /*
+  * NAND special boot partitions
+@@ -530,97 +120,6 @@ struct qcom_nand_host {
+ 	bool bch_enabled;
+ };
+ 
+-/*
+- * This data type corresponds to the NAND controller properties which varies
+- * among different NAND controllers.
+- * @ecc_modes - ecc mode for NAND
+- * @dev_cmd_reg_start - NAND_DEV_CMD_* registers starting offset
+- * @supports_bam - whether NAND controller is using Bus Access Manager (BAM)
+- * @nandc_part_of_qpic - whether NAND controller is part of qpic IP
+- * @qpic_version2 - flag to indicate QPIC IP version 2
+- * @use_codeword_fixup - whether NAND has different layout for boot partitions
+- */
+-struct qcom_nandc_props {
+-	u32 ecc_modes;
+-	u32 dev_cmd_reg_start;
+-	bool supports_bam;
+-	bool nandc_part_of_qpic;
+-	bool qpic_version2;
+-	bool use_codeword_fixup;
+-};
+-
+-/* Frees the BAM transaction memory */
+-static void qcom_free_bam_transaction(struct qcom_nand_controller *nandc)
+-{
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-
+-	devm_kfree(nandc->dev, bam_txn);
+-}
+-
+-/* Allocates and Initializes the BAM transaction */
+-static struct bam_transaction *
+-qcom_alloc_bam_transaction(struct qcom_nand_controller *nandc)
+-{
+-	struct bam_transaction *bam_txn;
+-	size_t bam_txn_size;
+-	unsigned int num_cw = nandc->max_cwperpage;
+-	void *bam_txn_buf;
+-
+-	bam_txn_size =
+-		sizeof(*bam_txn) + num_cw *
+-		((sizeof(*bam_txn->bam_ce) * QPIC_PER_CW_CMD_ELEMENTS) +
+-		(sizeof(*bam_txn->cmd_sgl) * QPIC_PER_CW_CMD_SGL) +
+-		(sizeof(*bam_txn->data_sgl) * QPIC_PER_CW_DATA_SGL));
+-
+-	bam_txn_buf = devm_kzalloc(nandc->dev, bam_txn_size, GFP_KERNEL);
+-	if (!bam_txn_buf)
+-		return NULL;
+-
+-	bam_txn = bam_txn_buf;
+-	bam_txn_buf += sizeof(*bam_txn);
+-
+-	bam_txn->bam_ce = bam_txn_buf;
+-	bam_txn_buf +=
+-		sizeof(*bam_txn->bam_ce) * QPIC_PER_CW_CMD_ELEMENTS * num_cw;
+-
+-	bam_txn->cmd_sgl = bam_txn_buf;
+-	bam_txn_buf +=
+-		sizeof(*bam_txn->cmd_sgl) * QPIC_PER_CW_CMD_SGL * num_cw;
+-
+-	bam_txn->data_sgl = bam_txn_buf;
+-
+-	init_completion(&bam_txn->txn_done);
+-
+-	return bam_txn;
+-}
+-
+-/* Clears the BAM transaction indexes */
+-static void qcom_clear_bam_transaction(struct qcom_nand_controller *nandc)
+-{
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-
+-	if (!nandc->props->supports_bam)
+-		return;
+-
+-	memset(&bam_txn->bam_ce_pos, 0, sizeof(u32) * 8);
+-	bam_txn->last_data_desc = NULL;
+-
+-	sg_init_table(bam_txn->cmd_sgl, nandc->max_cwperpage *
+-		      QPIC_PER_CW_CMD_SGL);
+-	sg_init_table(bam_txn->data_sgl, nandc->max_cwperpage *
+-		      QPIC_PER_CW_DATA_SGL);
+-
+-	reinit_completion(&bam_txn->txn_done);
+-}
+-
+-/* Callback for DMA descriptor completion */
+-static void qcom_qpic_bam_dma_done(void *data)
+-{
+-	struct bam_transaction *bam_txn = data;
+-
+-	complete(&bam_txn->txn_done);
+-}
+-
+ static struct qcom_nand_host *to_qcom_nand_host(struct nand_chip *chip)
+ {
+ 	return container_of(chip, struct qcom_nand_host, chip);
+@@ -629,8 +128,8 @@ static struct qcom_nand_host *to_qcom_na
+ static struct qcom_nand_controller *
+ get_qcom_nand_controller(struct nand_chip *chip)
+ {
+-	return container_of(chip->controller, struct qcom_nand_controller,
+-			    controller);
++	return (struct qcom_nand_controller *)
++		((u8 *)chip->controller - sizeof(struct qcom_nand_controller));
+ }
+ 
+ static u32 nandc_read(struct qcom_nand_controller *nandc, int offset)
+@@ -644,23 +143,6 @@ static void nandc_write(struct qcom_nand
+ 	iowrite32(val, nandc->base + offset);
+ }
+ 
+-static void qcom_nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
+-{
+-	if (!nandc->props->supports_bam)
+-		return;
+-
+-	if (is_cpu)
+-		dma_sync_single_for_cpu(nandc->dev, nandc->reg_read_dma,
+-					MAX_REG_RD *
+-					sizeof(*nandc->reg_read_buf),
+-					DMA_FROM_DEVICE);
+-	else
+-		dma_sync_single_for_device(nandc->dev, nandc->reg_read_dma,
+-					   MAX_REG_RD *
+-					   sizeof(*nandc->reg_read_buf),
+-					   DMA_FROM_DEVICE);
+-}
+-
+ /* Helper to check whether this is the last CW or not */
+ static bool qcom_nandc_is_last_cw(struct nand_ecc_ctrl *ecc, int cw)
+ {
+@@ -820,356 +302,6 @@ static void update_rw_regs(struct qcom_n
+ }
+ 
+ /*
+- * Maps the scatter gather list for DMA transfer and forms the DMA descriptor
+- * for BAM. This descriptor will be added in the NAND DMA descriptor queue
+- * which will be submitted to DMA engine.
+- */
+-static int qcom_prepare_bam_async_desc(struct qcom_nand_controller *nandc,
+-				       struct dma_chan *chan,
+-				       unsigned long flags)
+-{
+-	struct desc_info *desc;
+-	struct scatterlist *sgl;
+-	unsigned int sgl_cnt;
+-	int ret;
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-	enum dma_transfer_direction dir_eng;
+-	struct dma_async_tx_descriptor *dma_desc;
+-
+-	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+-	if (!desc)
+-		return -ENOMEM;
+-
+-	if (chan == nandc->cmd_chan) {
+-		sgl = &bam_txn->cmd_sgl[bam_txn->cmd_sgl_start];
+-		sgl_cnt = bam_txn->cmd_sgl_pos - bam_txn->cmd_sgl_start;
+-		bam_txn->cmd_sgl_start = bam_txn->cmd_sgl_pos;
+-		dir_eng = DMA_MEM_TO_DEV;
+-		desc->dir = DMA_TO_DEVICE;
+-	} else if (chan == nandc->tx_chan) {
+-		sgl = &bam_txn->data_sgl[bam_txn->tx_sgl_start];
+-		sgl_cnt = bam_txn->tx_sgl_pos - bam_txn->tx_sgl_start;
+-		bam_txn->tx_sgl_start = bam_txn->tx_sgl_pos;
+-		dir_eng = DMA_MEM_TO_DEV;
+-		desc->dir = DMA_TO_DEVICE;
+-	} else {
+-		sgl = &bam_txn->data_sgl[bam_txn->rx_sgl_start];
+-		sgl_cnt = bam_txn->rx_sgl_pos - bam_txn->rx_sgl_start;
+-		bam_txn->rx_sgl_start = bam_txn->rx_sgl_pos;
+-		dir_eng = DMA_DEV_TO_MEM;
+-		desc->dir = DMA_FROM_DEVICE;
+-	}
+-
+-	sg_mark_end(sgl + sgl_cnt - 1);
+-	ret = dma_map_sg(nandc->dev, sgl, sgl_cnt, desc->dir);
+-	if (ret == 0) {
+-		dev_err(nandc->dev, "failure in mapping desc\n");
+-		kfree(desc);
+-		return -ENOMEM;
+-	}
+-
+-	desc->sgl_cnt = sgl_cnt;
+-	desc->bam_sgl = sgl;
+-
+-	dma_desc = dmaengine_prep_slave_sg(chan, sgl, sgl_cnt, dir_eng,
+-					   flags);
+-
+-	if (!dma_desc) {
+-		dev_err(nandc->dev, "failure in prep desc\n");
+-		dma_unmap_sg(nandc->dev, sgl, sgl_cnt, desc->dir);
+-		kfree(desc);
+-		return -EINVAL;
+-	}
+-
+-	desc->dma_desc = dma_desc;
+-
+-	/* update last data/command descriptor */
+-	if (chan == nandc->cmd_chan)
+-		bam_txn->last_cmd_desc = dma_desc;
+-	else
+-		bam_txn->last_data_desc = dma_desc;
+-
+-	list_add_tail(&desc->node, &nandc->desc_list);
+-
+-	return 0;
+-}
+-
+-/*
+- * Prepares the command descriptor for BAM DMA which will be used for NAND
+- * register reads and writes. The command descriptor requires the command
+- * to be formed in command element type so this function uses the command
+- * element from bam transaction ce array and fills the same with required
+- * data. A single SGL can contain multiple command elements so
+- * NAND_BAM_NEXT_SGL will be used for starting the separate SGL
+- * after the current command element.
+- */
+-static int qcom_prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
+-				      int reg_off, const void *vaddr,
+-				      int size, unsigned int flags)
+-{
+-	int bam_ce_size;
+-	int i, ret;
+-	struct bam_cmd_element *bam_ce_buffer;
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-
+-	bam_ce_buffer = &bam_txn->bam_ce[bam_txn->bam_ce_pos];
+-
+-	/* fill the command desc */
+-	for (i = 0; i < size; i++) {
+-		if (read)
+-			bam_prep_ce(&bam_ce_buffer[i],
+-				    nandc_reg_phys(nandc, reg_off + 4 * i),
+-				    BAM_READ_COMMAND,
+-				    reg_buf_dma_addr(nandc,
+-						     (__le32 *)vaddr + i));
+-		else
+-			bam_prep_ce_le32(&bam_ce_buffer[i],
+-					 nandc_reg_phys(nandc, reg_off + 4 * i),
+-					 BAM_WRITE_COMMAND,
+-					 *((__le32 *)vaddr + i));
+-	}
+-
+-	bam_txn->bam_ce_pos += size;
+-
+-	/* use the separate sgl after this command */
+-	if (flags & NAND_BAM_NEXT_SGL) {
+-		bam_ce_buffer = &bam_txn->bam_ce[bam_txn->bam_ce_start];
+-		bam_ce_size = (bam_txn->bam_ce_pos -
+-				bam_txn->bam_ce_start) *
+-				sizeof(struct bam_cmd_element);
+-		sg_set_buf(&bam_txn->cmd_sgl[bam_txn->cmd_sgl_pos],
+-			   bam_ce_buffer, bam_ce_size);
+-		bam_txn->cmd_sgl_pos++;
+-		bam_txn->bam_ce_start = bam_txn->bam_ce_pos;
+-
+-		if (flags & NAND_BAM_NWD) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
+-							  DMA_PREP_FENCE |
+-							  DMA_PREP_CMD);
+-			if (ret)
+-				return ret;
+-		}
+-	}
+-
+-	return 0;
+-}
+-
+-/*
+- * Prepares the data descriptor for BAM DMA which will be used for NAND
+- * data reads and writes.
+- */
+-static int qcom_prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
+-				       const void *vaddr, int size, unsigned int flags)
+-{
+-	int ret;
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-
+-	if (read) {
+-		sg_set_buf(&bam_txn->data_sgl[bam_txn->rx_sgl_pos],
+-			   vaddr, size);
+-		bam_txn->rx_sgl_pos++;
+-	} else {
+-		sg_set_buf(&bam_txn->data_sgl[bam_txn->tx_sgl_pos],
+-			   vaddr, size);
+-		bam_txn->tx_sgl_pos++;
+-
+-		/*
+-		 * BAM will only set EOT for DMA_PREP_INTERRUPT so if this flag
+-		 * is not set, form the DMA descriptor
+-		 */
+-		if (!(flags & NAND_BAM_NO_EOT)) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
+-							  DMA_PREP_INTERRUPT);
+-			if (ret)
+-				return ret;
+-		}
+-	}
+-
+-	return 0;
+-}
+-
+-static int qcom_prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read,
+-				  int reg_off, const void *vaddr, int size,
+-				  bool flow_control)
+-{
+-	struct desc_info *desc;
+-	struct dma_async_tx_descriptor *dma_desc;
+-	struct scatterlist *sgl;
+-	struct dma_slave_config slave_conf;
+-	struct qcom_adm_peripheral_config periph_conf = {};
+-	enum dma_transfer_direction dir_eng;
+-	int ret;
+-
+-	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+-	if (!desc)
+-		return -ENOMEM;
+-
+-	sgl = &desc->adm_sgl;
+-
+-	sg_init_one(sgl, vaddr, size);
+-
+-	if (read) {
+-		dir_eng = DMA_DEV_TO_MEM;
+-		desc->dir = DMA_FROM_DEVICE;
+-	} else {
+-		dir_eng = DMA_MEM_TO_DEV;
+-		desc->dir = DMA_TO_DEVICE;
+-	}
+-
+-	ret = dma_map_sg(nandc->dev, sgl, 1, desc->dir);
+-	if (ret == 0) {
+-		ret = -ENOMEM;
+-		goto err;
+-	}
+-
+-	memset(&slave_conf, 0x00, sizeof(slave_conf));
+-
+-	slave_conf.device_fc = flow_control;
+-	if (read) {
+-		slave_conf.src_maxburst = 16;
+-		slave_conf.src_addr = nandc->base_dma + reg_off;
+-		if (nandc->data_crci) {
+-			periph_conf.crci = nandc->data_crci;
+-			slave_conf.peripheral_config = &periph_conf;
+-			slave_conf.peripheral_size = sizeof(periph_conf);
+-		}
+-	} else {
+-		slave_conf.dst_maxburst = 16;
+-		slave_conf.dst_addr = nandc->base_dma + reg_off;
+-		if (nandc->cmd_crci) {
+-			periph_conf.crci = nandc->cmd_crci;
+-			slave_conf.peripheral_config = &periph_conf;
+-			slave_conf.peripheral_size = sizeof(periph_conf);
+-		}
+-	}
+-
+-	ret = dmaengine_slave_config(nandc->chan, &slave_conf);
+-	if (ret) {
+-		dev_err(nandc->dev, "failed to configure dma channel\n");
+-		goto err;
+-	}
+-
+-	dma_desc = dmaengine_prep_slave_sg(nandc->chan, sgl, 1, dir_eng, 0);
+-	if (!dma_desc) {
+-		dev_err(nandc->dev, "failed to prepare desc\n");
+-		ret = -EINVAL;
+-		goto err;
+-	}
+-
+-	desc->dma_desc = dma_desc;
+-
+-	list_add_tail(&desc->node, &nandc->desc_list);
+-
+-	return 0;
+-err:
+-	kfree(desc);
+-
+-	return ret;
+-}
+-
+-/*
+- * qcom_read_reg_dma:	prepares a descriptor to read a given number of
+- *			contiguous registers to the reg_read_buf pointer
+- *
+- * @first:		offset of the first register in the contiguous block
+- * @num_regs:		number of registers to read
+- * @flags:		flags to control DMA descriptor preparation
+- */
+-static int qcom_read_reg_dma(struct qcom_nand_controller *nandc, int first,
+-			     int num_regs, unsigned int flags)
+-{
+-	bool flow_control = false;
+-	void *vaddr;
+-
+-	vaddr = nandc->reg_read_buf + nandc->reg_read_pos;
+-	nandc->reg_read_pos += num_regs;
+-
+-	if (first == NAND_DEV_CMD_VLD || first == NAND_DEV_CMD1)
+-		first = dev_cmd_reg_addr(nandc, first);
+-
+-	if (nandc->props->supports_bam)
+-		return qcom_prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
+-					     num_regs, flags);
+-
+-	if (first == NAND_READ_ID || first == NAND_FLASH_STATUS)
+-		flow_control = true;
+-
+-	return qcom_prep_adm_dma_desc(nandc, true, first, vaddr,
+-				 num_regs * sizeof(u32), flow_control);
+-}
+-
+-/*
+- * qcom_write_reg_dma:	prepares a descriptor to write a given number of
+- *			contiguous registers
+- *
+- * @vaddr:		contiguous memory from where register value will
+- *			be written
+- * @first:		offset of the first register in the contiguous block
+- * @num_regs:		number of registers to write
+- * @flags:		flags to control DMA descriptor preparation
+- */
+-static int qcom_write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
+-			      int first, int num_regs, unsigned int flags)
+-{
+-	bool flow_control = false;
+-
+-	if (first == NAND_EXEC_CMD)
+-		flags |= NAND_BAM_NWD;
+-
+-	if (first == NAND_DEV_CMD1_RESTORE || first == NAND_DEV_CMD1)
+-		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD1);
+-
+-	if (first == NAND_DEV_CMD_VLD_RESTORE || first == NAND_DEV_CMD_VLD)
+-		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD);
+-
+-	if (nandc->props->supports_bam)
+-		return qcom_prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
+-					     num_regs, flags);
+-
+-	if (first == NAND_FLASH_CMD)
+-		flow_control = true;
+-
+-	return qcom_prep_adm_dma_desc(nandc, false, first, vaddr,
+-				 num_regs * sizeof(u32), flow_control);
+-}
+-
+-/*
+- * qcom_read_data_dma:	prepares a DMA descriptor to transfer data from the
+- *			controller's internal buffer to the buffer 'vaddr'
+- *
+- * @reg_off:		offset within the controller's data buffer
+- * @vaddr:		virtual address of the buffer we want to write to
+- * @size:		DMA transaction size in bytes
+- * @flags:		flags to control DMA descriptor preparation
+- */
+-static int qcom_read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+-			      const u8 *vaddr, int size, unsigned int flags)
+-{
+-	if (nandc->props->supports_bam)
+-		return qcom_prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
+-
+-	return qcom_prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
+-}
+-
+-/*
+- * qcom_write_data_dma:	prepares a DMA descriptor to transfer data from
+- *			'vaddr' to the controller's internal buffer
+- *
+- * @reg_off:		offset within the controller's data buffer
+- * @vaddr:		virtual address of the buffer we want to read from
+- * @size:		DMA transaction size in bytes
+- * @flags:		flags to control DMA descriptor preparation
+- */
+-static int qcom_write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+-			       const u8 *vaddr, int size, unsigned int flags)
+-{
+-	if (nandc->props->supports_bam)
+-		return qcom_prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
+-
+-	return qcom_prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
+-}
+-
+-/*
+  * Helper to prepare DMA descriptors for configuring registers
+  * before reading a NAND page.
+  */
+@@ -1262,83 +394,6 @@ static void config_nand_cw_write(struct
+ 			   NAND_BAM_NEXT_SGL);
+ }
+ 
+-/* helpers to submit/free our list of dma descriptors */
+-static int qcom_submit_descs(struct qcom_nand_controller *nandc)
+-{
+-	struct desc_info *desc, *n;
+-	dma_cookie_t cookie = 0;
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-	int ret = 0;
+-
+-	if (nandc->props->supports_bam) {
+-		if (bam_txn->rx_sgl_pos > bam_txn->rx_sgl_start) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
+-			if (ret)
+-				goto err_unmap_free_desc;
+-		}
+-
+-		if (bam_txn->tx_sgl_pos > bam_txn->tx_sgl_start) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
+-							  DMA_PREP_INTERRUPT);
+-			if (ret)
+-				goto err_unmap_free_desc;
+-		}
+-
+-		if (bam_txn->cmd_sgl_pos > bam_txn->cmd_sgl_start) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
+-							  DMA_PREP_CMD);
+-			if (ret)
+-				goto err_unmap_free_desc;
+-		}
+-	}
+-
+-	list_for_each_entry(desc, &nandc->desc_list, node)
+-		cookie = dmaengine_submit(desc->dma_desc);
+-
+-	if (nandc->props->supports_bam) {
+-		bam_txn->last_cmd_desc->callback = qcom_qpic_bam_dma_done;
+-		bam_txn->last_cmd_desc->callback_param = bam_txn;
+-
+-		dma_async_issue_pending(nandc->tx_chan);
+-		dma_async_issue_pending(nandc->rx_chan);
+-		dma_async_issue_pending(nandc->cmd_chan);
+-
+-		if (!wait_for_completion_timeout(&bam_txn->txn_done,
+-						 QPIC_NAND_COMPLETION_TIMEOUT))
+-			ret = -ETIMEDOUT;
+-	} else {
+-		if (dma_sync_wait(nandc->chan, cookie) != DMA_COMPLETE)
+-			ret = -ETIMEDOUT;
+-	}
+-
+-err_unmap_free_desc:
+-	/*
+-	 * Unmap the dma sg_list and free the desc allocated by both
+-	 * qcom_prepare_bam_async_desc() and qcom_prep_adm_dma_desc() functions.
+-	 */
+-	list_for_each_entry_safe(desc, n, &nandc->desc_list, node) {
+-		list_del(&desc->node);
+-
+-		if (nandc->props->supports_bam)
+-			dma_unmap_sg(nandc->dev, desc->bam_sgl,
+-				     desc->sgl_cnt, desc->dir);
+-		else
+-			dma_unmap_sg(nandc->dev, &desc->adm_sgl, 1,
+-				     desc->dir);
+-
+-		kfree(desc);
+-	}
+-
+-	return ret;
+-}
+-
+-/* reset the register read buffer for next NAND operation */
+-static void qcom_clear_read_regs(struct qcom_nand_controller *nandc)
+-{
+-	nandc->reg_read_pos = 0;
+-	qcom_nandc_dev_to_mem(nandc, false);
+-}
+-
+ /*
+  * when using BCH ECC, the HW flags an error in NAND_FLASH_STATUS if it read
+  * an erased CW, and reports an erased CW in NAND_ERASED_CW_DETECT_STATUS.
+@@ -2967,141 +2022,14 @@ static const struct nand_controller_ops
+ 	.exec_op = qcom_nand_exec_op,
+ };
+ 
+-static void qcom_nandc_unalloc(struct qcom_nand_controller *nandc)
+-{
+-	if (nandc->props->supports_bam) {
+-		if (!dma_mapping_error(nandc->dev, nandc->reg_read_dma))
+-			dma_unmap_single(nandc->dev, nandc->reg_read_dma,
+-					 MAX_REG_RD *
+-					 sizeof(*nandc->reg_read_buf),
+-					 DMA_FROM_DEVICE);
+-
+-		if (nandc->tx_chan)
+-			dma_release_channel(nandc->tx_chan);
+-
+-		if (nandc->rx_chan)
+-			dma_release_channel(nandc->rx_chan);
+-
+-		if (nandc->cmd_chan)
+-			dma_release_channel(nandc->cmd_chan);
+-	} else {
+-		if (nandc->chan)
+-			dma_release_channel(nandc->chan);
+-	}
+-}
+-
+-static int qcom_nandc_alloc(struct qcom_nand_controller *nandc)
+-{
+-	int ret;
+-
+-	ret = dma_set_coherent_mask(nandc->dev, DMA_BIT_MASK(32));
+-	if (ret) {
+-		dev_err(nandc->dev, "failed to set DMA mask\n");
+-		return ret;
+-	}
+-
+-	/*
+-	 * we use the internal buffer for reading ONFI params, reading small
+-	 * data like ID and status, and preforming read-copy-write operations
+-	 * when writing to a codeword partially. 532 is the maximum possible
+-	 * size of a codeword for our nand controller
+-	 */
+-	nandc->buf_size = 532;
+-
+-	nandc->data_buffer = devm_kzalloc(nandc->dev, nandc->buf_size, GFP_KERNEL);
+-	if (!nandc->data_buffer)
+-		return -ENOMEM;
+-
+-	nandc->regs = devm_kzalloc(nandc->dev, sizeof(*nandc->regs), GFP_KERNEL);
+-	if (!nandc->regs)
+-		return -ENOMEM;
+-
+-	nandc->reg_read_buf = devm_kcalloc(nandc->dev, MAX_REG_RD,
+-					   sizeof(*nandc->reg_read_buf),
+-					   GFP_KERNEL);
+-	if (!nandc->reg_read_buf)
+-		return -ENOMEM;
+-
+-	if (nandc->props->supports_bam) {
+-		nandc->reg_read_dma =
+-			dma_map_single(nandc->dev, nandc->reg_read_buf,
+-				       MAX_REG_RD *
+-				       sizeof(*nandc->reg_read_buf),
+-				       DMA_FROM_DEVICE);
+-		if (dma_mapping_error(nandc->dev, nandc->reg_read_dma)) {
+-			dev_err(nandc->dev, "failed to DMA MAP reg buffer\n");
+-			return -EIO;
+-		}
+-
+-		nandc->tx_chan = dma_request_chan(nandc->dev, "tx");
+-		if (IS_ERR(nandc->tx_chan)) {
+-			ret = PTR_ERR(nandc->tx_chan);
+-			nandc->tx_chan = NULL;
+-			dev_err_probe(nandc->dev, ret,
+-				      "tx DMA channel request failed\n");
+-			goto unalloc;
+-		}
+-
+-		nandc->rx_chan = dma_request_chan(nandc->dev, "rx");
+-		if (IS_ERR(nandc->rx_chan)) {
+-			ret = PTR_ERR(nandc->rx_chan);
+-			nandc->rx_chan = NULL;
+-			dev_err_probe(nandc->dev, ret,
+-				      "rx DMA channel request failed\n");
+-			goto unalloc;
+-		}
+-
+-		nandc->cmd_chan = dma_request_chan(nandc->dev, "cmd");
+-		if (IS_ERR(nandc->cmd_chan)) {
+-			ret = PTR_ERR(nandc->cmd_chan);
+-			nandc->cmd_chan = NULL;
+-			dev_err_probe(nandc->dev, ret,
+-				      "cmd DMA channel request failed\n");
+-			goto unalloc;
+-		}
+-
+-		/*
+-		 * Initially allocate BAM transaction to read ONFI param page.
+-		 * After detecting all the devices, this BAM transaction will
+-		 * be freed and the next BAM transaction will be allocated with
+-		 * maximum codeword size
+-		 */
+-		nandc->max_cwperpage = 1;
+-		nandc->bam_txn = qcom_alloc_bam_transaction(nandc);
+-		if (!nandc->bam_txn) {
+-			dev_err(nandc->dev,
+-				"failed to allocate bam transaction\n");
+-			ret = -ENOMEM;
+-			goto unalloc;
+-		}
+-	} else {
+-		nandc->chan = dma_request_chan(nandc->dev, "rxtx");
+-		if (IS_ERR(nandc->chan)) {
+-			ret = PTR_ERR(nandc->chan);
+-			nandc->chan = NULL;
+-			dev_err_probe(nandc->dev, ret,
+-				      "rxtx DMA channel request failed\n");
+-			return ret;
+-		}
+-	}
+-
+-	INIT_LIST_HEAD(&nandc->desc_list);
+-	INIT_LIST_HEAD(&nandc->host_list);
+-
+-	nand_controller_init(&nandc->controller);
+-	nandc->controller.ops = &qcom_nandc_ops;
+-
+-	return 0;
+-unalloc:
+-	qcom_nandc_unalloc(nandc);
+-	return ret;
+-}
+-
+ /* one time setup of a few nand controller registers */
+ static int qcom_nandc_setup(struct qcom_nand_controller *nandc)
+ {
+ 	u32 nand_ctrl;
+ 
++	nand_controller_init(nandc->controller);
++	nandc->controller->ops = &qcom_nandc_ops;
++
+ 	/* kill onenand */
+ 	if (!nandc->props->nandc_part_of_qpic)
+ 		nandc_write(nandc, SFLASHC_BURST_CFG, 0);
+@@ -3240,7 +2168,7 @@ static int qcom_nand_host_init_and_regis
+ 	chip->legacy.block_bad		= qcom_nandc_block_bad;
+ 	chip->legacy.block_markbad	= qcom_nandc_block_markbad;
+ 
+-	chip->controller = &nandc->controller;
++	chip->controller = nandc->controller;
+ 	chip->options |= NAND_NO_SUBPAGE_WRITE | NAND_USES_DMA |
+ 			 NAND_SKIP_BBTSCAN;
+ 
+@@ -3323,17 +2251,21 @@ static int qcom_nandc_parse_dt(struct pl
+ static int qcom_nandc_probe(struct platform_device *pdev)
+ {
+ 	struct qcom_nand_controller *nandc;
++	struct nand_controller *controller;
+ 	const void *dev_data;
+ 	struct device *dev = &pdev->dev;
+ 	struct resource *res;
+ 	int ret;
+ 
+-	nandc = devm_kzalloc(&pdev->dev, sizeof(*nandc), GFP_KERNEL);
++	nandc = devm_kzalloc(&pdev->dev, sizeof(*nandc) + sizeof(*controller),
++			     GFP_KERNEL);
+ 	if (!nandc)
+ 		return -ENOMEM;
++	controller = (struct nand_controller *)&nandc[1];
+ 
+ 	platform_set_drvdata(pdev, nandc);
+ 	nandc->dev = dev;
++	nandc->controller = controller;
+ 
+ 	dev_data = of_device_get_match_data(dev);
+ 	if (!dev_data) {
+--- /dev/null
++++ b/include/linux/mtd/nand-qpic-common.h
+@@ -0,0 +1,468 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * QCOM QPIC common APIs header file
++ *
++ * Copyright (c) 2023 Qualcomm Inc.
++ * Authors:	Md sadre Alam	<quic_mdalam@quicinc.com>
++ *
++ */
++#ifndef __MTD_NAND_QPIC_COMMON_H__
++#define __MTD_NAND_QPIC_COMMON_H__
++
++/* NANDc reg offsets */
++#define	NAND_FLASH_CMD			0x00
++#define	NAND_ADDR0			0x04
++#define	NAND_ADDR1			0x08
++#define	NAND_FLASH_CHIP_SELECT		0x0c
++#define	NAND_EXEC_CMD			0x10
++#define	NAND_FLASH_STATUS		0x14
++#define	NAND_BUFFER_STATUS		0x18
++#define	NAND_DEV0_CFG0			0x20
++#define	NAND_DEV0_CFG1			0x24
++#define	NAND_DEV0_ECC_CFG		0x28
++#define	NAND_AUTO_STATUS_EN		0x2c
++#define	NAND_DEV1_CFG0			0x30
++#define	NAND_DEV1_CFG1			0x34
++#define	NAND_READ_ID			0x40
++#define	NAND_READ_STATUS		0x44
++#define	NAND_DEV_CMD0			0xa0
++#define	NAND_DEV_CMD1			0xa4
++#define	NAND_DEV_CMD2			0xa8
++#define	NAND_DEV_CMD_VLD		0xac
++#define	SFLASHC_BURST_CFG		0xe0
++#define	NAND_ERASED_CW_DETECT_CFG	0xe8
++#define	NAND_ERASED_CW_DETECT_STATUS	0xec
++#define	NAND_EBI2_ECC_BUF_CFG		0xf0
++#define	FLASH_BUF_ACC			0x100
++
++#define	NAND_CTRL			0xf00
++#define	NAND_VERSION			0xf08
++#define	NAND_READ_LOCATION_0		0xf20
++#define	NAND_READ_LOCATION_1		0xf24
++#define	NAND_READ_LOCATION_2		0xf28
++#define	NAND_READ_LOCATION_3		0xf2c
++#define	NAND_READ_LOCATION_LAST_CW_0	0xf40
++#define	NAND_READ_LOCATION_LAST_CW_1	0xf44
++#define	NAND_READ_LOCATION_LAST_CW_2	0xf48
++#define	NAND_READ_LOCATION_LAST_CW_3	0xf4c
++
++/* dummy register offsets, used by qcom_write_reg_dma */
++#define	NAND_DEV_CMD1_RESTORE		0xdead
++#define	NAND_DEV_CMD_VLD_RESTORE	0xbeef
++
++/* NAND_FLASH_CMD bits */
++#define	PAGE_ACC			BIT(4)
++#define	LAST_PAGE			BIT(5)
++
++/* NAND_FLASH_CHIP_SELECT bits */
++#define	NAND_DEV_SEL			0
++#define	DM_EN				BIT(2)
++
++/* NAND_FLASH_STATUS bits */
++#define	FS_OP_ERR			BIT(4)
++#define	FS_READY_BSY_N			BIT(5)
++#define	FS_MPU_ERR			BIT(8)
++#define	FS_DEVICE_STS_ERR		BIT(16)
++#define	FS_DEVICE_WP			BIT(23)
++
++/* NAND_BUFFER_STATUS bits */
++#define	BS_UNCORRECTABLE_BIT		BIT(8)
++#define	BS_CORRECTABLE_ERR_MSK		0x1f
++
++/* NAND_DEVn_CFG0 bits */
++#define	DISABLE_STATUS_AFTER_WRITE	4
++#define	CW_PER_PAGE			6
++#define	UD_SIZE_BYTES			9
++#define	UD_SIZE_BYTES_MASK		GENMASK(18, 9)
++#define	ECC_PARITY_SIZE_BYTES_RS	19
++#define	SPARE_SIZE_BYTES		23
++#define	SPARE_SIZE_BYTES_MASK		GENMASK(26, 23)
++#define	NUM_ADDR_CYCLES			27
++#define	STATUS_BFR_READ			30
++#define	SET_RD_MODE_AFTER_STATUS	31
++
++/* NAND_DEVn_CFG0 bits */
++#define	DEV0_CFG1_ECC_DISABLE		0
++#define	WIDE_FLASH			1
++#define	NAND_RECOVERY_CYCLES		2
++#define	CS_ACTIVE_BSY			5
++#define	BAD_BLOCK_BYTE_NUM		6
++#define	BAD_BLOCK_IN_SPARE_AREA		16
++#define	WR_RD_BSY_GAP			17
++#define	ENABLE_BCH_ECC			27
++
++/* NAND_DEV0_ECC_CFG bits */
++#define	ECC_CFG_ECC_DISABLE		0
++#define	ECC_SW_RESET			1
++#define	ECC_MODE			4
++#define	ECC_PARITY_SIZE_BYTES_BCH	8
++#define	ECC_NUM_DATA_BYTES		16
++#define	ECC_NUM_DATA_BYTES_MASK		GENMASK(25, 16)
++#define	ECC_FORCE_CLK_OPEN		30
++
++/* NAND_DEV_CMD1 bits */
++#define	READ_ADDR			0
++
++/* NAND_DEV_CMD_VLD bits */
++#define	READ_START_VLD			BIT(0)
++#define	READ_STOP_VLD			BIT(1)
++#define	WRITE_START_VLD			BIT(2)
++#define	ERASE_START_VLD			BIT(3)
++#define	SEQ_READ_START_VLD		BIT(4)
++
++/* NAND_EBI2_ECC_BUF_CFG bits */
++#define	NUM_STEPS			0
++
++/* NAND_ERASED_CW_DETECT_CFG bits */
++#define	ERASED_CW_ECC_MASK		1
++#define	AUTO_DETECT_RES			0
++#define	MASK_ECC			BIT(ERASED_CW_ECC_MASK)
++#define	RESET_ERASED_DET		BIT(AUTO_DETECT_RES)
++#define	ACTIVE_ERASED_DET		(0 << AUTO_DETECT_RES)
++#define	CLR_ERASED_PAGE_DET		(RESET_ERASED_DET | MASK_ECC)
++#define	SET_ERASED_PAGE_DET		(ACTIVE_ERASED_DET | MASK_ECC)
++
++/* NAND_ERASED_CW_DETECT_STATUS bits */
++#define	PAGE_ALL_ERASED			BIT(7)
++#define	CODEWORD_ALL_ERASED		BIT(6)
++#define	PAGE_ERASED			BIT(5)
++#define	CODEWORD_ERASED			BIT(4)
++#define	ERASED_PAGE			(PAGE_ALL_ERASED | PAGE_ERASED)
++#define	ERASED_CW			(CODEWORD_ALL_ERASED | CODEWORD_ERASED)
++
++/* NAND_READ_LOCATION_n bits */
++#define READ_LOCATION_OFFSET		0
++#define READ_LOCATION_SIZE		16
++#define READ_LOCATION_LAST		31
++
++/* Version Mask */
++#define	NAND_VERSION_MAJOR_MASK		0xf0000000
++#define	NAND_VERSION_MAJOR_SHIFT	28
++#define	NAND_VERSION_MINOR_MASK		0x0fff0000
++#define	NAND_VERSION_MINOR_SHIFT	16
++
++/* NAND OP_CMDs */
++#define	OP_PAGE_READ			0x2
++#define	OP_PAGE_READ_WITH_ECC		0x3
++#define	OP_PAGE_READ_WITH_ECC_SPARE	0x4
++#define	OP_PAGE_READ_ONFI_READ		0x5
++#define	OP_PROGRAM_PAGE			0x6
++#define	OP_PAGE_PROGRAM_WITH_ECC	0x7
++#define	OP_PROGRAM_PAGE_SPARE		0x9
++#define	OP_BLOCK_ERASE			0xa
++#define	OP_CHECK_STATUS			0xc
++#define	OP_FETCH_ID			0xb
++#define	OP_RESET_DEVICE			0xd
++
++/* Default Value for NAND_DEV_CMD_VLD */
++#define NAND_DEV_CMD_VLD_VAL		(READ_START_VLD | WRITE_START_VLD | \
++					 ERASE_START_VLD | SEQ_READ_START_VLD)
++
++/* NAND_CTRL bits */
++#define	BAM_MODE_EN			BIT(0)
++
++/*
++ * the NAND controller performs reads/writes with ECC in 516 byte chunks.
++ * the driver calls the chunks 'step' or 'codeword' interchangeably
++ */
++#define	NANDC_STEP_SIZE			512
++
++/*
++ * the largest page size we support is 8K, this will have 16 steps/codewords
++ * of 512 bytes each
++ */
++#define	MAX_NUM_STEPS			(SZ_8K / NANDC_STEP_SIZE)
++
++/* we read at most 3 registers per codeword scan */
++#define	MAX_REG_RD			(3 * MAX_NUM_STEPS)
++
++/* ECC modes supported by the controller */
++#define	ECC_NONE	BIT(0)
++#define	ECC_RS_4BIT	BIT(1)
++#define	ECC_BCH_4BIT	BIT(2)
++#define	ECC_BCH_8BIT	BIT(3)
++
++/*
++ * Returns the actual register address for all NAND_DEV_ registers
++ * (i.e. NAND_DEV_CMD0, NAND_DEV_CMD1, NAND_DEV_CMD2 and NAND_DEV_CMD_VLD)
++ */
++#define dev_cmd_reg_addr(nandc, reg) ((nandc)->props->dev_cmd_reg_start + (reg))
++
++/* Returns the NAND register physical address */
++#define nandc_reg_phys(chip, offset) ((chip)->base_phys + (offset))
++
++/* Returns the dma address for reg read buffer */
++#define reg_buf_dma_addr(chip, vaddr) \
++	((chip)->reg_read_dma + \
++	((u8 *)(vaddr) - (u8 *)(chip)->reg_read_buf))
++
++#define QPIC_PER_CW_CMD_ELEMENTS	32
++#define QPIC_PER_CW_CMD_SGL		32
++#define QPIC_PER_CW_DATA_SGL		8
++
++#define QPIC_NAND_COMPLETION_TIMEOUT	msecs_to_jiffies(2000)
++
++/*
++ * Flags used in DMA descriptor preparation helper functions
++ * (i.e. qcom_read_reg_dma/qcom_write_reg_dma/qcom_read_data_dma/qcom_write_data_dma)
++ */
++/* Don't set the EOT in current tx BAM sgl */
++#define NAND_BAM_NO_EOT			BIT(0)
++/* Set the NWD flag in current BAM sgl */
++#define NAND_BAM_NWD			BIT(1)
++/* Finish writing in the current BAM sgl and start writing in another BAM sgl */
++#define NAND_BAM_NEXT_SGL		BIT(2)
++/*
++ * Erased codeword status is being used two times in single transfer so this
++ * flag will determine the current value of erased codeword status register
++ */
++#define NAND_ERASED_CW_SET		BIT(4)
++
++#define MAX_ADDRESS_CYCLE		5
++
++/*
++ * This data type corresponds to the BAM transaction which will be used for all
++ * NAND transfers.
++ * @bam_ce - the array of BAM command elements
++ * @cmd_sgl - sgl for NAND BAM command pipe
++ * @data_sgl - sgl for NAND BAM consumer/producer pipe
++ * @last_data_desc - last DMA desc in data channel (tx/rx).
++ * @last_cmd_desc - last DMA desc in command channel.
++ * @txn_done - completion for NAND transfer.
++ * @bam_ce_pos - the index in bam_ce which is available for next sgl
++ * @bam_ce_start - the index in bam_ce which marks the start position ce
++ *		   for current sgl. It will be used for size calculation
++ *		   for current sgl
++ * @cmd_sgl_pos - current index in command sgl.
++ * @cmd_sgl_start - start index in command sgl.
++ * @tx_sgl_pos - current index in data sgl for tx.
++ * @tx_sgl_start - start index in data sgl for tx.
++ * @rx_sgl_pos - current index in data sgl for rx.
++ * @rx_sgl_start - start index in data sgl for rx.
++ */
++struct bam_transaction {
++	struct bam_cmd_element *bam_ce;
++	struct scatterlist *cmd_sgl;
++	struct scatterlist *data_sgl;
++	struct dma_async_tx_descriptor *last_data_desc;
++	struct dma_async_tx_descriptor *last_cmd_desc;
++	struct completion txn_done;
++	u32 bam_ce_pos;
++	u32 bam_ce_start;
++	u32 cmd_sgl_pos;
++	u32 cmd_sgl_start;
++	u32 tx_sgl_pos;
++	u32 tx_sgl_start;
++	u32 rx_sgl_pos;
++	u32 rx_sgl_start;
++};
++
++/*
++ * This data type corresponds to the nand dma descriptor
++ * @dma_desc - low level DMA engine descriptor
++ * @list - list for desc_info
++ *
++ * @adm_sgl - sgl which will be used for single sgl dma descriptor. Only used by
++ *	      ADM
++ * @bam_sgl - sgl which will be used for dma descriptor. Only used by BAM
++ * @sgl_cnt - number of SGL in bam_sgl. Only used by BAM
++ * @dir - DMA transfer direction
++ */
++struct desc_info {
++	struct dma_async_tx_descriptor *dma_desc;
++	struct list_head node;
++
++	union {
++		struct scatterlist adm_sgl;
++		struct {
++			struct scatterlist *bam_sgl;
++			int sgl_cnt;
++		};
++	};
++	enum dma_data_direction dir;
++};
++
++/*
++ * holds the current register values that we want to write. acts as a contiguous
++ * chunk of memory which we use to write the controller registers through DMA.
++ */
++struct nandc_regs {
++	__le32 cmd;
++	__le32 addr0;
++	__le32 addr1;
++	__le32 chip_sel;
++	__le32 exec;
++
++	__le32 cfg0;
++	__le32 cfg1;
++	__le32 ecc_bch_cfg;
++
++	__le32 clrflashstatus;
++	__le32 clrreadstatus;
++
++	__le32 cmd1;
++	__le32 vld;
++
++	__le32 orig_cmd1;
++	__le32 orig_vld;
++
++	__le32 ecc_buf_cfg;
++	__le32 read_location0;
++	__le32 read_location1;
++	__le32 read_location2;
++	__le32 read_location3;
++	__le32 read_location_last0;
++	__le32 read_location_last1;
++	__le32 read_location_last2;
++	__le32 read_location_last3;
++
++	__le32 erased_cw_detect_cfg_clr;
++	__le32 erased_cw_detect_cfg_set;
++};
++
++/*
++ * NAND controller data struct
++ *
++ * @dev:			parent device
++ *
++ * @base:			MMIO base
++ *
++ * @core_clk:			controller clock
++ * @aon_clk:			another controller clock
++ *
++ * @regs:			a contiguous chunk of memory for DMA register
++ *				writes. contains the register values to be
++ *				written to controller
++ *
++ * @props:			properties of current NAND controller,
++ *				initialized via DT match data
++ *
++ * @controller:			base controller structure
++ * @host_list:			list containing all the chips attached to the
++ *				controller
++ *
++ * @chan:			dma channel
++ * @cmd_crci:			ADM DMA CRCI for command flow control
++ * @data_crci:			ADM DMA CRCI for data flow control
++ *
++ * @desc_list:			DMA descriptor list (list of desc_infos)
++ *
++ * @data_buffer:		our local DMA buffer for page read/writes,
++ *				used when we can't use the buffer provided
++ *				by upper layers directly
++ * @reg_read_buf:		local buffer for reading back registers via DMA
++ *
++ * @base_phys:			physical base address of controller registers
++ * @base_dma:			dma base address of controller registers
++ * @reg_read_dma:		contains dma address for register read buffer
++ *
++ * @buf_size/count/start:	markers for chip->legacy.read_buf/write_buf
++ *				functions
++ * @max_cwperpage:		maximum QPIC codewords required. calculated
++ *				from all connected NAND devices pagesize
++ *
++ * @reg_read_pos:		marker for data read in reg_read_buf
++ *
++ * @cmd1/vld:			some fixed controller register values
++ *
++ * @exec_opwrite:		flag to select correct number of code word
++ *				while reading status
++ */
++struct qcom_nand_controller {
++	struct device *dev;
++
++	void __iomem *base;
++
++	struct clk *core_clk;
++	struct clk *aon_clk;
++
++	struct nandc_regs *regs;
++	struct bam_transaction *bam_txn;
++
++	const struct qcom_nandc_props *props;
++
++	struct nand_controller *controller;
++	struct list_head host_list;
++
++	union {
++		/* will be used only by QPIC for BAM DMA */
++		struct {
++			struct dma_chan *tx_chan;
++			struct dma_chan *rx_chan;
++			struct dma_chan *cmd_chan;
++		};
++
++		/* will be used only by EBI2 for ADM DMA */
++		struct {
++			struct dma_chan *chan;
++			unsigned int cmd_crci;
++			unsigned int data_crci;
++		};
++	};
++
++	struct list_head desc_list;
++
++	u8		*data_buffer;
++	__le32		*reg_read_buf;
++
++	phys_addr_t base_phys;
++	dma_addr_t base_dma;
++	dma_addr_t reg_read_dma;
++
++	int		buf_size;
++	int		buf_count;
++	int		buf_start;
++	unsigned int	max_cwperpage;
++
++	int reg_read_pos;
++
++	u32 cmd1, vld;
++	bool exec_opwrite;
++};
++
++/*
++ * This data type corresponds to the NAND controller properties which varies
++ * among different NAND controllers.
++ * @ecc_modes - ecc mode for NAND
++ * @dev_cmd_reg_start - NAND_DEV_CMD_* registers starting offset
++ * @supports_bam - whether NAND controller is using BAM
++ * @nandc_part_of_qpic - whether NAND controller is part of qpic IP
++ * @qpic_version2 - flag to indicate QPIC IP version 2
++ * @use_codeword_fixup - whether NAND has different layout for boot partitions
++ */
++struct qcom_nandc_props {
++	u32 ecc_modes;
++	u32 dev_cmd_reg_start;
++	bool supports_bam;
++	bool nandc_part_of_qpic;
++	bool qpic_version2;
++	bool use_codeword_fixup;
++};
++
++void qcom_free_bam_transaction(struct qcom_nand_controller *nandc);
++struct bam_transaction *qcom_alloc_bam_transaction(struct qcom_nand_controller *nandc);
++void qcom_clear_bam_transaction(struct qcom_nand_controller *nandc);
++void qcom_qpic_bam_dma_done(void *data);
++void qcom_nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu);
++int qcom_prepare_bam_async_desc(struct qcom_nand_controller *nandc,
++				struct dma_chan *chan, unsigned long flags);
++int qcom_prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
++			       int reg_off, const void *vaddr, int size, unsigned int flags);
++int qcom_prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
++				const void *vaddr, int size, unsigned int flags);
++int qcom_prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read, int reg_off,
++			   const void *vaddr, int size, bool flow_control);
++int qcom_read_reg_dma(struct qcom_nand_controller *nandc, int first, int num_regs,
++		      unsigned int flags);
++int qcom_write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr, int first,
++		       int num_regs, unsigned int flags);
++int qcom_read_data_dma(struct qcom_nand_controller *nandc, int reg_off, const u8 *vaddr,
++		       int size, unsigned int flags);
++int qcom_write_data_dma(struct qcom_nand_controller *nandc, int reg_off, const u8 *vaddr,
++			int size, unsigned int flags);
++int qcom_submit_descs(struct qcom_nand_controller *nandc);
++void qcom_clear_read_regs(struct qcom_nand_controller *nandc);
++void qcom_nandc_unalloc(struct qcom_nand_controller *nandc);
++int qcom_nandc_alloc(struct qcom_nand_controller *nandc);
++#endif
++
diff --git a/target/linux/generic/backport-6.12/413-04-v6.14-mtd-rawnand-qcom-use-FIELD_PREP-and-GENMASK.patch b/target/linux/generic/backport-6.12/413-04-v6.14-mtd-rawnand-qcom-use-FIELD_PREP-and-GENMASK.patch
new file mode 100644
index 0000000000..b37507409a
--- /dev/null
+++ b/target/linux/generic/backport-6.12/413-04-v6.14-mtd-rawnand-qcom-use-FIELD_PREP-and-GENMASK.patch
@@ -0,0 +1,198 @@
+From 0c08080fd71cd5dd59643104b39d3c89d793ab3c Mon Sep 17 00:00:00 2001
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Wed, 20 Nov 2024 14:45:03 +0530
+Subject: [PATCH 4/4] mtd: rawnand: qcom: use FIELD_PREP and GENMASK
+
+Use the bitfield macro FIELD_PREP, and GENMASK to
+do the shift and mask in one go. This makes the code
+more readable.
+
+Reviewed-by: Konrad Dybcio <konrad.dybcio@oss.qualcomm.com>
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/mtd/nand/raw/qcom_nandc.c    | 97 ++++++++++++++--------------
+ include/linux/mtd/nand-qpic-common.h | 31 +++++----
+ 2 files changed, 67 insertions(+), 61 deletions(-)
+
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -281,7 +281,7 @@ static void update_rw_regs(struct qcom_n
+ 				(num_cw - 1) << CW_PER_PAGE);
+ 
+ 		cfg1 = cpu_to_le32(host->cfg1_raw);
+-		ecc_bch_cfg = cpu_to_le32(1 << ECC_CFG_ECC_DISABLE);
++		ecc_bch_cfg = cpu_to_le32(ECC_CFG_ECC_DISABLE);
+ 	}
+ 
+ 	nandc->regs->cmd = cmd;
+@@ -1494,42 +1494,41 @@ static int qcom_nand_attach_chip(struct
+ 	host->cw_size = host->cw_data + ecc->bytes;
+ 	bad_block_byte = mtd->writesize - host->cw_size * (cwperpage - 1) + 1;
+ 
+-	host->cfg0 = (cwperpage - 1) << CW_PER_PAGE
+-				| host->cw_data << UD_SIZE_BYTES
+-				| 0 << DISABLE_STATUS_AFTER_WRITE
+-				| 5 << NUM_ADDR_CYCLES
+-				| host->ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_RS
+-				| 0 << STATUS_BFR_READ
+-				| 1 << SET_RD_MODE_AFTER_STATUS
+-				| host->spare_bytes << SPARE_SIZE_BYTES;
+-
+-	host->cfg1 = 7 << NAND_RECOVERY_CYCLES
+-				| 0 <<  CS_ACTIVE_BSY
+-				| bad_block_byte << BAD_BLOCK_BYTE_NUM
+-				| 0 << BAD_BLOCK_IN_SPARE_AREA
+-				| 2 << WR_RD_BSY_GAP
+-				| wide_bus << WIDE_FLASH
+-				| host->bch_enabled << ENABLE_BCH_ECC;
+-
+-	host->cfg0_raw = (cwperpage - 1) << CW_PER_PAGE
+-				| host->cw_size << UD_SIZE_BYTES
+-				| 5 << NUM_ADDR_CYCLES
+-				| 0 << SPARE_SIZE_BYTES;
+-
+-	host->cfg1_raw = 7 << NAND_RECOVERY_CYCLES
+-				| 0 << CS_ACTIVE_BSY
+-				| 17 << BAD_BLOCK_BYTE_NUM
+-				| 1 << BAD_BLOCK_IN_SPARE_AREA
+-				| 2 << WR_RD_BSY_GAP
+-				| wide_bus << WIDE_FLASH
+-				| 1 << DEV0_CFG1_ECC_DISABLE;
+-
+-	host->ecc_bch_cfg = !host->bch_enabled << ECC_CFG_ECC_DISABLE
+-				| 0 << ECC_SW_RESET
+-				| host->cw_data << ECC_NUM_DATA_BYTES
+-				| 1 << ECC_FORCE_CLK_OPEN
+-				| ecc_mode << ECC_MODE
+-				| host->ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_BCH;
++	host->cfg0 = FIELD_PREP(CW_PER_PAGE_MASK, (cwperpage - 1)) |
++		     FIELD_PREP(UD_SIZE_BYTES_MASK, host->cw_data) |
++		     FIELD_PREP(DISABLE_STATUS_AFTER_WRITE, 0) |
++		     FIELD_PREP(NUM_ADDR_CYCLES_MASK, 5) |
++		     FIELD_PREP(ECC_PARITY_SIZE_BYTES_RS, host->ecc_bytes_hw) |
++		     FIELD_PREP(STATUS_BFR_READ, 0) |
++		     FIELD_PREP(SET_RD_MODE_AFTER_STATUS, 1) |
++		     FIELD_PREP(SPARE_SIZE_BYTES_MASK, host->spare_bytes);
++
++	host->cfg1 = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 7) |
++		     FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, bad_block_byte) |
++		     FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 0) |
++		     FIELD_PREP(WR_RD_BSY_GAP_MASK, 2) |
++		     FIELD_PREP(WIDE_FLASH, wide_bus) |
++		     FIELD_PREP(ENABLE_BCH_ECC, host->bch_enabled);
++
++	host->cfg0_raw = FIELD_PREP(CW_PER_PAGE_MASK, (cwperpage - 1)) |
++			 FIELD_PREP(UD_SIZE_BYTES_MASK, host->cw_size) |
++			 FIELD_PREP(NUM_ADDR_CYCLES_MASK, 5) |
++			 FIELD_PREP(SPARE_SIZE_BYTES_MASK, 0);
++
++	host->cfg1_raw = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 7) |
++			 FIELD_PREP(CS_ACTIVE_BSY, 0) |
++			 FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, 17) |
++			 FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 1) |
++			 FIELD_PREP(WR_RD_BSY_GAP_MASK, 2) |
++			 FIELD_PREP(WIDE_FLASH, wide_bus) |
++			 FIELD_PREP(DEV0_CFG1_ECC_DISABLE, 1);
++
++	host->ecc_bch_cfg = FIELD_PREP(ECC_CFG_ECC_DISABLE, !host->bch_enabled) |
++			    FIELD_PREP(ECC_SW_RESET, 0) |
++			    FIELD_PREP(ECC_NUM_DATA_BYTES_MASK, host->cw_data) |
++			    FIELD_PREP(ECC_FORCE_CLK_OPEN, 1) |
++			    FIELD_PREP(ECC_MODE_MASK, ecc_mode) |
++			    FIELD_PREP(ECC_PARITY_SIZE_BYTES_BCH_MASK, host->ecc_bytes_hw);
+ 
+ 	if (!nandc->props->qpic_version2)
+ 		host->ecc_buf_cfg = 0x203 << NUM_STEPS;
+@@ -1882,21 +1881,21 @@ static int qcom_param_page_type_exec(str
+ 	nandc->regs->addr0 = 0;
+ 	nandc->regs->addr1 = 0;
+ 
+-	nandc->regs->cfg0 = cpu_to_le32(0 << CW_PER_PAGE |
+-					512 << UD_SIZE_BYTES |
+-					5 << NUM_ADDR_CYCLES |
+-					0 << SPARE_SIZE_BYTES);
+-
+-	nandc->regs->cfg1 = cpu_to_le32(7 << NAND_RECOVERY_CYCLES |
+-					0 << CS_ACTIVE_BSY |
+-					17 << BAD_BLOCK_BYTE_NUM |
+-					1 << BAD_BLOCK_IN_SPARE_AREA |
+-					2 << WR_RD_BSY_GAP |
+-					0 << WIDE_FLASH |
+-					1 << DEV0_CFG1_ECC_DISABLE);
++	host->cfg0 = FIELD_PREP(CW_PER_PAGE_MASK, 0) |
++		     FIELD_PREP(UD_SIZE_BYTES_MASK, 512) |
++		     FIELD_PREP(NUM_ADDR_CYCLES_MASK, 5) |
++		     FIELD_PREP(SPARE_SIZE_BYTES_MASK, 0);
++
++	host->cfg1 = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 7) |
++		     FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, 17) |
++		     FIELD_PREP(CS_ACTIVE_BSY, 0) |
++		     FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 1) |
++		     FIELD_PREP(WR_RD_BSY_GAP_MASK, 2) |
++		     FIELD_PREP(WIDE_FLASH, 0) |
++		     FIELD_PREP(DEV0_CFG1_ECC_DISABLE, 1);
+ 
+ 	if (!nandc->props->qpic_version2)
+-		nandc->regs->ecc_buf_cfg = cpu_to_le32(1 << ECC_CFG_ECC_DISABLE);
++		nandc->regs->ecc_buf_cfg = cpu_to_le32(ECC_CFG_ECC_DISABLE);
+ 
+ 	/* configure CMD1 and VLD for ONFI param probing in QPIC v1 */
+ 	if (!nandc->props->qpic_version2) {
+--- a/include/linux/mtd/nand-qpic-common.h
++++ b/include/linux/mtd/nand-qpic-common.h
+@@ -70,35 +70,42 @@
+ #define	BS_CORRECTABLE_ERR_MSK		0x1f
+ 
+ /* NAND_DEVn_CFG0 bits */
+-#define	DISABLE_STATUS_AFTER_WRITE	4
++#define	DISABLE_STATUS_AFTER_WRITE	BIT(4)
+ #define	CW_PER_PAGE			6
++#define	CW_PER_PAGE_MASK		GENMASK(8, 6)
+ #define	UD_SIZE_BYTES			9
+ #define	UD_SIZE_BYTES_MASK		GENMASK(18, 9)
+-#define	ECC_PARITY_SIZE_BYTES_RS	19
++#define	ECC_PARITY_SIZE_BYTES_RS	GENMASK(22, 19)
+ #define	SPARE_SIZE_BYTES		23
+ #define	SPARE_SIZE_BYTES_MASK		GENMASK(26, 23)
+ #define	NUM_ADDR_CYCLES			27
+-#define	STATUS_BFR_READ			30
+-#define	SET_RD_MODE_AFTER_STATUS	31
++#define	NUM_ADDR_CYCLES_MASK		GENMASK(29, 27)
++#define	STATUS_BFR_READ			BIT(30)
++#define	SET_RD_MODE_AFTER_STATUS	BIT(31)
+ 
+ /* NAND_DEVn_CFG0 bits */
+-#define	DEV0_CFG1_ECC_DISABLE		0
+-#define	WIDE_FLASH			1
++#define	DEV0_CFG1_ECC_DISABLE		BIT(0)
++#define	WIDE_FLASH			BIT(1)
+ #define	NAND_RECOVERY_CYCLES		2
+-#define	CS_ACTIVE_BSY			5
++#define	NAND_RECOVERY_CYCLES_MASK	GENMASK(4, 2)
++#define	CS_ACTIVE_BSY			BIT(5)
+ #define	BAD_BLOCK_BYTE_NUM		6
+-#define	BAD_BLOCK_IN_SPARE_AREA		16
++#define	BAD_BLOCK_BYTE_NUM_MASK		GENMASK(15, 6)
++#define	BAD_BLOCK_IN_SPARE_AREA		BIT(16)
+ #define	WR_RD_BSY_GAP			17
+-#define	ENABLE_BCH_ECC			27
++#define	WR_RD_BSY_GAP_MASK		GENMASK(22, 17)
++#define	ENABLE_BCH_ECC			BIT(27)
+ 
+ /* NAND_DEV0_ECC_CFG bits */
+-#define	ECC_CFG_ECC_DISABLE		0
+-#define	ECC_SW_RESET			1
++#define	ECC_CFG_ECC_DISABLE		BIT(0)
++#define	ECC_SW_RESET			BIT(1)
+ #define	ECC_MODE			4
++#define	ECC_MODE_MASK			GENMASK(5, 4)
+ #define	ECC_PARITY_SIZE_BYTES_BCH	8
++#define	ECC_PARITY_SIZE_BYTES_BCH_MASK	GENMASK(12, 8)
+ #define	ECC_NUM_DATA_BYTES		16
+ #define	ECC_NUM_DATA_BYTES_MASK		GENMASK(25, 16)
+-#define	ECC_FORCE_CLK_OPEN		30
++#define	ECC_FORCE_CLK_OPEN		BIT(30)
+ 
+ /* NAND_DEV_CMD1 bits */
+ #define	READ_ADDR			0
diff --git a/target/linux/generic/backport-6.12/414-v6.14-mtd-rawnand-qcom-fix-broken-config-in-qcom_param_pag.patch b/target/linux/generic/backport-6.12/414-v6.14-mtd-rawnand-qcom-fix-broken-config-in-qcom_param_pag.patch
new file mode 100644
index 0000000000..a6a4db229f
--- /dev/null
+++ b/target/linux/generic/backport-6.12/414-v6.14-mtd-rawnand-qcom-fix-broken-config-in-qcom_param_pag.patch
@@ -0,0 +1,64 @@
+From 9d4ffbcfde283f2a87ea45128ddf7e6651facdd9 Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Fri, 7 Feb 2025 20:42:38 +0100
+Subject: [PATCH] mtd: rawnand: qcom: fix broken config in
+ qcom_param_page_type_exec
+
+Fix broken config in qcom_param_page_type_exec caused by copy-paste error
+from commit 0c08080fd71c ("mtd: rawnand: qcom: use FIELD_PREP and GENMASK")
+
+In qcom_param_page_type_exec the value needs to be set to
+nandc->regs->cfg0 instead of host->cfg0. This wrong configuration caused
+the Qcom NANDC driver to malfunction on any device that makes use of it
+(IPQ806x, IPQ40xx, IPQ807x, IPQ60xx) with the following error:
+
+[    0.885369] nand: device found, Manufacturer ID: 0x2c, Chip ID: 0xaa
+[    0.885909] nand: Micron NAND 256MiB 1,8V 8-bit
+[    0.892499] nand: 256 MiB, SLC, erase size: 128 KiB, page size: 2048, OOB size: 64
+[    0.896823] nand: ECC (step, strength) = (512, 8) does not fit in OOB
+[    0.896836] qcom-nandc 79b0000.nand-controller: No valid ECC settings possible
+[    0.910996] bam-dma-engine 7984000.dma-controller: Cannot free busy channel
+[    0.918070] qcom-nandc: probe of 79b0000.nand-controller failed with error -28
+
+Restore original configuration fix the problem and makes the driver work
+again.
+
+Cc: stable@vger.kernel.org
+Fixes: 0c08080fd71c ("mtd: rawnand: qcom: use FIELD_PREP and GENMASK")
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ drivers/mtd/nand/raw/qcom_nandc.c | 24 ++++++++++++------------
+ 1 file changed, 12 insertions(+), 12 deletions(-)
+
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -1881,18 +1881,18 @@ static int qcom_param_page_type_exec(str
+ 	nandc->regs->addr0 = 0;
+ 	nandc->regs->addr1 = 0;
+ 
+-	host->cfg0 = FIELD_PREP(CW_PER_PAGE_MASK, 0) |
+-		     FIELD_PREP(UD_SIZE_BYTES_MASK, 512) |
+-		     FIELD_PREP(NUM_ADDR_CYCLES_MASK, 5) |
+-		     FIELD_PREP(SPARE_SIZE_BYTES_MASK, 0);
++	nandc->regs->cfg0 = FIELD_PREP(CW_PER_PAGE_MASK, 0) |
++			    FIELD_PREP(UD_SIZE_BYTES_MASK, 512) |
++			    FIELD_PREP(NUM_ADDR_CYCLES_MASK, 5) |
++			    FIELD_PREP(SPARE_SIZE_BYTES_MASK, 0);
+ 
+-	host->cfg1 = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 7) |
+-		     FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, 17) |
+-		     FIELD_PREP(CS_ACTIVE_BSY, 0) |
+-		     FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 1) |
+-		     FIELD_PREP(WR_RD_BSY_GAP_MASK, 2) |
+-		     FIELD_PREP(WIDE_FLASH, 0) |
+-		     FIELD_PREP(DEV0_CFG1_ECC_DISABLE, 1);
++	nandc->regs->cfg1 = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 7) |
++			    FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, 17) |
++			    FIELD_PREP(CS_ACTIVE_BSY, 0) |
++			    FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 1) |
++			    FIELD_PREP(WR_RD_BSY_GAP_MASK, 2) |
++			    FIELD_PREP(WIDE_FLASH, 0) |
++			    FIELD_PREP(DEV0_CFG1_ECC_DISABLE, 1);
+ 
+ 	if (!nandc->props->qpic_version2)
+ 		nandc->regs->ecc_buf_cfg = cpu_to_le32(ECC_CFG_ECC_DISABLE);
diff --git a/target/linux/generic/backport-6.12/415-v6.14-mtd-rawnand-qcom-Fix-build-issue-on-x86-architecture.patch b/target/linux/generic/backport-6.12/415-v6.14-mtd-rawnand-qcom-Fix-build-issue-on-x86-architecture.patch
new file mode 100644
index 0000000000..67beed38d5
--- /dev/null
+++ b/target/linux/generic/backport-6.12/415-v6.14-mtd-rawnand-qcom-Fix-build-issue-on-x86-architecture.patch
@@ -0,0 +1,77 @@
+From b9371866799d67a80be0ea9e01bd41987db22f26 Mon Sep 17 00:00:00 2001
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Mon, 6 Jan 2025 18:45:58 +0530
+Subject: [PATCH] mtd: rawnand: qcom: Fix build issue on x86 architecture
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Fix a buffer overflow issue in qcom_clear_bam_transaction by using
+struct_group to group related fields and avoid FORTIFY_SOURCE warnings.
+
+On x86 architecture, the following error occurs due to warnings being
+treated as errors:
+
+In function ‘fortify_memset_chk’,
+    inlined from ‘qcom_clear_bam_transaction’ at
+drivers/mtd/nand/qpic_common.c:88:2:
+./include/linux/fortify-string.h:480:25: error: call to ‘__write_overflow_field’
+declared with attribute warning: detected write beyond size of field
+(1st parameter); maybe use struct_group()? [-Werror=attribute-warning]
+  480 |                         __write_overflow_field(p_size_field, size);
+      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  LD [M]  drivers/mtd/nand/nandcore.o
+  CC [M]  drivers/w1/masters/mxc_w1.o
+cc1: all warnings being treated as errors
+
+This patch addresses the issue by grouping the related fields in
+struct bam_transaction using struct_group and updating the memset call
+accordingly.
+
+Fixes: 8c52932da5e6 ("mtd: rawnand: qcom: cleanup qcom_nandc driver")
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/mtd/nand/qpic_common.c       |  2 +-
+ include/linux/mtd/nand-qpic-common.h | 19 +++++++++++--------
+ 2 files changed, 12 insertions(+), 9 deletions(-)
+
+--- a/drivers/mtd/nand/qpic_common.c
++++ b/drivers/mtd/nand/qpic_common.c
+@@ -85,7 +85,7 @@ void qcom_clear_bam_transaction(struct q
+ 	if (!nandc->props->supports_bam)
+ 		return;
+ 
+-	memset(&bam_txn->bam_ce_pos, 0, sizeof(u32) * 8);
++	memset(&bam_txn->bam_positions, 0, sizeof(bam_txn->bam_positions));
+ 	bam_txn->last_data_desc = NULL;
+ 
+ 	sg_init_table(bam_txn->cmd_sgl, nandc->max_cwperpage *
+--- a/include/linux/mtd/nand-qpic-common.h
++++ b/include/linux/mtd/nand-qpic-common.h
+@@ -254,14 +254,17 @@ struct bam_transaction {
+ 	struct dma_async_tx_descriptor *last_data_desc;
+ 	struct dma_async_tx_descriptor *last_cmd_desc;
+ 	struct completion txn_done;
+-	u32 bam_ce_pos;
+-	u32 bam_ce_start;
+-	u32 cmd_sgl_pos;
+-	u32 cmd_sgl_start;
+-	u32 tx_sgl_pos;
+-	u32 tx_sgl_start;
+-	u32 rx_sgl_pos;
+-	u32 rx_sgl_start;
++	struct_group(bam_positions,
++		u32 bam_ce_pos;
++		u32 bam_ce_start;
++		u32 cmd_sgl_pos;
++		u32 cmd_sgl_start;
++		u32 tx_sgl_pos;
++		u32 tx_sgl_start;
++		u32 rx_sgl_pos;
++		u32 rx_sgl_start;
++
++	);
+ };
+ 
+ /*
diff --git a/target/linux/generic/backport-6.12/416-v6.15-01-spi-spi-qpic-add-driver-for-QCOM-SPI-NAND-flash-Inte.patch b/target/linux/generic/backport-6.12/416-v6.15-01-spi-spi-qpic-add-driver-for-QCOM-SPI-NAND-flash-Inte.patch
new file mode 100644
index 0000000000..310d90233f
--- /dev/null
+++ b/target/linux/generic/backport-6.12/416-v6.15-01-spi-spi-qpic-add-driver-for-QCOM-SPI-NAND-flash-Inte.patch
@@ -0,0 +1,1737 @@
+From 7304d1909080ef0c9da703500a97f46c98393fcd Mon Sep 17 00:00:00 2001
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Mon, 24 Feb 2025 16:44:14 +0530
+Subject: [PATCH] spi: spi-qpic: add driver for QCOM SPI NAND flash Interface
+
+This driver implements support for the SPI-NAND mode of QCOM NAND Flash
+Interface as a SPI-MEM controller with pipelined ECC capability.
+
+Co-developed-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Signed-off-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Co-developed-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+Link: https://patch.msgid.link/20250224111414.2809669-3-quic_mdalam@quicinc.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/mtd/nand/Makefile            |    4 +
+ drivers/spi/Kconfig                  |    9 +
+ drivers/spi/Makefile                 |    1 +
+ drivers/spi/spi-qpic-snand.c         | 1631 ++++++++++++++++++++++++++
+ include/linux/mtd/nand-qpic-common.h |    7 +
+ 5 files changed, 1652 insertions(+)
+ create mode 100644 drivers/spi/spi-qpic-snand.c
+
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -3,7 +3,11 @@
+ nandcore-objs := core.o bbt.o
+ obj-$(CONFIG_MTD_NAND_CORE) += nandcore.o
+ obj-$(CONFIG_MTD_NAND_ECC_MEDIATEK) += ecc-mtk.o
++ifeq ($(CONFIG_SPI_QPIC_SNAND),y)
++obj-$(CONFIG_SPI_QPIC_SNAND) += qpic_common.o
++else
+ obj-$(CONFIG_MTD_NAND_QCOM) += qpic_common.o
++endif
+ obj-y	+= onenand/
+ obj-y	+= raw/
+ obj-y	+= spi/
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -898,6 +898,15 @@ config SPI_QCOM_QSPI
+ 	help
+ 	  QSPI(Quad SPI) driver for Qualcomm QSPI controller.
+ 
++config SPI_QPIC_SNAND
++	bool "QPIC SNAND controller"
++	depends on ARCH_QCOM || COMPILE_TEST
++	select MTD
++	help
++	  QPIC_SNAND (QPIC SPI NAND) driver for Qualcomm QPIC controller.
++	  QPIC controller supports both parallel nand and serial nand.
++	  This config will enable serial nand driver for QPIC controller.
++
+ config SPI_QUP
+ 	tristate "Qualcomm SPI controller with QUP interface"
+ 	depends on ARCH_QCOM || COMPILE_TEST
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -114,6 +114,7 @@ obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-
+ obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
+ obj-$(CONFIG_SPI_QCOM_GENI)		+= spi-geni-qcom.o
+ obj-$(CONFIG_SPI_QCOM_QSPI)		+= spi-qcom-qspi.o
++obj-$(CONFIG_SPI_QPIC_SNAND)            += spi-qpic-snand.o
+ obj-$(CONFIG_SPI_QUP)			+= spi-qup.o
+ obj-$(CONFIG_SPI_ROCKCHIP)		+= spi-rockchip.o
+ obj-$(CONFIG_SPI_ROCKCHIP_SFC)		+= spi-rockchip-sfc.o
+--- /dev/null
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -0,0 +1,1631 @@
++/*
++ * SPDX-License-Identifier: GPL-2.0
++ *
++ * Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
++ *
++ * Authors:
++ *	Md Sadre Alam <quic_mdalam@quicinc.com>
++ *	Sricharan R <quic_srichara@quicinc.com>
++ *	Varadarajan Narayanan <quic_varada@quicinc.com>
++ */
++#include <linux/bitops.h>
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/dmaengine.h>
++#include <linux/dma-mapping.h>
++#include <linux/dma/qcom_adm.h>
++#include <linux/dma/qcom_bam_dma.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/mtd/nand-qpic-common.h>
++#include <linux/mtd/spinand.h>
++#include <linux/bitfield.h>
++
++#define NAND_FLASH_SPI_CFG		0xc0
++#define NAND_NUM_ADDR_CYCLES		0xc4
++#define NAND_BUSY_CHECK_WAIT_CNT	0xc8
++#define NAND_FLASH_FEATURES		0xf64
++
++/* QSPI NAND config reg bits */
++#define LOAD_CLK_CNTR_INIT_EN		BIT(28)
++#define CLK_CNTR_INIT_VAL_VEC		0x924
++#define CLK_CNTR_INIT_VAL_VEC_MASK	GENMASK(27, 16)
++#define FEA_STATUS_DEV_ADDR		0xc0
++#define FEA_STATUS_DEV_ADDR_MASK	GENMASK(15, 8)
++#define SPI_CFG				BIT(0)
++#define SPI_NUM_ADDR			0xDA4DB
++#define SPI_WAIT_CNT			0x10
++#define QPIC_QSPI_NUM_CS		1
++#define SPI_TRANSFER_MODE_x1		BIT(29)
++#define SPI_TRANSFER_MODE_x4		(3 << 29)
++#define SPI_WP				BIT(28)
++#define SPI_HOLD			BIT(27)
++#define QPIC_SET_FEATURE		BIT(31)
++
++#define SPINAND_RESET			0xff
++#define SPINAND_READID			0x9f
++#define SPINAND_GET_FEATURE		0x0f
++#define SPINAND_SET_FEATURE		0x1f
++#define SPINAND_READ			0x13
++#define SPINAND_ERASE			0xd8
++#define SPINAND_WRITE_EN		0x06
++#define SPINAND_PROGRAM_EXECUTE		0x10
++#define SPINAND_PROGRAM_LOAD		0x84
++
++#define ACC_FEATURE			0xe
++#define BAD_BLOCK_MARKER_SIZE		0x2
++#define OOB_BUF_SIZE			128
++#define ecceng_to_qspi(eng)		container_of(eng, struct qpic_spi_nand, ecc_eng)
++
++struct qpic_snand_op {
++	u32 cmd_reg;
++	u32 addr1_reg;
++	u32 addr2_reg;
++};
++
++struct snandc_read_status {
++	__le32 snandc_flash;
++	__le32 snandc_buffer;
++	__le32 snandc_erased_cw;
++};
++
++/*
++ * ECC state struct
++ * @corrected:		ECC corrected
++ * @bitflips:		Max bit flip
++ * @failed:		ECC failed
++ */
++struct qcom_ecc_stats {
++	u32 corrected;
++	u32 bitflips;
++	u32 failed;
++};
++
++struct qpic_ecc {
++	struct device *dev;
++	int ecc_bytes_hw;
++	int spare_bytes;
++	int bbm_size;
++	int ecc_mode;
++	int bytes;
++	int steps;
++	int step_size;
++	int strength;
++	int cw_size;
++	int cw_data;
++	u32 cfg0;
++	u32 cfg1;
++	u32 cfg0_raw;
++	u32 cfg1_raw;
++	u32 ecc_buf_cfg;
++	u32 ecc_bch_cfg;
++	u32 clrflashstatus;
++	u32 clrreadstatus;
++	bool bch_enabled;
++};
++
++struct qpic_spi_nand {
++	struct qcom_nand_controller *snandc;
++	struct spi_controller *ctlr;
++	struct mtd_info *mtd;
++	struct clk *iomacro_clk;
++	struct qpic_ecc *ecc;
++	struct qcom_ecc_stats ecc_stats;
++	struct nand_ecc_engine ecc_eng;
++	u8 *data_buf;
++	u8 *oob_buf;
++	u32 wlen;
++	__le32 addr1;
++	__le32 addr2;
++	__le32 cmd;
++	u32 num_cw;
++	bool oob_rw;
++	bool page_rw;
++	bool raw_rw;
++};
++
++static void qcom_spi_set_read_loc_first(struct qcom_nand_controller *snandc,
++					int reg, int cw_offset, int read_size,
++					int is_last_read_loc)
++{
++	__le32 locreg_val;
++	u32 val = (((cw_offset) << READ_LOCATION_OFFSET) |
++		  ((read_size) << READ_LOCATION_SIZE) | ((is_last_read_loc)
++		  << READ_LOCATION_LAST));
++
++	locreg_val = cpu_to_le32(val);
++
++	if (reg == NAND_READ_LOCATION_0)
++		snandc->regs->read_location0 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_1)
++		snandc->regs->read_location1 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_2)
++		snandc->regs->read_location1 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_3)
++		snandc->regs->read_location3 = locreg_val;
++}
++
++static void qcom_spi_set_read_loc_last(struct qcom_nand_controller *snandc,
++				       int reg, int cw_offset, int read_size,
++				       int is_last_read_loc)
++{
++	__le32 locreg_val;
++	u32 val = (((cw_offset) << READ_LOCATION_OFFSET) |
++		  ((read_size) << READ_LOCATION_SIZE) | ((is_last_read_loc)
++		  << READ_LOCATION_LAST));
++
++	locreg_val = cpu_to_le32(val);
++
++	if (reg == NAND_READ_LOCATION_LAST_CW_0)
++		snandc->regs->read_location_last0 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_LAST_CW_1)
++		snandc->regs->read_location_last1 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_LAST_CW_2)
++		snandc->regs->read_location_last2 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_LAST_CW_3)
++		snandc->regs->read_location_last3 = locreg_val;
++}
++
++static struct qcom_nand_controller *nand_to_qcom_snand(struct nand_device *nand)
++{
++	struct nand_ecc_engine *eng = nand->ecc.engine;
++	struct qpic_spi_nand *qspi = ecceng_to_qspi(eng);
++
++	return qspi->snandc;
++}
++
++static int qcom_spi_init(struct qcom_nand_controller *snandc)
++{
++	u32 snand_cfg_val = 0x0;
++	int ret;
++
++	snand_cfg_val = FIELD_PREP(CLK_CNTR_INIT_VAL_VEC_MASK, CLK_CNTR_INIT_VAL_VEC) |
++			FIELD_PREP(LOAD_CLK_CNTR_INIT_EN, 0) |
++			FIELD_PREP(FEA_STATUS_DEV_ADDR_MASK, FEA_STATUS_DEV_ADDR) |
++			FIELD_PREP(SPI_CFG, 0);
++
++	snandc->regs->spi_cfg = cpu_to_le32(snand_cfg_val);
++	snandc->regs->num_addr_cycle = cpu_to_le32(SPI_NUM_ADDR);
++	snandc->regs->busy_wait_cnt = cpu_to_le32(SPI_WAIT_CNT);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->spi_cfg, NAND_FLASH_SPI_CFG, 1, 0);
++
++	snand_cfg_val &= ~LOAD_CLK_CNTR_INIT_EN;
++	snandc->regs->spi_cfg = cpu_to_le32(snand_cfg_val);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->spi_cfg, NAND_FLASH_SPI_CFG, 1, 0);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->num_addr_cycle, NAND_NUM_ADDR_CYCLES, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->busy_wait_cnt, NAND_BUSY_CHECK_WAIT_CNT, 1,
++			   NAND_BAM_NEXT_SGL);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure in submitting spi init descriptor\n");
++		return ret;
++	}
++
++	return ret;
++}
++
++static int qcom_spi_ooblayout_ecc(struct mtd_info *mtd, int section,
++				  struct mtd_oob_region *oobregion)
++{
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct qpic_ecc *qecc = snandc->qspi->ecc;
++
++	if (section > 1)
++		return -ERANGE;
++
++	oobregion->length = qecc->ecc_bytes_hw + qecc->spare_bytes;
++	oobregion->offset = mtd->oobsize - oobregion->length;
++
++	return 0;
++}
++
++static int qcom_spi_ooblayout_free(struct mtd_info *mtd, int section,
++				   struct mtd_oob_region *oobregion)
++{
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct qpic_ecc *qecc = snandc->qspi->ecc;
++
++	if (section)
++		return -ERANGE;
++
++	oobregion->length = qecc->steps * 4;
++	oobregion->offset = ((qecc->steps - 1) * qecc->bytes) + qecc->bbm_size;
++
++	return 0;
++}
++
++static const struct mtd_ooblayout_ops qcom_spi_ooblayout = {
++	.ecc = qcom_spi_ooblayout_ecc,
++	.free = qcom_spi_ooblayout_free,
++};
++
++static int qcom_spi_ecc_init_ctx_pipelined(struct nand_device *nand)
++{
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct nand_ecc_props *conf = &nand->ecc.ctx.conf;
++	struct mtd_info *mtd = nanddev_to_mtd(nand);
++	int cwperpage, bad_block_byte;
++	struct qpic_ecc *ecc_cfg;
++
++	cwperpage = mtd->writesize / NANDC_STEP_SIZE;
++	snandc->qspi->num_cw = cwperpage;
++
++	ecc_cfg = kzalloc(sizeof(*ecc_cfg), GFP_KERNEL);
++	if (!ecc_cfg)
++		return -ENOMEM;
++	snandc->qspi->oob_buf = kzalloc(mtd->writesize + mtd->oobsize,
++					GFP_KERNEL);
++	if (!snandc->qspi->oob_buf)
++		return -ENOMEM;
++
++	memset(snandc->qspi->oob_buf, 0xff, mtd->writesize + mtd->oobsize);
++
++	nand->ecc.ctx.priv = ecc_cfg;
++	snandc->qspi->mtd = mtd;
++
++	ecc_cfg->ecc_bytes_hw = 7;
++	ecc_cfg->spare_bytes = 4;
++	ecc_cfg->bbm_size = 1;
++	ecc_cfg->bch_enabled = true;
++	ecc_cfg->bytes = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes + ecc_cfg->bbm_size;
++
++	ecc_cfg->steps = 4;
++	ecc_cfg->strength = 4;
++	ecc_cfg->step_size = 512;
++	ecc_cfg->cw_data = 516;
++	ecc_cfg->cw_size = ecc_cfg->cw_data + ecc_cfg->bytes;
++	bad_block_byte = mtd->writesize - ecc_cfg->cw_size * (cwperpage - 1) + 1;
++
++	mtd_set_ooblayout(mtd, &qcom_spi_ooblayout);
++
++	ecc_cfg->cfg0 = FIELD_PREP(CW_PER_PAGE_MASK, (cwperpage - 1)) |
++			FIELD_PREP(UD_SIZE_BYTES_MASK, ecc_cfg->cw_data) |
++			FIELD_PREP(DISABLE_STATUS_AFTER_WRITE, 1) |
++			FIELD_PREP(NUM_ADDR_CYCLES_MASK, 3) |
++			FIELD_PREP(ECC_PARITY_SIZE_BYTES_RS, ecc_cfg->ecc_bytes_hw) |
++			FIELD_PREP(STATUS_BFR_READ, 0) |
++			FIELD_PREP(SET_RD_MODE_AFTER_STATUS, 1) |
++			FIELD_PREP(SPARE_SIZE_BYTES_MASK, ecc_cfg->spare_bytes);
++
++	ecc_cfg->cfg1 = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 0) |
++			FIELD_PREP(CS_ACTIVE_BSY, 0) |
++			FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, bad_block_byte) |
++			FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 0) |
++			FIELD_PREP(WR_RD_BSY_GAP_MASK, 20) |
++			FIELD_PREP(WIDE_FLASH, 0) |
++			FIELD_PREP(ENABLE_BCH_ECC, ecc_cfg->bch_enabled);
++
++	ecc_cfg->cfg0_raw = FIELD_PREP(CW_PER_PAGE_MASK, (cwperpage - 1)) |
++			    FIELD_PREP(NUM_ADDR_CYCLES_MASK, 3) |
++			    FIELD_PREP(UD_SIZE_BYTES_MASK, ecc_cfg->cw_size) |
++			    FIELD_PREP(SPARE_SIZE_BYTES_MASK, 0);
++
++	ecc_cfg->cfg1_raw = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 0) |
++			    FIELD_PREP(CS_ACTIVE_BSY, 0) |
++			    FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, 17) |
++			    FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 1) |
++			    FIELD_PREP(WR_RD_BSY_GAP_MASK, 20) |
++			    FIELD_PREP(WIDE_FLASH, 0) |
++			    FIELD_PREP(DEV0_CFG1_ECC_DISABLE, 1);
++
++	ecc_cfg->ecc_bch_cfg = FIELD_PREP(ECC_CFG_ECC_DISABLE, !ecc_cfg->bch_enabled) |
++			       FIELD_PREP(ECC_SW_RESET, 0) |
++			       FIELD_PREP(ECC_NUM_DATA_BYTES_MASK, ecc_cfg->cw_data) |
++			       FIELD_PREP(ECC_FORCE_CLK_OPEN, 1) |
++			       FIELD_PREP(ECC_MODE_MASK, 0) |
++			       FIELD_PREP(ECC_PARITY_SIZE_BYTES_BCH_MASK, ecc_cfg->ecc_bytes_hw);
++
++	ecc_cfg->ecc_buf_cfg = 0x203 << NUM_STEPS;
++	ecc_cfg->clrflashstatus = FS_READY_BSY_N;
++	ecc_cfg->clrreadstatus = 0xc0;
++
++	conf->step_size = ecc_cfg->step_size;
++	conf->strength = ecc_cfg->strength;
++
++	snandc->regs->erased_cw_detect_cfg_clr = cpu_to_le32(CLR_ERASED_PAGE_DET);
++	snandc->regs->erased_cw_detect_cfg_set = cpu_to_le32(SET_ERASED_PAGE_DET);
++
++	dev_dbg(snandc->dev, "ECC strength: %u bits per %u bytes\n",
++		ecc_cfg->strength, ecc_cfg->step_size);
++
++	return 0;
++}
++
++static void qcom_spi_ecc_cleanup_ctx_pipelined(struct nand_device *nand)
++{
++	struct qpic_ecc *ecc_cfg = nand_to_ecc_ctx(nand);
++
++	kfree(ecc_cfg);
++}
++
++static int qcom_spi_ecc_prepare_io_req_pipelined(struct nand_device *nand,
++						 struct nand_page_io_req *req)
++{
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct qpic_ecc *ecc_cfg = nand_to_ecc_ctx(nand);
++
++	snandc->qspi->ecc = ecc_cfg;
++	snandc->qspi->raw_rw = false;
++	snandc->qspi->oob_rw = false;
++	snandc->qspi->page_rw = false;
++
++	if (req->datalen)
++		snandc->qspi->page_rw = true;
++
++	if (req->ooblen)
++		snandc->qspi->oob_rw = true;
++
++	if (req->mode == MTD_OPS_RAW)
++		snandc->qspi->raw_rw = true;
++
++	return 0;
++}
++
++static int qcom_spi_ecc_finish_io_req_pipelined(struct nand_device *nand,
++						struct nand_page_io_req *req)
++{
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct mtd_info *mtd = nanddev_to_mtd(nand);
++
++	if (req->mode == MTD_OPS_RAW || req->type != NAND_PAGE_READ)
++		return 0;
++
++	if (snandc->qspi->ecc_stats.failed)
++		mtd->ecc_stats.failed += snandc->qspi->ecc_stats.failed;
++	else
++		mtd->ecc_stats.corrected += snandc->qspi->ecc_stats.corrected;
++
++	if (snandc->qspi->ecc_stats.failed)
++		return -EBADMSG;
++	else
++		return snandc->qspi->ecc_stats.bitflips;
++}
++
++static struct nand_ecc_engine_ops qcom_spi_ecc_engine_ops_pipelined = {
++	.init_ctx = qcom_spi_ecc_init_ctx_pipelined,
++	.cleanup_ctx = qcom_spi_ecc_cleanup_ctx_pipelined,
++	.prepare_io_req = qcom_spi_ecc_prepare_io_req_pipelined,
++	.finish_io_req = qcom_spi_ecc_finish_io_req_pipelined,
++};
++
++/* helper to configure location register values */
++static void qcom_spi_set_read_loc(struct qcom_nand_controller *snandc, int cw, int reg,
++				  int cw_offset, int read_size, int is_last_read_loc)
++{
++	int reg_base = NAND_READ_LOCATION_0;
++	int num_cw = snandc->qspi->num_cw;
++
++	if (cw == (num_cw - 1))
++		reg_base = NAND_READ_LOCATION_LAST_CW_0;
++
++	reg_base += reg * 4;
++
++	if (cw == (num_cw - 1))
++		return qcom_spi_set_read_loc_last(snandc, reg_base, cw_offset,
++						  read_size, is_last_read_loc);
++	else
++		return qcom_spi_set_read_loc_first(snandc, reg_base, cw_offset,
++						   read_size, is_last_read_loc);
++}
++
++static void
++qcom_spi_config_cw_read(struct qcom_nand_controller *snandc, bool use_ecc, int cw)
++{
++	__le32 *reg = &snandc->regs->read_location0;
++	int num_cw = snandc->qspi->num_cw;
++
++	qcom_write_reg_dma(snandc, reg, NAND_READ_LOCATION_0, 4, NAND_BAM_NEXT_SGL);
++	if (cw == (num_cw - 1)) {
++		reg = &snandc->regs->read_location_last0;
++		qcom_write_reg_dma(snandc, reg, NAND_READ_LOCATION_LAST_CW_0, 4,
++				   NAND_BAM_NEXT_SGL);
++	}
++
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++
++	qcom_read_reg_dma(snandc, NAND_FLASH_STATUS, 2, 0);
++	qcom_read_reg_dma(snandc, NAND_ERASED_CW_DETECT_STATUS, 1,
++			  NAND_BAM_NEXT_SGL);
++}
++
++static int qcom_spi_block_erase(struct qcom_nand_controller *snandc)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	int ret;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cfg0 = cpu_to_le32(ecc_cfg->cfg0_raw & ~(7 << CW_PER_PAGE));
++	snandc->regs->cfg1 = cpu_to_le32(ecc_cfg->cfg1_raw);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 3, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to erase block\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static void qcom_spi_config_single_cw_page_read(struct qcom_nand_controller *snandc,
++						bool use_ecc, int cw)
++{
++	__le32 *reg = &snandc->regs->read_location0;
++	int num_cw = snandc->qspi->num_cw;
++
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1,
++			   NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++
++	if (cw == (num_cw - 1)) {
++		reg = &snandc->regs->read_location_last0;
++		qcom_write_reg_dma(snandc, reg, NAND_READ_LOCATION_LAST_CW_0, 4, NAND_BAM_NEXT_SGL);
++	}
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++
++	qcom_read_reg_dma(snandc, NAND_FLASH_STATUS, 1, 0);
++}
++
++static int qcom_spi_read_last_cw(struct qcom_nand_controller *snandc,
++				 const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	struct mtd_info *mtd = snandc->qspi->mtd;
++	int size, ret = 0;
++	int col,  bbpos;
++	u32 cfg0, cfg1, ecc_bch_cfg;
++	u32 num_cw = snandc->qspi->num_cw;
++
++	qcom_clear_bam_transaction(snandc);
++	qcom_clear_read_regs(snandc);
++
++	size = ecc_cfg->cw_size;
++	col = ecc_cfg->cw_size * (num_cw - 1);
++
++	memset(snandc->data_buffer, 0xff, size);
++	snandc->regs->addr0 = (snandc->qspi->addr1 | cpu_to_le32(col));
++	snandc->regs->addr1 = snandc->qspi->addr2;
++
++	cfg0 = (ecc_cfg->cfg0_raw & ~(7U << CW_PER_PAGE)) |
++		0 << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1_raw;
++	ecc_bch_cfg = 1 << ECC_CFG_ECC_DISABLE;
++
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_set_read_loc(snandc, num_cw - 1, 0, 0, ecc_cfg->cw_size, 1);
++
++	qcom_spi_config_single_cw_page_read(snandc, false, num_cw - 1);
++
++	qcom_read_data_dma(snandc, FLASH_BUF_ACC, snandc->data_buffer, size, 0);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failed to read last cw\n");
++		return ret;
++	}
++
++	qcom_nandc_dev_to_mem(snandc, true);
++	u32 flash = le32_to_cpu(snandc->reg_read_buf[0]);
++
++	if (flash & (FS_OP_ERR | FS_MPU_ERR))
++		return -EIO;
++
++	bbpos = mtd->writesize - ecc_cfg->cw_size * (num_cw - 1);
++
++	if (snandc->data_buffer[bbpos] == 0xff)
++		snandc->data_buffer[bbpos + 1] = 0xff;
++	if (snandc->data_buffer[bbpos] != 0xff)
++		snandc->data_buffer[bbpos + 1] = snandc->data_buffer[bbpos];
++
++	memcpy(op->data.buf.in, snandc->data_buffer + bbpos, op->data.nbytes);
++
++	return ret;
++}
++
++static int qcom_spi_check_error(struct qcom_nand_controller *snandc, u8 *data_buf, u8 *oob_buf)
++{
++	struct snandc_read_status *buf;
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	int i, num_cw = snandc->qspi->num_cw;
++	bool flash_op_err = false, erased;
++	unsigned int max_bitflips = 0;
++	unsigned int uncorrectable_cws = 0;
++
++	snandc->qspi->ecc_stats.failed = 0;
++	snandc->qspi->ecc_stats.corrected = 0;
++
++	qcom_nandc_dev_to_mem(snandc, true);
++	buf = (struct snandc_read_status *)snandc->reg_read_buf;
++
++	for (i = 0; i < num_cw; i++, buf++) {
++		u32 flash, buffer, erased_cw;
++		int data_len, oob_len;
++
++		if (i == (num_cw - 1)) {
++			data_len = NANDC_STEP_SIZE - ((num_cw - 1) << 2);
++			oob_len = num_cw << 2;
++		} else {
++			data_len = ecc_cfg->cw_data;
++			oob_len = 0;
++		}
++
++		flash = le32_to_cpu(buf->snandc_flash);
++		buffer = le32_to_cpu(buf->snandc_buffer);
++		erased_cw = le32_to_cpu(buf->snandc_erased_cw);
++
++		if ((flash & FS_OP_ERR) && (buffer & BS_UNCORRECTABLE_BIT)) {
++			if (ecc_cfg->bch_enabled)
++				erased = (erased_cw & ERASED_CW) == ERASED_CW;
++			else
++				erased = false;
++
++			if (!erased)
++				uncorrectable_cws |= BIT(i);
++
++		} else if (flash & (FS_OP_ERR | FS_MPU_ERR)) {
++			flash_op_err = true;
++		} else {
++			unsigned int stat;
++
++			stat = buffer & BS_CORRECTABLE_ERR_MSK;
++			snandc->qspi->ecc_stats.corrected += stat;
++			max_bitflips = max(max_bitflips, stat);
++		}
++
++		if (data_buf)
++			data_buf += data_len;
++		if (oob_buf)
++			oob_buf += oob_len + ecc_cfg->bytes;
++	}
++
++	if (flash_op_err)
++		return -EIO;
++
++	if (!uncorrectable_cws)
++		snandc->qspi->ecc_stats.bitflips = max_bitflips;
++	else
++		snandc->qspi->ecc_stats.failed++;
++
++	return 0;
++}
++
++static int qcom_spi_check_raw_flash_errors(struct qcom_nand_controller *snandc, int cw_cnt)
++{
++	int i;
++
++	qcom_nandc_dev_to_mem(snandc, true);
++
++	for (i = 0; i < cw_cnt; i++) {
++		u32 flash = le32_to_cpu(snandc->reg_read_buf[i]);
++
++		if (flash & (FS_OP_ERR | FS_MPU_ERR))
++			return -EIO;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_read_cw_raw(struct qcom_nand_controller *snandc, u8 *data_buf,
++				u8 *oob_buf, int cw)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	struct mtd_info *mtd = snandc->qspi->mtd;
++	int data_size1, data_size2, oob_size1, oob_size2;
++	int ret, reg_off = FLASH_BUF_ACC, read_loc = 0;
++	int raw_cw = cw;
++	u32 cfg0, cfg1, ecc_bch_cfg, num_cw = snandc->qspi->num_cw;
++	int col;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++	raw_cw = num_cw - 1;
++
++	cfg0 = (ecc_cfg->cfg0_raw & ~(7U << CW_PER_PAGE)) |
++				0 << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1_raw;
++	ecc_bch_cfg = ECC_CFG_ECC_DISABLE;
++
++	col = ecc_cfg->cw_size * cw;
++
++	snandc->regs->addr0 = (snandc->qspi->addr1 | cpu_to_le32(col));
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_set_read_loc(snandc, raw_cw, 0, 0, ecc_cfg->cw_size, 1);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1, 0);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1,
++			   NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++
++	data_size1 = mtd->writesize - ecc_cfg->cw_size * (num_cw - 1);
++	oob_size1 = ecc_cfg->bbm_size;
++
++	if (cw == (num_cw - 1)) {
++		data_size2 = NANDC_STEP_SIZE - data_size1 -
++			     ((num_cw - 1) * 4);
++		oob_size2 = (num_cw * 4) + ecc_cfg->ecc_bytes_hw +
++			    ecc_cfg->spare_bytes;
++	} else {
++		data_size2 = ecc_cfg->cw_data - data_size1;
++		oob_size2 = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes;
++	}
++
++	qcom_spi_set_read_loc(snandc, cw, 0, read_loc, data_size1, 0);
++	read_loc += data_size1;
++
++	qcom_spi_set_read_loc(snandc, cw, 1, read_loc, oob_size1, 0);
++	read_loc += oob_size1;
++
++	qcom_spi_set_read_loc(snandc, cw, 2, read_loc, data_size2, 0);
++	read_loc += data_size2;
++
++	qcom_spi_set_read_loc(snandc, cw, 3, read_loc, oob_size2, 1);
++
++	qcom_spi_config_cw_read(snandc, false, raw_cw);
++
++	qcom_read_data_dma(snandc, reg_off, data_buf, data_size1, 0);
++	reg_off += data_size1;
++
++	qcom_read_data_dma(snandc, reg_off, oob_buf, oob_size1, 0);
++	reg_off += oob_size1;
++
++	qcom_read_data_dma(snandc, reg_off, data_buf + data_size1, data_size2, 0);
++	reg_off += data_size2;
++
++	qcom_read_data_dma(snandc, reg_off, oob_buf + oob_size1, oob_size2, 0);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to read raw cw %d\n", cw);
++		return ret;
++	}
++
++	return qcom_spi_check_raw_flash_errors(snandc, 1);
++}
++
++static int qcom_spi_read_page_raw(struct qcom_nand_controller *snandc,
++				  const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *data_buf = NULL, *oob_buf = NULL;
++	int ret, cw;
++	u32 num_cw = snandc->qspi->num_cw;
++
++	if (snandc->qspi->page_rw)
++		data_buf = op->data.buf.in;
++
++	oob_buf = snandc->qspi->oob_buf;
++	memset(oob_buf, 0xff, OOB_BUF_SIZE);
++
++	for (cw = 0; cw < num_cw; cw++) {
++		ret = qcom_spi_read_cw_raw(snandc, data_buf, oob_buf, cw);
++		if (ret)
++			return ret;
++
++		if (data_buf)
++			data_buf += ecc_cfg->cw_data;
++		if (oob_buf)
++			oob_buf += ecc_cfg->bytes;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_read_page_ecc(struct qcom_nand_controller *snandc,
++				  const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *data_buf = NULL, *data_buf_start, *oob_buf = NULL, *oob_buf_start;
++	int ret, i;
++	u32 cfg0, cfg1, ecc_bch_cfg, num_cw = snandc->qspi->num_cw;
++
++	data_buf = op->data.buf.in;
++	data_buf_start = data_buf;
++
++	oob_buf = snandc->qspi->oob_buf;
++	oob_buf_start = oob_buf;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++
++	cfg0 = (ecc_cfg->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1;
++	ecc_bch_cfg = ecc_cfg->ecc_bch_cfg;
++
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_set_read_loc(snandc, 0, 0, 0, ecc_cfg->cw_data, 1);
++
++	qcom_clear_bam_transaction(snandc);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1,
++			   NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++
++	for (i = 0; i < num_cw; i++) {
++		int data_size, oob_size;
++
++		if (i == (num_cw - 1)) {
++			data_size = 512 - ((num_cw - 1) << 2);
++			oob_size = (num_cw << 2) + ecc_cfg->ecc_bytes_hw +
++				    ecc_cfg->spare_bytes;
++		} else {
++			data_size = ecc_cfg->cw_data;
++			oob_size = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes;
++		}
++
++		if (data_buf && oob_buf) {
++			qcom_spi_set_read_loc(snandc, i, 0, 0, data_size, 0);
++			qcom_spi_set_read_loc(snandc, i, 1, data_size, oob_size, 1);
++		} else if (data_buf) {
++			qcom_spi_set_read_loc(snandc, i, 0, 0, data_size, 1);
++		} else {
++			qcom_spi_set_read_loc(snandc, i, 0, data_size, oob_size, 1);
++		}
++
++		qcom_spi_config_cw_read(snandc, true, i);
++
++		if (data_buf)
++			qcom_read_data_dma(snandc, FLASH_BUF_ACC, data_buf,
++					   data_size, 0);
++		if (oob_buf) {
++			int j;
++
++			for (j = 0; j < ecc_cfg->bbm_size; j++)
++				*oob_buf++ = 0xff;
++
++			qcom_read_data_dma(snandc, FLASH_BUF_ACC + data_size,
++					   oob_buf, oob_size, 0);
++		}
++
++		if (data_buf)
++			data_buf += data_size;
++		if (oob_buf)
++			oob_buf += oob_size;
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to read page\n");
++		return ret;
++	}
++
++	return qcom_spi_check_error(snandc, data_buf_start, oob_buf_start);
++}
++
++static int qcom_spi_read_page_oob(struct qcom_nand_controller *snandc,
++				  const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *data_buf = NULL, *data_buf_start, *oob_buf = NULL, *oob_buf_start;
++	int ret, i;
++	u32 cfg0, cfg1, ecc_bch_cfg, num_cw = snandc->qspi->num_cw;
++
++	oob_buf = op->data.buf.in;
++	oob_buf_start = oob_buf;
++
++	data_buf_start = data_buf;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	cfg0 = (ecc_cfg->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1;
++	ecc_bch_cfg = ecc_cfg->ecc_bch_cfg;
++
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_set_read_loc(snandc, 0, 0, 0, ecc_cfg->cw_data, 1);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1,
++			   NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++
++	for (i = 0; i < num_cw; i++) {
++		int data_size, oob_size;
++
++		if (i == (num_cw - 1)) {
++			data_size = NANDC_STEP_SIZE - ((num_cw - 1) << 2);
++			oob_size = (num_cw << 2) + ecc_cfg->ecc_bytes_hw +
++				    ecc_cfg->spare_bytes;
++		} else {
++			data_size = ecc_cfg->cw_data;
++			oob_size = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes;
++		}
++
++		qcom_spi_set_read_loc(snandc, i, 0, data_size, oob_size, 1);
++
++		qcom_spi_config_cw_read(snandc, true, i);
++
++		if (oob_buf) {
++			int j;
++
++			for (j = 0; j < ecc_cfg->bbm_size; j++)
++				*oob_buf++ = 0xff;
++
++			qcom_read_data_dma(snandc, FLASH_BUF_ACC + data_size,
++					   oob_buf, oob_size, 0);
++		}
++
++		if (oob_buf)
++			oob_buf += oob_size;
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to read oob\n");
++		return ret;
++	}
++
++	return qcom_spi_check_error(snandc, data_buf_start, oob_buf_start);
++}
++
++static int qcom_spi_read_page(struct qcom_nand_controller *snandc,
++			      const struct spi_mem_op *op)
++{
++	if (snandc->qspi->page_rw && snandc->qspi->raw_rw)
++		return qcom_spi_read_page_raw(snandc, op);
++
++	if (snandc->qspi->page_rw)
++		return qcom_spi_read_page_ecc(snandc, op);
++
++	if (snandc->qspi->oob_rw && snandc->qspi->raw_rw)
++		return qcom_spi_read_last_cw(snandc, op);
++
++	if (snandc->qspi->oob_rw)
++		return qcom_spi_read_page_oob(snandc, op);
++
++	return 0;
++}
++
++static void qcom_spi_config_page_write(struct qcom_nand_controller *snandc)
++{
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG,
++			   1, NAND_BAM_NEXT_SGL);
++}
++
++static void qcom_spi_config_cw_write(struct qcom_nand_controller *snandc)
++{
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(snandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->clrflashstatus, NAND_FLASH_STATUS, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->clrreadstatus, NAND_READ_STATUS, 1,
++			   NAND_BAM_NEXT_SGL);
++}
++
++static int qcom_spi_program_raw(struct qcom_nand_controller *snandc,
++				const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	struct mtd_info *mtd = snandc->qspi->mtd;
++	u8 *data_buf = NULL, *oob_buf = NULL;
++	int i, ret;
++	int num_cw = snandc->qspi->num_cw;
++	u32 cfg0, cfg1, ecc_bch_cfg;
++
++	cfg0 = (ecc_cfg->cfg0_raw & ~(7U << CW_PER_PAGE)) |
++			(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1_raw;
++	ecc_bch_cfg = ECC_CFG_ECC_DISABLE;
++
++	data_buf = snandc->qspi->data_buf;
++
++	oob_buf = snandc->qspi->oob_buf;
++	memset(oob_buf, 0xff, OOB_BUF_SIZE);
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_config_page_write(snandc);
++
++	for (i = 0; i < num_cw; i++) {
++		int data_size1, data_size2, oob_size1, oob_size2;
++		int reg_off = FLASH_BUF_ACC;
++
++		data_size1 = mtd->writesize - ecc_cfg->cw_size * (num_cw - 1);
++		oob_size1 = ecc_cfg->bbm_size;
++
++		if (i == (num_cw - 1)) {
++			data_size2 = NANDC_STEP_SIZE - data_size1 -
++				     ((num_cw - 1) << 2);
++			oob_size2 = (num_cw << 2) + ecc_cfg->ecc_bytes_hw +
++				    ecc_cfg->spare_bytes;
++		} else {
++			data_size2 = ecc_cfg->cw_data - data_size1;
++			oob_size2 = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes;
++		}
++
++		qcom_write_data_dma(snandc, reg_off, data_buf, data_size1,
++				    NAND_BAM_NO_EOT);
++		reg_off += data_size1;
++		data_buf += data_size1;
++
++		qcom_write_data_dma(snandc, reg_off, oob_buf, oob_size1,
++				    NAND_BAM_NO_EOT);
++		oob_buf += oob_size1;
++		reg_off += oob_size1;
++
++		qcom_write_data_dma(snandc, reg_off, data_buf, data_size2,
++				    NAND_BAM_NO_EOT);
++		reg_off += data_size2;
++		data_buf += data_size2;
++
++		qcom_write_data_dma(snandc, reg_off, oob_buf, oob_size2, 0);
++		oob_buf += oob_size2;
++
++		qcom_spi_config_cw_write(snandc);
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to write raw page\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_program_ecc(struct qcom_nand_controller *snandc,
++				const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *data_buf = NULL, *oob_buf = NULL;
++	int i, ret;
++	int num_cw = snandc->qspi->num_cw;
++	u32 cfg0, cfg1, ecc_bch_cfg, ecc_buf_cfg;
++
++	cfg0 = (ecc_cfg->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1;
++	ecc_bch_cfg = ecc_cfg->ecc_bch_cfg;
++	ecc_buf_cfg = ecc_cfg->ecc_buf_cfg;
++
++	if (snandc->qspi->data_buf)
++		data_buf = snandc->qspi->data_buf;
++
++	oob_buf = snandc->qspi->oob_buf;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->ecc_buf_cfg = cpu_to_le32(ecc_buf_cfg);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_config_page_write(snandc);
++
++	for (i = 0; i < num_cw; i++) {
++		int data_size, oob_size;
++
++		if (i == (num_cw - 1)) {
++			data_size = NANDC_STEP_SIZE - ((num_cw - 1) << 2);
++			oob_size = (num_cw << 2) + ecc_cfg->ecc_bytes_hw +
++				    ecc_cfg->spare_bytes;
++		} else {
++			data_size = ecc_cfg->cw_data;
++			oob_size = ecc_cfg->bytes;
++		}
++
++		if (data_buf)
++			qcom_write_data_dma(snandc, FLASH_BUF_ACC, data_buf, data_size,
++					    i == (num_cw - 1) ? NAND_BAM_NO_EOT : 0);
++
++		if (i == (num_cw - 1)) {
++			if (oob_buf) {
++				oob_buf += ecc_cfg->bbm_size;
++				qcom_write_data_dma(snandc, FLASH_BUF_ACC + data_size,
++						    oob_buf, oob_size, 0);
++			}
++		}
++
++		qcom_spi_config_cw_write(snandc);
++
++		if (data_buf)
++			data_buf += data_size;
++		if (oob_buf)
++			oob_buf += oob_size;
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to write page\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_program_oob(struct qcom_nand_controller *snandc,
++				const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *oob_buf = NULL;
++	int ret, col, data_size, oob_size;
++	int num_cw = snandc->qspi->num_cw;
++	u32 cfg0, cfg1, ecc_bch_cfg, ecc_buf_cfg;
++
++	cfg0 = (ecc_cfg->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1;
++	ecc_bch_cfg = ecc_cfg->ecc_bch_cfg;
++	ecc_buf_cfg = ecc_cfg->ecc_buf_cfg;
++
++	col = ecc_cfg->cw_size * (num_cw - 1);
++
++	oob_buf = snandc->qspi->data_buf;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++	snandc->regs->addr0 = (snandc->qspi->addr1 | cpu_to_le32(col));
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->ecc_buf_cfg = cpu_to_le32(ecc_buf_cfg);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	/* calculate the data and oob size for the last codeword/step */
++	data_size = NANDC_STEP_SIZE - ((num_cw - 1) << 2);
++	oob_size = snandc->qspi->mtd->oobavail;
++
++	memset(snandc->data_buffer, 0xff, ecc_cfg->cw_data);
++	/* override new oob content to last codeword */
++	mtd_ooblayout_get_databytes(snandc->qspi->mtd, snandc->data_buffer + data_size,
++				    oob_buf, 0, snandc->qspi->mtd->oobavail);
++	qcom_spi_config_page_write(snandc);
++	qcom_write_data_dma(snandc, FLASH_BUF_ACC, snandc->data_buffer, data_size + oob_size, 0);
++	qcom_spi_config_cw_write(snandc);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to write oob\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_program_execute(struct qcom_nand_controller *snandc,
++				    const struct spi_mem_op *op)
++{
++	if (snandc->qspi->page_rw && snandc->qspi->raw_rw)
++		return qcom_spi_program_raw(snandc, op);
++
++	if (snandc->qspi->page_rw)
++		return qcom_spi_program_ecc(snandc, op);
++
++	if (snandc->qspi->oob_rw)
++		return qcom_spi_program_oob(snandc, op);
++
++	return 0;
++}
++
++static int qcom_spi_cmd_mapping(struct qcom_nand_controller *snandc, u32 opcode, u32 *cmd)
++{
++	switch (opcode) {
++	case SPINAND_RESET:
++		*cmd = (SPI_WP | SPI_HOLD | SPI_TRANSFER_MODE_x1 | OP_RESET_DEVICE);
++		break;
++	case SPINAND_READID:
++		*cmd = (SPI_WP | SPI_HOLD | SPI_TRANSFER_MODE_x1 | OP_FETCH_ID);
++		break;
++	case SPINAND_GET_FEATURE:
++		*cmd = (SPI_TRANSFER_MODE_x1 | SPI_WP | SPI_HOLD | ACC_FEATURE);
++		break;
++	case SPINAND_SET_FEATURE:
++		*cmd = (SPI_TRANSFER_MODE_x1 | SPI_WP | SPI_HOLD | ACC_FEATURE |
++			QPIC_SET_FEATURE);
++		break;
++	case SPINAND_READ:
++		if (snandc->qspi->raw_rw) {
++			*cmd = (PAGE_ACC | LAST_PAGE | SPI_TRANSFER_MODE_x1 |
++					SPI_WP | SPI_HOLD | OP_PAGE_READ);
++		} else {
++			*cmd = (PAGE_ACC | LAST_PAGE | SPI_TRANSFER_MODE_x1 |
++					SPI_WP | SPI_HOLD | OP_PAGE_READ_WITH_ECC);
++		}
++
++		break;
++	case SPINAND_ERASE:
++		*cmd = OP_BLOCK_ERASE | PAGE_ACC | LAST_PAGE | SPI_WP |
++			SPI_HOLD | SPI_TRANSFER_MODE_x1;
++		break;
++	case SPINAND_WRITE_EN:
++		*cmd = SPINAND_WRITE_EN;
++		break;
++	case SPINAND_PROGRAM_EXECUTE:
++		*cmd = (PAGE_ACC | LAST_PAGE | SPI_TRANSFER_MODE_x1 |
++				SPI_WP | SPI_HOLD | OP_PROGRAM_PAGE);
++		break;
++	case SPINAND_PROGRAM_LOAD:
++		*cmd = SPINAND_PROGRAM_LOAD;
++		break;
++	default:
++		dev_err(snandc->dev, "Opcode not supported: %u\n", opcode);
++		return -EOPNOTSUPP;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_write_page(struct qcom_nand_controller *snandc,
++			       const struct spi_mem_op *op)
++{
++	int ret;
++	u32 cmd;
++
++	ret = qcom_spi_cmd_mapping(snandc, op->cmd.opcode, &cmd);
++	if (ret < 0)
++		return ret;
++
++	if (op->cmd.opcode == SPINAND_PROGRAM_LOAD)
++		snandc->qspi->data_buf = (u8 *)op->data.buf.out;
++
++	return 0;
++}
++
++static int qcom_spi_send_cmdaddr(struct qcom_nand_controller *snandc,
++				 const struct spi_mem_op *op)
++{
++	struct qpic_snand_op s_op = {};
++	u32 cmd;
++	int ret, opcode;
++
++	ret = qcom_spi_cmd_mapping(snandc, op->cmd.opcode, &cmd);
++	if (ret < 0)
++		return ret;
++
++	s_op.cmd_reg = cmd;
++	s_op.addr1_reg = op->addr.val;
++	s_op.addr2_reg = 0;
++
++	opcode = op->cmd.opcode;
++
++	switch (opcode) {
++	case SPINAND_WRITE_EN:
++		return 0;
++	case SPINAND_PROGRAM_EXECUTE:
++		s_op.addr1_reg = op->addr.val << 16;
++		s_op.addr2_reg = op->addr.val >> 16 & 0xff;
++		snandc->qspi->addr1 = cpu_to_le32(s_op.addr1_reg);
++		snandc->qspi->addr2 = cpu_to_le32(s_op.addr2_reg);
++		snandc->qspi->cmd = cpu_to_le32(cmd);
++		return qcom_spi_program_execute(snandc, op);
++	case SPINAND_READ:
++		s_op.addr1_reg = (op->addr.val << 16);
++		s_op.addr2_reg = op->addr.val >> 16 & 0xff;
++		snandc->qspi->addr1 = cpu_to_le32(s_op.addr1_reg);
++		snandc->qspi->addr2 = cpu_to_le32(s_op.addr2_reg);
++		snandc->qspi->cmd = cpu_to_le32(cmd);
++		return 0;
++	case SPINAND_ERASE:
++		s_op.addr2_reg = (op->addr.val >> 16) & 0xffff;
++		s_op.addr1_reg = op->addr.val;
++		snandc->qspi->addr1 = cpu_to_le32(s_op.addr1_reg << 16);
++		snandc->qspi->addr2 = cpu_to_le32(s_op.addr2_reg);
++		snandc->qspi->cmd = cpu_to_le32(cmd);
++		qcom_spi_block_erase(snandc);
++		return 0;
++	default:
++		break;
++	}
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	snandc->regs->cmd = cpu_to_le32(s_op.cmd_reg);
++	snandc->regs->exec = cpu_to_le32(1);
++	snandc->regs->addr0 = cpu_to_le32(s_op.addr1_reg);
++	snandc->regs->addr1 = cpu_to_le32(s_op.addr2_reg);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 3, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret)
++		dev_err(snandc->dev, "failure in submitting cmd descriptor\n");
++
++	return ret;
++}
++
++static int qcom_spi_io_op(struct qcom_nand_controller *snandc, const struct spi_mem_op *op)
++{
++	int ret, val, opcode;
++	bool copy = false, copy_ftr = false;
++
++	ret = qcom_spi_send_cmdaddr(snandc, op);
++	if (ret)
++		return ret;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++	opcode = op->cmd.opcode;
++
++	switch (opcode) {
++	case SPINAND_READID:
++		snandc->buf_count = 4;
++		qcom_read_reg_dma(snandc, NAND_READ_ID, 1, NAND_BAM_NEXT_SGL);
++		copy = true;
++		break;
++	case SPINAND_GET_FEATURE:
++		snandc->buf_count = 4;
++		qcom_read_reg_dma(snandc, NAND_FLASH_FEATURES, 1, NAND_BAM_NEXT_SGL);
++		copy_ftr = true;
++		break;
++	case SPINAND_SET_FEATURE:
++		snandc->regs->flash_feature = cpu_to_le32(*(u32 *)op->data.buf.out);
++		qcom_write_reg_dma(snandc, &snandc->regs->flash_feature,
++				   NAND_FLASH_FEATURES, 1, NAND_BAM_NEXT_SGL);
++		break;
++	case SPINAND_PROGRAM_EXECUTE:
++	case SPINAND_WRITE_EN:
++	case SPINAND_RESET:
++	case SPINAND_ERASE:
++	case SPINAND_READ:
++		return 0;
++	default:
++		return -EOPNOTSUPP;
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret)
++		dev_err(snandc->dev, "failure in submitting descriptor for:%d\n", opcode);
++
++	if (copy) {
++		qcom_nandc_dev_to_mem(snandc, true);
++		memcpy(op->data.buf.in, snandc->reg_read_buf, snandc->buf_count);
++	}
++
++	if (copy_ftr) {
++		qcom_nandc_dev_to_mem(snandc, true);
++		val = le32_to_cpu(*(__le32 *)snandc->reg_read_buf);
++		val >>= 8;
++		memcpy(op->data.buf.in, &val, snandc->buf_count);
++	}
++
++	return ret;
++}
++
++static bool qcom_spi_is_page_op(const struct spi_mem_op *op)
++{
++	if (op->addr.buswidth != 1 && op->addr.buswidth != 2 && op->addr.buswidth != 4)
++		return false;
++
++	if (op->data.dir == SPI_MEM_DATA_IN) {
++		if (op->addr.buswidth == 4 && op->data.buswidth == 4)
++			return true;
++
++		if (op->addr.nbytes == 2 && op->addr.buswidth == 1)
++			return true;
++
++	} else if (op->data.dir == SPI_MEM_DATA_OUT) {
++		if (op->data.buswidth == 4)
++			return true;
++		if (op->addr.nbytes == 2 && op->addr.buswidth == 1)
++			return true;
++	}
++
++	return false;
++}
++
++static bool qcom_spi_supports_op(struct spi_mem *mem, const struct spi_mem_op *op)
++{
++	if (!spi_mem_default_supports_op(mem, op))
++		return false;
++
++	if (op->cmd.nbytes != 1 || op->cmd.buswidth != 1)
++		return false;
++
++	if (qcom_spi_is_page_op(op))
++		return true;
++
++	return ((!op->addr.nbytes || op->addr.buswidth == 1) &&
++		(!op->dummy.nbytes || op->dummy.buswidth == 1) &&
++		(!op->data.nbytes || op->data.buswidth == 1));
++}
++
++static int qcom_spi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
++{
++	struct qcom_nand_controller *snandc = spi_controller_get_devdata(mem->spi->controller);
++
++	dev_dbg(snandc->dev, "OP %02x ADDR %08llX@%d:%u DATA %d:%u", op->cmd.opcode,
++		op->addr.val, op->addr.buswidth, op->addr.nbytes,
++		op->data.buswidth, op->data.nbytes);
++
++	if (qcom_spi_is_page_op(op)) {
++		if (op->data.dir == SPI_MEM_DATA_IN)
++			return qcom_spi_read_page(snandc, op);
++		if (op->data.dir == SPI_MEM_DATA_OUT)
++			return qcom_spi_write_page(snandc, op);
++	} else {
++		return qcom_spi_io_op(snandc, op);
++	}
++
++	return 0;
++}
++
++static const struct spi_controller_mem_ops qcom_spi_mem_ops = {
++	.supports_op = qcom_spi_supports_op,
++	.exec_op = qcom_spi_exec_op,
++};
++
++static const struct spi_controller_mem_caps qcom_spi_mem_caps = {
++	.ecc = true,
++};
++
++static int qcom_spi_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct spi_controller *ctlr;
++	struct qcom_nand_controller *snandc;
++	struct qpic_spi_nand *qspi;
++	struct qpic_ecc *ecc;
++	struct resource *res;
++	const void *dev_data;
++	int ret;
++
++	ecc = devm_kzalloc(dev, sizeof(*ecc), GFP_KERNEL);
++	if (!ecc)
++		return -ENOMEM;
++
++	qspi = devm_kzalloc(dev, sizeof(*qspi), GFP_KERNEL);
++	if (!qspi)
++		return -ENOMEM;
++
++	ctlr = __devm_spi_alloc_controller(dev, sizeof(*snandc), false);
++	if (!ctlr)
++		return -ENOMEM;
++
++	platform_set_drvdata(pdev, ctlr);
++
++	snandc = spi_controller_get_devdata(ctlr);
++	qspi->snandc = snandc;
++
++	snandc->dev = dev;
++	snandc->qspi = qspi;
++	snandc->qspi->ctlr = ctlr;
++	snandc->qspi->ecc = ecc;
++
++	dev_data = of_device_get_match_data(dev);
++	if (!dev_data) {
++		dev_err(&pdev->dev, "failed to get device data\n");
++		return -ENODEV;
++	}
++
++	snandc->props = dev_data;
++	snandc->dev = &pdev->dev;
++
++	snandc->core_clk = devm_clk_get(dev, "core");
++	if (IS_ERR(snandc->core_clk))
++		return PTR_ERR(snandc->core_clk);
++
++	snandc->aon_clk = devm_clk_get(dev, "aon");
++	if (IS_ERR(snandc->aon_clk))
++		return PTR_ERR(snandc->aon_clk);
++
++	snandc->qspi->iomacro_clk = devm_clk_get(dev, "iom");
++	if (IS_ERR(snandc->qspi->iomacro_clk))
++		return PTR_ERR(snandc->qspi->iomacro_clk);
++
++	snandc->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
++	if (IS_ERR(snandc->base))
++		return PTR_ERR(snandc->base);
++
++	snandc->base_phys = res->start;
++	snandc->base_dma = dma_map_resource(dev, res->start, resource_size(res),
++					    DMA_BIDIRECTIONAL, 0);
++	if (dma_mapping_error(dev, snandc->base_dma))
++		return -ENXIO;
++
++	ret = clk_prepare_enable(snandc->core_clk);
++	if (ret)
++		goto err_dis_core_clk;
++
++	ret = clk_prepare_enable(snandc->aon_clk);
++	if (ret)
++		goto err_dis_aon_clk;
++
++	ret = clk_prepare_enable(snandc->qspi->iomacro_clk);
++	if (ret)
++		goto err_dis_iom_clk;
++
++	ret = qcom_nandc_alloc(snandc);
++	if (ret)
++		goto err_snand_alloc;
++
++	ret = qcom_spi_init(snandc);
++	if (ret)
++		goto err_spi_init;
++
++	/* setup ECC engine */
++	snandc->qspi->ecc_eng.dev = &pdev->dev;
++	snandc->qspi->ecc_eng.integration = NAND_ECC_ENGINE_INTEGRATION_PIPELINED;
++	snandc->qspi->ecc_eng.ops = &qcom_spi_ecc_engine_ops_pipelined;
++	snandc->qspi->ecc_eng.priv = snandc;
++
++	ret = nand_ecc_register_on_host_hw_engine(&snandc->qspi->ecc_eng);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to register ecc engine:%d\n", ret);
++		goto err_spi_init;
++	}
++
++	ctlr->num_chipselect = QPIC_QSPI_NUM_CS;
++	ctlr->mem_ops = &qcom_spi_mem_ops;
++	ctlr->mem_caps = &qcom_spi_mem_caps;
++	ctlr->dev.of_node = pdev->dev.of_node;
++	ctlr->mode_bits = SPI_TX_DUAL | SPI_RX_DUAL |
++			    SPI_TX_QUAD | SPI_RX_QUAD;
++
++	ret = spi_register_controller(ctlr);
++	if (ret) {
++		dev_err(&pdev->dev, "spi_register_controller failed.\n");
++		goto err_spi_init;
++	}
++
++	return 0;
++
++err_spi_init:
++	qcom_nandc_unalloc(snandc);
++err_snand_alloc:
++	clk_disable_unprepare(snandc->qspi->iomacro_clk);
++err_dis_iom_clk:
++	clk_disable_unprepare(snandc->aon_clk);
++err_dis_aon_clk:
++	clk_disable_unprepare(snandc->core_clk);
++err_dis_core_clk:
++	dma_unmap_resource(dev, res->start, resource_size(res),
++			   DMA_BIDIRECTIONAL, 0);
++	return ret;
++}
++
++static void qcom_spi_remove(struct platform_device *pdev)
++{
++	struct spi_controller *ctlr = platform_get_drvdata(pdev);
++	struct qcom_nand_controller *snandc = spi_controller_get_devdata(ctlr);
++	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	spi_unregister_controller(ctlr);
++
++	qcom_nandc_unalloc(snandc);
++
++	clk_disable_unprepare(snandc->aon_clk);
++	clk_disable_unprepare(snandc->core_clk);
++	clk_disable_unprepare(snandc->qspi->iomacro_clk);
++
++	dma_unmap_resource(&pdev->dev, snandc->base_dma, resource_size(res),
++			   DMA_BIDIRECTIONAL, 0);
++}
++
++static const struct qcom_nandc_props ipq9574_snandc_props = {
++	.dev_cmd_reg_start = 0x7000,
++	.supports_bam = true,
++};
++
++static const struct of_device_id qcom_snandc_of_match[] = {
++	{
++		.compatible = "qcom,ipq9574-snand",
++		.data = &ipq9574_snandc_props,
++	},
++	{}
++}
++MODULE_DEVICE_TABLE(of, qcom_snandc_of_match);
++
++static struct platform_driver qcom_spi_driver = {
++	.driver = {
++		.name		= "qcom_snand",
++		.of_match_table = qcom_snandc_of_match,
++	},
++	.probe = qcom_spi_probe,
++	.remove_new = qcom_spi_remove,
++};
++module_platform_driver(qcom_spi_driver);
++
++MODULE_DESCRIPTION("SPI driver for QPIC QSPI cores");
++MODULE_AUTHOR("Md Sadre Alam <quic_mdalam@quicinc.com>");
++MODULE_LICENSE("GPL");
++
+--- a/include/linux/mtd/nand-qpic-common.h
++++ b/include/linux/mtd/nand-qpic-common.h
+@@ -325,6 +325,10 @@ struct nandc_regs {
+ 	__le32 read_location_last1;
+ 	__le32 read_location_last2;
+ 	__le32 read_location_last3;
++	__le32 spi_cfg;
++	__le32 num_addr_cycle;
++	__le32 busy_wait_cnt;
++	__le32 flash_feature;
+ 
+ 	__le32 erased_cw_detect_cfg_clr;
+ 	__le32 erased_cw_detect_cfg_set;
+@@ -339,6 +343,7 @@ struct nandc_regs {
+  *
+  * @core_clk:			controller clock
+  * @aon_clk:			another controller clock
++ * @iomacro_clk:		io macro clock
+  *
+  * @regs:			a contiguous chunk of memory for DMA register
+  *				writes. contains the register values to be
+@@ -348,6 +353,7 @@ struct nandc_regs {
+  *				initialized via DT match data
+  *
+  * @controller:			base controller structure
++ * @qspi:			qpic spi structure
+  * @host_list:			list containing all the chips attached to the
+  *				controller
+  *
+@@ -392,6 +398,7 @@ struct qcom_nand_controller {
+ 	const struct qcom_nandc_props *props;
+ 
+ 	struct nand_controller *controller;
++	struct qpic_spi_nand *qspi;
+ 	struct list_head host_list;
+ 
+ 	union {
diff --git a/target/linux/generic/backport-6.12/416-v6.15-02-spi-spi-qpic-snand-Fix-ECC_CFG_ECC_DISABLE-shift-in-.patch b/target/linux/generic/backport-6.12/416-v6.15-02-spi-spi-qpic-snand-Fix-ECC_CFG_ECC_DISABLE-shift-in-.patch
new file mode 100644
index 0000000000..ad43f8dff1
--- /dev/null
+++ b/target/linux/generic/backport-6.12/416-v6.15-02-spi-spi-qpic-snand-Fix-ECC_CFG_ECC_DISABLE-shift-in-.patch
@@ -0,0 +1,28 @@
+From cf1ba3cb245020459f2ca446b7a7b199839f5d83 Mon Sep 17 00:00:00 2001
+From: Dan Carpenter <dan.carpenter@linaro.org>
+Date: Thu, 6 Mar 2025 12:40:01 +0300
+Subject: [PATCH] spi: spi-qpic-snand: Fix ECC_CFG_ECC_DISABLE shift in
+ qcom_spi_read_last_cw()
+
+The ECC_CFG_ECC_DISABLE define is BIT(0).  It's supposed to be used
+directly instead of used as a shifter.
+
+Fixes: 7304d1909080 ("spi: spi-qpic: add driver for QCOM SPI NAND flash Interface")
+Signed-off-by: Dan Carpenter <dan.carpenter@linaro.org>
+Link: https://patch.msgid.link/2f4b0a0b-2c03-41c0-8a4a-3d789a83832d@stanley.mountain
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-qpic-snand.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -514,7 +514,7 @@ static int qcom_spi_read_last_cw(struct
+ 	cfg0 = (ecc_cfg->cfg0_raw & ~(7U << CW_PER_PAGE)) |
+ 		0 << CW_PER_PAGE;
+ 	cfg1 = ecc_cfg->cfg1_raw;
+-	ecc_bch_cfg = 1 << ECC_CFG_ECC_DISABLE;
++	ecc_bch_cfg = ECC_CFG_ECC_DISABLE;
+ 
+ 	snandc->regs->cmd = snandc->qspi->cmd;
+ 	snandc->regs->cfg0 = cpu_to_le32(cfg0);
diff --git a/target/linux/generic/backport-6.12/416-v6.15-03-spi-spi-qpic-snand-avoid-memleak-in-qcom_spi_ecc_ini.patch b/target/linux/generic/backport-6.12/416-v6.15-03-spi-spi-qpic-snand-avoid-memleak-in-qcom_spi_ecc_ini.patch
new file mode 100644
index 0000000000..1e2a3b0298
--- /dev/null
+++ b/target/linux/generic/backport-6.12/416-v6.15-03-spi-spi-qpic-snand-avoid-memleak-in-qcom_spi_ecc_ini.patch
@@ -0,0 +1,35 @@
+From d450cdd9c4398add1f2aa7200f2c95f1e3b9f9fa Mon Sep 17 00:00:00 2001
+From: Gabor Juhos <j4g8y7@gmail.com>
+Date: Thu, 13 Mar 2025 19:31:21 +0100
+Subject: [PATCH] spi: spi-qpic-snand: avoid memleak in
+ qcom_spi_ecc_init_ctx_pipelined()
+
+When the allocation of the OOB buffer fails, the
+qcom_spi_ecc_init_ctx_pipelined() function returns without freeing
+the memory allocated for 'ecc_cfg' thus it can cause a memory leak.
+
+Call kfree() to free 'ecc_cfg' before returning from the function
+to avoid that.
+
+Fixes: 7304d1909080 ("spi: spi-qpic: add driver for QCOM SPI NAND flash Interface")
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+Link: https://patch.msgid.link/20250313-qpic-snand-memleak-fix-v1-1-e54e78d1da3a@gmail.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-qpic-snand.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -263,8 +263,10 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 		return -ENOMEM;
+ 	snandc->qspi->oob_buf = kzalloc(mtd->writesize + mtd->oobsize,
+ 					GFP_KERNEL);
+-	if (!snandc->qspi->oob_buf)
++	if (!snandc->qspi->oob_buf) {
++		kfree(ecc_cfg);
+ 		return -ENOMEM;
++	}
+ 
+ 	memset(snandc->qspi->oob_buf, 0xff, mtd->writesize + mtd->oobsize);
+ 
diff --git a/target/linux/generic/backport-6.12/416-v6.15-04-spi-SPI_QPIC_SNAND-should-be-tristate-and-depend-on-.patch b/target/linux/generic/backport-6.12/416-v6.15-04-spi-SPI_QPIC_SNAND-should-be-tristate-and-depend-on-.patch
new file mode 100644
index 0000000000..5e92048438
--- /dev/null
+++ b/target/linux/generic/backport-6.12/416-v6.15-04-spi-SPI_QPIC_SNAND-should-be-tristate-and-depend-on-.patch
@@ -0,0 +1,49 @@
+From d32c4e58545f17caaa854415f854691e32d42075 Mon Sep 17 00:00:00 2001
+From: Geert Uytterhoeven <geert+renesas@glider.be>
+Date: Wed, 26 Mar 2025 15:22:19 +0100
+Subject: [PATCH] spi: SPI_QPIC_SNAND should be tristate and depend on MTD
+
+SPI_QPIC_SNAND is the only driver that selects MTD instead of depending
+on it, which could lead to circular dependencies.  Moreover, as
+SPI_QPIC_SNAND is bool, this forces MTD (and various related symbols) to
+be built-in, as can be seen in an allmodconfig kernel.
+
+Except for a missing semicolon, there is no reason why SPI_QPIC_SNAND
+cannot be tristate; all MODULE_*() boilerplate is already present.
+Hence make SPI_QPIC_SNAND tristate, let it depend on MTD, and add the
+missing semicolon.
+
+Fixes: 7304d1909080ef0c ("spi: spi-qpic: add driver for QCOM SPI NAND flash Interface")
+Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
+Link: https://patch.msgid.link/b63db431cbf35223a4400e44c296293d32c4543c.1742998909.git.geert+renesas@glider.be
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/Kconfig          | 4 ++--
+ drivers/spi/spi-qpic-snand.c | 2 +-
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -899,9 +899,9 @@ config SPI_QCOM_QSPI
+ 	  QSPI(Quad SPI) driver for Qualcomm QSPI controller.
+ 
+ config SPI_QPIC_SNAND
+-	bool "QPIC SNAND controller"
++	tristate "QPIC SNAND controller"
+ 	depends on ARCH_QCOM || COMPILE_TEST
+-	select MTD
++	depends on MTD
+ 	help
+ 	  QPIC_SNAND (QPIC SPI NAND) driver for Qualcomm QPIC controller.
+ 	  QPIC controller supports both parallel nand and serial nand.
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -1614,7 +1614,7 @@ static const struct of_device_id qcom_sn
+ 		.data = &ipq9574_snandc_props,
+ 	},
+ 	{}
+-}
++};
+ MODULE_DEVICE_TABLE(of, qcom_snandc_of_match);
+ 
+ static struct platform_driver qcom_spi_driver = {
diff --git a/target/linux/generic/backport-6.12/416-v6.15-05-spi-spi-qpic-snand-propagate-errors-from-qcom_spi_block_erase.patch b/target/linux/generic/backport-6.12/416-v6.15-05-spi-spi-qpic-snand-propagate-errors-from-qcom_spi_block_erase.patch
new file mode 100644
index 0000000000..9da531bed1
--- /dev/null
+++ b/target/linux/generic/backport-6.12/416-v6.15-05-spi-spi-qpic-snand-propagate-errors-from-qcom_spi_block_erase.patch
@@ -0,0 +1,36 @@
+From: Gabor Juhos <j4g8y7@gmail.com>
+Date: Wed, 23 Apr 2025 21:31:57 +0200
+Subject: [PATCH] spi: spi-qpic-snand: propagate errors from
+ qcom_spi_block_erase()
+
+The qcom_spi_block_erase() function returns with error in case of
+failure. Change the qcom_spi_send_cmdaddr() function to propagate
+these errors to the callers instead of returning with success.
+
+Fixes: 7304d1909080 ("spi: spi-qpic: add driver for QCOM SPI NAND flash Interface")
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+Reviewed-by: Abel Vesa <abel.vesa@linaro.org>
+Reviewed-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+---
+ drivers/spi/spi-qpic-snand.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+
+---
+base-commit: 9c32cda43eb78f78c73aee4aa344b777714e259b
+change-id: 20250422-qpic-snand-propagate-error-9c95811ab811
+
+Best regards,
+
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -1307,8 +1307,7 @@ static int qcom_spi_send_cmdaddr(struct
+ 		snandc->qspi->addr1 = cpu_to_le32(s_op.addr1_reg << 16);
+ 		snandc->qspi->addr2 = cpu_to_le32(s_op.addr2_reg);
+ 		snandc->qspi->cmd = cpu_to_le32(cmd);
+-		qcom_spi_block_erase(snandc);
+-		return 0;
++		return qcom_spi_block_erase(snandc);
+ 	default:
+ 		break;
+ 	}
diff --git a/target/linux/generic/backport-6.12/416-v6.15-06-spi-spi-qpic-snand-fix-NAND_READ_LOCATION_2-register-handling.patch b/target/linux/generic/backport-6.12/416-v6.15-06-spi-spi-qpic-snand-fix-NAND_READ_LOCATION_2-register-handling.patch
new file mode 100644
index 0000000000..a2cd636fee
--- /dev/null
+++ b/target/linux/generic/backport-6.12/416-v6.15-06-spi-spi-qpic-snand-fix-NAND_READ_LOCATION_2-register-handling.patch
@@ -0,0 +1,35 @@
+From: Gabor Juhos <j4g8y7@gmail.com>
+Date: Mon, 28 Apr 2025 09:30:55 +0200
+Subject: [PATCH] spi: spi-qpic-snand: fix NAND_READ_LOCATION_2 register
+ handling
+
+The precomputed value for the NAND_READ_LOCATION_2 register should be
+stored in 'snandc->regs->read_location2'.
+
+Fix the qcom_spi_set_read_loc_first() function accordingly.
+
+Fixes: 7304d1909080 ("spi: spi-qpic: add driver for QCOM SPI NAND flash Interface")
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+Reviewed-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+---
+ drivers/spi/spi-qpic-snand.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+
+---
+base-commit: 15cfe55ec58ace931a73e19e5367598734ceb074
+change-id: 20250428-qpic-snand-readloc2-fix-bccd07cf26d3
+
+Best regards,
+
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -142,7 +142,7 @@ static void qcom_spi_set_read_loc_first(
+ 	else if (reg == NAND_READ_LOCATION_1)
+ 		snandc->regs->read_location1 = locreg_val;
+ 	else if (reg == NAND_READ_LOCATION_2)
+-		snandc->regs->read_location1 = locreg_val;
++		snandc->regs->read_location2 = locreg_val;
+ 	else if (reg == NAND_READ_LOCATION_3)
+ 		snandc->regs->read_location3 = locreg_val;
+ }
diff --git a/target/linux/generic/backport-6.12/416-v6.15-07-spi-spi-qpic-snand-use-kmalloc-for-OOB-buffer-alloca.patch b/target/linux/generic/backport-6.12/416-v6.15-07-spi-spi-qpic-snand-use-kmalloc-for-OOB-buffer-alloca.patch
new file mode 100644
index 0000000000..5a3d498bcb
--- /dev/null
+++ b/target/linux/generic/backport-6.12/416-v6.15-07-spi-spi-qpic-snand-use-kmalloc-for-OOB-buffer-alloca.patch
@@ -0,0 +1,29 @@
+From f48d80503504257682e493dc17408f2f0b47bcfa Mon Sep 17 00:00:00 2001
+From: Gabor Juhos <j4g8y7@gmail.com>
+Date: Thu, 20 Mar 2025 19:11:59 +0100
+Subject: [PATCH] spi: spi-qpic-snand: use kmalloc() for OOB buffer allocation
+
+The qcom_spi_ecc_init_ctx_pipelined() function allocates zeroed
+memory for the OOB buffer, then it fills the buffer with '0xff'
+bytes right after the allocation. In this case zeroing the memory
+during allocation is superfluous, so use kmalloc() instead of
+kzalloc() to avoid that.
+
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+Link: https://patch.msgid.link/20250320-qpic-snand-kmalloc-v1-1-94e267550675@gmail.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-qpic-snand.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -261,7 +261,7 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 	ecc_cfg = kzalloc(sizeof(*ecc_cfg), GFP_KERNEL);
+ 	if (!ecc_cfg)
+ 		return -ENOMEM;
+-	snandc->qspi->oob_buf = kzalloc(mtd->writesize + mtd->oobsize,
++	snandc->qspi->oob_buf = kmalloc(mtd->writesize + mtd->oobsize,
+ 					GFP_KERNEL);
+ 	if (!snandc->qspi->oob_buf) {
+ 		kfree(ecc_cfg);
diff --git a/target/linux/generic/backport-6.12/416-v6.16-08-spi-spi-qpic-snand-remove-unused-wlen-member-of-struct-qpic_spi_nand.patch b/target/linux/generic/backport-6.12/416-v6.16-08-spi-spi-qpic-snand-remove-unused-wlen-member-of-struct-qpic_spi_nand.patch
new file mode 100644
index 0000000000..55e84daf09
--- /dev/null
+++ b/target/linux/generic/backport-6.12/416-v6.16-08-spi-spi-qpic-snand-remove-unused-wlen-member-of-struct-qpic_spi_nand.patch
@@ -0,0 +1,30 @@
+From: Gabor Juhos <j4g8y7@gmail.com>
+Date: Thu, 24 Apr 2025 20:10:59 +0200
+Subject: [PATCH] spi: spi-qpic-snand: remove unused 'wlen' member of
+ 'struct qpic_spi_nand'
+
+The 'wlen' member of the qpic_spi_nand structure is never used in the
+code so remove that.
+
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+---
+ drivers/spi/spi-qpic-snand.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+
+---
+base-commit: 9c32cda43eb78f78c73aee4aa344b777714e259b
+change-id: 20250424-qpic-snand-remove-wlen-c0cef3801a7f
+
+Best regards,
+
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -116,7 +116,6 @@ struct qpic_spi_nand {
+ 	struct nand_ecc_engine ecc_eng;
+ 	u8 *data_buf;
+ 	u8 *oob_buf;
+-	u32 wlen;
+ 	__le32 addr1;
+ 	__le32 addr2;
+ 	__le32 cmd;
diff --git a/target/linux/generic/backport-6.12/720-v6.13-net-phy-mediatek-ge-soc-Fix-coding-style.patch b/target/linux/generic/backport-6.12/720-v6.13-net-phy-mediatek-ge-soc-Fix-coding-style.patch
new file mode 100644
index 0000000000..25bd96fa1f
--- /dev/null
+++ b/target/linux/generic/backport-6.12/720-v6.13-net-phy-mediatek-ge-soc-Fix-coding-style.patch
@@ -0,0 +1,88 @@
+From 277f96c1f3f71d6e1d3bcf650d7cd84c1442210f Mon Sep 17 00:00:00 2001
+From: "SkyLake.Huang" <skylake.huang@mediatek.com>
+Date: Thu, 17 Oct 2024 11:22:11 +0800
+Subject: [PATCH 01/20] net: phy: mediatek-ge-soc: Fix coding style
+
+This patch fixes spelling errors, re-arrange vars with
+reverse Xmas tree and remove unnecessary parens in
+mediatek-ge-soc.c.
+
+Signed-off-by: SkyLake.Huang <skylake.huang@mediatek.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/phy/mediatek-ge-soc.c | 36 ++++++++++++++++---------------
+ 1 file changed, 19 insertions(+), 17 deletions(-)
+
+--- a/drivers/net/phy/mediatek-ge-soc.c
++++ b/drivers/net/phy/mediatek-ge-soc.c
+@@ -408,16 +408,17 @@ static int tx_offset_cal_efuse(struct ph
+ 
+ static int tx_amp_fill_result(struct phy_device *phydev, u16 *buf)
+ {
+-	int i;
+-	int bias[16] = {};
+-	const int vals_9461[16] = { 7, 1, 4, 7,
+-				    7, 1, 4, 7,
+-				    7, 1, 4, 7,
+-				    7, 1, 4, 7 };
+ 	const int vals_9481[16] = { 10, 6, 6, 10,
+ 				    10, 6, 6, 10,
+ 				    10, 6, 6, 10,
+ 				    10, 6, 6, 10 };
++	const int vals_9461[16] = { 7, 1, 4, 7,
++				    7, 1, 4, 7,
++				    7, 1, 4, 7,
++				    7, 1, 4, 7 };
++	int bias[16] = {};
++	int i;
++
+ 	switch (phydev->drv->phy_id) {
+ 	case MTK_GPHY_ID_MT7981:
+ 		/* We add some calibration to efuse values
+@@ -1069,10 +1070,10 @@ static int start_cal(struct phy_device *
+ 
+ static int mt798x_phy_calibration(struct phy_device *phydev)
+ {
++	struct nvmem_cell *cell;
+ 	int ret = 0;
+-	u32 *buf;
+ 	size_t len;
+-	struct nvmem_cell *cell;
++	u32 *buf;
+ 
+ 	cell = nvmem_cell_get(&phydev->mdio.dev, "phy-cal-data");
+ 	if (IS_ERR(cell)) {
+@@ -1210,14 +1211,15 @@ static int mt798x_phy_led_brightness_set
+ 	return mt798x_phy_hw_led_on_set(phydev, index, (value != LED_OFF));
+ }
+ 
+-static const unsigned long supported_triggers = (BIT(TRIGGER_NETDEV_FULL_DUPLEX) |
+-						 BIT(TRIGGER_NETDEV_HALF_DUPLEX) |
+-						 BIT(TRIGGER_NETDEV_LINK)        |
+-						 BIT(TRIGGER_NETDEV_LINK_10)     |
+-						 BIT(TRIGGER_NETDEV_LINK_100)    |
+-						 BIT(TRIGGER_NETDEV_LINK_1000)   |
+-						 BIT(TRIGGER_NETDEV_RX)          |
+-						 BIT(TRIGGER_NETDEV_TX));
++static const unsigned long supported_triggers =
++	BIT(TRIGGER_NETDEV_FULL_DUPLEX) |
++	BIT(TRIGGER_NETDEV_HALF_DUPLEX) |
++	BIT(TRIGGER_NETDEV_LINK)        |
++	BIT(TRIGGER_NETDEV_LINK_10)     |
++	BIT(TRIGGER_NETDEV_LINK_100)    |
++	BIT(TRIGGER_NETDEV_LINK_1000)   |
++	BIT(TRIGGER_NETDEV_RX)          |
++	BIT(TRIGGER_NETDEV_TX);
+ 
+ static int mt798x_phy_led_hw_is_supported(struct phy_device *phydev, u8 index,
+ 					  unsigned long rules)
+@@ -1415,7 +1417,7 @@ static int mt7988_phy_probe_shared(struc
+ 	 * LED_C and LED_D respectively. At the same time those pins are used to
+ 	 * bootstrap configuration of the reference clock source (LED_A),
+ 	 * DRAM DDRx16b x2/x1 (LED_B) and boot device (LED_C, LED_D).
+-	 * In practise this is done using a LED and a resistor pulling the pin
++	 * In practice this is done using a LED and a resistor pulling the pin
+ 	 * either to GND or to VIO.
+ 	 * The detected value at boot time is accessible at run-time using the
+ 	 * TPBANK0 register located in the gpio base of the pinctrl, in order
diff --git a/target/linux/generic/backport-6.12/721-v6.13-net-phy-mediatek-ge-soc-Shrink-line-wrapping-to-80-c.patch b/target/linux/generic/backport-6.12/721-v6.13-net-phy-mediatek-ge-soc-Shrink-line-wrapping-to-80-c.patch
new file mode 100644
index 0000000000..fbf3a99bd7
--- /dev/null
+++ b/target/linux/generic/backport-6.12/721-v6.13-net-phy-mediatek-ge-soc-Shrink-line-wrapping-to-80-c.patch
@@ -0,0 +1,271 @@
+From c0dc1b412f9d840c51c5ee8927bf066e15a59550 Mon Sep 17 00:00:00 2001
+From: "SkyLake.Huang" <skylake.huang@mediatek.com>
+Date: Thu, 17 Oct 2024 11:22:12 +0800
+Subject: [PATCH 02/20] net: phy: mediatek-ge-soc: Shrink line wrapping to 80
+ characters
+
+This patch shrinks line wrapping to 80 chars. Also, in
+tx_amp_fill_result(), use FIELD_PREP() to prettify code.
+
+Signed-off-by: SkyLake.Huang <skylake.huang@mediatek.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/phy/mediatek-ge-soc.c | 125 +++++++++++++++++++++---------
+ 1 file changed, 88 insertions(+), 37 deletions(-)
+
+--- a/drivers/net/phy/mediatek-ge-soc.c
++++ b/drivers/net/phy/mediatek-ge-soc.c
+@@ -342,7 +342,8 @@ static int cal_cycle(struct phy_device *
+ 	ret = phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1,
+ 					MTK_PHY_RG_AD_CAL_CLK, reg_val,
+ 					reg_val & MTK_PHY_DA_CAL_CLK, 500,
+-					ANALOG_INTERNAL_OPERATION_MAX_US, false);
++					ANALOG_INTERNAL_OPERATION_MAX_US,
++					false);
+ 	if (ret) {
+ 		phydev_err(phydev, "Calibration cycle timeout\n");
+ 		return ret;
+@@ -441,40 +442,72 @@ static int tx_amp_fill_result(struct phy
+ 	}
+ 
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TXVLD_DA_RG,
+-		       MTK_PHY_DA_TX_I2MPB_A_GBE_MASK, (buf[0] + bias[0]) << 10);
++		       MTK_PHY_DA_TX_I2MPB_A_GBE_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_GBE_MASK,
++				  buf[0] + bias[0]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TXVLD_DA_RG,
+-		       MTK_PHY_DA_TX_I2MPB_A_TBT_MASK, buf[0] + bias[1]);
++		       MTK_PHY_DA_TX_I2MPB_A_TBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_TBT_MASK,
++				  buf[0] + bias[1]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_A2,
+-		       MTK_PHY_DA_TX_I2MPB_A_HBT_MASK, (buf[0] + bias[2]) << 10);
++		       MTK_PHY_DA_TX_I2MPB_A_HBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_HBT_MASK,
++				  buf[0] + bias[2]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_A2,
+-		       MTK_PHY_DA_TX_I2MPB_A_TST_MASK, buf[0] + bias[3]);
++		       MTK_PHY_DA_TX_I2MPB_A_TST_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_TST_MASK,
++				  buf[0] + bias[3]));
+ 
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B1,
+-		       MTK_PHY_DA_TX_I2MPB_B_GBE_MASK, (buf[1] + bias[4]) << 8);
++		       MTK_PHY_DA_TX_I2MPB_B_GBE_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_GBE_MASK,
++				  buf[1] + bias[4]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B1,
+-		       MTK_PHY_DA_TX_I2MPB_B_TBT_MASK, buf[1] + bias[5]);
++		       MTK_PHY_DA_TX_I2MPB_B_TBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_TBT_MASK,
++				  buf[1] + bias[5]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B2,
+-		       MTK_PHY_DA_TX_I2MPB_B_HBT_MASK, (buf[1] + bias[6]) << 8);
++		       MTK_PHY_DA_TX_I2MPB_B_HBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_HBT_MASK,
++				  buf[1] + bias[6]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B2,
+-		       MTK_PHY_DA_TX_I2MPB_B_TST_MASK, buf[1] + bias[7]);
++		       MTK_PHY_DA_TX_I2MPB_B_TST_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_TST_MASK,
++				  buf[1] + bias[7]));
+ 
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C1,
+-		       MTK_PHY_DA_TX_I2MPB_C_GBE_MASK, (buf[2] + bias[8]) << 8);
++		       MTK_PHY_DA_TX_I2MPB_C_GBE_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_GBE_MASK,
++				  buf[2] + bias[8]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C1,
+-		       MTK_PHY_DA_TX_I2MPB_C_TBT_MASK, buf[2] + bias[9]);
++		       MTK_PHY_DA_TX_I2MPB_C_TBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_TBT_MASK,
++				  buf[2] + bias[9]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C2,
+-		       MTK_PHY_DA_TX_I2MPB_C_HBT_MASK, (buf[2] + bias[10]) << 8);
++		       MTK_PHY_DA_TX_I2MPB_C_HBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_HBT_MASK,
++				  buf[2] + bias[10]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C2,
+-		       MTK_PHY_DA_TX_I2MPB_C_TST_MASK, buf[2] + bias[11]);
++		       MTK_PHY_DA_TX_I2MPB_C_TST_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_TST_MASK,
++				  buf[2] + bias[11]));
+ 
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D1,
+-		       MTK_PHY_DA_TX_I2MPB_D_GBE_MASK, (buf[3] + bias[12]) << 8);
++		       MTK_PHY_DA_TX_I2MPB_D_GBE_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_GBE_MASK,
++				  buf[3] + bias[12]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D1,
+-		       MTK_PHY_DA_TX_I2MPB_D_TBT_MASK, buf[3] + bias[13]);
++		       MTK_PHY_DA_TX_I2MPB_D_TBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_TBT_MASK,
++				  buf[3] + bias[13]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D2,
+-		       MTK_PHY_DA_TX_I2MPB_D_HBT_MASK, (buf[3] + bias[14]) << 8);
++		       MTK_PHY_DA_TX_I2MPB_D_HBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_HBT_MASK,
++				  buf[3] + bias[14]));
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D2,
+-		       MTK_PHY_DA_TX_I2MPB_D_TST_MASK, buf[3] + bias[15]);
++		       MTK_PHY_DA_TX_I2MPB_D_TST_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_TST_MASK,
++				  buf[3] + bias[15]));
+ 
+ 	return 0;
+ }
+@@ -663,7 +696,8 @@ static int tx_vcm_cal_sw(struct phy_devi
+ 		goto restore;
+ 
+ 	/* We calibrate TX-VCM in different logic. Check upper index and then
+-	 * lower index. If this calibration is valid, apply lower index's result.
++	 * lower index. If this calibration is valid, apply lower index's
++	 * result.
+ 	 */
+ 	ret = upper_ret - lower_ret;
+ 	if (ret == 1) {
+@@ -692,7 +726,8 @@ static int tx_vcm_cal_sw(struct phy_devi
+ 	} else if (upper_idx == TXRESERVE_MAX && upper_ret == 0 &&
+ 		   lower_ret == 0) {
+ 		ret = 0;
+-		phydev_warn(phydev, "TX-VCM SW cal result at high margin 0x%x\n",
++		phydev_warn(phydev,
++			    "TX-VCM SW cal result at high margin 0x%x\n",
+ 			    upper_idx);
+ 	} else {
+ 		ret = -EINVAL;
+@@ -796,7 +831,8 @@ static void mt7981_phy_finetune(struct p
+ 
+ 	/* TR_OPEN_LOOP_EN = 1, lpf_x_average = 9 */
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG234,
+-		       MTK_PHY_TR_OPEN_LOOP_EN_MASK | MTK_PHY_LPF_X_AVERAGE_MASK,
++		       MTK_PHY_TR_OPEN_LOOP_EN_MASK |
++		       MTK_PHY_LPF_X_AVERAGE_MASK,
+ 		       BIT(0) | FIELD_PREP(MTK_PHY_LPF_X_AVERAGE_MASK, 0x9));
+ 
+ 	/* rg_tr_lpf_cnt_val = 512 */
+@@ -865,7 +901,8 @@ static void mt7988_phy_finetune(struct p
+ 
+ 	/* TR_OPEN_LOOP_EN = 1, lpf_x_average = 10 */
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG234,
+-		       MTK_PHY_TR_OPEN_LOOP_EN_MASK | MTK_PHY_LPF_X_AVERAGE_MASK,
++		       MTK_PHY_TR_OPEN_LOOP_EN_MASK |
++		       MTK_PHY_LPF_X_AVERAGE_MASK,
+ 		       BIT(0) | FIELD_PREP(MTK_PHY_LPF_X_AVERAGE_MASK, 0xa));
+ 
+ 	/* rg_tr_lpf_cnt_val = 1023 */
+@@ -977,7 +1014,8 @@ static void mt798x_phy_eee(struct phy_de
+ 	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+ 
+ 	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_3);
+-	__phy_modify(phydev, MTK_PHY_LPI_REG_14, MTK_PHY_LPI_WAKE_TIMER_1000_MASK,
++	__phy_modify(phydev, MTK_PHY_LPI_REG_14,
++		     MTK_PHY_LPI_WAKE_TIMER_1000_MASK,
+ 		     FIELD_PREP(MTK_PHY_LPI_WAKE_TIMER_1000_MASK, 0x19c));
+ 
+ 	__phy_modify(phydev, MTK_PHY_LPI_REG_1c, MTK_PHY_SMI_DET_ON_THRESH_MASK,
+@@ -987,7 +1025,8 @@ static void mt798x_phy_eee(struct phy_de
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
+ 		       MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG122,
+ 		       MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
+-		       FIELD_PREP(MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK, 0xff));
++		       FIELD_PREP(MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
++				  0xff));
+ }
+ 
+ static int cal_sw(struct phy_device *phydev, enum CAL_ITEM cal_item,
+@@ -1147,7 +1186,8 @@ static int mt798x_phy_hw_led_on_set(stru
+ 					(index ? 16 : 0), &priv->led_state);
+ 	if (changed)
+ 		return phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				      MTK_PHY_LED1_ON_CTRL : MTK_PHY_LED0_ON_CTRL,
++				      MTK_PHY_LED1_ON_CTRL :
++				      MTK_PHY_LED0_ON_CTRL,
+ 				      MTK_PHY_LED_ON_MASK,
+ 				      on ? MTK_PHY_LED_ON_FORCE_ON : 0);
+ 	else
+@@ -1157,7 +1197,8 @@ static int mt798x_phy_hw_led_on_set(stru
+ static int mt798x_phy_hw_led_blink_set(struct phy_device *phydev, u8 index,
+ 				       bool blinking)
+ {
+-	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK + (index ? 16 : 0);
++	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
++				 (index ? 16 : 0);
+ 	struct mtk_socphy_priv *priv = phydev->priv;
+ 	bool changed;
+ 
+@@ -1170,8 +1211,10 @@ static int mt798x_phy_hw_led_blink_set(s
+ 			      (index ? 16 : 0), &priv->led_state);
+ 	if (changed)
+ 		return phy_write_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				     MTK_PHY_LED1_BLINK_CTRL : MTK_PHY_LED0_BLINK_CTRL,
+-				     blinking ? MTK_PHY_LED_BLINK_FORCE_BLINK : 0);
++				     MTK_PHY_LED1_BLINK_CTRL :
++				     MTK_PHY_LED0_BLINK_CTRL,
++				     blinking ?
++				     MTK_PHY_LED_BLINK_FORCE_BLINK : 0);
+ 	else
+ 		return 0;
+ }
+@@ -1237,7 +1280,8 @@ static int mt798x_phy_led_hw_is_supporte
+ static int mt798x_phy_led_hw_control_get(struct phy_device *phydev, u8 index,
+ 					 unsigned long *rules)
+ {
+-	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK + (index ? 16 : 0);
++	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
++				 (index ? 16 : 0);
+ 	unsigned int bit_netdev = MTK_PHY_LED_STATE_NETDEV + (index ? 16 : 0);
+ 	unsigned int bit_on = MTK_PHY_LED_STATE_FORCE_ON + (index ? 16 : 0);
+ 	struct mtk_socphy_priv *priv = phydev->priv;
+@@ -1258,8 +1302,8 @@ static int mt798x_phy_led_hw_control_get
+ 	if (blink < 0)
+ 		return -EIO;
+ 
+-	if ((on & (MTK_PHY_LED_ON_LINK | MTK_PHY_LED_ON_FDX | MTK_PHY_LED_ON_HDX |
+-		   MTK_PHY_LED_ON_LINKDOWN)) ||
++	if ((on & (MTK_PHY_LED_ON_LINK | MTK_PHY_LED_ON_FDX |
++		   MTK_PHY_LED_ON_HDX | MTK_PHY_LED_ON_LINKDOWN)) ||
+ 	    (blink & (MTK_PHY_LED_BLINK_RX | MTK_PHY_LED_BLINK_TX)))
+ 		set_bit(bit_netdev, &priv->led_state);
+ 	else
+@@ -1333,17 +1377,23 @@ static int mt798x_phy_led_hw_control_set
+ 
+ 	if (rules & BIT(TRIGGER_NETDEV_RX)) {
+ 		blink |= (on & MTK_PHY_LED_ON_LINK) ?
+-			  (((on & MTK_PHY_LED_ON_LINK10) ? MTK_PHY_LED_BLINK_10RX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK100) ? MTK_PHY_LED_BLINK_100RX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK1000) ? MTK_PHY_LED_BLINK_1000RX : 0)) :
++			  (((on & MTK_PHY_LED_ON_LINK10) ?
++			    MTK_PHY_LED_BLINK_10RX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK100) ?
++			    MTK_PHY_LED_BLINK_100RX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK1000) ?
++			    MTK_PHY_LED_BLINK_1000RX : 0)) :
+ 			  MTK_PHY_LED_BLINK_RX;
+ 	}
+ 
+ 	if (rules & BIT(TRIGGER_NETDEV_TX)) {
+ 		blink |= (on & MTK_PHY_LED_ON_LINK) ?
+-			  (((on & MTK_PHY_LED_ON_LINK10) ? MTK_PHY_LED_BLINK_10TX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK100) ? MTK_PHY_LED_BLINK_100TX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK1000) ? MTK_PHY_LED_BLINK_1000TX : 0)) :
++			  (((on & MTK_PHY_LED_ON_LINK10) ?
++			    MTK_PHY_LED_BLINK_10TX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK100) ?
++			    MTK_PHY_LED_BLINK_100TX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK1000) ?
++			    MTK_PHY_LED_BLINK_1000TX : 0)) :
+ 			  MTK_PHY_LED_BLINK_TX;
+ 	}
+ 
+@@ -1400,7 +1450,8 @@ static int mt7988_phy_fix_leds_polaritie
+ 	/* Only now setup pinctrl to avoid bogus blinking */
+ 	pinctrl = devm_pinctrl_get_select(&phydev->mdio.dev, "gbe-led");
+ 	if (IS_ERR(pinctrl))
+-		dev_err(&phydev->mdio.bus->dev, "Failed to setup PHY LED pinctrl\n");
++		dev_err(&phydev->mdio.bus->dev,
++			"Failed to setup PHY LED pinctrl\n");
+ 
+ 	return 0;
+ }
diff --git a/target/linux/generic/backport-6.12/722-v6.13-net-phy-mediatek-ge-soc-Propagate-error-code-correct.patch b/target/linux/generic/backport-6.12/722-v6.13-net-phy-mediatek-ge-soc-Propagate-error-code-correct.patch
new file mode 100644
index 0000000000..1f6f5f5df6
--- /dev/null
+++ b/target/linux/generic/backport-6.12/722-v6.13-net-phy-mediatek-ge-soc-Propagate-error-code-correct.patch
@@ -0,0 +1,40 @@
+From bcbbfb4f62c4ba35783cc617997a2e92d91e3940 Mon Sep 17 00:00:00 2001
+From: "SkyLake.Huang" <skylake.huang@mediatek.com>
+Date: Thu, 17 Oct 2024 11:22:13 +0800
+Subject: [PATCH 03/20] net: phy: mediatek-ge-soc: Propagate error code
+ correctly in cal_cycle()
+
+This patch propagates error code correctly in cal_cycle()
+and improve with FIELD_GET().
+
+Signed-off-by: SkyLake.Huang <skylake.huang@mediatek.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/phy/mediatek-ge-soc.c | 8 +++++---
+ 1 file changed, 5 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/phy/mediatek-ge-soc.c
++++ b/drivers/net/phy/mediatek-ge-soc.c
+@@ -110,7 +110,7 @@
+ #define   MTK_PHY_CR_TX_AMP_OFFSET_D_MASK	GENMASK(6, 0)
+ 
+ #define MTK_PHY_RG_AD_CAL_COMP			0x17a
+-#define   MTK_PHY_AD_CAL_COMP_OUT_SHIFT		(8)
++#define   MTK_PHY_AD_CAL_COMP_OUT_MASK		GENMASK(8, 8)
+ 
+ #define MTK_PHY_RG_AD_CAL_CLK			0x17b
+ #define   MTK_PHY_DA_CAL_CLK			BIT(0)
+@@ -351,8 +351,10 @@ static int cal_cycle(struct phy_device *
+ 
+ 	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_AD_CALIN,
+ 			   MTK_PHY_DA_CALIN_FLAG);
+-	ret = phy_read_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_AD_CAL_COMP) >>
+-			   MTK_PHY_AD_CAL_COMP_OUT_SHIFT;
++	ret = phy_read_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_AD_CAL_COMP);
++	if (ret < 0)
++		return ret;
++	ret = FIELD_GET(MTK_PHY_AD_CAL_COMP_OUT_MASK, ret);
+ 	phydev_dbg(phydev, "cal_val: 0x%x, ret: %d\n", cal_val, ret);
+ 
+ 	return ret;
diff --git a/target/linux/generic/backport-6.12/723-v6.13-net-phy-mediatek-Re-organize-MediaTek-ethernet-phy-d.patch b/target/linux/generic/backport-6.12/723-v6.13-net-phy-mediatek-Re-organize-MediaTek-ethernet-phy-d.patch
new file mode 100644
index 0000000000..7161ffe069
--- /dev/null
+++ b/target/linux/generic/backport-6.12/723-v6.13-net-phy-mediatek-Re-organize-MediaTek-ethernet-phy-d.patch
@@ -0,0 +1,3565 @@
+From e062f073dc0df4fcd338043cb0b69b6bcd31e4af Mon Sep 17 00:00:00 2001
+From: "SkyLake.Huang" <skylake.huang@mediatek.com>
+Date: Sat, 9 Nov 2024 00:34:51 +0800
+Subject: [PATCH 04/20] net: phy: mediatek: Re-organize MediaTek ethernet phy
+ drivers
+
+Re-organize MediaTek ethernet phy driver files and get ready to integrate
+some common functions and add new 2.5G phy driver.
+mtk-ge.c: MT7530 Gphy on MT7621 & MT7531 Gphy
+mtk-ge-soc.c: Built-in Gphy on MT7981 & Built-in switch Gphy on MT7988
+mtk-2p5ge.c: Planned for built-in 2.5G phy on MT7988
+
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: SkyLake.Huang <skylake.huang@mediatek.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ MAINTAINERS                                   |  4 ++--
+ drivers/net/phy/Kconfig                       | 17 +-------------
+ drivers/net/phy/Makefile                      |  3 +--
+ drivers/net/phy/mediatek/Kconfig              | 22 +++++++++++++++++++
+ drivers/net/phy/mediatek/Makefile             |  3 +++
+ .../mtk-ge-soc.c}                             |  0
+ .../phy/{mediatek-ge.c => mediatek/mtk-ge.c}  |  0
+ 7 files changed, 29 insertions(+), 20 deletions(-)
+ create mode 100644 drivers/net/phy/mediatek/Kconfig
+ create mode 100644 drivers/net/phy/mediatek/Makefile
+ rename drivers/net/phy/{mediatek-ge-soc.c => mediatek/mtk-ge-soc.c} (100%)
+ rename drivers/net/phy/{mediatek-ge.c => mediatek/mtk-ge.c} (100%)
+
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -14427,8 +14427,8 @@ M:	Qingfang Deng <dqfext@gmail.com>
+ M:	SkyLake Huang <SkyLake.Huang@mediatek.com>
+ L:	netdev@vger.kernel.org
+ S:	Maintained
+-F:	drivers/net/phy/mediatek-ge-soc.c
+-F:	drivers/net/phy/mediatek-ge.c
++F:	drivers/net/phy/mediatek/mtk-ge-soc.c
++F:	drivers/net/phy/mediatek/mtk-ge.c
+ F:	drivers/phy/mediatek/phy-mtk-xfi-tphy.c
+ 
+ MEDIATEK I2C CONTROLLER DRIVER
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -266,22 +266,7 @@ config MAXLINEAR_GPHY
+ 	  Support for the Maxlinear GPY115, GPY211, GPY212, GPY215,
+ 	  GPY241, GPY245 PHYs.
+ 
+-config MEDIATEK_GE_PHY
+-	tristate "MediaTek Gigabit Ethernet PHYs"
+-	help
+-	  Supports the MediaTek Gigabit Ethernet PHYs.
+-
+-config MEDIATEK_GE_SOC_PHY
+-	tristate "MediaTek SoC Ethernet PHYs"
+-	depends on (ARM64 && ARCH_MEDIATEK) || COMPILE_TEST
+-	depends on NVMEM_MTK_EFUSE
+-	help
+-	  Supports MediaTek SoC built-in Gigabit Ethernet PHYs.
+-
+-	  Include support for built-in Ethernet PHYs which are present in
+-	  the MT7981 and MT7988 SoCs. These PHYs need calibration data
+-	  present in the SoCs efuse and will dynamically calibrate VCM
+-	  (common-mode voltage) during startup.
++source "drivers/net/phy/mediatek/Kconfig"
+ 
+ config MICREL_PHY
+ 	tristate "Micrel PHYs"
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -74,8 +74,7 @@ obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
+ obj-$(CONFIG_MARVELL_88Q2XXX_PHY)	+= marvell-88q2xxx.o
+ obj-$(CONFIG_MARVELL_88X2222_PHY)	+= marvell-88x2222.o
+ obj-$(CONFIG_MAXLINEAR_GPHY)	+= mxl-gpy.o
+-obj-$(CONFIG_MEDIATEK_GE_PHY)	+= mediatek-ge.o
+-obj-$(CONFIG_MEDIATEK_GE_SOC_PHY)	+= mediatek-ge-soc.o
++obj-y				+= mediatek/
+ obj-$(CONFIG_MESON_GXL_PHY)	+= meson-gxl.o
+ obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
+ obj-$(CONFIG_MICREL_PHY)	+= micrel.o
+--- /dev/null
++++ b/drivers/net/phy/mediatek/Kconfig
+@@ -0,0 +1,22 @@
++# SPDX-License-Identifier: GPL-2.0-only
++config MEDIATEK_GE_PHY
++	tristate "MediaTek Gigabit Ethernet PHYs"
++	help
++	  Supports the MediaTek non-built-in Gigabit Ethernet PHYs.
++
++	  Non-built-in Gigabit Ethernet PHYs include mt7530/mt7531.
++	  You may find mt7530 inside mt7621. This driver shares some
++	  common operations with MediaTek SoC built-in Gigabit
++	  Ethernet PHYs.
++
++config MEDIATEK_GE_SOC_PHY
++	tristate "MediaTek SoC Ethernet PHYs"
++	depends on (ARM64 && ARCH_MEDIATEK) || COMPILE_TEST
++	depends on NVMEM_MTK_EFUSE
++	help
++	  Supports MediaTek SoC built-in Gigabit Ethernet PHYs.
++
++	  Include support for built-in Ethernet PHYs which are present in
++	  the MT7981 and MT7988 SoCs. These PHYs need calibration data
++	  present in the SoCs efuse and will dynamically calibrate VCM
++	  (common-mode voltage) during startup.
+--- /dev/null
++++ b/drivers/net/phy/mediatek/Makefile
+@@ -0,0 +1,3 @@
++# SPDX-License-Identifier: GPL-2.0
++obj-$(CONFIG_MEDIATEK_GE_PHY)		+= mtk-ge.o
++obj-$(CONFIG_MEDIATEK_GE_SOC_PHY)	+= mtk-ge-soc.o
+--- a/drivers/net/phy/mediatek-ge-soc.c
++++ /dev/null
+@@ -1,1610 +0,0 @@
+-// SPDX-License-Identifier: GPL-2.0+
+-#include <linux/bitfield.h>
+-#include <linux/bitmap.h>
+-#include <linux/mfd/syscon.h>
+-#include <linux/module.h>
+-#include <linux/nvmem-consumer.h>
+-#include <linux/pinctrl/consumer.h>
+-#include <linux/phy.h>
+-#include <linux/regmap.h>
+-
+-#define MTK_GPHY_ID_MT7981			0x03a29461
+-#define MTK_GPHY_ID_MT7988			0x03a29481
+-
+-#define MTK_EXT_PAGE_ACCESS			0x1f
+-#define MTK_PHY_PAGE_STANDARD			0x0000
+-#define MTK_PHY_PAGE_EXTENDED_3			0x0003
+-
+-#define MTK_PHY_LPI_REG_14			0x14
+-#define MTK_PHY_LPI_WAKE_TIMER_1000_MASK	GENMASK(8, 0)
+-
+-#define MTK_PHY_LPI_REG_1c			0x1c
+-#define MTK_PHY_SMI_DET_ON_THRESH_MASK		GENMASK(13, 8)
+-
+-#define MTK_PHY_PAGE_EXTENDED_2A30		0x2a30
+-#define MTK_PHY_PAGE_EXTENDED_52B5		0x52b5
+-
+-#define ANALOG_INTERNAL_OPERATION_MAX_US	20
+-#define TXRESERVE_MIN				0
+-#define TXRESERVE_MAX				7
+-
+-#define MTK_PHY_ANARG_RG			0x10
+-#define   MTK_PHY_TCLKOFFSET_MASK		GENMASK(12, 8)
+-
+-/* Registers on MDIO_MMD_VEND1 */
+-#define MTK_PHY_TXVLD_DA_RG			0x12
+-#define   MTK_PHY_DA_TX_I2MPB_A_GBE_MASK	GENMASK(15, 10)
+-#define   MTK_PHY_DA_TX_I2MPB_A_TBT_MASK	GENMASK(5, 0)
+-
+-#define MTK_PHY_TX_I2MPB_TEST_MODE_A2		0x16
+-#define   MTK_PHY_DA_TX_I2MPB_A_HBT_MASK	GENMASK(15, 10)
+-#define   MTK_PHY_DA_TX_I2MPB_A_TST_MASK	GENMASK(5, 0)
+-
+-#define MTK_PHY_TX_I2MPB_TEST_MODE_B1		0x17
+-#define   MTK_PHY_DA_TX_I2MPB_B_GBE_MASK	GENMASK(13, 8)
+-#define   MTK_PHY_DA_TX_I2MPB_B_TBT_MASK	GENMASK(5, 0)
+-
+-#define MTK_PHY_TX_I2MPB_TEST_MODE_B2		0x18
+-#define   MTK_PHY_DA_TX_I2MPB_B_HBT_MASK	GENMASK(13, 8)
+-#define   MTK_PHY_DA_TX_I2MPB_B_TST_MASK	GENMASK(5, 0)
+-
+-#define MTK_PHY_TX_I2MPB_TEST_MODE_C1		0x19
+-#define   MTK_PHY_DA_TX_I2MPB_C_GBE_MASK	GENMASK(13, 8)
+-#define   MTK_PHY_DA_TX_I2MPB_C_TBT_MASK	GENMASK(5, 0)
+-
+-#define MTK_PHY_TX_I2MPB_TEST_MODE_C2		0x20
+-#define   MTK_PHY_DA_TX_I2MPB_C_HBT_MASK	GENMASK(13, 8)
+-#define   MTK_PHY_DA_TX_I2MPB_C_TST_MASK	GENMASK(5, 0)
+-
+-#define MTK_PHY_TX_I2MPB_TEST_MODE_D1		0x21
+-#define   MTK_PHY_DA_TX_I2MPB_D_GBE_MASK	GENMASK(13, 8)
+-#define   MTK_PHY_DA_TX_I2MPB_D_TBT_MASK	GENMASK(5, 0)
+-
+-#define MTK_PHY_TX_I2MPB_TEST_MODE_D2		0x22
+-#define   MTK_PHY_DA_TX_I2MPB_D_HBT_MASK	GENMASK(13, 8)
+-#define   MTK_PHY_DA_TX_I2MPB_D_TST_MASK	GENMASK(5, 0)
+-
+-#define MTK_PHY_RXADC_CTRL_RG7			0xc6
+-#define   MTK_PHY_DA_AD_BUF_BIAS_LP_MASK	GENMASK(9, 8)
+-
+-#define MTK_PHY_RXADC_CTRL_RG9			0xc8
+-#define   MTK_PHY_DA_RX_PSBN_TBT_MASK		GENMASK(14, 12)
+-#define   MTK_PHY_DA_RX_PSBN_HBT_MASK		GENMASK(10, 8)
+-#define   MTK_PHY_DA_RX_PSBN_GBE_MASK		GENMASK(6, 4)
+-#define   MTK_PHY_DA_RX_PSBN_LP_MASK		GENMASK(2, 0)
+-
+-#define MTK_PHY_LDO_OUTPUT_V			0xd7
+-
+-#define MTK_PHY_RG_ANA_CAL_RG0			0xdb
+-#define   MTK_PHY_RG_CAL_CKINV			BIT(12)
+-#define   MTK_PHY_RG_ANA_CALEN			BIT(8)
+-#define   MTK_PHY_RG_ZCALEN_A			BIT(0)
+-
+-#define MTK_PHY_RG_ANA_CAL_RG1			0xdc
+-#define   MTK_PHY_RG_ZCALEN_B			BIT(12)
+-#define   MTK_PHY_RG_ZCALEN_C			BIT(8)
+-#define   MTK_PHY_RG_ZCALEN_D			BIT(4)
+-#define   MTK_PHY_RG_TXVOS_CALEN		BIT(0)
+-
+-#define MTK_PHY_RG_ANA_CAL_RG5			0xe0
+-#define   MTK_PHY_RG_REXT_TRIM_MASK		GENMASK(13, 8)
+-
+-#define MTK_PHY_RG_TX_FILTER			0xfe
+-
+-#define MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG120	0x120
+-#define   MTK_PHY_LPI_SIG_EN_LO_THRESH1000_MASK	GENMASK(12, 8)
+-#define   MTK_PHY_LPI_SIG_EN_HI_THRESH1000_MASK	GENMASK(4, 0)
+-
+-#define MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG122	0x122
+-#define   MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK	GENMASK(7, 0)
+-
+-#define MTK_PHY_RG_TESTMUX_ADC_CTRL		0x144
+-#define   MTK_PHY_RG_TXEN_DIG_MASK		GENMASK(5, 5)
+-
+-#define MTK_PHY_RG_CR_TX_AMP_OFFSET_A_B		0x172
+-#define   MTK_PHY_CR_TX_AMP_OFFSET_A_MASK	GENMASK(13, 8)
+-#define   MTK_PHY_CR_TX_AMP_OFFSET_B_MASK	GENMASK(6, 0)
+-
+-#define MTK_PHY_RG_CR_TX_AMP_OFFSET_C_D		0x173
+-#define   MTK_PHY_CR_TX_AMP_OFFSET_C_MASK	GENMASK(13, 8)
+-#define   MTK_PHY_CR_TX_AMP_OFFSET_D_MASK	GENMASK(6, 0)
+-
+-#define MTK_PHY_RG_AD_CAL_COMP			0x17a
+-#define   MTK_PHY_AD_CAL_COMP_OUT_MASK		GENMASK(8, 8)
+-
+-#define MTK_PHY_RG_AD_CAL_CLK			0x17b
+-#define   MTK_PHY_DA_CAL_CLK			BIT(0)
+-
+-#define MTK_PHY_RG_AD_CALIN			0x17c
+-#define   MTK_PHY_DA_CALIN_FLAG			BIT(0)
+-
+-#define MTK_PHY_RG_DASN_DAC_IN0_A		0x17d
+-#define   MTK_PHY_DASN_DAC_IN0_A_MASK		GENMASK(9, 0)
+-
+-#define MTK_PHY_RG_DASN_DAC_IN0_B		0x17e
+-#define   MTK_PHY_DASN_DAC_IN0_B_MASK		GENMASK(9, 0)
+-
+-#define MTK_PHY_RG_DASN_DAC_IN0_C		0x17f
+-#define   MTK_PHY_DASN_DAC_IN0_C_MASK		GENMASK(9, 0)
+-
+-#define MTK_PHY_RG_DASN_DAC_IN0_D		0x180
+-#define   MTK_PHY_DASN_DAC_IN0_D_MASK		GENMASK(9, 0)
+-
+-#define MTK_PHY_RG_DASN_DAC_IN1_A		0x181
+-#define   MTK_PHY_DASN_DAC_IN1_A_MASK		GENMASK(9, 0)
+-
+-#define MTK_PHY_RG_DASN_DAC_IN1_B		0x182
+-#define   MTK_PHY_DASN_DAC_IN1_B_MASK		GENMASK(9, 0)
+-
+-#define MTK_PHY_RG_DASN_DAC_IN1_C		0x183
+-#define   MTK_PHY_DASN_DAC_IN1_C_MASK		GENMASK(9, 0)
+-
+-#define MTK_PHY_RG_DASN_DAC_IN1_D		0x184
+-#define   MTK_PHY_DASN_DAC_IN1_D_MASK		GENMASK(9, 0)
+-
+-#define MTK_PHY_RG_DEV1E_REG19b			0x19b
+-#define   MTK_PHY_BYPASS_DSP_LPI_READY		BIT(8)
+-
+-#define MTK_PHY_RG_LP_IIR2_K1_L			0x22a
+-#define MTK_PHY_RG_LP_IIR2_K1_U			0x22b
+-#define MTK_PHY_RG_LP_IIR2_K2_L			0x22c
+-#define MTK_PHY_RG_LP_IIR2_K2_U			0x22d
+-#define MTK_PHY_RG_LP_IIR2_K3_L			0x22e
+-#define MTK_PHY_RG_LP_IIR2_K3_U			0x22f
+-#define MTK_PHY_RG_LP_IIR2_K4_L			0x230
+-#define MTK_PHY_RG_LP_IIR2_K4_U			0x231
+-#define MTK_PHY_RG_LP_IIR2_K5_L			0x232
+-#define MTK_PHY_RG_LP_IIR2_K5_U			0x233
+-
+-#define MTK_PHY_RG_DEV1E_REG234			0x234
+-#define   MTK_PHY_TR_OPEN_LOOP_EN_MASK		GENMASK(0, 0)
+-#define   MTK_PHY_LPF_X_AVERAGE_MASK		GENMASK(7, 4)
+-#define   MTK_PHY_TR_LP_IIR_EEE_EN		BIT(12)
+-
+-#define MTK_PHY_RG_LPF_CNT_VAL			0x235
+-
+-#define MTK_PHY_RG_DEV1E_REG238			0x238
+-#define   MTK_PHY_LPI_SLV_SEND_TX_TIMER_MASK	GENMASK(8, 0)
+-#define   MTK_PHY_LPI_SLV_SEND_TX_EN		BIT(12)
+-
+-#define MTK_PHY_RG_DEV1E_REG239			0x239
+-#define   MTK_PHY_LPI_SEND_LOC_TIMER_MASK	GENMASK(8, 0)
+-#define   MTK_PHY_LPI_TXPCS_LOC_RCV		BIT(12)
+-
+-#define MTK_PHY_RG_DEV1E_REG27C			0x27c
+-#define   MTK_PHY_VGASTATE_FFE_THR_ST1_MASK	GENMASK(12, 8)
+-#define MTK_PHY_RG_DEV1E_REG27D			0x27d
+-#define   MTK_PHY_VGASTATE_FFE_THR_ST2_MASK	GENMASK(4, 0)
+-
+-#define MTK_PHY_RG_DEV1E_REG2C7			0x2c7
+-#define   MTK_PHY_MAX_GAIN_MASK			GENMASK(4, 0)
+-#define   MTK_PHY_MIN_GAIN_MASK			GENMASK(12, 8)
+-
+-#define MTK_PHY_RG_DEV1E_REG2D1			0x2d1
+-#define   MTK_PHY_VCO_SLICER_THRESH_BITS_HIGH_EEE_MASK	GENMASK(7, 0)
+-#define   MTK_PHY_LPI_SKIP_SD_SLV_TR		BIT(8)
+-#define   MTK_PHY_LPI_TR_READY			BIT(9)
+-#define   MTK_PHY_LPI_VCO_EEE_STG0_EN		BIT(10)
+-
+-#define MTK_PHY_RG_DEV1E_REG323			0x323
+-#define   MTK_PHY_EEE_WAKE_MAS_INT_DC		BIT(0)
+-#define   MTK_PHY_EEE_WAKE_SLV_INT_DC		BIT(4)
+-
+-#define MTK_PHY_RG_DEV1E_REG324			0x324
+-#define   MTK_PHY_SMI_DETCNT_MAX_MASK		GENMASK(5, 0)
+-#define   MTK_PHY_SMI_DET_MAX_EN		BIT(8)
+-
+-#define MTK_PHY_RG_DEV1E_REG326			0x326
+-#define   MTK_PHY_LPI_MODE_SD_ON		BIT(0)
+-#define   MTK_PHY_RESET_RANDUPD_CNT		BIT(1)
+-#define   MTK_PHY_TREC_UPDATE_ENAB_CLR		BIT(2)
+-#define   MTK_PHY_LPI_QUIT_WAIT_DFE_SIG_DET_OFF	BIT(4)
+-#define   MTK_PHY_TR_READY_SKIP_AFE_WAKEUP	BIT(5)
+-
+-#define MTK_PHY_LDO_PUMP_EN_PAIRAB		0x502
+-#define MTK_PHY_LDO_PUMP_EN_PAIRCD		0x503
+-
+-#define MTK_PHY_DA_TX_R50_PAIR_A		0x53d
+-#define MTK_PHY_DA_TX_R50_PAIR_B		0x53e
+-#define MTK_PHY_DA_TX_R50_PAIR_C		0x53f
+-#define MTK_PHY_DA_TX_R50_PAIR_D		0x540
+-
+-/* Registers on MDIO_MMD_VEND2 */
+-#define MTK_PHY_LED0_ON_CTRL			0x24
+-#define MTK_PHY_LED1_ON_CTRL			0x26
+-#define   MTK_PHY_LED_ON_MASK			GENMASK(6, 0)
+-#define   MTK_PHY_LED_ON_LINK1000		BIT(0)
+-#define   MTK_PHY_LED_ON_LINK100		BIT(1)
+-#define   MTK_PHY_LED_ON_LINK10			BIT(2)
+-#define   MTK_PHY_LED_ON_LINK			(MTK_PHY_LED_ON_LINK10 |\
+-						 MTK_PHY_LED_ON_LINK100 |\
+-						 MTK_PHY_LED_ON_LINK1000)
+-#define   MTK_PHY_LED_ON_LINKDOWN		BIT(3)
+-#define   MTK_PHY_LED_ON_FDX			BIT(4) /* Full duplex */
+-#define   MTK_PHY_LED_ON_HDX			BIT(5) /* Half duplex */
+-#define   MTK_PHY_LED_ON_FORCE_ON		BIT(6)
+-#define   MTK_PHY_LED_ON_POLARITY		BIT(14)
+-#define   MTK_PHY_LED_ON_ENABLE			BIT(15)
+-
+-#define MTK_PHY_LED0_BLINK_CTRL			0x25
+-#define MTK_PHY_LED1_BLINK_CTRL			0x27
+-#define   MTK_PHY_LED_BLINK_1000TX		BIT(0)
+-#define   MTK_PHY_LED_BLINK_1000RX		BIT(1)
+-#define   MTK_PHY_LED_BLINK_100TX		BIT(2)
+-#define   MTK_PHY_LED_BLINK_100RX		BIT(3)
+-#define   MTK_PHY_LED_BLINK_10TX		BIT(4)
+-#define   MTK_PHY_LED_BLINK_10RX		BIT(5)
+-#define   MTK_PHY_LED_BLINK_RX			(MTK_PHY_LED_BLINK_10RX |\
+-						 MTK_PHY_LED_BLINK_100RX |\
+-						 MTK_PHY_LED_BLINK_1000RX)
+-#define   MTK_PHY_LED_BLINK_TX			(MTK_PHY_LED_BLINK_10TX |\
+-						 MTK_PHY_LED_BLINK_100TX |\
+-						 MTK_PHY_LED_BLINK_1000TX)
+-#define   MTK_PHY_LED_BLINK_COLLISION		BIT(6)
+-#define   MTK_PHY_LED_BLINK_RX_CRC_ERR		BIT(7)
+-#define   MTK_PHY_LED_BLINK_RX_IDLE_ERR		BIT(8)
+-#define   MTK_PHY_LED_BLINK_FORCE_BLINK		BIT(9)
+-
+-#define MTK_PHY_LED1_DEFAULT_POLARITIES		BIT(1)
+-
+-#define MTK_PHY_RG_BG_RASEL			0x115
+-#define   MTK_PHY_RG_BG_RASEL_MASK		GENMASK(2, 0)
+-
+-/* 'boottrap' register reflecting the configuration of the 4 PHY LEDs */
+-#define RG_GPIO_MISC_TPBANK0			0x6f0
+-#define   RG_GPIO_MISC_TPBANK0_BOOTMODE		GENMASK(11, 8)
+-
+-/* These macro privides efuse parsing for internal phy. */
+-#define EFS_DA_TX_I2MPB_A(x)			(((x) >> 0) & GENMASK(5, 0))
+-#define EFS_DA_TX_I2MPB_B(x)			(((x) >> 6) & GENMASK(5, 0))
+-#define EFS_DA_TX_I2MPB_C(x)			(((x) >> 12) & GENMASK(5, 0))
+-#define EFS_DA_TX_I2MPB_D(x)			(((x) >> 18) & GENMASK(5, 0))
+-#define EFS_DA_TX_AMP_OFFSET_A(x)		(((x) >> 24) & GENMASK(5, 0))
+-
+-#define EFS_DA_TX_AMP_OFFSET_B(x)		(((x) >> 0) & GENMASK(5, 0))
+-#define EFS_DA_TX_AMP_OFFSET_C(x)		(((x) >> 6) & GENMASK(5, 0))
+-#define EFS_DA_TX_AMP_OFFSET_D(x)		(((x) >> 12) & GENMASK(5, 0))
+-#define EFS_DA_TX_R50_A(x)			(((x) >> 18) & GENMASK(5, 0))
+-#define EFS_DA_TX_R50_B(x)			(((x) >> 24) & GENMASK(5, 0))
+-
+-#define EFS_DA_TX_R50_C(x)			(((x) >> 0) & GENMASK(5, 0))
+-#define EFS_DA_TX_R50_D(x)			(((x) >> 6) & GENMASK(5, 0))
+-
+-#define EFS_RG_BG_RASEL(x)			(((x) >> 4) & GENMASK(2, 0))
+-#define EFS_RG_REXT_TRIM(x)			(((x) >> 7) & GENMASK(5, 0))
+-
+-enum {
+-	NO_PAIR,
+-	PAIR_A,
+-	PAIR_B,
+-	PAIR_C,
+-	PAIR_D,
+-};
+-
+-enum calibration_mode {
+-	EFUSE_K,
+-	SW_K
+-};
+-
+-enum CAL_ITEM {
+-	REXT,
+-	TX_OFFSET,
+-	TX_AMP,
+-	TX_R50,
+-	TX_VCM
+-};
+-
+-enum CAL_MODE {
+-	EFUSE_M,
+-	SW_M
+-};
+-
+-#define MTK_PHY_LED_STATE_FORCE_ON	0
+-#define MTK_PHY_LED_STATE_FORCE_BLINK	1
+-#define MTK_PHY_LED_STATE_NETDEV	2
+-
+-struct mtk_socphy_priv {
+-	unsigned long		led_state;
+-};
+-
+-struct mtk_socphy_shared {
+-	u32			boottrap;
+-	struct mtk_socphy_priv	priv[4];
+-};
+-
+-static int mtk_socphy_read_page(struct phy_device *phydev)
+-{
+-	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
+-}
+-
+-static int mtk_socphy_write_page(struct phy_device *phydev, int page)
+-{
+-	return __phy_write(phydev, MTK_EXT_PAGE_ACCESS, page);
+-}
+-
+-/* One calibration cycle consists of:
+- * 1.Set DA_CALIN_FLAG high to start calibration. Keep it high
+- *   until AD_CAL_COMP is ready to output calibration result.
+- * 2.Wait until DA_CAL_CLK is available.
+- * 3.Fetch AD_CAL_COMP_OUT.
+- */
+-static int cal_cycle(struct phy_device *phydev, int devad,
+-		     u32 regnum, u16 mask, u16 cal_val)
+-{
+-	int reg_val;
+-	int ret;
+-
+-	phy_modify_mmd(phydev, devad, regnum,
+-		       mask, cal_val);
+-	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_AD_CALIN,
+-			 MTK_PHY_DA_CALIN_FLAG);
+-
+-	ret = phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1,
+-					MTK_PHY_RG_AD_CAL_CLK, reg_val,
+-					reg_val & MTK_PHY_DA_CAL_CLK, 500,
+-					ANALOG_INTERNAL_OPERATION_MAX_US,
+-					false);
+-	if (ret) {
+-		phydev_err(phydev, "Calibration cycle timeout\n");
+-		return ret;
+-	}
+-
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_AD_CALIN,
+-			   MTK_PHY_DA_CALIN_FLAG);
+-	ret = phy_read_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_AD_CAL_COMP);
+-	if (ret < 0)
+-		return ret;
+-	ret = FIELD_GET(MTK_PHY_AD_CAL_COMP_OUT_MASK, ret);
+-	phydev_dbg(phydev, "cal_val: 0x%x, ret: %d\n", cal_val, ret);
+-
+-	return ret;
+-}
+-
+-static int rext_fill_result(struct phy_device *phydev, u16 *buf)
+-{
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG5,
+-		       MTK_PHY_RG_REXT_TRIM_MASK, buf[0] << 8);
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND2, MTK_PHY_RG_BG_RASEL,
+-		       MTK_PHY_RG_BG_RASEL_MASK, buf[1]);
+-
+-	return 0;
+-}
+-
+-static int rext_cal_efuse(struct phy_device *phydev, u32 *buf)
+-{
+-	u16 rext_cal_val[2];
+-
+-	rext_cal_val[0] = EFS_RG_REXT_TRIM(buf[3]);
+-	rext_cal_val[1] = EFS_RG_BG_RASEL(buf[3]);
+-	rext_fill_result(phydev, rext_cal_val);
+-
+-	return 0;
+-}
+-
+-static int tx_offset_fill_result(struct phy_device *phydev, u16 *buf)
+-{
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_CR_TX_AMP_OFFSET_A_B,
+-		       MTK_PHY_CR_TX_AMP_OFFSET_A_MASK, buf[0] << 8);
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_CR_TX_AMP_OFFSET_A_B,
+-		       MTK_PHY_CR_TX_AMP_OFFSET_B_MASK, buf[1]);
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_CR_TX_AMP_OFFSET_C_D,
+-		       MTK_PHY_CR_TX_AMP_OFFSET_C_MASK, buf[2] << 8);
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_CR_TX_AMP_OFFSET_C_D,
+-		       MTK_PHY_CR_TX_AMP_OFFSET_D_MASK, buf[3]);
+-
+-	return 0;
+-}
+-
+-static int tx_offset_cal_efuse(struct phy_device *phydev, u32 *buf)
+-{
+-	u16 tx_offset_cal_val[4];
+-
+-	tx_offset_cal_val[0] = EFS_DA_TX_AMP_OFFSET_A(buf[0]);
+-	tx_offset_cal_val[1] = EFS_DA_TX_AMP_OFFSET_B(buf[1]);
+-	tx_offset_cal_val[2] = EFS_DA_TX_AMP_OFFSET_C(buf[1]);
+-	tx_offset_cal_val[3] = EFS_DA_TX_AMP_OFFSET_D(buf[1]);
+-
+-	tx_offset_fill_result(phydev, tx_offset_cal_val);
+-
+-	return 0;
+-}
+-
+-static int tx_amp_fill_result(struct phy_device *phydev, u16 *buf)
+-{
+-	const int vals_9481[16] = { 10, 6, 6, 10,
+-				    10, 6, 6, 10,
+-				    10, 6, 6, 10,
+-				    10, 6, 6, 10 };
+-	const int vals_9461[16] = { 7, 1, 4, 7,
+-				    7, 1, 4, 7,
+-				    7, 1, 4, 7,
+-				    7, 1, 4, 7 };
+-	int bias[16] = {};
+-	int i;
+-
+-	switch (phydev->drv->phy_id) {
+-	case MTK_GPHY_ID_MT7981:
+-		/* We add some calibration to efuse values
+-		 * due to board level influence.
+-		 * GBE: +7, TBT: +1, HBT: +4, TST: +7
+-		 */
+-		memcpy(bias, (const void *)vals_9461, sizeof(bias));
+-		break;
+-	case MTK_GPHY_ID_MT7988:
+-		memcpy(bias, (const void *)vals_9481, sizeof(bias));
+-		break;
+-	}
+-
+-	/* Prevent overflow */
+-	for (i = 0; i < 12; i++) {
+-		if (buf[i >> 2] + bias[i] > 63) {
+-			buf[i >> 2] = 63;
+-			bias[i] = 0;
+-		}
+-	}
+-
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TXVLD_DA_RG,
+-		       MTK_PHY_DA_TX_I2MPB_A_GBE_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_GBE_MASK,
+-				  buf[0] + bias[0]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TXVLD_DA_RG,
+-		       MTK_PHY_DA_TX_I2MPB_A_TBT_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_TBT_MASK,
+-				  buf[0] + bias[1]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_A2,
+-		       MTK_PHY_DA_TX_I2MPB_A_HBT_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_HBT_MASK,
+-				  buf[0] + bias[2]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_A2,
+-		       MTK_PHY_DA_TX_I2MPB_A_TST_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_TST_MASK,
+-				  buf[0] + bias[3]));
+-
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B1,
+-		       MTK_PHY_DA_TX_I2MPB_B_GBE_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_GBE_MASK,
+-				  buf[1] + bias[4]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B1,
+-		       MTK_PHY_DA_TX_I2MPB_B_TBT_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_TBT_MASK,
+-				  buf[1] + bias[5]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B2,
+-		       MTK_PHY_DA_TX_I2MPB_B_HBT_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_HBT_MASK,
+-				  buf[1] + bias[6]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B2,
+-		       MTK_PHY_DA_TX_I2MPB_B_TST_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_TST_MASK,
+-				  buf[1] + bias[7]));
+-
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C1,
+-		       MTK_PHY_DA_TX_I2MPB_C_GBE_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_GBE_MASK,
+-				  buf[2] + bias[8]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C1,
+-		       MTK_PHY_DA_TX_I2MPB_C_TBT_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_TBT_MASK,
+-				  buf[2] + bias[9]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C2,
+-		       MTK_PHY_DA_TX_I2MPB_C_HBT_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_HBT_MASK,
+-				  buf[2] + bias[10]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C2,
+-		       MTK_PHY_DA_TX_I2MPB_C_TST_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_TST_MASK,
+-				  buf[2] + bias[11]));
+-
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D1,
+-		       MTK_PHY_DA_TX_I2MPB_D_GBE_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_GBE_MASK,
+-				  buf[3] + bias[12]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D1,
+-		       MTK_PHY_DA_TX_I2MPB_D_TBT_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_TBT_MASK,
+-				  buf[3] + bias[13]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D2,
+-		       MTK_PHY_DA_TX_I2MPB_D_HBT_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_HBT_MASK,
+-				  buf[3] + bias[14]));
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D2,
+-		       MTK_PHY_DA_TX_I2MPB_D_TST_MASK,
+-		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_TST_MASK,
+-				  buf[3] + bias[15]));
+-
+-	return 0;
+-}
+-
+-static int tx_amp_cal_efuse(struct phy_device *phydev, u32 *buf)
+-{
+-	u16 tx_amp_cal_val[4];
+-
+-	tx_amp_cal_val[0] = EFS_DA_TX_I2MPB_A(buf[0]);
+-	tx_amp_cal_val[1] = EFS_DA_TX_I2MPB_B(buf[0]);
+-	tx_amp_cal_val[2] = EFS_DA_TX_I2MPB_C(buf[0]);
+-	tx_amp_cal_val[3] = EFS_DA_TX_I2MPB_D(buf[0]);
+-	tx_amp_fill_result(phydev, tx_amp_cal_val);
+-
+-	return 0;
+-}
+-
+-static int tx_r50_fill_result(struct phy_device *phydev, u16 tx_r50_cal_val,
+-			      u8 txg_calen_x)
+-{
+-	int bias = 0;
+-	u16 reg, val;
+-
+-	if (phydev->drv->phy_id == MTK_GPHY_ID_MT7988)
+-		bias = -1;
+-
+-	val = clamp_val(bias + tx_r50_cal_val, 0, 63);
+-
+-	switch (txg_calen_x) {
+-	case PAIR_A:
+-		reg = MTK_PHY_DA_TX_R50_PAIR_A;
+-		break;
+-	case PAIR_B:
+-		reg = MTK_PHY_DA_TX_R50_PAIR_B;
+-		break;
+-	case PAIR_C:
+-		reg = MTK_PHY_DA_TX_R50_PAIR_C;
+-		break;
+-	case PAIR_D:
+-		reg = MTK_PHY_DA_TX_R50_PAIR_D;
+-		break;
+-	default:
+-		return -EINVAL;
+-	}
+-
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, reg, val | val << 8);
+-
+-	return 0;
+-}
+-
+-static int tx_r50_cal_efuse(struct phy_device *phydev, u32 *buf,
+-			    u8 txg_calen_x)
+-{
+-	u16 tx_r50_cal_val;
+-
+-	switch (txg_calen_x) {
+-	case PAIR_A:
+-		tx_r50_cal_val = EFS_DA_TX_R50_A(buf[1]);
+-		break;
+-	case PAIR_B:
+-		tx_r50_cal_val = EFS_DA_TX_R50_B(buf[1]);
+-		break;
+-	case PAIR_C:
+-		tx_r50_cal_val = EFS_DA_TX_R50_C(buf[2]);
+-		break;
+-	case PAIR_D:
+-		tx_r50_cal_val = EFS_DA_TX_R50_D(buf[2]);
+-		break;
+-	default:
+-		return -EINVAL;
+-	}
+-	tx_r50_fill_result(phydev, tx_r50_cal_val, txg_calen_x);
+-
+-	return 0;
+-}
+-
+-static int tx_vcm_cal_sw(struct phy_device *phydev, u8 rg_txreserve_x)
+-{
+-	u8 lower_idx, upper_idx, txreserve_val;
+-	u8 lower_ret, upper_ret;
+-	int ret;
+-
+-	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG0,
+-			 MTK_PHY_RG_ANA_CALEN);
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG0,
+-			   MTK_PHY_RG_CAL_CKINV);
+-	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG1,
+-			 MTK_PHY_RG_TXVOS_CALEN);
+-
+-	switch (rg_txreserve_x) {
+-	case PAIR_A:
+-		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				   MTK_PHY_RG_DASN_DAC_IN0_A,
+-				   MTK_PHY_DASN_DAC_IN0_A_MASK);
+-		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				   MTK_PHY_RG_DASN_DAC_IN1_A,
+-				   MTK_PHY_DASN_DAC_IN1_A_MASK);
+-		phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				 MTK_PHY_RG_ANA_CAL_RG0,
+-				 MTK_PHY_RG_ZCALEN_A);
+-		break;
+-	case PAIR_B:
+-		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				   MTK_PHY_RG_DASN_DAC_IN0_B,
+-				   MTK_PHY_DASN_DAC_IN0_B_MASK);
+-		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				   MTK_PHY_RG_DASN_DAC_IN1_B,
+-				   MTK_PHY_DASN_DAC_IN1_B_MASK);
+-		phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				 MTK_PHY_RG_ANA_CAL_RG1,
+-				 MTK_PHY_RG_ZCALEN_B);
+-		break;
+-	case PAIR_C:
+-		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				   MTK_PHY_RG_DASN_DAC_IN0_C,
+-				   MTK_PHY_DASN_DAC_IN0_C_MASK);
+-		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				   MTK_PHY_RG_DASN_DAC_IN1_C,
+-				   MTK_PHY_DASN_DAC_IN1_C_MASK);
+-		phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				 MTK_PHY_RG_ANA_CAL_RG1,
+-				 MTK_PHY_RG_ZCALEN_C);
+-		break;
+-	case PAIR_D:
+-		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				   MTK_PHY_RG_DASN_DAC_IN0_D,
+-				   MTK_PHY_DASN_DAC_IN0_D_MASK);
+-		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				   MTK_PHY_RG_DASN_DAC_IN1_D,
+-				   MTK_PHY_DASN_DAC_IN1_D_MASK);
+-		phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
+-				 MTK_PHY_RG_ANA_CAL_RG1,
+-				 MTK_PHY_RG_ZCALEN_D);
+-		break;
+-	default:
+-		ret = -EINVAL;
+-		goto restore;
+-	}
+-
+-	lower_idx = TXRESERVE_MIN;
+-	upper_idx = TXRESERVE_MAX;
+-
+-	phydev_dbg(phydev, "Start TX-VCM SW cal.\n");
+-	while ((upper_idx - lower_idx) > 1) {
+-		txreserve_val = DIV_ROUND_CLOSEST(lower_idx + upper_idx, 2);
+-		ret = cal_cycle(phydev, MDIO_MMD_VEND1, MTK_PHY_RXADC_CTRL_RG9,
+-				MTK_PHY_DA_RX_PSBN_TBT_MASK |
+-				MTK_PHY_DA_RX_PSBN_HBT_MASK |
+-				MTK_PHY_DA_RX_PSBN_GBE_MASK |
+-				MTK_PHY_DA_RX_PSBN_LP_MASK,
+-				txreserve_val << 12 | txreserve_val << 8 |
+-				txreserve_val << 4 | txreserve_val);
+-		if (ret == 1) {
+-			upper_idx = txreserve_val;
+-			upper_ret = ret;
+-		} else if (ret == 0) {
+-			lower_idx = txreserve_val;
+-			lower_ret = ret;
+-		} else {
+-			goto restore;
+-		}
+-	}
+-
+-	if (lower_idx == TXRESERVE_MIN) {
+-		lower_ret = cal_cycle(phydev, MDIO_MMD_VEND1,
+-				      MTK_PHY_RXADC_CTRL_RG9,
+-				      MTK_PHY_DA_RX_PSBN_TBT_MASK |
+-				      MTK_PHY_DA_RX_PSBN_HBT_MASK |
+-				      MTK_PHY_DA_RX_PSBN_GBE_MASK |
+-				      MTK_PHY_DA_RX_PSBN_LP_MASK,
+-				      lower_idx << 12 | lower_idx << 8 |
+-				      lower_idx << 4 | lower_idx);
+-		ret = lower_ret;
+-	} else if (upper_idx == TXRESERVE_MAX) {
+-		upper_ret = cal_cycle(phydev, MDIO_MMD_VEND1,
+-				      MTK_PHY_RXADC_CTRL_RG9,
+-				      MTK_PHY_DA_RX_PSBN_TBT_MASK |
+-				      MTK_PHY_DA_RX_PSBN_HBT_MASK |
+-				      MTK_PHY_DA_RX_PSBN_GBE_MASK |
+-				      MTK_PHY_DA_RX_PSBN_LP_MASK,
+-				      upper_idx << 12 | upper_idx << 8 |
+-				      upper_idx << 4 | upper_idx);
+-		ret = upper_ret;
+-	}
+-	if (ret < 0)
+-		goto restore;
+-
+-	/* We calibrate TX-VCM in different logic. Check upper index and then
+-	 * lower index. If this calibration is valid, apply lower index's
+-	 * result.
+-	 */
+-	ret = upper_ret - lower_ret;
+-	if (ret == 1) {
+-		ret = 0;
+-		/* Make sure we use upper_idx in our calibration system */
+-		cal_cycle(phydev, MDIO_MMD_VEND1, MTK_PHY_RXADC_CTRL_RG9,
+-			  MTK_PHY_DA_RX_PSBN_TBT_MASK |
+-			  MTK_PHY_DA_RX_PSBN_HBT_MASK |
+-			  MTK_PHY_DA_RX_PSBN_GBE_MASK |
+-			  MTK_PHY_DA_RX_PSBN_LP_MASK,
+-			  upper_idx << 12 | upper_idx << 8 |
+-			  upper_idx << 4 | upper_idx);
+-		phydev_dbg(phydev, "TX-VCM SW cal result: 0x%x\n", upper_idx);
+-	} else if (lower_idx == TXRESERVE_MIN && upper_ret == 1 &&
+-		   lower_ret == 1) {
+-		ret = 0;
+-		cal_cycle(phydev, MDIO_MMD_VEND1, MTK_PHY_RXADC_CTRL_RG9,
+-			  MTK_PHY_DA_RX_PSBN_TBT_MASK |
+-			  MTK_PHY_DA_RX_PSBN_HBT_MASK |
+-			  MTK_PHY_DA_RX_PSBN_GBE_MASK |
+-			  MTK_PHY_DA_RX_PSBN_LP_MASK,
+-			  lower_idx << 12 | lower_idx << 8 |
+-			  lower_idx << 4 | lower_idx);
+-		phydev_warn(phydev, "TX-VCM SW cal result at low margin 0x%x\n",
+-			    lower_idx);
+-	} else if (upper_idx == TXRESERVE_MAX && upper_ret == 0 &&
+-		   lower_ret == 0) {
+-		ret = 0;
+-		phydev_warn(phydev,
+-			    "TX-VCM SW cal result at high margin 0x%x\n",
+-			    upper_idx);
+-	} else {
+-		ret = -EINVAL;
+-	}
+-
+-restore:
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG0,
+-			   MTK_PHY_RG_ANA_CALEN);
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG1,
+-			   MTK_PHY_RG_TXVOS_CALEN);
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG0,
+-			   MTK_PHY_RG_ZCALEN_A);
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG1,
+-			   MTK_PHY_RG_ZCALEN_B | MTK_PHY_RG_ZCALEN_C |
+-			   MTK_PHY_RG_ZCALEN_D);
+-
+-	return ret;
+-}
+-
+-static void mt798x_phy_common_finetune(struct phy_device *phydev)
+-{
+-	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	/* SlvDSPreadyTime = 24, MasDSPreadyTime = 24 */
+-	__phy_write(phydev, 0x11, 0xc71);
+-	__phy_write(phydev, 0x12, 0xc);
+-	__phy_write(phydev, 0x10, 0x8fae);
+-
+-	/* EnabRandUpdTrig = 1 */
+-	__phy_write(phydev, 0x11, 0x2f00);
+-	__phy_write(phydev, 0x12, 0xe);
+-	__phy_write(phydev, 0x10, 0x8fb0);
+-
+-	/* NormMseLoThresh = 85 */
+-	__phy_write(phydev, 0x11, 0x55a0);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x83aa);
+-
+-	/* FfeUpdGainForce = 1(Enable), FfeUpdGainForceVal = 4 */
+-	__phy_write(phydev, 0x11, 0x240);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x9680);
+-
+-	/* TrFreeze = 0 (mt7988 default) */
+-	__phy_write(phydev, 0x11, 0x0);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x9686);
+-
+-	/* SSTrKp100 = 5 */
+-	/* SSTrKf100 = 6 */
+-	/* SSTrKp1000Mas = 5 */
+-	/* SSTrKf1000Mas = 6 */
+-	/* SSTrKp1000Slv = 5 */
+-	/* SSTrKf1000Slv = 6 */
+-	__phy_write(phydev, 0x11, 0xbaef);
+-	__phy_write(phydev, 0x12, 0x2e);
+-	__phy_write(phydev, 0x10, 0x968c);
+-	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+-}
+-
+-static void mt7981_phy_finetune(struct phy_device *phydev)
+-{
+-	u16 val[8] = { 0x01ce, 0x01c1,
+-		       0x020f, 0x0202,
+-		       0x03d0, 0x03c0,
+-		       0x0013, 0x0005 };
+-	int i, k;
+-
+-	/* 100M eye finetune:
+-	 * Keep middle level of TX MLT3 shapper as default.
+-	 * Only change TX MLT3 overshoot level here.
+-	 */
+-	for (k = 0, i = 1; i < 12; i++) {
+-		if (i % 3 == 0)
+-			continue;
+-		phy_write_mmd(phydev, MDIO_MMD_VEND1, i, val[k++]);
+-	}
+-
+-	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	/* ResetSyncOffset = 6 */
+-	__phy_write(phydev, 0x11, 0x600);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x8fc0);
+-
+-	/* VgaDecRate = 1 */
+-	__phy_write(phydev, 0x11, 0x4c2a);
+-	__phy_write(phydev, 0x12, 0x3e);
+-	__phy_write(phydev, 0x10, 0x8fa4);
+-
+-	/* MrvlTrFix100Kp = 3, MrvlTrFix100Kf = 2,
+-	 * MrvlTrFix1000Kp = 3, MrvlTrFix1000Kf = 2
+-	 */
+-	__phy_write(phydev, 0x11, 0xd10a);
+-	__phy_write(phydev, 0x12, 0x34);
+-	__phy_write(phydev, 0x10, 0x8f82);
+-
+-	/* VcoSlicerThreshBitsHigh */
+-	__phy_write(phydev, 0x11, 0x5555);
+-	__phy_write(phydev, 0x12, 0x55);
+-	__phy_write(phydev, 0x10, 0x8ec0);
+-	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+-
+-	/* TR_OPEN_LOOP_EN = 1, lpf_x_average = 9 */
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG234,
+-		       MTK_PHY_TR_OPEN_LOOP_EN_MASK |
+-		       MTK_PHY_LPF_X_AVERAGE_MASK,
+-		       BIT(0) | FIELD_PREP(MTK_PHY_LPF_X_AVERAGE_MASK, 0x9));
+-
+-	/* rg_tr_lpf_cnt_val = 512 */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LPF_CNT_VAL, 0x200);
+-
+-	/* IIR2 related */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K1_L, 0x82);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K1_U, 0x0);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K2_L, 0x103);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K2_U, 0x0);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K3_L, 0x82);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K3_U, 0x0);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K4_L, 0xd177);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K4_U, 0x3);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K5_L, 0x2c82);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K5_U, 0xe);
+-
+-	/* FFE peaking */
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG27C,
+-		       MTK_PHY_VGASTATE_FFE_THR_ST1_MASK, 0x1b << 8);
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG27D,
+-		       MTK_PHY_VGASTATE_FFE_THR_ST2_MASK, 0x1e);
+-
+-	/* Disable LDO pump */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_LDO_PUMP_EN_PAIRAB, 0x0);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_LDO_PUMP_EN_PAIRCD, 0x0);
+-	/* Adjust LDO output voltage */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_LDO_OUTPUT_V, 0x2222);
+-}
+-
+-static void mt7988_phy_finetune(struct phy_device *phydev)
+-{
+-	u16 val[12] = { 0x0187, 0x01cd, 0x01c8, 0x0182,
+-			0x020d, 0x0206, 0x0384, 0x03d0,
+-			0x03c6, 0x030a, 0x0011, 0x0005 };
+-	int i;
+-
+-	/* Set default MLT3 shaper first */
+-	for (i = 0; i < 12; i++)
+-		phy_write_mmd(phydev, MDIO_MMD_VEND1, i, val[i]);
+-
+-	/* TCT finetune */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_TX_FILTER, 0x5);
+-
+-	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	/* ResetSyncOffset = 5 */
+-	__phy_write(phydev, 0x11, 0x500);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x8fc0);
+-
+-	/* VgaDecRate is 1 at default on mt7988 */
+-
+-	/* MrvlTrFix100Kp = 6, MrvlTrFix100Kf = 7,
+-	 * MrvlTrFix1000Kp = 6, MrvlTrFix1000Kf = 7
+-	 */
+-	__phy_write(phydev, 0x11, 0xb90a);
+-	__phy_write(phydev, 0x12, 0x6f);
+-	__phy_write(phydev, 0x10, 0x8f82);
+-
+-	/* RemAckCntLimitCtrl = 1 */
+-	__phy_write(phydev, 0x11, 0xfbba);
+-	__phy_write(phydev, 0x12, 0xc3);
+-	__phy_write(phydev, 0x10, 0x87f8);
+-
+-	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+-
+-	/* TR_OPEN_LOOP_EN = 1, lpf_x_average = 10 */
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG234,
+-		       MTK_PHY_TR_OPEN_LOOP_EN_MASK |
+-		       MTK_PHY_LPF_X_AVERAGE_MASK,
+-		       BIT(0) | FIELD_PREP(MTK_PHY_LPF_X_AVERAGE_MASK, 0xa));
+-
+-	/* rg_tr_lpf_cnt_val = 1023 */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LPF_CNT_VAL, 0x3ff);
+-}
+-
+-static void mt798x_phy_eee(struct phy_device *phydev)
+-{
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
+-		       MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG120,
+-		       MTK_PHY_LPI_SIG_EN_LO_THRESH1000_MASK |
+-		       MTK_PHY_LPI_SIG_EN_HI_THRESH1000_MASK,
+-		       FIELD_PREP(MTK_PHY_LPI_SIG_EN_LO_THRESH1000_MASK, 0x0) |
+-		       FIELD_PREP(MTK_PHY_LPI_SIG_EN_HI_THRESH1000_MASK, 0x14));
+-
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
+-		       MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG122,
+-		       MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
+-		       FIELD_PREP(MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
+-				  0xff));
+-
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-			   MTK_PHY_RG_TESTMUX_ADC_CTRL,
+-			   MTK_PHY_RG_TXEN_DIG_MASK);
+-
+-	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
+-			 MTK_PHY_RG_DEV1E_REG19b, MTK_PHY_BYPASS_DSP_LPI_READY);
+-
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
+-			   MTK_PHY_RG_DEV1E_REG234, MTK_PHY_TR_LP_IIR_EEE_EN);
+-
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG238,
+-		       MTK_PHY_LPI_SLV_SEND_TX_TIMER_MASK |
+-		       MTK_PHY_LPI_SLV_SEND_TX_EN,
+-		       FIELD_PREP(MTK_PHY_LPI_SLV_SEND_TX_TIMER_MASK, 0x120));
+-
+-	/* Keep MTK_PHY_LPI_SEND_LOC_TIMER as 375 */
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG239,
+-			   MTK_PHY_LPI_TXPCS_LOC_RCV);
+-
+-	/* This also fixes some IoT issues, such as CH340 */
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG2C7,
+-		       MTK_PHY_MAX_GAIN_MASK | MTK_PHY_MIN_GAIN_MASK,
+-		       FIELD_PREP(MTK_PHY_MAX_GAIN_MASK, 0x8) |
+-		       FIELD_PREP(MTK_PHY_MIN_GAIN_MASK, 0x13));
+-
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG2D1,
+-		       MTK_PHY_VCO_SLICER_THRESH_BITS_HIGH_EEE_MASK,
+-		       FIELD_PREP(MTK_PHY_VCO_SLICER_THRESH_BITS_HIGH_EEE_MASK,
+-				  0x33) |
+-		       MTK_PHY_LPI_SKIP_SD_SLV_TR | MTK_PHY_LPI_TR_READY |
+-		       MTK_PHY_LPI_VCO_EEE_STG0_EN);
+-
+-	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG323,
+-			 MTK_PHY_EEE_WAKE_MAS_INT_DC |
+-			 MTK_PHY_EEE_WAKE_SLV_INT_DC);
+-
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG324,
+-		       MTK_PHY_SMI_DETCNT_MAX_MASK,
+-		       FIELD_PREP(MTK_PHY_SMI_DETCNT_MAX_MASK, 0x3f) |
+-		       MTK_PHY_SMI_DET_MAX_EN);
+-
+-	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG326,
+-			 MTK_PHY_LPI_MODE_SD_ON | MTK_PHY_RESET_RANDUPD_CNT |
+-			 MTK_PHY_TREC_UPDATE_ENAB_CLR |
+-			 MTK_PHY_LPI_QUIT_WAIT_DFE_SIG_DET_OFF |
+-			 MTK_PHY_TR_READY_SKIP_AFE_WAKEUP);
+-
+-	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	/* Regsigdet_sel_1000 = 0 */
+-	__phy_write(phydev, 0x11, 0xb);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x9690);
+-
+-	/* REG_EEE_st2TrKf1000 = 2 */
+-	__phy_write(phydev, 0x11, 0x114f);
+-	__phy_write(phydev, 0x12, 0x2);
+-	__phy_write(phydev, 0x10, 0x969a);
+-
+-	/* RegEEE_slv_wake_tr_timer_tar = 6, RegEEE_slv_remtx_timer_tar = 20 */
+-	__phy_write(phydev, 0x11, 0x3028);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x969e);
+-
+-	/* RegEEE_slv_wake_int_timer_tar = 8 */
+-	__phy_write(phydev, 0x11, 0x5010);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x96a0);
+-
+-	/* RegEEE_trfreeze_timer2 = 586 */
+-	__phy_write(phydev, 0x11, 0x24a);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x96a8);
+-
+-	/* RegEEE100Stg1_tar = 16 */
+-	__phy_write(phydev, 0x11, 0x3210);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x96b8);
+-
+-	/* REGEEE_wake_slv_tr_wait_dfesigdet_en = 0 */
+-	__phy_write(phydev, 0x11, 0x1463);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x96ca);
+-
+-	/* DfeTailEnableVgaThresh1000 = 27 */
+-	__phy_write(phydev, 0x11, 0x36);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x8f80);
+-	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+-
+-	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_3);
+-	__phy_modify(phydev, MTK_PHY_LPI_REG_14,
+-		     MTK_PHY_LPI_WAKE_TIMER_1000_MASK,
+-		     FIELD_PREP(MTK_PHY_LPI_WAKE_TIMER_1000_MASK, 0x19c));
+-
+-	__phy_modify(phydev, MTK_PHY_LPI_REG_1c, MTK_PHY_SMI_DET_ON_THRESH_MASK,
+-		     FIELD_PREP(MTK_PHY_SMI_DET_ON_THRESH_MASK, 0xc));
+-	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+-
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
+-		       MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG122,
+-		       MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
+-		       FIELD_PREP(MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
+-				  0xff));
+-}
+-
+-static int cal_sw(struct phy_device *phydev, enum CAL_ITEM cal_item,
+-		  u8 start_pair, u8 end_pair)
+-{
+-	u8 pair_n;
+-	int ret;
+-
+-	for (pair_n = start_pair; pair_n <= end_pair; pair_n++) {
+-		/* TX_OFFSET & TX_AMP have no SW calibration. */
+-		switch (cal_item) {
+-		case TX_VCM:
+-			ret = tx_vcm_cal_sw(phydev, pair_n);
+-			break;
+-		default:
+-			return -EINVAL;
+-		}
+-		if (ret)
+-			return ret;
+-	}
+-	return 0;
+-}
+-
+-static int cal_efuse(struct phy_device *phydev, enum CAL_ITEM cal_item,
+-		     u8 start_pair, u8 end_pair, u32 *buf)
+-{
+-	u8 pair_n;
+-	int ret;
+-
+-	for (pair_n = start_pair; pair_n <= end_pair; pair_n++) {
+-		/* TX_VCM has no efuse calibration. */
+-		switch (cal_item) {
+-		case REXT:
+-			ret = rext_cal_efuse(phydev, buf);
+-			break;
+-		case TX_OFFSET:
+-			ret = tx_offset_cal_efuse(phydev, buf);
+-			break;
+-		case TX_AMP:
+-			ret = tx_amp_cal_efuse(phydev, buf);
+-			break;
+-		case TX_R50:
+-			ret = tx_r50_cal_efuse(phydev, buf, pair_n);
+-			break;
+-		default:
+-			return -EINVAL;
+-		}
+-		if (ret)
+-			return ret;
+-	}
+-
+-	return 0;
+-}
+-
+-static int start_cal(struct phy_device *phydev, enum CAL_ITEM cal_item,
+-		     enum CAL_MODE cal_mode, u8 start_pair,
+-		     u8 end_pair, u32 *buf)
+-{
+-	int ret;
+-
+-	switch (cal_mode) {
+-	case EFUSE_M:
+-		ret = cal_efuse(phydev, cal_item, start_pair,
+-				end_pair, buf);
+-		break;
+-	case SW_M:
+-		ret = cal_sw(phydev, cal_item, start_pair, end_pair);
+-		break;
+-	default:
+-		return -EINVAL;
+-	}
+-
+-	if (ret) {
+-		phydev_err(phydev, "cal %d failed\n", cal_item);
+-		return -EIO;
+-	}
+-
+-	return 0;
+-}
+-
+-static int mt798x_phy_calibration(struct phy_device *phydev)
+-{
+-	struct nvmem_cell *cell;
+-	int ret = 0;
+-	size_t len;
+-	u32 *buf;
+-
+-	cell = nvmem_cell_get(&phydev->mdio.dev, "phy-cal-data");
+-	if (IS_ERR(cell)) {
+-		if (PTR_ERR(cell) == -EPROBE_DEFER)
+-			return PTR_ERR(cell);
+-		return 0;
+-	}
+-
+-	buf = (u32 *)nvmem_cell_read(cell, &len);
+-	if (IS_ERR(buf))
+-		return PTR_ERR(buf);
+-	nvmem_cell_put(cell);
+-
+-	if (!buf[0] || !buf[1] || !buf[2] || !buf[3] || len < 4 * sizeof(u32)) {
+-		phydev_err(phydev, "invalid efuse data\n");
+-		ret = -EINVAL;
+-		goto out;
+-	}
+-
+-	ret = start_cal(phydev, REXT, EFUSE_M, NO_PAIR, NO_PAIR, buf);
+-	if (ret)
+-		goto out;
+-	ret = start_cal(phydev, TX_OFFSET, EFUSE_M, NO_PAIR, NO_PAIR, buf);
+-	if (ret)
+-		goto out;
+-	ret = start_cal(phydev, TX_AMP, EFUSE_M, NO_PAIR, NO_PAIR, buf);
+-	if (ret)
+-		goto out;
+-	ret = start_cal(phydev, TX_R50, EFUSE_M, PAIR_A, PAIR_D, buf);
+-	if (ret)
+-		goto out;
+-	ret = start_cal(phydev, TX_VCM, SW_M, PAIR_A, PAIR_A, buf);
+-	if (ret)
+-		goto out;
+-
+-out:
+-	kfree(buf);
+-	return ret;
+-}
+-
+-static int mt798x_phy_config_init(struct phy_device *phydev)
+-{
+-	switch (phydev->drv->phy_id) {
+-	case MTK_GPHY_ID_MT7981:
+-		mt7981_phy_finetune(phydev);
+-		break;
+-	case MTK_GPHY_ID_MT7988:
+-		mt7988_phy_finetune(phydev);
+-		break;
+-	}
+-
+-	mt798x_phy_common_finetune(phydev);
+-	mt798x_phy_eee(phydev);
+-
+-	return mt798x_phy_calibration(phydev);
+-}
+-
+-static int mt798x_phy_hw_led_on_set(struct phy_device *phydev, u8 index,
+-				    bool on)
+-{
+-	unsigned int bit_on = MTK_PHY_LED_STATE_FORCE_ON + (index ? 16 : 0);
+-	struct mtk_socphy_priv *priv = phydev->priv;
+-	bool changed;
+-
+-	if (on)
+-		changed = !test_and_set_bit(bit_on, &priv->led_state);
+-	else
+-		changed = !!test_and_clear_bit(bit_on, &priv->led_state);
+-
+-	changed |= !!test_and_clear_bit(MTK_PHY_LED_STATE_NETDEV +
+-					(index ? 16 : 0), &priv->led_state);
+-	if (changed)
+-		return phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				      MTK_PHY_LED1_ON_CTRL :
+-				      MTK_PHY_LED0_ON_CTRL,
+-				      MTK_PHY_LED_ON_MASK,
+-				      on ? MTK_PHY_LED_ON_FORCE_ON : 0);
+-	else
+-		return 0;
+-}
+-
+-static int mt798x_phy_hw_led_blink_set(struct phy_device *phydev, u8 index,
+-				       bool blinking)
+-{
+-	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
+-				 (index ? 16 : 0);
+-	struct mtk_socphy_priv *priv = phydev->priv;
+-	bool changed;
+-
+-	if (blinking)
+-		changed = !test_and_set_bit(bit_blink, &priv->led_state);
+-	else
+-		changed = !!test_and_clear_bit(bit_blink, &priv->led_state);
+-
+-	changed |= !!test_bit(MTK_PHY_LED_STATE_NETDEV +
+-			      (index ? 16 : 0), &priv->led_state);
+-	if (changed)
+-		return phy_write_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				     MTK_PHY_LED1_BLINK_CTRL :
+-				     MTK_PHY_LED0_BLINK_CTRL,
+-				     blinking ?
+-				     MTK_PHY_LED_BLINK_FORCE_BLINK : 0);
+-	else
+-		return 0;
+-}
+-
+-static int mt798x_phy_led_blink_set(struct phy_device *phydev, u8 index,
+-				    unsigned long *delay_on,
+-				    unsigned long *delay_off)
+-{
+-	bool blinking = false;
+-	int err = 0;
+-
+-	if (index > 1)
+-		return -EINVAL;
+-
+-	if (delay_on && delay_off && (*delay_on > 0) && (*delay_off > 0)) {
+-		blinking = true;
+-		*delay_on = 50;
+-		*delay_off = 50;
+-	}
+-
+-	err = mt798x_phy_hw_led_blink_set(phydev, index, blinking);
+-	if (err)
+-		return err;
+-
+-	return mt798x_phy_hw_led_on_set(phydev, index, false);
+-}
+-
+-static int mt798x_phy_led_brightness_set(struct phy_device *phydev,
+-					 u8 index, enum led_brightness value)
+-{
+-	int err;
+-
+-	err = mt798x_phy_hw_led_blink_set(phydev, index, false);
+-	if (err)
+-		return err;
+-
+-	return mt798x_phy_hw_led_on_set(phydev, index, (value != LED_OFF));
+-}
+-
+-static const unsigned long supported_triggers =
+-	BIT(TRIGGER_NETDEV_FULL_DUPLEX) |
+-	BIT(TRIGGER_NETDEV_HALF_DUPLEX) |
+-	BIT(TRIGGER_NETDEV_LINK)        |
+-	BIT(TRIGGER_NETDEV_LINK_10)     |
+-	BIT(TRIGGER_NETDEV_LINK_100)    |
+-	BIT(TRIGGER_NETDEV_LINK_1000)   |
+-	BIT(TRIGGER_NETDEV_RX)          |
+-	BIT(TRIGGER_NETDEV_TX);
+-
+-static int mt798x_phy_led_hw_is_supported(struct phy_device *phydev, u8 index,
+-					  unsigned long rules)
+-{
+-	if (index > 1)
+-		return -EINVAL;
+-
+-	/* All combinations of the supported triggers are allowed */
+-	if (rules & ~supported_triggers)
+-		return -EOPNOTSUPP;
+-
+-	return 0;
+-};
+-
+-static int mt798x_phy_led_hw_control_get(struct phy_device *phydev, u8 index,
+-					 unsigned long *rules)
+-{
+-	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
+-				 (index ? 16 : 0);
+-	unsigned int bit_netdev = MTK_PHY_LED_STATE_NETDEV + (index ? 16 : 0);
+-	unsigned int bit_on = MTK_PHY_LED_STATE_FORCE_ON + (index ? 16 : 0);
+-	struct mtk_socphy_priv *priv = phydev->priv;
+-	int on, blink;
+-
+-	if (index > 1)
+-		return -EINVAL;
+-
+-	on = phy_read_mmd(phydev, MDIO_MMD_VEND2,
+-			  index ? MTK_PHY_LED1_ON_CTRL : MTK_PHY_LED0_ON_CTRL);
+-
+-	if (on < 0)
+-		return -EIO;
+-
+-	blink = phy_read_mmd(phydev, MDIO_MMD_VEND2,
+-			     index ? MTK_PHY_LED1_BLINK_CTRL :
+-				     MTK_PHY_LED0_BLINK_CTRL);
+-	if (blink < 0)
+-		return -EIO;
+-
+-	if ((on & (MTK_PHY_LED_ON_LINK | MTK_PHY_LED_ON_FDX |
+-		   MTK_PHY_LED_ON_HDX | MTK_PHY_LED_ON_LINKDOWN)) ||
+-	    (blink & (MTK_PHY_LED_BLINK_RX | MTK_PHY_LED_BLINK_TX)))
+-		set_bit(bit_netdev, &priv->led_state);
+-	else
+-		clear_bit(bit_netdev, &priv->led_state);
+-
+-	if (on & MTK_PHY_LED_ON_FORCE_ON)
+-		set_bit(bit_on, &priv->led_state);
+-	else
+-		clear_bit(bit_on, &priv->led_state);
+-
+-	if (blink & MTK_PHY_LED_BLINK_FORCE_BLINK)
+-		set_bit(bit_blink, &priv->led_state);
+-	else
+-		clear_bit(bit_blink, &priv->led_state);
+-
+-	if (!rules)
+-		return 0;
+-
+-	if (on & MTK_PHY_LED_ON_LINK)
+-		*rules |= BIT(TRIGGER_NETDEV_LINK);
+-
+-	if (on & MTK_PHY_LED_ON_LINK10)
+-		*rules |= BIT(TRIGGER_NETDEV_LINK_10);
+-
+-	if (on & MTK_PHY_LED_ON_LINK100)
+-		*rules |= BIT(TRIGGER_NETDEV_LINK_100);
+-
+-	if (on & MTK_PHY_LED_ON_LINK1000)
+-		*rules |= BIT(TRIGGER_NETDEV_LINK_1000);
+-
+-	if (on & MTK_PHY_LED_ON_FDX)
+-		*rules |= BIT(TRIGGER_NETDEV_FULL_DUPLEX);
+-
+-	if (on & MTK_PHY_LED_ON_HDX)
+-		*rules |= BIT(TRIGGER_NETDEV_HALF_DUPLEX);
+-
+-	if (blink & MTK_PHY_LED_BLINK_RX)
+-		*rules |= BIT(TRIGGER_NETDEV_RX);
+-
+-	if (blink & MTK_PHY_LED_BLINK_TX)
+-		*rules |= BIT(TRIGGER_NETDEV_TX);
+-
+-	return 0;
+-};
+-
+-static int mt798x_phy_led_hw_control_set(struct phy_device *phydev, u8 index,
+-					 unsigned long rules)
+-{
+-	unsigned int bit_netdev = MTK_PHY_LED_STATE_NETDEV + (index ? 16 : 0);
+-	struct mtk_socphy_priv *priv = phydev->priv;
+-	u16 on = 0, blink = 0;
+-	int ret;
+-
+-	if (index > 1)
+-		return -EINVAL;
+-
+-	if (rules & BIT(TRIGGER_NETDEV_FULL_DUPLEX))
+-		on |= MTK_PHY_LED_ON_FDX;
+-
+-	if (rules & BIT(TRIGGER_NETDEV_HALF_DUPLEX))
+-		on |= MTK_PHY_LED_ON_HDX;
+-
+-	if (rules & (BIT(TRIGGER_NETDEV_LINK_10) | BIT(TRIGGER_NETDEV_LINK)))
+-		on |= MTK_PHY_LED_ON_LINK10;
+-
+-	if (rules & (BIT(TRIGGER_NETDEV_LINK_100) | BIT(TRIGGER_NETDEV_LINK)))
+-		on |= MTK_PHY_LED_ON_LINK100;
+-
+-	if (rules & (BIT(TRIGGER_NETDEV_LINK_1000) | BIT(TRIGGER_NETDEV_LINK)))
+-		on |= MTK_PHY_LED_ON_LINK1000;
+-
+-	if (rules & BIT(TRIGGER_NETDEV_RX)) {
+-		blink |= (on & MTK_PHY_LED_ON_LINK) ?
+-			  (((on & MTK_PHY_LED_ON_LINK10) ?
+-			    MTK_PHY_LED_BLINK_10RX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK100) ?
+-			    MTK_PHY_LED_BLINK_100RX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK1000) ?
+-			    MTK_PHY_LED_BLINK_1000RX : 0)) :
+-			  MTK_PHY_LED_BLINK_RX;
+-	}
+-
+-	if (rules & BIT(TRIGGER_NETDEV_TX)) {
+-		blink |= (on & MTK_PHY_LED_ON_LINK) ?
+-			  (((on & MTK_PHY_LED_ON_LINK10) ?
+-			    MTK_PHY_LED_BLINK_10TX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK100) ?
+-			    MTK_PHY_LED_BLINK_100TX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK1000) ?
+-			    MTK_PHY_LED_BLINK_1000TX : 0)) :
+-			  MTK_PHY_LED_BLINK_TX;
+-	}
+-
+-	if (blink || on)
+-		set_bit(bit_netdev, &priv->led_state);
+-	else
+-		clear_bit(bit_netdev, &priv->led_state);
+-
+-	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				MTK_PHY_LED1_ON_CTRL :
+-				MTK_PHY_LED0_ON_CTRL,
+-			     MTK_PHY_LED_ON_FDX     |
+-			     MTK_PHY_LED_ON_HDX     |
+-			     MTK_PHY_LED_ON_LINK,
+-			     on);
+-
+-	if (ret)
+-		return ret;
+-
+-	return phy_write_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				MTK_PHY_LED1_BLINK_CTRL :
+-				MTK_PHY_LED0_BLINK_CTRL, blink);
+-};
+-
+-static bool mt7988_phy_led_get_polarity(struct phy_device *phydev, int led_num)
+-{
+-	struct mtk_socphy_shared *priv = phydev->shared->priv;
+-	u32 polarities;
+-
+-	if (led_num == 0)
+-		polarities = ~(priv->boottrap);
+-	else
+-		polarities = MTK_PHY_LED1_DEFAULT_POLARITIES;
+-
+-	if (polarities & BIT(phydev->mdio.addr))
+-		return true;
+-
+-	return false;
+-}
+-
+-static int mt7988_phy_fix_leds_polarities(struct phy_device *phydev)
+-{
+-	struct pinctrl *pinctrl;
+-	int index;
+-
+-	/* Setup LED polarity according to bootstrap use of LED pins */
+-	for (index = 0; index < 2; ++index)
+-		phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				MTK_PHY_LED1_ON_CTRL : MTK_PHY_LED0_ON_CTRL,
+-			       MTK_PHY_LED_ON_POLARITY,
+-			       mt7988_phy_led_get_polarity(phydev, index) ?
+-				MTK_PHY_LED_ON_POLARITY : 0);
+-
+-	/* Only now setup pinctrl to avoid bogus blinking */
+-	pinctrl = devm_pinctrl_get_select(&phydev->mdio.dev, "gbe-led");
+-	if (IS_ERR(pinctrl))
+-		dev_err(&phydev->mdio.bus->dev,
+-			"Failed to setup PHY LED pinctrl\n");
+-
+-	return 0;
+-}
+-
+-static int mt7988_phy_probe_shared(struct phy_device *phydev)
+-{
+-	struct device_node *np = dev_of_node(&phydev->mdio.bus->dev);
+-	struct mtk_socphy_shared *shared = phydev->shared->priv;
+-	struct regmap *regmap;
+-	u32 reg;
+-	int ret;
+-
+-	/* The LED0 of the 4 PHYs in MT7988 are wired to SoC pins LED_A, LED_B,
+-	 * LED_C and LED_D respectively. At the same time those pins are used to
+-	 * bootstrap configuration of the reference clock source (LED_A),
+-	 * DRAM DDRx16b x2/x1 (LED_B) and boot device (LED_C, LED_D).
+-	 * In practice this is done using a LED and a resistor pulling the pin
+-	 * either to GND or to VIO.
+-	 * The detected value at boot time is accessible at run-time using the
+-	 * TPBANK0 register located in the gpio base of the pinctrl, in order
+-	 * to read it here it needs to be referenced by a phandle called
+-	 * 'mediatek,pio' in the MDIO bus hosting the PHY.
+-	 * The 4 bits in TPBANK0 are kept as package shared data and are used to
+-	 * set LED polarity for each of the LED0.
+-	 */
+-	regmap = syscon_regmap_lookup_by_phandle(np, "mediatek,pio");
+-	if (IS_ERR(regmap))
+-		return PTR_ERR(regmap);
+-
+-	ret = regmap_read(regmap, RG_GPIO_MISC_TPBANK0, &reg);
+-	if (ret)
+-		return ret;
+-
+-	shared->boottrap = FIELD_GET(RG_GPIO_MISC_TPBANK0_BOOTMODE, reg);
+-
+-	return 0;
+-}
+-
+-static void mt798x_phy_leds_state_init(struct phy_device *phydev)
+-{
+-	int i;
+-
+-	for (i = 0; i < 2; ++i)
+-		mt798x_phy_led_hw_control_get(phydev, i, NULL);
+-}
+-
+-static int mt7988_phy_probe(struct phy_device *phydev)
+-{
+-	struct mtk_socphy_shared *shared;
+-	struct mtk_socphy_priv *priv;
+-	int err;
+-
+-	if (phydev->mdio.addr > 3)
+-		return -EINVAL;
+-
+-	err = devm_phy_package_join(&phydev->mdio.dev, phydev, 0,
+-				    sizeof(struct mtk_socphy_shared));
+-	if (err)
+-		return err;
+-
+-	if (phy_package_probe_once(phydev)) {
+-		err = mt7988_phy_probe_shared(phydev);
+-		if (err)
+-			return err;
+-	}
+-
+-	shared = phydev->shared->priv;
+-	priv = &shared->priv[phydev->mdio.addr];
+-
+-	phydev->priv = priv;
+-
+-	mt798x_phy_leds_state_init(phydev);
+-
+-	err = mt7988_phy_fix_leds_polarities(phydev);
+-	if (err)
+-		return err;
+-
+-	/* Disable TX power saving at probing to:
+-	 * 1. Meet common mode compliance test criteria
+-	 * 2. Make sure that TX-VCM calibration works fine
+-	 */
+-	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RXADC_CTRL_RG7,
+-		       MTK_PHY_DA_AD_BUF_BIAS_LP_MASK, 0x3 << 8);
+-
+-	return mt798x_phy_calibration(phydev);
+-}
+-
+-static int mt7981_phy_probe(struct phy_device *phydev)
+-{
+-	struct mtk_socphy_priv *priv;
+-
+-	priv = devm_kzalloc(&phydev->mdio.dev, sizeof(struct mtk_socphy_priv),
+-			    GFP_KERNEL);
+-	if (!priv)
+-		return -ENOMEM;
+-
+-	phydev->priv = priv;
+-
+-	mt798x_phy_leds_state_init(phydev);
+-
+-	return mt798x_phy_calibration(phydev);
+-}
+-
+-static struct phy_driver mtk_socphy_driver[] = {
+-	{
+-		PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7981),
+-		.name		= "MediaTek MT7981 PHY",
+-		.config_init	= mt798x_phy_config_init,
+-		.config_intr	= genphy_no_config_intr,
+-		.handle_interrupt = genphy_handle_interrupt_no_ack,
+-		.probe		= mt7981_phy_probe,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_page	= mtk_socphy_read_page,
+-		.write_page	= mtk_socphy_write_page,
+-		.led_blink_set	= mt798x_phy_led_blink_set,
+-		.led_brightness_set = mt798x_phy_led_brightness_set,
+-		.led_hw_is_supported = mt798x_phy_led_hw_is_supported,
+-		.led_hw_control_set = mt798x_phy_led_hw_control_set,
+-		.led_hw_control_get = mt798x_phy_led_hw_control_get,
+-	},
+-	{
+-		PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7988),
+-		.name		= "MediaTek MT7988 PHY",
+-		.config_init	= mt798x_phy_config_init,
+-		.config_intr	= genphy_no_config_intr,
+-		.handle_interrupt = genphy_handle_interrupt_no_ack,
+-		.probe		= mt7988_phy_probe,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_page	= mtk_socphy_read_page,
+-		.write_page	= mtk_socphy_write_page,
+-		.led_blink_set	= mt798x_phy_led_blink_set,
+-		.led_brightness_set = mt798x_phy_led_brightness_set,
+-		.led_hw_is_supported = mt798x_phy_led_hw_is_supported,
+-		.led_hw_control_set = mt798x_phy_led_hw_control_set,
+-		.led_hw_control_get = mt798x_phy_led_hw_control_get,
+-	},
+-};
+-
+-module_phy_driver(mtk_socphy_driver);
+-
+-static struct mdio_device_id __maybe_unused mtk_socphy_tbl[] = {
+-	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7981) },
+-	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7988) },
+-	{ }
+-};
+-
+-MODULE_DESCRIPTION("MediaTek SoC Gigabit Ethernet PHY driver");
+-MODULE_AUTHOR("Daniel Golle <daniel@makrotopia.org>");
+-MODULE_AUTHOR("SkyLake Huang <SkyLake.Huang@mediatek.com>");
+-MODULE_LICENSE("GPL");
+-
+-MODULE_DEVICE_TABLE(mdio, mtk_socphy_tbl);
+--- a/drivers/net/phy/mediatek-ge.c
++++ /dev/null
+@@ -1,111 +0,0 @@
+-// SPDX-License-Identifier: GPL-2.0+
+-#include <linux/bitfield.h>
+-#include <linux/module.h>
+-#include <linux/phy.h>
+-
+-#define MTK_EXT_PAGE_ACCESS		0x1f
+-#define MTK_PHY_PAGE_STANDARD		0x0000
+-#define MTK_PHY_PAGE_EXTENDED		0x0001
+-#define MTK_PHY_PAGE_EXTENDED_2		0x0002
+-#define MTK_PHY_PAGE_EXTENDED_3		0x0003
+-#define MTK_PHY_PAGE_EXTENDED_2A30	0x2a30
+-#define MTK_PHY_PAGE_EXTENDED_52B5	0x52b5
+-
+-static int mtk_gephy_read_page(struct phy_device *phydev)
+-{
+-	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
+-}
+-
+-static int mtk_gephy_write_page(struct phy_device *phydev, int page)
+-{
+-	return __phy_write(phydev, MTK_EXT_PAGE_ACCESS, page);
+-}
+-
+-static void mtk_gephy_config_init(struct phy_device *phydev)
+-{
+-	/* Enable HW auto downshift */
+-	phy_modify_paged(phydev, MTK_PHY_PAGE_EXTENDED, 0x14, 0, BIT(4));
+-
+-	/* Increase SlvDPSready time */
+-	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	__phy_write(phydev, 0x10, 0xafae);
+-	__phy_write(phydev, 0x12, 0x2f);
+-	__phy_write(phydev, 0x10, 0x8fae);
+-	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+-
+-	/* Adjust 100_mse_threshold */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x123, 0xffff);
+-
+-	/* Disable mcc */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0xa6, 0x300);
+-}
+-
+-static int mt7530_phy_config_init(struct phy_device *phydev)
+-{
+-	mtk_gephy_config_init(phydev);
+-
+-	/* Increase post_update_timer */
+-	phy_write_paged(phydev, MTK_PHY_PAGE_EXTENDED_3, 0x11, 0x4b);
+-
+-	return 0;
+-}
+-
+-static int mt7531_phy_config_init(struct phy_device *phydev)
+-{
+-	mtk_gephy_config_init(phydev);
+-
+-	/* PHY link down power saving enable */
+-	phy_set_bits(phydev, 0x17, BIT(4));
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, 0xc6, 0x300);
+-
+-	/* Set TX Pair delay selection */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x13, 0x404);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x14, 0x404);
+-
+-	return 0;
+-}
+-
+-static struct phy_driver mtk_gephy_driver[] = {
+-	{
+-		PHY_ID_MATCH_EXACT(0x03a29412),
+-		.name		= "MediaTek MT7530 PHY",
+-		.config_init	= mt7530_phy_config_init,
+-		/* Interrupts are handled by the switch, not the PHY
+-		 * itself.
+-		 */
+-		.config_intr	= genphy_no_config_intr,
+-		.handle_interrupt = genphy_handle_interrupt_no_ack,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_page	= mtk_gephy_read_page,
+-		.write_page	= mtk_gephy_write_page,
+-	},
+-	{
+-		PHY_ID_MATCH_EXACT(0x03a29441),
+-		.name		= "MediaTek MT7531 PHY",
+-		.config_init	= mt7531_phy_config_init,
+-		/* Interrupts are handled by the switch, not the PHY
+-		 * itself.
+-		 */
+-		.config_intr	= genphy_no_config_intr,
+-		.handle_interrupt = genphy_handle_interrupt_no_ack,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_page	= mtk_gephy_read_page,
+-		.write_page	= mtk_gephy_write_page,
+-	},
+-};
+-
+-module_phy_driver(mtk_gephy_driver);
+-
+-static struct mdio_device_id __maybe_unused mtk_gephy_tbl[] = {
+-	{ PHY_ID_MATCH_EXACT(0x03a29441) },
+-	{ PHY_ID_MATCH_EXACT(0x03a29412) },
+-	{ }
+-};
+-
+-MODULE_DESCRIPTION("MediaTek Gigabit Ethernet PHY driver");
+-MODULE_AUTHOR("DENG, Qingfang <dqfext@gmail.com>");
+-MODULE_LICENSE("GPL");
+-
+-MODULE_DEVICE_TABLE(mdio, mtk_gephy_tbl);
+--- /dev/null
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -0,0 +1,1610 @@
++// SPDX-License-Identifier: GPL-2.0+
++#include <linux/bitfield.h>
++#include <linux/bitmap.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/nvmem-consumer.h>
++#include <linux/pinctrl/consumer.h>
++#include <linux/phy.h>
++#include <linux/regmap.h>
++
++#define MTK_GPHY_ID_MT7981			0x03a29461
++#define MTK_GPHY_ID_MT7988			0x03a29481
++
++#define MTK_EXT_PAGE_ACCESS			0x1f
++#define MTK_PHY_PAGE_STANDARD			0x0000
++#define MTK_PHY_PAGE_EXTENDED_3			0x0003
++
++#define MTK_PHY_LPI_REG_14			0x14
++#define MTK_PHY_LPI_WAKE_TIMER_1000_MASK	GENMASK(8, 0)
++
++#define MTK_PHY_LPI_REG_1c			0x1c
++#define MTK_PHY_SMI_DET_ON_THRESH_MASK		GENMASK(13, 8)
++
++#define MTK_PHY_PAGE_EXTENDED_2A30		0x2a30
++#define MTK_PHY_PAGE_EXTENDED_52B5		0x52b5
++
++#define ANALOG_INTERNAL_OPERATION_MAX_US	20
++#define TXRESERVE_MIN				0
++#define TXRESERVE_MAX				7
++
++#define MTK_PHY_ANARG_RG			0x10
++#define   MTK_PHY_TCLKOFFSET_MASK		GENMASK(12, 8)
++
++/* Registers on MDIO_MMD_VEND1 */
++#define MTK_PHY_TXVLD_DA_RG			0x12
++#define   MTK_PHY_DA_TX_I2MPB_A_GBE_MASK	GENMASK(15, 10)
++#define   MTK_PHY_DA_TX_I2MPB_A_TBT_MASK	GENMASK(5, 0)
++
++#define MTK_PHY_TX_I2MPB_TEST_MODE_A2		0x16
++#define   MTK_PHY_DA_TX_I2MPB_A_HBT_MASK	GENMASK(15, 10)
++#define   MTK_PHY_DA_TX_I2MPB_A_TST_MASK	GENMASK(5, 0)
++
++#define MTK_PHY_TX_I2MPB_TEST_MODE_B1		0x17
++#define   MTK_PHY_DA_TX_I2MPB_B_GBE_MASK	GENMASK(13, 8)
++#define   MTK_PHY_DA_TX_I2MPB_B_TBT_MASK	GENMASK(5, 0)
++
++#define MTK_PHY_TX_I2MPB_TEST_MODE_B2		0x18
++#define   MTK_PHY_DA_TX_I2MPB_B_HBT_MASK	GENMASK(13, 8)
++#define   MTK_PHY_DA_TX_I2MPB_B_TST_MASK	GENMASK(5, 0)
++
++#define MTK_PHY_TX_I2MPB_TEST_MODE_C1		0x19
++#define   MTK_PHY_DA_TX_I2MPB_C_GBE_MASK	GENMASK(13, 8)
++#define   MTK_PHY_DA_TX_I2MPB_C_TBT_MASK	GENMASK(5, 0)
++
++#define MTK_PHY_TX_I2MPB_TEST_MODE_C2		0x20
++#define   MTK_PHY_DA_TX_I2MPB_C_HBT_MASK	GENMASK(13, 8)
++#define   MTK_PHY_DA_TX_I2MPB_C_TST_MASK	GENMASK(5, 0)
++
++#define MTK_PHY_TX_I2MPB_TEST_MODE_D1		0x21
++#define   MTK_PHY_DA_TX_I2MPB_D_GBE_MASK	GENMASK(13, 8)
++#define   MTK_PHY_DA_TX_I2MPB_D_TBT_MASK	GENMASK(5, 0)
++
++#define MTK_PHY_TX_I2MPB_TEST_MODE_D2		0x22
++#define   MTK_PHY_DA_TX_I2MPB_D_HBT_MASK	GENMASK(13, 8)
++#define   MTK_PHY_DA_TX_I2MPB_D_TST_MASK	GENMASK(5, 0)
++
++#define MTK_PHY_RXADC_CTRL_RG7			0xc6
++#define   MTK_PHY_DA_AD_BUF_BIAS_LP_MASK	GENMASK(9, 8)
++
++#define MTK_PHY_RXADC_CTRL_RG9			0xc8
++#define   MTK_PHY_DA_RX_PSBN_TBT_MASK		GENMASK(14, 12)
++#define   MTK_PHY_DA_RX_PSBN_HBT_MASK		GENMASK(10, 8)
++#define   MTK_PHY_DA_RX_PSBN_GBE_MASK		GENMASK(6, 4)
++#define   MTK_PHY_DA_RX_PSBN_LP_MASK		GENMASK(2, 0)
++
++#define MTK_PHY_LDO_OUTPUT_V			0xd7
++
++#define MTK_PHY_RG_ANA_CAL_RG0			0xdb
++#define   MTK_PHY_RG_CAL_CKINV			BIT(12)
++#define   MTK_PHY_RG_ANA_CALEN			BIT(8)
++#define   MTK_PHY_RG_ZCALEN_A			BIT(0)
++
++#define MTK_PHY_RG_ANA_CAL_RG1			0xdc
++#define   MTK_PHY_RG_ZCALEN_B			BIT(12)
++#define   MTK_PHY_RG_ZCALEN_C			BIT(8)
++#define   MTK_PHY_RG_ZCALEN_D			BIT(4)
++#define   MTK_PHY_RG_TXVOS_CALEN		BIT(0)
++
++#define MTK_PHY_RG_ANA_CAL_RG5			0xe0
++#define   MTK_PHY_RG_REXT_TRIM_MASK		GENMASK(13, 8)
++
++#define MTK_PHY_RG_TX_FILTER			0xfe
++
++#define MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG120	0x120
++#define   MTK_PHY_LPI_SIG_EN_LO_THRESH1000_MASK	GENMASK(12, 8)
++#define   MTK_PHY_LPI_SIG_EN_HI_THRESH1000_MASK	GENMASK(4, 0)
++
++#define MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG122	0x122
++#define   MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK	GENMASK(7, 0)
++
++#define MTK_PHY_RG_TESTMUX_ADC_CTRL		0x144
++#define   MTK_PHY_RG_TXEN_DIG_MASK		GENMASK(5, 5)
++
++#define MTK_PHY_RG_CR_TX_AMP_OFFSET_A_B		0x172
++#define   MTK_PHY_CR_TX_AMP_OFFSET_A_MASK	GENMASK(13, 8)
++#define   MTK_PHY_CR_TX_AMP_OFFSET_B_MASK	GENMASK(6, 0)
++
++#define MTK_PHY_RG_CR_TX_AMP_OFFSET_C_D		0x173
++#define   MTK_PHY_CR_TX_AMP_OFFSET_C_MASK	GENMASK(13, 8)
++#define   MTK_PHY_CR_TX_AMP_OFFSET_D_MASK	GENMASK(6, 0)
++
++#define MTK_PHY_RG_AD_CAL_COMP			0x17a
++#define   MTK_PHY_AD_CAL_COMP_OUT_MASK		GENMASK(8, 8)
++
++#define MTK_PHY_RG_AD_CAL_CLK			0x17b
++#define   MTK_PHY_DA_CAL_CLK			BIT(0)
++
++#define MTK_PHY_RG_AD_CALIN			0x17c
++#define   MTK_PHY_DA_CALIN_FLAG			BIT(0)
++
++#define MTK_PHY_RG_DASN_DAC_IN0_A		0x17d
++#define   MTK_PHY_DASN_DAC_IN0_A_MASK		GENMASK(9, 0)
++
++#define MTK_PHY_RG_DASN_DAC_IN0_B		0x17e
++#define   MTK_PHY_DASN_DAC_IN0_B_MASK		GENMASK(9, 0)
++
++#define MTK_PHY_RG_DASN_DAC_IN0_C		0x17f
++#define   MTK_PHY_DASN_DAC_IN0_C_MASK		GENMASK(9, 0)
++
++#define MTK_PHY_RG_DASN_DAC_IN0_D		0x180
++#define   MTK_PHY_DASN_DAC_IN0_D_MASK		GENMASK(9, 0)
++
++#define MTK_PHY_RG_DASN_DAC_IN1_A		0x181
++#define   MTK_PHY_DASN_DAC_IN1_A_MASK		GENMASK(9, 0)
++
++#define MTK_PHY_RG_DASN_DAC_IN1_B		0x182
++#define   MTK_PHY_DASN_DAC_IN1_B_MASK		GENMASK(9, 0)
++
++#define MTK_PHY_RG_DASN_DAC_IN1_C		0x183
++#define   MTK_PHY_DASN_DAC_IN1_C_MASK		GENMASK(9, 0)
++
++#define MTK_PHY_RG_DASN_DAC_IN1_D		0x184
++#define   MTK_PHY_DASN_DAC_IN1_D_MASK		GENMASK(9, 0)
++
++#define MTK_PHY_RG_DEV1E_REG19b			0x19b
++#define   MTK_PHY_BYPASS_DSP_LPI_READY		BIT(8)
++
++#define MTK_PHY_RG_LP_IIR2_K1_L			0x22a
++#define MTK_PHY_RG_LP_IIR2_K1_U			0x22b
++#define MTK_PHY_RG_LP_IIR2_K2_L			0x22c
++#define MTK_PHY_RG_LP_IIR2_K2_U			0x22d
++#define MTK_PHY_RG_LP_IIR2_K3_L			0x22e
++#define MTK_PHY_RG_LP_IIR2_K3_U			0x22f
++#define MTK_PHY_RG_LP_IIR2_K4_L			0x230
++#define MTK_PHY_RG_LP_IIR2_K4_U			0x231
++#define MTK_PHY_RG_LP_IIR2_K5_L			0x232
++#define MTK_PHY_RG_LP_IIR2_K5_U			0x233
++
++#define MTK_PHY_RG_DEV1E_REG234			0x234
++#define   MTK_PHY_TR_OPEN_LOOP_EN_MASK		GENMASK(0, 0)
++#define   MTK_PHY_LPF_X_AVERAGE_MASK		GENMASK(7, 4)
++#define   MTK_PHY_TR_LP_IIR_EEE_EN		BIT(12)
++
++#define MTK_PHY_RG_LPF_CNT_VAL			0x235
++
++#define MTK_PHY_RG_DEV1E_REG238			0x238
++#define   MTK_PHY_LPI_SLV_SEND_TX_TIMER_MASK	GENMASK(8, 0)
++#define   MTK_PHY_LPI_SLV_SEND_TX_EN		BIT(12)
++
++#define MTK_PHY_RG_DEV1E_REG239			0x239
++#define   MTK_PHY_LPI_SEND_LOC_TIMER_MASK	GENMASK(8, 0)
++#define   MTK_PHY_LPI_TXPCS_LOC_RCV		BIT(12)
++
++#define MTK_PHY_RG_DEV1E_REG27C			0x27c
++#define   MTK_PHY_VGASTATE_FFE_THR_ST1_MASK	GENMASK(12, 8)
++#define MTK_PHY_RG_DEV1E_REG27D			0x27d
++#define   MTK_PHY_VGASTATE_FFE_THR_ST2_MASK	GENMASK(4, 0)
++
++#define MTK_PHY_RG_DEV1E_REG2C7			0x2c7
++#define   MTK_PHY_MAX_GAIN_MASK			GENMASK(4, 0)
++#define   MTK_PHY_MIN_GAIN_MASK			GENMASK(12, 8)
++
++#define MTK_PHY_RG_DEV1E_REG2D1			0x2d1
++#define   MTK_PHY_VCO_SLICER_THRESH_BITS_HIGH_EEE_MASK	GENMASK(7, 0)
++#define   MTK_PHY_LPI_SKIP_SD_SLV_TR		BIT(8)
++#define   MTK_PHY_LPI_TR_READY			BIT(9)
++#define   MTK_PHY_LPI_VCO_EEE_STG0_EN		BIT(10)
++
++#define MTK_PHY_RG_DEV1E_REG323			0x323
++#define   MTK_PHY_EEE_WAKE_MAS_INT_DC		BIT(0)
++#define   MTK_PHY_EEE_WAKE_SLV_INT_DC		BIT(4)
++
++#define MTK_PHY_RG_DEV1E_REG324			0x324
++#define   MTK_PHY_SMI_DETCNT_MAX_MASK		GENMASK(5, 0)
++#define   MTK_PHY_SMI_DET_MAX_EN		BIT(8)
++
++#define MTK_PHY_RG_DEV1E_REG326			0x326
++#define   MTK_PHY_LPI_MODE_SD_ON		BIT(0)
++#define   MTK_PHY_RESET_RANDUPD_CNT		BIT(1)
++#define   MTK_PHY_TREC_UPDATE_ENAB_CLR		BIT(2)
++#define   MTK_PHY_LPI_QUIT_WAIT_DFE_SIG_DET_OFF	BIT(4)
++#define   MTK_PHY_TR_READY_SKIP_AFE_WAKEUP	BIT(5)
++
++#define MTK_PHY_LDO_PUMP_EN_PAIRAB		0x502
++#define MTK_PHY_LDO_PUMP_EN_PAIRCD		0x503
++
++#define MTK_PHY_DA_TX_R50_PAIR_A		0x53d
++#define MTK_PHY_DA_TX_R50_PAIR_B		0x53e
++#define MTK_PHY_DA_TX_R50_PAIR_C		0x53f
++#define MTK_PHY_DA_TX_R50_PAIR_D		0x540
++
++/* Registers on MDIO_MMD_VEND2 */
++#define MTK_PHY_LED0_ON_CTRL			0x24
++#define MTK_PHY_LED1_ON_CTRL			0x26
++#define   MTK_PHY_LED_ON_MASK			GENMASK(6, 0)
++#define   MTK_PHY_LED_ON_LINK1000		BIT(0)
++#define   MTK_PHY_LED_ON_LINK100		BIT(1)
++#define   MTK_PHY_LED_ON_LINK10			BIT(2)
++#define   MTK_PHY_LED_ON_LINK			(MTK_PHY_LED_ON_LINK10 |\
++						 MTK_PHY_LED_ON_LINK100 |\
++						 MTK_PHY_LED_ON_LINK1000)
++#define   MTK_PHY_LED_ON_LINKDOWN		BIT(3)
++#define   MTK_PHY_LED_ON_FDX			BIT(4) /* Full duplex */
++#define   MTK_PHY_LED_ON_HDX			BIT(5) /* Half duplex */
++#define   MTK_PHY_LED_ON_FORCE_ON		BIT(6)
++#define   MTK_PHY_LED_ON_POLARITY		BIT(14)
++#define   MTK_PHY_LED_ON_ENABLE			BIT(15)
++
++#define MTK_PHY_LED0_BLINK_CTRL			0x25
++#define MTK_PHY_LED1_BLINK_CTRL			0x27
++#define   MTK_PHY_LED_BLINK_1000TX		BIT(0)
++#define   MTK_PHY_LED_BLINK_1000RX		BIT(1)
++#define   MTK_PHY_LED_BLINK_100TX		BIT(2)
++#define   MTK_PHY_LED_BLINK_100RX		BIT(3)
++#define   MTK_PHY_LED_BLINK_10TX		BIT(4)
++#define   MTK_PHY_LED_BLINK_10RX		BIT(5)
++#define   MTK_PHY_LED_BLINK_RX			(MTK_PHY_LED_BLINK_10RX |\
++						 MTK_PHY_LED_BLINK_100RX |\
++						 MTK_PHY_LED_BLINK_1000RX)
++#define   MTK_PHY_LED_BLINK_TX			(MTK_PHY_LED_BLINK_10TX |\
++						 MTK_PHY_LED_BLINK_100TX |\
++						 MTK_PHY_LED_BLINK_1000TX)
++#define   MTK_PHY_LED_BLINK_COLLISION		BIT(6)
++#define   MTK_PHY_LED_BLINK_RX_CRC_ERR		BIT(7)
++#define   MTK_PHY_LED_BLINK_RX_IDLE_ERR		BIT(8)
++#define   MTK_PHY_LED_BLINK_FORCE_BLINK		BIT(9)
++
++#define MTK_PHY_LED1_DEFAULT_POLARITIES		BIT(1)
++
++#define MTK_PHY_RG_BG_RASEL			0x115
++#define   MTK_PHY_RG_BG_RASEL_MASK		GENMASK(2, 0)
++
++/* 'boottrap' register reflecting the configuration of the 4 PHY LEDs */
++#define RG_GPIO_MISC_TPBANK0			0x6f0
++#define   RG_GPIO_MISC_TPBANK0_BOOTMODE		GENMASK(11, 8)
++
++/* These macro privides efuse parsing for internal phy. */
++#define EFS_DA_TX_I2MPB_A(x)			(((x) >> 0) & GENMASK(5, 0))
++#define EFS_DA_TX_I2MPB_B(x)			(((x) >> 6) & GENMASK(5, 0))
++#define EFS_DA_TX_I2MPB_C(x)			(((x) >> 12) & GENMASK(5, 0))
++#define EFS_DA_TX_I2MPB_D(x)			(((x) >> 18) & GENMASK(5, 0))
++#define EFS_DA_TX_AMP_OFFSET_A(x)		(((x) >> 24) & GENMASK(5, 0))
++
++#define EFS_DA_TX_AMP_OFFSET_B(x)		(((x) >> 0) & GENMASK(5, 0))
++#define EFS_DA_TX_AMP_OFFSET_C(x)		(((x) >> 6) & GENMASK(5, 0))
++#define EFS_DA_TX_AMP_OFFSET_D(x)		(((x) >> 12) & GENMASK(5, 0))
++#define EFS_DA_TX_R50_A(x)			(((x) >> 18) & GENMASK(5, 0))
++#define EFS_DA_TX_R50_B(x)			(((x) >> 24) & GENMASK(5, 0))
++
++#define EFS_DA_TX_R50_C(x)			(((x) >> 0) & GENMASK(5, 0))
++#define EFS_DA_TX_R50_D(x)			(((x) >> 6) & GENMASK(5, 0))
++
++#define EFS_RG_BG_RASEL(x)			(((x) >> 4) & GENMASK(2, 0))
++#define EFS_RG_REXT_TRIM(x)			(((x) >> 7) & GENMASK(5, 0))
++
++enum {
++	NO_PAIR,
++	PAIR_A,
++	PAIR_B,
++	PAIR_C,
++	PAIR_D,
++};
++
++enum calibration_mode {
++	EFUSE_K,
++	SW_K
++};
++
++enum CAL_ITEM {
++	REXT,
++	TX_OFFSET,
++	TX_AMP,
++	TX_R50,
++	TX_VCM
++};
++
++enum CAL_MODE {
++	EFUSE_M,
++	SW_M
++};
++
++#define MTK_PHY_LED_STATE_FORCE_ON	0
++#define MTK_PHY_LED_STATE_FORCE_BLINK	1
++#define MTK_PHY_LED_STATE_NETDEV	2
++
++struct mtk_socphy_priv {
++	unsigned long		led_state;
++};
++
++struct mtk_socphy_shared {
++	u32			boottrap;
++	struct mtk_socphy_priv	priv[4];
++};
++
++static int mtk_socphy_read_page(struct phy_device *phydev)
++{
++	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
++}
++
++static int mtk_socphy_write_page(struct phy_device *phydev, int page)
++{
++	return __phy_write(phydev, MTK_EXT_PAGE_ACCESS, page);
++}
++
++/* One calibration cycle consists of:
++ * 1.Set DA_CALIN_FLAG high to start calibration. Keep it high
++ *   until AD_CAL_COMP is ready to output calibration result.
++ * 2.Wait until DA_CAL_CLK is available.
++ * 3.Fetch AD_CAL_COMP_OUT.
++ */
++static int cal_cycle(struct phy_device *phydev, int devad,
++		     u32 regnum, u16 mask, u16 cal_val)
++{
++	int reg_val;
++	int ret;
++
++	phy_modify_mmd(phydev, devad, regnum,
++		       mask, cal_val);
++	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_AD_CALIN,
++			 MTK_PHY_DA_CALIN_FLAG);
++
++	ret = phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1,
++					MTK_PHY_RG_AD_CAL_CLK, reg_val,
++					reg_val & MTK_PHY_DA_CAL_CLK, 500,
++					ANALOG_INTERNAL_OPERATION_MAX_US,
++					false);
++	if (ret) {
++		phydev_err(phydev, "Calibration cycle timeout\n");
++		return ret;
++	}
++
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_AD_CALIN,
++			   MTK_PHY_DA_CALIN_FLAG);
++	ret = phy_read_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_AD_CAL_COMP);
++	if (ret < 0)
++		return ret;
++	ret = FIELD_GET(MTK_PHY_AD_CAL_COMP_OUT_MASK, ret);
++	phydev_dbg(phydev, "cal_val: 0x%x, ret: %d\n", cal_val, ret);
++
++	return ret;
++}
++
++static int rext_fill_result(struct phy_device *phydev, u16 *buf)
++{
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG5,
++		       MTK_PHY_RG_REXT_TRIM_MASK, buf[0] << 8);
++	phy_modify_mmd(phydev, MDIO_MMD_VEND2, MTK_PHY_RG_BG_RASEL,
++		       MTK_PHY_RG_BG_RASEL_MASK, buf[1]);
++
++	return 0;
++}
++
++static int rext_cal_efuse(struct phy_device *phydev, u32 *buf)
++{
++	u16 rext_cal_val[2];
++
++	rext_cal_val[0] = EFS_RG_REXT_TRIM(buf[3]);
++	rext_cal_val[1] = EFS_RG_BG_RASEL(buf[3]);
++	rext_fill_result(phydev, rext_cal_val);
++
++	return 0;
++}
++
++static int tx_offset_fill_result(struct phy_device *phydev, u16 *buf)
++{
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_CR_TX_AMP_OFFSET_A_B,
++		       MTK_PHY_CR_TX_AMP_OFFSET_A_MASK, buf[0] << 8);
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_CR_TX_AMP_OFFSET_A_B,
++		       MTK_PHY_CR_TX_AMP_OFFSET_B_MASK, buf[1]);
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_CR_TX_AMP_OFFSET_C_D,
++		       MTK_PHY_CR_TX_AMP_OFFSET_C_MASK, buf[2] << 8);
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_CR_TX_AMP_OFFSET_C_D,
++		       MTK_PHY_CR_TX_AMP_OFFSET_D_MASK, buf[3]);
++
++	return 0;
++}
++
++static int tx_offset_cal_efuse(struct phy_device *phydev, u32 *buf)
++{
++	u16 tx_offset_cal_val[4];
++
++	tx_offset_cal_val[0] = EFS_DA_TX_AMP_OFFSET_A(buf[0]);
++	tx_offset_cal_val[1] = EFS_DA_TX_AMP_OFFSET_B(buf[1]);
++	tx_offset_cal_val[2] = EFS_DA_TX_AMP_OFFSET_C(buf[1]);
++	tx_offset_cal_val[3] = EFS_DA_TX_AMP_OFFSET_D(buf[1]);
++
++	tx_offset_fill_result(phydev, tx_offset_cal_val);
++
++	return 0;
++}
++
++static int tx_amp_fill_result(struct phy_device *phydev, u16 *buf)
++{
++	const int vals_9481[16] = { 10, 6, 6, 10,
++				    10, 6, 6, 10,
++				    10, 6, 6, 10,
++				    10, 6, 6, 10 };
++	const int vals_9461[16] = { 7, 1, 4, 7,
++				    7, 1, 4, 7,
++				    7, 1, 4, 7,
++				    7, 1, 4, 7 };
++	int bias[16] = {};
++	int i;
++
++	switch (phydev->drv->phy_id) {
++	case MTK_GPHY_ID_MT7981:
++		/* We add some calibration to efuse values
++		 * due to board level influence.
++		 * GBE: +7, TBT: +1, HBT: +4, TST: +7
++		 */
++		memcpy(bias, (const void *)vals_9461, sizeof(bias));
++		break;
++	case MTK_GPHY_ID_MT7988:
++		memcpy(bias, (const void *)vals_9481, sizeof(bias));
++		break;
++	}
++
++	/* Prevent overflow */
++	for (i = 0; i < 12; i++) {
++		if (buf[i >> 2] + bias[i] > 63) {
++			buf[i >> 2] = 63;
++			bias[i] = 0;
++		}
++	}
++
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TXVLD_DA_RG,
++		       MTK_PHY_DA_TX_I2MPB_A_GBE_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_GBE_MASK,
++				  buf[0] + bias[0]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TXVLD_DA_RG,
++		       MTK_PHY_DA_TX_I2MPB_A_TBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_TBT_MASK,
++				  buf[0] + bias[1]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_A2,
++		       MTK_PHY_DA_TX_I2MPB_A_HBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_HBT_MASK,
++				  buf[0] + bias[2]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_A2,
++		       MTK_PHY_DA_TX_I2MPB_A_TST_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_A_TST_MASK,
++				  buf[0] + bias[3]));
++
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B1,
++		       MTK_PHY_DA_TX_I2MPB_B_GBE_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_GBE_MASK,
++				  buf[1] + bias[4]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B1,
++		       MTK_PHY_DA_TX_I2MPB_B_TBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_TBT_MASK,
++				  buf[1] + bias[5]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B2,
++		       MTK_PHY_DA_TX_I2MPB_B_HBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_HBT_MASK,
++				  buf[1] + bias[6]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_B2,
++		       MTK_PHY_DA_TX_I2MPB_B_TST_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_B_TST_MASK,
++				  buf[1] + bias[7]));
++
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C1,
++		       MTK_PHY_DA_TX_I2MPB_C_GBE_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_GBE_MASK,
++				  buf[2] + bias[8]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C1,
++		       MTK_PHY_DA_TX_I2MPB_C_TBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_TBT_MASK,
++				  buf[2] + bias[9]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C2,
++		       MTK_PHY_DA_TX_I2MPB_C_HBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_HBT_MASK,
++				  buf[2] + bias[10]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_C2,
++		       MTK_PHY_DA_TX_I2MPB_C_TST_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_C_TST_MASK,
++				  buf[2] + bias[11]));
++
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D1,
++		       MTK_PHY_DA_TX_I2MPB_D_GBE_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_GBE_MASK,
++				  buf[3] + bias[12]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D1,
++		       MTK_PHY_DA_TX_I2MPB_D_TBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_TBT_MASK,
++				  buf[3] + bias[13]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D2,
++		       MTK_PHY_DA_TX_I2MPB_D_HBT_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_HBT_MASK,
++				  buf[3] + bias[14]));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TX_I2MPB_TEST_MODE_D2,
++		       MTK_PHY_DA_TX_I2MPB_D_TST_MASK,
++		       FIELD_PREP(MTK_PHY_DA_TX_I2MPB_D_TST_MASK,
++				  buf[3] + bias[15]));
++
++	return 0;
++}
++
++static int tx_amp_cal_efuse(struct phy_device *phydev, u32 *buf)
++{
++	u16 tx_amp_cal_val[4];
++
++	tx_amp_cal_val[0] = EFS_DA_TX_I2MPB_A(buf[0]);
++	tx_amp_cal_val[1] = EFS_DA_TX_I2MPB_B(buf[0]);
++	tx_amp_cal_val[2] = EFS_DA_TX_I2MPB_C(buf[0]);
++	tx_amp_cal_val[3] = EFS_DA_TX_I2MPB_D(buf[0]);
++	tx_amp_fill_result(phydev, tx_amp_cal_val);
++
++	return 0;
++}
++
++static int tx_r50_fill_result(struct phy_device *phydev, u16 tx_r50_cal_val,
++			      u8 txg_calen_x)
++{
++	int bias = 0;
++	u16 reg, val;
++
++	if (phydev->drv->phy_id == MTK_GPHY_ID_MT7988)
++		bias = -1;
++
++	val = clamp_val(bias + tx_r50_cal_val, 0, 63);
++
++	switch (txg_calen_x) {
++	case PAIR_A:
++		reg = MTK_PHY_DA_TX_R50_PAIR_A;
++		break;
++	case PAIR_B:
++		reg = MTK_PHY_DA_TX_R50_PAIR_B;
++		break;
++	case PAIR_C:
++		reg = MTK_PHY_DA_TX_R50_PAIR_C;
++		break;
++	case PAIR_D:
++		reg = MTK_PHY_DA_TX_R50_PAIR_D;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, reg, val | val << 8);
++
++	return 0;
++}
++
++static int tx_r50_cal_efuse(struct phy_device *phydev, u32 *buf,
++			    u8 txg_calen_x)
++{
++	u16 tx_r50_cal_val;
++
++	switch (txg_calen_x) {
++	case PAIR_A:
++		tx_r50_cal_val = EFS_DA_TX_R50_A(buf[1]);
++		break;
++	case PAIR_B:
++		tx_r50_cal_val = EFS_DA_TX_R50_B(buf[1]);
++		break;
++	case PAIR_C:
++		tx_r50_cal_val = EFS_DA_TX_R50_C(buf[2]);
++		break;
++	case PAIR_D:
++		tx_r50_cal_val = EFS_DA_TX_R50_D(buf[2]);
++		break;
++	default:
++		return -EINVAL;
++	}
++	tx_r50_fill_result(phydev, tx_r50_cal_val, txg_calen_x);
++
++	return 0;
++}
++
++static int tx_vcm_cal_sw(struct phy_device *phydev, u8 rg_txreserve_x)
++{
++	u8 lower_idx, upper_idx, txreserve_val;
++	u8 lower_ret, upper_ret;
++	int ret;
++
++	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG0,
++			 MTK_PHY_RG_ANA_CALEN);
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG0,
++			   MTK_PHY_RG_CAL_CKINV);
++	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG1,
++			 MTK_PHY_RG_TXVOS_CALEN);
++
++	switch (rg_txreserve_x) {
++	case PAIR_A:
++		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++				   MTK_PHY_RG_DASN_DAC_IN0_A,
++				   MTK_PHY_DASN_DAC_IN0_A_MASK);
++		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++				   MTK_PHY_RG_DASN_DAC_IN1_A,
++				   MTK_PHY_DASN_DAC_IN1_A_MASK);
++		phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
++				 MTK_PHY_RG_ANA_CAL_RG0,
++				 MTK_PHY_RG_ZCALEN_A);
++		break;
++	case PAIR_B:
++		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++				   MTK_PHY_RG_DASN_DAC_IN0_B,
++				   MTK_PHY_DASN_DAC_IN0_B_MASK);
++		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++				   MTK_PHY_RG_DASN_DAC_IN1_B,
++				   MTK_PHY_DASN_DAC_IN1_B_MASK);
++		phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
++				 MTK_PHY_RG_ANA_CAL_RG1,
++				 MTK_PHY_RG_ZCALEN_B);
++		break;
++	case PAIR_C:
++		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++				   MTK_PHY_RG_DASN_DAC_IN0_C,
++				   MTK_PHY_DASN_DAC_IN0_C_MASK);
++		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++				   MTK_PHY_RG_DASN_DAC_IN1_C,
++				   MTK_PHY_DASN_DAC_IN1_C_MASK);
++		phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
++				 MTK_PHY_RG_ANA_CAL_RG1,
++				 MTK_PHY_RG_ZCALEN_C);
++		break;
++	case PAIR_D:
++		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++				   MTK_PHY_RG_DASN_DAC_IN0_D,
++				   MTK_PHY_DASN_DAC_IN0_D_MASK);
++		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++				   MTK_PHY_RG_DASN_DAC_IN1_D,
++				   MTK_PHY_DASN_DAC_IN1_D_MASK);
++		phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
++				 MTK_PHY_RG_ANA_CAL_RG1,
++				 MTK_PHY_RG_ZCALEN_D);
++		break;
++	default:
++		ret = -EINVAL;
++		goto restore;
++	}
++
++	lower_idx = TXRESERVE_MIN;
++	upper_idx = TXRESERVE_MAX;
++
++	phydev_dbg(phydev, "Start TX-VCM SW cal.\n");
++	while ((upper_idx - lower_idx) > 1) {
++		txreserve_val = DIV_ROUND_CLOSEST(lower_idx + upper_idx, 2);
++		ret = cal_cycle(phydev, MDIO_MMD_VEND1, MTK_PHY_RXADC_CTRL_RG9,
++				MTK_PHY_DA_RX_PSBN_TBT_MASK |
++				MTK_PHY_DA_RX_PSBN_HBT_MASK |
++				MTK_PHY_DA_RX_PSBN_GBE_MASK |
++				MTK_PHY_DA_RX_PSBN_LP_MASK,
++				txreserve_val << 12 | txreserve_val << 8 |
++				txreserve_val << 4 | txreserve_val);
++		if (ret == 1) {
++			upper_idx = txreserve_val;
++			upper_ret = ret;
++		} else if (ret == 0) {
++			lower_idx = txreserve_val;
++			lower_ret = ret;
++		} else {
++			goto restore;
++		}
++	}
++
++	if (lower_idx == TXRESERVE_MIN) {
++		lower_ret = cal_cycle(phydev, MDIO_MMD_VEND1,
++				      MTK_PHY_RXADC_CTRL_RG9,
++				      MTK_PHY_DA_RX_PSBN_TBT_MASK |
++				      MTK_PHY_DA_RX_PSBN_HBT_MASK |
++				      MTK_PHY_DA_RX_PSBN_GBE_MASK |
++				      MTK_PHY_DA_RX_PSBN_LP_MASK,
++				      lower_idx << 12 | lower_idx << 8 |
++				      lower_idx << 4 | lower_idx);
++		ret = lower_ret;
++	} else if (upper_idx == TXRESERVE_MAX) {
++		upper_ret = cal_cycle(phydev, MDIO_MMD_VEND1,
++				      MTK_PHY_RXADC_CTRL_RG9,
++				      MTK_PHY_DA_RX_PSBN_TBT_MASK |
++				      MTK_PHY_DA_RX_PSBN_HBT_MASK |
++				      MTK_PHY_DA_RX_PSBN_GBE_MASK |
++				      MTK_PHY_DA_RX_PSBN_LP_MASK,
++				      upper_idx << 12 | upper_idx << 8 |
++				      upper_idx << 4 | upper_idx);
++		ret = upper_ret;
++	}
++	if (ret < 0)
++		goto restore;
++
++	/* We calibrate TX-VCM in different logic. Check upper index and then
++	 * lower index. If this calibration is valid, apply lower index's
++	 * result.
++	 */
++	ret = upper_ret - lower_ret;
++	if (ret == 1) {
++		ret = 0;
++		/* Make sure we use upper_idx in our calibration system */
++		cal_cycle(phydev, MDIO_MMD_VEND1, MTK_PHY_RXADC_CTRL_RG9,
++			  MTK_PHY_DA_RX_PSBN_TBT_MASK |
++			  MTK_PHY_DA_RX_PSBN_HBT_MASK |
++			  MTK_PHY_DA_RX_PSBN_GBE_MASK |
++			  MTK_PHY_DA_RX_PSBN_LP_MASK,
++			  upper_idx << 12 | upper_idx << 8 |
++			  upper_idx << 4 | upper_idx);
++		phydev_dbg(phydev, "TX-VCM SW cal result: 0x%x\n", upper_idx);
++	} else if (lower_idx == TXRESERVE_MIN && upper_ret == 1 &&
++		   lower_ret == 1) {
++		ret = 0;
++		cal_cycle(phydev, MDIO_MMD_VEND1, MTK_PHY_RXADC_CTRL_RG9,
++			  MTK_PHY_DA_RX_PSBN_TBT_MASK |
++			  MTK_PHY_DA_RX_PSBN_HBT_MASK |
++			  MTK_PHY_DA_RX_PSBN_GBE_MASK |
++			  MTK_PHY_DA_RX_PSBN_LP_MASK,
++			  lower_idx << 12 | lower_idx << 8 |
++			  lower_idx << 4 | lower_idx);
++		phydev_warn(phydev, "TX-VCM SW cal result at low margin 0x%x\n",
++			    lower_idx);
++	} else if (upper_idx == TXRESERVE_MAX && upper_ret == 0 &&
++		   lower_ret == 0) {
++		ret = 0;
++		phydev_warn(phydev,
++			    "TX-VCM SW cal result at high margin 0x%x\n",
++			    upper_idx);
++	} else {
++		ret = -EINVAL;
++	}
++
++restore:
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG0,
++			   MTK_PHY_RG_ANA_CALEN);
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG1,
++			   MTK_PHY_RG_TXVOS_CALEN);
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG0,
++			   MTK_PHY_RG_ZCALEN_A);
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_ANA_CAL_RG1,
++			   MTK_PHY_RG_ZCALEN_B | MTK_PHY_RG_ZCALEN_C |
++			   MTK_PHY_RG_ZCALEN_D);
++
++	return ret;
++}
++
++static void mt798x_phy_common_finetune(struct phy_device *phydev)
++{
++	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
++	/* SlvDSPreadyTime = 24, MasDSPreadyTime = 24 */
++	__phy_write(phydev, 0x11, 0xc71);
++	__phy_write(phydev, 0x12, 0xc);
++	__phy_write(phydev, 0x10, 0x8fae);
++
++	/* EnabRandUpdTrig = 1 */
++	__phy_write(phydev, 0x11, 0x2f00);
++	__phy_write(phydev, 0x12, 0xe);
++	__phy_write(phydev, 0x10, 0x8fb0);
++
++	/* NormMseLoThresh = 85 */
++	__phy_write(phydev, 0x11, 0x55a0);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x83aa);
++
++	/* FfeUpdGainForce = 1(Enable), FfeUpdGainForceVal = 4 */
++	__phy_write(phydev, 0x11, 0x240);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x9680);
++
++	/* TrFreeze = 0 (mt7988 default) */
++	__phy_write(phydev, 0x11, 0x0);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x9686);
++
++	/* SSTrKp100 = 5 */
++	/* SSTrKf100 = 6 */
++	/* SSTrKp1000Mas = 5 */
++	/* SSTrKf1000Mas = 6 */
++	/* SSTrKp1000Slv = 5 */
++	/* SSTrKf1000Slv = 6 */
++	__phy_write(phydev, 0x11, 0xbaef);
++	__phy_write(phydev, 0x12, 0x2e);
++	__phy_write(phydev, 0x10, 0x968c);
++	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
++}
++
++static void mt7981_phy_finetune(struct phy_device *phydev)
++{
++	u16 val[8] = { 0x01ce, 0x01c1,
++		       0x020f, 0x0202,
++		       0x03d0, 0x03c0,
++		       0x0013, 0x0005 };
++	int i, k;
++
++	/* 100M eye finetune:
++	 * Keep middle level of TX MLT3 shapper as default.
++	 * Only change TX MLT3 overshoot level here.
++	 */
++	for (k = 0, i = 1; i < 12; i++) {
++		if (i % 3 == 0)
++			continue;
++		phy_write_mmd(phydev, MDIO_MMD_VEND1, i, val[k++]);
++	}
++
++	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
++	/* ResetSyncOffset = 6 */
++	__phy_write(phydev, 0x11, 0x600);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x8fc0);
++
++	/* VgaDecRate = 1 */
++	__phy_write(phydev, 0x11, 0x4c2a);
++	__phy_write(phydev, 0x12, 0x3e);
++	__phy_write(phydev, 0x10, 0x8fa4);
++
++	/* MrvlTrFix100Kp = 3, MrvlTrFix100Kf = 2,
++	 * MrvlTrFix1000Kp = 3, MrvlTrFix1000Kf = 2
++	 */
++	__phy_write(phydev, 0x11, 0xd10a);
++	__phy_write(phydev, 0x12, 0x34);
++	__phy_write(phydev, 0x10, 0x8f82);
++
++	/* VcoSlicerThreshBitsHigh */
++	__phy_write(phydev, 0x11, 0x5555);
++	__phy_write(phydev, 0x12, 0x55);
++	__phy_write(phydev, 0x10, 0x8ec0);
++	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
++
++	/* TR_OPEN_LOOP_EN = 1, lpf_x_average = 9 */
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG234,
++		       MTK_PHY_TR_OPEN_LOOP_EN_MASK |
++		       MTK_PHY_LPF_X_AVERAGE_MASK,
++		       BIT(0) | FIELD_PREP(MTK_PHY_LPF_X_AVERAGE_MASK, 0x9));
++
++	/* rg_tr_lpf_cnt_val = 512 */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LPF_CNT_VAL, 0x200);
++
++	/* IIR2 related */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K1_L, 0x82);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K1_U, 0x0);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K2_L, 0x103);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K2_U, 0x0);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K3_L, 0x82);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K3_U, 0x0);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K4_L, 0xd177);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K4_U, 0x3);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K5_L, 0x2c82);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LP_IIR2_K5_U, 0xe);
++
++	/* FFE peaking */
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG27C,
++		       MTK_PHY_VGASTATE_FFE_THR_ST1_MASK, 0x1b << 8);
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG27D,
++		       MTK_PHY_VGASTATE_FFE_THR_ST2_MASK, 0x1e);
++
++	/* Disable LDO pump */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_LDO_PUMP_EN_PAIRAB, 0x0);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_LDO_PUMP_EN_PAIRCD, 0x0);
++	/* Adjust LDO output voltage */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_LDO_OUTPUT_V, 0x2222);
++}
++
++static void mt7988_phy_finetune(struct phy_device *phydev)
++{
++	u16 val[12] = { 0x0187, 0x01cd, 0x01c8, 0x0182,
++			0x020d, 0x0206, 0x0384, 0x03d0,
++			0x03c6, 0x030a, 0x0011, 0x0005 };
++	int i;
++
++	/* Set default MLT3 shaper first */
++	for (i = 0; i < 12; i++)
++		phy_write_mmd(phydev, MDIO_MMD_VEND1, i, val[i]);
++
++	/* TCT finetune */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_TX_FILTER, 0x5);
++
++	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
++	/* ResetSyncOffset = 5 */
++	__phy_write(phydev, 0x11, 0x500);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x8fc0);
++
++	/* VgaDecRate is 1 at default on mt7988 */
++
++	/* MrvlTrFix100Kp = 6, MrvlTrFix100Kf = 7,
++	 * MrvlTrFix1000Kp = 6, MrvlTrFix1000Kf = 7
++	 */
++	__phy_write(phydev, 0x11, 0xb90a);
++	__phy_write(phydev, 0x12, 0x6f);
++	__phy_write(phydev, 0x10, 0x8f82);
++
++	/* RemAckCntLimitCtrl = 1 */
++	__phy_write(phydev, 0x11, 0xfbba);
++	__phy_write(phydev, 0x12, 0xc3);
++	__phy_write(phydev, 0x10, 0x87f8);
++
++	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
++
++	/* TR_OPEN_LOOP_EN = 1, lpf_x_average = 10 */
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG234,
++		       MTK_PHY_TR_OPEN_LOOP_EN_MASK |
++		       MTK_PHY_LPF_X_AVERAGE_MASK,
++		       BIT(0) | FIELD_PREP(MTK_PHY_LPF_X_AVERAGE_MASK, 0xa));
++
++	/* rg_tr_lpf_cnt_val = 1023 */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_LPF_CNT_VAL, 0x3ff);
++}
++
++static void mt798x_phy_eee(struct phy_device *phydev)
++{
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
++		       MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG120,
++		       MTK_PHY_LPI_SIG_EN_LO_THRESH1000_MASK |
++		       MTK_PHY_LPI_SIG_EN_HI_THRESH1000_MASK,
++		       FIELD_PREP(MTK_PHY_LPI_SIG_EN_LO_THRESH1000_MASK, 0x0) |
++		       FIELD_PREP(MTK_PHY_LPI_SIG_EN_HI_THRESH1000_MASK, 0x14));
++
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
++		       MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG122,
++		       MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
++		       FIELD_PREP(MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
++				  0xff));
++
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++			   MTK_PHY_RG_TESTMUX_ADC_CTRL,
++			   MTK_PHY_RG_TXEN_DIG_MASK);
++
++	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,
++			 MTK_PHY_RG_DEV1E_REG19b, MTK_PHY_BYPASS_DSP_LPI_READY);
++
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,
++			   MTK_PHY_RG_DEV1E_REG234, MTK_PHY_TR_LP_IIR_EEE_EN);
++
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG238,
++		       MTK_PHY_LPI_SLV_SEND_TX_TIMER_MASK |
++		       MTK_PHY_LPI_SLV_SEND_TX_EN,
++		       FIELD_PREP(MTK_PHY_LPI_SLV_SEND_TX_TIMER_MASK, 0x120));
++
++	/* Keep MTK_PHY_LPI_SEND_LOC_TIMER as 375 */
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG239,
++			   MTK_PHY_LPI_TXPCS_LOC_RCV);
++
++	/* This also fixes some IoT issues, such as CH340 */
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG2C7,
++		       MTK_PHY_MAX_GAIN_MASK | MTK_PHY_MIN_GAIN_MASK,
++		       FIELD_PREP(MTK_PHY_MAX_GAIN_MASK, 0x8) |
++		       FIELD_PREP(MTK_PHY_MIN_GAIN_MASK, 0x13));
++
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG2D1,
++		       MTK_PHY_VCO_SLICER_THRESH_BITS_HIGH_EEE_MASK,
++		       FIELD_PREP(MTK_PHY_VCO_SLICER_THRESH_BITS_HIGH_EEE_MASK,
++				  0x33) |
++		       MTK_PHY_LPI_SKIP_SD_SLV_TR | MTK_PHY_LPI_TR_READY |
++		       MTK_PHY_LPI_VCO_EEE_STG0_EN);
++
++	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG323,
++			 MTK_PHY_EEE_WAKE_MAS_INT_DC |
++			 MTK_PHY_EEE_WAKE_SLV_INT_DC);
++
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG324,
++		       MTK_PHY_SMI_DETCNT_MAX_MASK,
++		       FIELD_PREP(MTK_PHY_SMI_DETCNT_MAX_MASK, 0x3f) |
++		       MTK_PHY_SMI_DET_MAX_EN);
++
++	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_DEV1E_REG326,
++			 MTK_PHY_LPI_MODE_SD_ON | MTK_PHY_RESET_RANDUPD_CNT |
++			 MTK_PHY_TREC_UPDATE_ENAB_CLR |
++			 MTK_PHY_LPI_QUIT_WAIT_DFE_SIG_DET_OFF |
++			 MTK_PHY_TR_READY_SKIP_AFE_WAKEUP);
++
++	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
++	/* Regsigdet_sel_1000 = 0 */
++	__phy_write(phydev, 0x11, 0xb);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x9690);
++
++	/* REG_EEE_st2TrKf1000 = 2 */
++	__phy_write(phydev, 0x11, 0x114f);
++	__phy_write(phydev, 0x12, 0x2);
++	__phy_write(phydev, 0x10, 0x969a);
++
++	/* RegEEE_slv_wake_tr_timer_tar = 6, RegEEE_slv_remtx_timer_tar = 20 */
++	__phy_write(phydev, 0x11, 0x3028);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x969e);
++
++	/* RegEEE_slv_wake_int_timer_tar = 8 */
++	__phy_write(phydev, 0x11, 0x5010);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x96a0);
++
++	/* RegEEE_trfreeze_timer2 = 586 */
++	__phy_write(phydev, 0x11, 0x24a);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x96a8);
++
++	/* RegEEE100Stg1_tar = 16 */
++	__phy_write(phydev, 0x11, 0x3210);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x96b8);
++
++	/* REGEEE_wake_slv_tr_wait_dfesigdet_en = 0 */
++	__phy_write(phydev, 0x11, 0x1463);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x96ca);
++
++	/* DfeTailEnableVgaThresh1000 = 27 */
++	__phy_write(phydev, 0x11, 0x36);
++	__phy_write(phydev, 0x12, 0x0);
++	__phy_write(phydev, 0x10, 0x8f80);
++	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
++
++	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_3);
++	__phy_modify(phydev, MTK_PHY_LPI_REG_14,
++		     MTK_PHY_LPI_WAKE_TIMER_1000_MASK,
++		     FIELD_PREP(MTK_PHY_LPI_WAKE_TIMER_1000_MASK, 0x19c));
++
++	__phy_modify(phydev, MTK_PHY_LPI_REG_1c, MTK_PHY_SMI_DET_ON_THRESH_MASK,
++		     FIELD_PREP(MTK_PHY_SMI_DET_ON_THRESH_MASK, 0xc));
++	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
++
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
++		       MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG122,
++		       MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
++		       FIELD_PREP(MTK_PHY_LPI_NORM_MSE_HI_THRESH1000_MASK,
++				  0xff));
++}
++
++static int cal_sw(struct phy_device *phydev, enum CAL_ITEM cal_item,
++		  u8 start_pair, u8 end_pair)
++{
++	u8 pair_n;
++	int ret;
++
++	for (pair_n = start_pair; pair_n <= end_pair; pair_n++) {
++		/* TX_OFFSET & TX_AMP have no SW calibration. */
++		switch (cal_item) {
++		case TX_VCM:
++			ret = tx_vcm_cal_sw(phydev, pair_n);
++			break;
++		default:
++			return -EINVAL;
++		}
++		if (ret)
++			return ret;
++	}
++	return 0;
++}
++
++static int cal_efuse(struct phy_device *phydev, enum CAL_ITEM cal_item,
++		     u8 start_pair, u8 end_pair, u32 *buf)
++{
++	u8 pair_n;
++	int ret;
++
++	for (pair_n = start_pair; pair_n <= end_pair; pair_n++) {
++		/* TX_VCM has no efuse calibration. */
++		switch (cal_item) {
++		case REXT:
++			ret = rext_cal_efuse(phydev, buf);
++			break;
++		case TX_OFFSET:
++			ret = tx_offset_cal_efuse(phydev, buf);
++			break;
++		case TX_AMP:
++			ret = tx_amp_cal_efuse(phydev, buf);
++			break;
++		case TX_R50:
++			ret = tx_r50_cal_efuse(phydev, buf, pair_n);
++			break;
++		default:
++			return -EINVAL;
++		}
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++static int start_cal(struct phy_device *phydev, enum CAL_ITEM cal_item,
++		     enum CAL_MODE cal_mode, u8 start_pair,
++		     u8 end_pair, u32 *buf)
++{
++	int ret;
++
++	switch (cal_mode) {
++	case EFUSE_M:
++		ret = cal_efuse(phydev, cal_item, start_pair,
++				end_pair, buf);
++		break;
++	case SW_M:
++		ret = cal_sw(phydev, cal_item, start_pair, end_pair);
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	if (ret) {
++		phydev_err(phydev, "cal %d failed\n", cal_item);
++		return -EIO;
++	}
++
++	return 0;
++}
++
++static int mt798x_phy_calibration(struct phy_device *phydev)
++{
++	struct nvmem_cell *cell;
++	int ret = 0;
++	size_t len;
++	u32 *buf;
++
++	cell = nvmem_cell_get(&phydev->mdio.dev, "phy-cal-data");
++	if (IS_ERR(cell)) {
++		if (PTR_ERR(cell) == -EPROBE_DEFER)
++			return PTR_ERR(cell);
++		return 0;
++	}
++
++	buf = (u32 *)nvmem_cell_read(cell, &len);
++	if (IS_ERR(buf))
++		return PTR_ERR(buf);
++	nvmem_cell_put(cell);
++
++	if (!buf[0] || !buf[1] || !buf[2] || !buf[3] || len < 4 * sizeof(u32)) {
++		phydev_err(phydev, "invalid efuse data\n");
++		ret = -EINVAL;
++		goto out;
++	}
++
++	ret = start_cal(phydev, REXT, EFUSE_M, NO_PAIR, NO_PAIR, buf);
++	if (ret)
++		goto out;
++	ret = start_cal(phydev, TX_OFFSET, EFUSE_M, NO_PAIR, NO_PAIR, buf);
++	if (ret)
++		goto out;
++	ret = start_cal(phydev, TX_AMP, EFUSE_M, NO_PAIR, NO_PAIR, buf);
++	if (ret)
++		goto out;
++	ret = start_cal(phydev, TX_R50, EFUSE_M, PAIR_A, PAIR_D, buf);
++	if (ret)
++		goto out;
++	ret = start_cal(phydev, TX_VCM, SW_M, PAIR_A, PAIR_A, buf);
++	if (ret)
++		goto out;
++
++out:
++	kfree(buf);
++	return ret;
++}
++
++static int mt798x_phy_config_init(struct phy_device *phydev)
++{
++	switch (phydev->drv->phy_id) {
++	case MTK_GPHY_ID_MT7981:
++		mt7981_phy_finetune(phydev);
++		break;
++	case MTK_GPHY_ID_MT7988:
++		mt7988_phy_finetune(phydev);
++		break;
++	}
++
++	mt798x_phy_common_finetune(phydev);
++	mt798x_phy_eee(phydev);
++
++	return mt798x_phy_calibration(phydev);
++}
++
++static int mt798x_phy_hw_led_on_set(struct phy_device *phydev, u8 index,
++				    bool on)
++{
++	unsigned int bit_on = MTK_PHY_LED_STATE_FORCE_ON + (index ? 16 : 0);
++	struct mtk_socphy_priv *priv = phydev->priv;
++	bool changed;
++
++	if (on)
++		changed = !test_and_set_bit(bit_on, &priv->led_state);
++	else
++		changed = !!test_and_clear_bit(bit_on, &priv->led_state);
++
++	changed |= !!test_and_clear_bit(MTK_PHY_LED_STATE_NETDEV +
++					(index ? 16 : 0), &priv->led_state);
++	if (changed)
++		return phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
++				      MTK_PHY_LED1_ON_CTRL :
++				      MTK_PHY_LED0_ON_CTRL,
++				      MTK_PHY_LED_ON_MASK,
++				      on ? MTK_PHY_LED_ON_FORCE_ON : 0);
++	else
++		return 0;
++}
++
++static int mt798x_phy_hw_led_blink_set(struct phy_device *phydev, u8 index,
++				       bool blinking)
++{
++	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
++				 (index ? 16 : 0);
++	struct mtk_socphy_priv *priv = phydev->priv;
++	bool changed;
++
++	if (blinking)
++		changed = !test_and_set_bit(bit_blink, &priv->led_state);
++	else
++		changed = !!test_and_clear_bit(bit_blink, &priv->led_state);
++
++	changed |= !!test_bit(MTK_PHY_LED_STATE_NETDEV +
++			      (index ? 16 : 0), &priv->led_state);
++	if (changed)
++		return phy_write_mmd(phydev, MDIO_MMD_VEND2, index ?
++				     MTK_PHY_LED1_BLINK_CTRL :
++				     MTK_PHY_LED0_BLINK_CTRL,
++				     blinking ?
++				     MTK_PHY_LED_BLINK_FORCE_BLINK : 0);
++	else
++		return 0;
++}
++
++static int mt798x_phy_led_blink_set(struct phy_device *phydev, u8 index,
++				    unsigned long *delay_on,
++				    unsigned long *delay_off)
++{
++	bool blinking = false;
++	int err = 0;
++
++	if (index > 1)
++		return -EINVAL;
++
++	if (delay_on && delay_off && (*delay_on > 0) && (*delay_off > 0)) {
++		blinking = true;
++		*delay_on = 50;
++		*delay_off = 50;
++	}
++
++	err = mt798x_phy_hw_led_blink_set(phydev, index, blinking);
++	if (err)
++		return err;
++
++	return mt798x_phy_hw_led_on_set(phydev, index, false);
++}
++
++static int mt798x_phy_led_brightness_set(struct phy_device *phydev,
++					 u8 index, enum led_brightness value)
++{
++	int err;
++
++	err = mt798x_phy_hw_led_blink_set(phydev, index, false);
++	if (err)
++		return err;
++
++	return mt798x_phy_hw_led_on_set(phydev, index, (value != LED_OFF));
++}
++
++static const unsigned long supported_triggers =
++	BIT(TRIGGER_NETDEV_FULL_DUPLEX) |
++	BIT(TRIGGER_NETDEV_HALF_DUPLEX) |
++	BIT(TRIGGER_NETDEV_LINK)        |
++	BIT(TRIGGER_NETDEV_LINK_10)     |
++	BIT(TRIGGER_NETDEV_LINK_100)    |
++	BIT(TRIGGER_NETDEV_LINK_1000)   |
++	BIT(TRIGGER_NETDEV_RX)          |
++	BIT(TRIGGER_NETDEV_TX);
++
++static int mt798x_phy_led_hw_is_supported(struct phy_device *phydev, u8 index,
++					  unsigned long rules)
++{
++	if (index > 1)
++		return -EINVAL;
++
++	/* All combinations of the supported triggers are allowed */
++	if (rules & ~supported_triggers)
++		return -EOPNOTSUPP;
++
++	return 0;
++};
++
++static int mt798x_phy_led_hw_control_get(struct phy_device *phydev, u8 index,
++					 unsigned long *rules)
++{
++	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
++				 (index ? 16 : 0);
++	unsigned int bit_netdev = MTK_PHY_LED_STATE_NETDEV + (index ? 16 : 0);
++	unsigned int bit_on = MTK_PHY_LED_STATE_FORCE_ON + (index ? 16 : 0);
++	struct mtk_socphy_priv *priv = phydev->priv;
++	int on, blink;
++
++	if (index > 1)
++		return -EINVAL;
++
++	on = phy_read_mmd(phydev, MDIO_MMD_VEND2,
++			  index ? MTK_PHY_LED1_ON_CTRL : MTK_PHY_LED0_ON_CTRL);
++
++	if (on < 0)
++		return -EIO;
++
++	blink = phy_read_mmd(phydev, MDIO_MMD_VEND2,
++			     index ? MTK_PHY_LED1_BLINK_CTRL :
++				     MTK_PHY_LED0_BLINK_CTRL);
++	if (blink < 0)
++		return -EIO;
++
++	if ((on & (MTK_PHY_LED_ON_LINK | MTK_PHY_LED_ON_FDX |
++		   MTK_PHY_LED_ON_HDX | MTK_PHY_LED_ON_LINKDOWN)) ||
++	    (blink & (MTK_PHY_LED_BLINK_RX | MTK_PHY_LED_BLINK_TX)))
++		set_bit(bit_netdev, &priv->led_state);
++	else
++		clear_bit(bit_netdev, &priv->led_state);
++
++	if (on & MTK_PHY_LED_ON_FORCE_ON)
++		set_bit(bit_on, &priv->led_state);
++	else
++		clear_bit(bit_on, &priv->led_state);
++
++	if (blink & MTK_PHY_LED_BLINK_FORCE_BLINK)
++		set_bit(bit_blink, &priv->led_state);
++	else
++		clear_bit(bit_blink, &priv->led_state);
++
++	if (!rules)
++		return 0;
++
++	if (on & MTK_PHY_LED_ON_LINK)
++		*rules |= BIT(TRIGGER_NETDEV_LINK);
++
++	if (on & MTK_PHY_LED_ON_LINK10)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_10);
++
++	if (on & MTK_PHY_LED_ON_LINK100)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_100);
++
++	if (on & MTK_PHY_LED_ON_LINK1000)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_1000);
++
++	if (on & MTK_PHY_LED_ON_FDX)
++		*rules |= BIT(TRIGGER_NETDEV_FULL_DUPLEX);
++
++	if (on & MTK_PHY_LED_ON_HDX)
++		*rules |= BIT(TRIGGER_NETDEV_HALF_DUPLEX);
++
++	if (blink & MTK_PHY_LED_BLINK_RX)
++		*rules |= BIT(TRIGGER_NETDEV_RX);
++
++	if (blink & MTK_PHY_LED_BLINK_TX)
++		*rules |= BIT(TRIGGER_NETDEV_TX);
++
++	return 0;
++};
++
++static int mt798x_phy_led_hw_control_set(struct phy_device *phydev, u8 index,
++					 unsigned long rules)
++{
++	unsigned int bit_netdev = MTK_PHY_LED_STATE_NETDEV + (index ? 16 : 0);
++	struct mtk_socphy_priv *priv = phydev->priv;
++	u16 on = 0, blink = 0;
++	int ret;
++
++	if (index > 1)
++		return -EINVAL;
++
++	if (rules & BIT(TRIGGER_NETDEV_FULL_DUPLEX))
++		on |= MTK_PHY_LED_ON_FDX;
++
++	if (rules & BIT(TRIGGER_NETDEV_HALF_DUPLEX))
++		on |= MTK_PHY_LED_ON_HDX;
++
++	if (rules & (BIT(TRIGGER_NETDEV_LINK_10) | BIT(TRIGGER_NETDEV_LINK)))
++		on |= MTK_PHY_LED_ON_LINK10;
++
++	if (rules & (BIT(TRIGGER_NETDEV_LINK_100) | BIT(TRIGGER_NETDEV_LINK)))
++		on |= MTK_PHY_LED_ON_LINK100;
++
++	if (rules & (BIT(TRIGGER_NETDEV_LINK_1000) | BIT(TRIGGER_NETDEV_LINK)))
++		on |= MTK_PHY_LED_ON_LINK1000;
++
++	if (rules & BIT(TRIGGER_NETDEV_RX)) {
++		blink |= (on & MTK_PHY_LED_ON_LINK) ?
++			  (((on & MTK_PHY_LED_ON_LINK10) ?
++			    MTK_PHY_LED_BLINK_10RX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK100) ?
++			    MTK_PHY_LED_BLINK_100RX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK1000) ?
++			    MTK_PHY_LED_BLINK_1000RX : 0)) :
++			  MTK_PHY_LED_BLINK_RX;
++	}
++
++	if (rules & BIT(TRIGGER_NETDEV_TX)) {
++		blink |= (on & MTK_PHY_LED_ON_LINK) ?
++			  (((on & MTK_PHY_LED_ON_LINK10) ?
++			    MTK_PHY_LED_BLINK_10TX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK100) ?
++			    MTK_PHY_LED_BLINK_100TX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK1000) ?
++			    MTK_PHY_LED_BLINK_1000TX : 0)) :
++			  MTK_PHY_LED_BLINK_TX;
++	}
++
++	if (blink || on)
++		set_bit(bit_netdev, &priv->led_state);
++	else
++		clear_bit(bit_netdev, &priv->led_state);
++
++	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
++				MTK_PHY_LED1_ON_CTRL :
++				MTK_PHY_LED0_ON_CTRL,
++			     MTK_PHY_LED_ON_FDX     |
++			     MTK_PHY_LED_ON_HDX     |
++			     MTK_PHY_LED_ON_LINK,
++			     on);
++
++	if (ret)
++		return ret;
++
++	return phy_write_mmd(phydev, MDIO_MMD_VEND2, index ?
++				MTK_PHY_LED1_BLINK_CTRL :
++				MTK_PHY_LED0_BLINK_CTRL, blink);
++};
++
++static bool mt7988_phy_led_get_polarity(struct phy_device *phydev, int led_num)
++{
++	struct mtk_socphy_shared *priv = phydev->shared->priv;
++	u32 polarities;
++
++	if (led_num == 0)
++		polarities = ~(priv->boottrap);
++	else
++		polarities = MTK_PHY_LED1_DEFAULT_POLARITIES;
++
++	if (polarities & BIT(phydev->mdio.addr))
++		return true;
++
++	return false;
++}
++
++static int mt7988_phy_fix_leds_polarities(struct phy_device *phydev)
++{
++	struct pinctrl *pinctrl;
++	int index;
++
++	/* Setup LED polarity according to bootstrap use of LED pins */
++	for (index = 0; index < 2; ++index)
++		phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
++				MTK_PHY_LED1_ON_CTRL : MTK_PHY_LED0_ON_CTRL,
++			       MTK_PHY_LED_ON_POLARITY,
++			       mt7988_phy_led_get_polarity(phydev, index) ?
++				MTK_PHY_LED_ON_POLARITY : 0);
++
++	/* Only now setup pinctrl to avoid bogus blinking */
++	pinctrl = devm_pinctrl_get_select(&phydev->mdio.dev, "gbe-led");
++	if (IS_ERR(pinctrl))
++		dev_err(&phydev->mdio.bus->dev,
++			"Failed to setup PHY LED pinctrl\n");
++
++	return 0;
++}
++
++static int mt7988_phy_probe_shared(struct phy_device *phydev)
++{
++	struct device_node *np = dev_of_node(&phydev->mdio.bus->dev);
++	struct mtk_socphy_shared *shared = phydev->shared->priv;
++	struct regmap *regmap;
++	u32 reg;
++	int ret;
++
++	/* The LED0 of the 4 PHYs in MT7988 are wired to SoC pins LED_A, LED_B,
++	 * LED_C and LED_D respectively. At the same time those pins are used to
++	 * bootstrap configuration of the reference clock source (LED_A),
++	 * DRAM DDRx16b x2/x1 (LED_B) and boot device (LED_C, LED_D).
++	 * In practice this is done using a LED and a resistor pulling the pin
++	 * either to GND or to VIO.
++	 * The detected value at boot time is accessible at run-time using the
++	 * TPBANK0 register located in the gpio base of the pinctrl, in order
++	 * to read it here it needs to be referenced by a phandle called
++	 * 'mediatek,pio' in the MDIO bus hosting the PHY.
++	 * The 4 bits in TPBANK0 are kept as package shared data and are used to
++	 * set LED polarity for each of the LED0.
++	 */
++	regmap = syscon_regmap_lookup_by_phandle(np, "mediatek,pio");
++	if (IS_ERR(regmap))
++		return PTR_ERR(regmap);
++
++	ret = regmap_read(regmap, RG_GPIO_MISC_TPBANK0, &reg);
++	if (ret)
++		return ret;
++
++	shared->boottrap = FIELD_GET(RG_GPIO_MISC_TPBANK0_BOOTMODE, reg);
++
++	return 0;
++}
++
++static void mt798x_phy_leds_state_init(struct phy_device *phydev)
++{
++	int i;
++
++	for (i = 0; i < 2; ++i)
++		mt798x_phy_led_hw_control_get(phydev, i, NULL);
++}
++
++static int mt7988_phy_probe(struct phy_device *phydev)
++{
++	struct mtk_socphy_shared *shared;
++	struct mtk_socphy_priv *priv;
++	int err;
++
++	if (phydev->mdio.addr > 3)
++		return -EINVAL;
++
++	err = devm_phy_package_join(&phydev->mdio.dev, phydev, 0,
++				    sizeof(struct mtk_socphy_shared));
++	if (err)
++		return err;
++
++	if (phy_package_probe_once(phydev)) {
++		err = mt7988_phy_probe_shared(phydev);
++		if (err)
++			return err;
++	}
++
++	shared = phydev->shared->priv;
++	priv = &shared->priv[phydev->mdio.addr];
++
++	phydev->priv = priv;
++
++	mt798x_phy_leds_state_init(phydev);
++
++	err = mt7988_phy_fix_leds_polarities(phydev);
++	if (err)
++		return err;
++
++	/* Disable TX power saving at probing to:
++	 * 1. Meet common mode compliance test criteria
++	 * 2. Make sure that TX-VCM calibration works fine
++	 */
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RXADC_CTRL_RG7,
++		       MTK_PHY_DA_AD_BUF_BIAS_LP_MASK, 0x3 << 8);
++
++	return mt798x_phy_calibration(phydev);
++}
++
++static int mt7981_phy_probe(struct phy_device *phydev)
++{
++	struct mtk_socphy_priv *priv;
++
++	priv = devm_kzalloc(&phydev->mdio.dev, sizeof(struct mtk_socphy_priv),
++			    GFP_KERNEL);
++	if (!priv)
++		return -ENOMEM;
++
++	phydev->priv = priv;
++
++	mt798x_phy_leds_state_init(phydev);
++
++	return mt798x_phy_calibration(phydev);
++}
++
++static struct phy_driver mtk_socphy_driver[] = {
++	{
++		PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7981),
++		.name		= "MediaTek MT7981 PHY",
++		.config_init	= mt798x_phy_config_init,
++		.config_intr	= genphy_no_config_intr,
++		.handle_interrupt = genphy_handle_interrupt_no_ack,
++		.probe		= mt7981_phy_probe,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_page	= mtk_socphy_read_page,
++		.write_page	= mtk_socphy_write_page,
++		.led_blink_set	= mt798x_phy_led_blink_set,
++		.led_brightness_set = mt798x_phy_led_brightness_set,
++		.led_hw_is_supported = mt798x_phy_led_hw_is_supported,
++		.led_hw_control_set = mt798x_phy_led_hw_control_set,
++		.led_hw_control_get = mt798x_phy_led_hw_control_get,
++	},
++	{
++		PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7988),
++		.name		= "MediaTek MT7988 PHY",
++		.config_init	= mt798x_phy_config_init,
++		.config_intr	= genphy_no_config_intr,
++		.handle_interrupt = genphy_handle_interrupt_no_ack,
++		.probe		= mt7988_phy_probe,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_page	= mtk_socphy_read_page,
++		.write_page	= mtk_socphy_write_page,
++		.led_blink_set	= mt798x_phy_led_blink_set,
++		.led_brightness_set = mt798x_phy_led_brightness_set,
++		.led_hw_is_supported = mt798x_phy_led_hw_is_supported,
++		.led_hw_control_set = mt798x_phy_led_hw_control_set,
++		.led_hw_control_get = mt798x_phy_led_hw_control_get,
++	},
++};
++
++module_phy_driver(mtk_socphy_driver);
++
++static struct mdio_device_id __maybe_unused mtk_socphy_tbl[] = {
++	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7981) },
++	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7988) },
++	{ }
++};
++
++MODULE_DESCRIPTION("MediaTek SoC Gigabit Ethernet PHY driver");
++MODULE_AUTHOR("Daniel Golle <daniel@makrotopia.org>");
++MODULE_AUTHOR("SkyLake Huang <SkyLake.Huang@mediatek.com>");
++MODULE_LICENSE("GPL");
++
++MODULE_DEVICE_TABLE(mdio, mtk_socphy_tbl);
+--- /dev/null
++++ b/drivers/net/phy/mediatek/mtk-ge.c
+@@ -0,0 +1,111 @@
++// SPDX-License-Identifier: GPL-2.0+
++#include <linux/bitfield.h>
++#include <linux/module.h>
++#include <linux/phy.h>
++
++#define MTK_EXT_PAGE_ACCESS		0x1f
++#define MTK_PHY_PAGE_STANDARD		0x0000
++#define MTK_PHY_PAGE_EXTENDED		0x0001
++#define MTK_PHY_PAGE_EXTENDED_2		0x0002
++#define MTK_PHY_PAGE_EXTENDED_3		0x0003
++#define MTK_PHY_PAGE_EXTENDED_2A30	0x2a30
++#define MTK_PHY_PAGE_EXTENDED_52B5	0x52b5
++
++static int mtk_gephy_read_page(struct phy_device *phydev)
++{
++	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
++}
++
++static int mtk_gephy_write_page(struct phy_device *phydev, int page)
++{
++	return __phy_write(phydev, MTK_EXT_PAGE_ACCESS, page);
++}
++
++static void mtk_gephy_config_init(struct phy_device *phydev)
++{
++	/* Enable HW auto downshift */
++	phy_modify_paged(phydev, MTK_PHY_PAGE_EXTENDED, 0x14, 0, BIT(4));
++
++	/* Increase SlvDPSready time */
++	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
++	__phy_write(phydev, 0x10, 0xafae);
++	__phy_write(phydev, 0x12, 0x2f);
++	__phy_write(phydev, 0x10, 0x8fae);
++	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
++
++	/* Adjust 100_mse_threshold */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x123, 0xffff);
++
++	/* Disable mcc */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0xa6, 0x300);
++}
++
++static int mt7530_phy_config_init(struct phy_device *phydev)
++{
++	mtk_gephy_config_init(phydev);
++
++	/* Increase post_update_timer */
++	phy_write_paged(phydev, MTK_PHY_PAGE_EXTENDED_3, 0x11, 0x4b);
++
++	return 0;
++}
++
++static int mt7531_phy_config_init(struct phy_device *phydev)
++{
++	mtk_gephy_config_init(phydev);
++
++	/* PHY link down power saving enable */
++	phy_set_bits(phydev, 0x17, BIT(4));
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, 0xc6, 0x300);
++
++	/* Set TX Pair delay selection */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x13, 0x404);
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x14, 0x404);
++
++	return 0;
++}
++
++static struct phy_driver mtk_gephy_driver[] = {
++	{
++		PHY_ID_MATCH_EXACT(0x03a29412),
++		.name		= "MediaTek MT7530 PHY",
++		.config_init	= mt7530_phy_config_init,
++		/* Interrupts are handled by the switch, not the PHY
++		 * itself.
++		 */
++		.config_intr	= genphy_no_config_intr,
++		.handle_interrupt = genphy_handle_interrupt_no_ack,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_page	= mtk_gephy_read_page,
++		.write_page	= mtk_gephy_write_page,
++	},
++	{
++		PHY_ID_MATCH_EXACT(0x03a29441),
++		.name		= "MediaTek MT7531 PHY",
++		.config_init	= mt7531_phy_config_init,
++		/* Interrupts are handled by the switch, not the PHY
++		 * itself.
++		 */
++		.config_intr	= genphy_no_config_intr,
++		.handle_interrupt = genphy_handle_interrupt_no_ack,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_page	= mtk_gephy_read_page,
++		.write_page	= mtk_gephy_write_page,
++	},
++};
++
++module_phy_driver(mtk_gephy_driver);
++
++static struct mdio_device_id __maybe_unused mtk_gephy_tbl[] = {
++	{ PHY_ID_MATCH_EXACT(0x03a29441) },
++	{ PHY_ID_MATCH_EXACT(0x03a29412) },
++	{ }
++};
++
++MODULE_DESCRIPTION("MediaTek Gigabit Ethernet PHY driver");
++MODULE_AUTHOR("DENG, Qingfang <dqfext@gmail.com>");
++MODULE_LICENSE("GPL");
++
++MODULE_DEVICE_TABLE(mdio, mtk_gephy_tbl);
diff --git a/target/linux/generic/backport-6.12/724-v6.13-net-phy-mediatek-Move-LED-helper-functions-into-mtk-.patch b/target/linux/generic/backport-6.12/724-v6.13-net-phy-mediatek-Move-LED-helper-functions-into-mtk-.patch
new file mode 100644
index 0000000000..63407ac55c
--- /dev/null
+++ b/target/linux/generic/backport-6.12/724-v6.13-net-phy-mediatek-Move-LED-helper-functions-into-mtk-.patch
@@ -0,0 +1,774 @@
+From 71d88c7409b91c853d7f9c933f5e27933d656e5e Mon Sep 17 00:00:00 2001
+From: "SkyLake.Huang" <skylake.huang@mediatek.com>
+Date: Sat, 9 Nov 2024 00:34:52 +0800
+Subject: [PATCH 05/20] net: phy: mediatek: Move LED helper functions into mtk
+ phy lib
+
+This patch creates mtk-phy-lib.c & mtk-phy.h and integrates mtk-ge-soc.c's
+LED helper functions so that we can use those helper functions in other
+MTK's ethernet phy driver.
+
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: SkyLake.Huang <skylake.huang@mediatek.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ MAINTAINERS                            |   2 +
+ drivers/net/phy/mediatek/Kconfig       |   4 +
+ drivers/net/phy/mediatek/Makefile      |   1 +
+ drivers/net/phy/mediatek/mtk-ge-soc.c  | 280 +++----------------------
+ drivers/net/phy/mediatek/mtk-phy-lib.c | 254 ++++++++++++++++++++++
+ drivers/net/phy/mediatek/mtk.h         |  86 ++++++++
+ 6 files changed, 372 insertions(+), 255 deletions(-)
+ create mode 100644 drivers/net/phy/mediatek/mtk-phy-lib.c
+ create mode 100644 drivers/net/phy/mediatek/mtk.h
+
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -14428,7 +14428,9 @@ M:	SkyLake Huang <SkyLake.Huang@mediatek
+ L:	netdev@vger.kernel.org
+ S:	Maintained
+ F:	drivers/net/phy/mediatek/mtk-ge-soc.c
++F:	drivers/net/phy/mediatek/mtk-phy-lib.c
+ F:	drivers/net/phy/mediatek/mtk-ge.c
++F:	drivers/net/phy/mediatek/mtk.h
+ F:	drivers/phy/mediatek/phy-mtk-xfi-tphy.c
+ 
+ MEDIATEK I2C CONTROLLER DRIVER
+--- a/drivers/net/phy/mediatek/Kconfig
++++ b/drivers/net/phy/mediatek/Kconfig
+@@ -1,4 +1,7 @@
+ # SPDX-License-Identifier: GPL-2.0-only
++config MTK_NET_PHYLIB
++	tristate
++
+ config MEDIATEK_GE_PHY
+ 	tristate "MediaTek Gigabit Ethernet PHYs"
+ 	help
+@@ -13,6 +16,7 @@ config MEDIATEK_GE_SOC_PHY
+ 	tristate "MediaTek SoC Ethernet PHYs"
+ 	depends on (ARM64 && ARCH_MEDIATEK) || COMPILE_TEST
+ 	depends on NVMEM_MTK_EFUSE
++	select MTK_NET_PHYLIB
+ 	help
+ 	  Supports MediaTek SoC built-in Gigabit Ethernet PHYs.
+ 
+--- a/drivers/net/phy/mediatek/Makefile
++++ b/drivers/net/phy/mediatek/Makefile
+@@ -1,3 +1,4 @@
+ # SPDX-License-Identifier: GPL-2.0
++obj-$(CONFIG_MTK_NET_PHYLIB)		+= mtk-phy-lib.o
+ obj-$(CONFIG_MEDIATEK_GE_PHY)		+= mtk-ge.o
+ obj-$(CONFIG_MEDIATEK_GE_SOC_PHY)	+= mtk-ge-soc.o
+--- a/drivers/net/phy/mediatek/mtk-ge-soc.c
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -8,6 +8,8 @@
+ #include <linux/phy.h>
+ #include <linux/regmap.h>
+ 
++#include "mtk.h"
++
+ #define MTK_GPHY_ID_MT7981			0x03a29461
+ #define MTK_GPHY_ID_MT7988			0x03a29481
+ 
+@@ -210,41 +212,6 @@
+ #define MTK_PHY_DA_TX_R50_PAIR_D		0x540
+ 
+ /* Registers on MDIO_MMD_VEND2 */
+-#define MTK_PHY_LED0_ON_CTRL			0x24
+-#define MTK_PHY_LED1_ON_CTRL			0x26
+-#define   MTK_PHY_LED_ON_MASK			GENMASK(6, 0)
+-#define   MTK_PHY_LED_ON_LINK1000		BIT(0)
+-#define   MTK_PHY_LED_ON_LINK100		BIT(1)
+-#define   MTK_PHY_LED_ON_LINK10			BIT(2)
+-#define   MTK_PHY_LED_ON_LINK			(MTK_PHY_LED_ON_LINK10 |\
+-						 MTK_PHY_LED_ON_LINK100 |\
+-						 MTK_PHY_LED_ON_LINK1000)
+-#define   MTK_PHY_LED_ON_LINKDOWN		BIT(3)
+-#define   MTK_PHY_LED_ON_FDX			BIT(4) /* Full duplex */
+-#define   MTK_PHY_LED_ON_HDX			BIT(5) /* Half duplex */
+-#define   MTK_PHY_LED_ON_FORCE_ON		BIT(6)
+-#define   MTK_PHY_LED_ON_POLARITY		BIT(14)
+-#define   MTK_PHY_LED_ON_ENABLE			BIT(15)
+-
+-#define MTK_PHY_LED0_BLINK_CTRL			0x25
+-#define MTK_PHY_LED1_BLINK_CTRL			0x27
+-#define   MTK_PHY_LED_BLINK_1000TX		BIT(0)
+-#define   MTK_PHY_LED_BLINK_1000RX		BIT(1)
+-#define   MTK_PHY_LED_BLINK_100TX		BIT(2)
+-#define   MTK_PHY_LED_BLINK_100RX		BIT(3)
+-#define   MTK_PHY_LED_BLINK_10TX		BIT(4)
+-#define   MTK_PHY_LED_BLINK_10RX		BIT(5)
+-#define   MTK_PHY_LED_BLINK_RX			(MTK_PHY_LED_BLINK_10RX |\
+-						 MTK_PHY_LED_BLINK_100RX |\
+-						 MTK_PHY_LED_BLINK_1000RX)
+-#define   MTK_PHY_LED_BLINK_TX			(MTK_PHY_LED_BLINK_10TX |\
+-						 MTK_PHY_LED_BLINK_100TX |\
+-						 MTK_PHY_LED_BLINK_1000TX)
+-#define   MTK_PHY_LED_BLINK_COLLISION		BIT(6)
+-#define   MTK_PHY_LED_BLINK_RX_CRC_ERR		BIT(7)
+-#define   MTK_PHY_LED_BLINK_RX_IDLE_ERR		BIT(8)
+-#define   MTK_PHY_LED_BLINK_FORCE_BLINK		BIT(9)
+-
+ #define MTK_PHY_LED1_DEFAULT_POLARITIES		BIT(1)
+ 
+ #define MTK_PHY_RG_BG_RASEL			0x115
+@@ -299,14 +266,6 @@ enum CAL_MODE {
+ 	SW_M
+ };
+ 
+-#define MTK_PHY_LED_STATE_FORCE_ON	0
+-#define MTK_PHY_LED_STATE_FORCE_BLINK	1
+-#define MTK_PHY_LED_STATE_NETDEV	2
+-
+-struct mtk_socphy_priv {
+-	unsigned long		led_state;
+-};
+-
+ struct mtk_socphy_shared {
+ 	u32			boottrap;
+ 	struct mtk_socphy_priv	priv[4];
+@@ -1172,76 +1131,23 @@ static int mt798x_phy_config_init(struct
+ 	return mt798x_phy_calibration(phydev);
+ }
+ 
+-static int mt798x_phy_hw_led_on_set(struct phy_device *phydev, u8 index,
+-				    bool on)
+-{
+-	unsigned int bit_on = MTK_PHY_LED_STATE_FORCE_ON + (index ? 16 : 0);
+-	struct mtk_socphy_priv *priv = phydev->priv;
+-	bool changed;
+-
+-	if (on)
+-		changed = !test_and_set_bit(bit_on, &priv->led_state);
+-	else
+-		changed = !!test_and_clear_bit(bit_on, &priv->led_state);
+-
+-	changed |= !!test_and_clear_bit(MTK_PHY_LED_STATE_NETDEV +
+-					(index ? 16 : 0), &priv->led_state);
+-	if (changed)
+-		return phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				      MTK_PHY_LED1_ON_CTRL :
+-				      MTK_PHY_LED0_ON_CTRL,
+-				      MTK_PHY_LED_ON_MASK,
+-				      on ? MTK_PHY_LED_ON_FORCE_ON : 0);
+-	else
+-		return 0;
+-}
+-
+-static int mt798x_phy_hw_led_blink_set(struct phy_device *phydev, u8 index,
+-				       bool blinking)
+-{
+-	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
+-				 (index ? 16 : 0);
+-	struct mtk_socphy_priv *priv = phydev->priv;
+-	bool changed;
+-
+-	if (blinking)
+-		changed = !test_and_set_bit(bit_blink, &priv->led_state);
+-	else
+-		changed = !!test_and_clear_bit(bit_blink, &priv->led_state);
+-
+-	changed |= !!test_bit(MTK_PHY_LED_STATE_NETDEV +
+-			      (index ? 16 : 0), &priv->led_state);
+-	if (changed)
+-		return phy_write_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				     MTK_PHY_LED1_BLINK_CTRL :
+-				     MTK_PHY_LED0_BLINK_CTRL,
+-				     blinking ?
+-				     MTK_PHY_LED_BLINK_FORCE_BLINK : 0);
+-	else
+-		return 0;
+-}
+-
+ static int mt798x_phy_led_blink_set(struct phy_device *phydev, u8 index,
+ 				    unsigned long *delay_on,
+ 				    unsigned long *delay_off)
+ {
+ 	bool blinking = false;
+-	int err = 0;
+-
+-	if (index > 1)
+-		return -EINVAL;
++	int err;
+ 
+-	if (delay_on && delay_off && (*delay_on > 0) && (*delay_off > 0)) {
+-		blinking = true;
+-		*delay_on = 50;
+-		*delay_off = 50;
+-	}
++	err = mtk_phy_led_num_dly_cfg(index, delay_on, delay_off, &blinking);
++	if (err < 0)
++		return err;
+ 
+-	err = mt798x_phy_hw_led_blink_set(phydev, index, blinking);
++	err = mtk_phy_hw_led_blink_set(phydev, index, blinking);
+ 	if (err)
+ 		return err;
+ 
+-	return mt798x_phy_hw_led_on_set(phydev, index, false);
++	return mtk_phy_hw_led_on_set(phydev, index, MTK_GPHY_LED_ON_MASK,
++				     false);
+ }
+ 
+ static int mt798x_phy_led_brightness_set(struct phy_device *phydev,
+@@ -1249,11 +1155,12 @@ static int mt798x_phy_led_brightness_set
+ {
+ 	int err;
+ 
+-	err = mt798x_phy_hw_led_blink_set(phydev, index, false);
++	err = mtk_phy_hw_led_blink_set(phydev, index, false);
+ 	if (err)
+ 		return err;
+ 
+-	return mt798x_phy_hw_led_on_set(phydev, index, (value != LED_OFF));
++	return mtk_phy_hw_led_on_set(phydev, index, MTK_GPHY_LED_ON_MASK,
++				     (value != LED_OFF));
+ }
+ 
+ static const unsigned long supported_triggers =
+@@ -1269,155 +1176,26 @@ static const unsigned long supported_tri
+ static int mt798x_phy_led_hw_is_supported(struct phy_device *phydev, u8 index,
+ 					  unsigned long rules)
+ {
+-	if (index > 1)
+-		return -EINVAL;
+-
+-	/* All combinations of the supported triggers are allowed */
+-	if (rules & ~supported_triggers)
+-		return -EOPNOTSUPP;
+-
+-	return 0;
+-};
++	return mtk_phy_led_hw_is_supported(phydev, index, rules,
++					   supported_triggers);
++}
+ 
+ static int mt798x_phy_led_hw_control_get(struct phy_device *phydev, u8 index,
+ 					 unsigned long *rules)
+ {
+-	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
+-				 (index ? 16 : 0);
+-	unsigned int bit_netdev = MTK_PHY_LED_STATE_NETDEV + (index ? 16 : 0);
+-	unsigned int bit_on = MTK_PHY_LED_STATE_FORCE_ON + (index ? 16 : 0);
+-	struct mtk_socphy_priv *priv = phydev->priv;
+-	int on, blink;
+-
+-	if (index > 1)
+-		return -EINVAL;
+-
+-	on = phy_read_mmd(phydev, MDIO_MMD_VEND2,
+-			  index ? MTK_PHY_LED1_ON_CTRL : MTK_PHY_LED0_ON_CTRL);
+-
+-	if (on < 0)
+-		return -EIO;
+-
+-	blink = phy_read_mmd(phydev, MDIO_MMD_VEND2,
+-			     index ? MTK_PHY_LED1_BLINK_CTRL :
+-				     MTK_PHY_LED0_BLINK_CTRL);
+-	if (blink < 0)
+-		return -EIO;
+-
+-	if ((on & (MTK_PHY_LED_ON_LINK | MTK_PHY_LED_ON_FDX |
+-		   MTK_PHY_LED_ON_HDX | MTK_PHY_LED_ON_LINKDOWN)) ||
+-	    (blink & (MTK_PHY_LED_BLINK_RX | MTK_PHY_LED_BLINK_TX)))
+-		set_bit(bit_netdev, &priv->led_state);
+-	else
+-		clear_bit(bit_netdev, &priv->led_state);
+-
+-	if (on & MTK_PHY_LED_ON_FORCE_ON)
+-		set_bit(bit_on, &priv->led_state);
+-	else
+-		clear_bit(bit_on, &priv->led_state);
+-
+-	if (blink & MTK_PHY_LED_BLINK_FORCE_BLINK)
+-		set_bit(bit_blink, &priv->led_state);
+-	else
+-		clear_bit(bit_blink, &priv->led_state);
+-
+-	if (!rules)
+-		return 0;
+-
+-	if (on & MTK_PHY_LED_ON_LINK)
+-		*rules |= BIT(TRIGGER_NETDEV_LINK);
+-
+-	if (on & MTK_PHY_LED_ON_LINK10)
+-		*rules |= BIT(TRIGGER_NETDEV_LINK_10);
+-
+-	if (on & MTK_PHY_LED_ON_LINK100)
+-		*rules |= BIT(TRIGGER_NETDEV_LINK_100);
+-
+-	if (on & MTK_PHY_LED_ON_LINK1000)
+-		*rules |= BIT(TRIGGER_NETDEV_LINK_1000);
+-
+-	if (on & MTK_PHY_LED_ON_FDX)
+-		*rules |= BIT(TRIGGER_NETDEV_FULL_DUPLEX);
+-
+-	if (on & MTK_PHY_LED_ON_HDX)
+-		*rules |= BIT(TRIGGER_NETDEV_HALF_DUPLEX);
+-
+-	if (blink & MTK_PHY_LED_BLINK_RX)
+-		*rules |= BIT(TRIGGER_NETDEV_RX);
+-
+-	if (blink & MTK_PHY_LED_BLINK_TX)
+-		*rules |= BIT(TRIGGER_NETDEV_TX);
+-
+-	return 0;
++	return mtk_phy_led_hw_ctrl_get(phydev, index, rules,
++				       MTK_GPHY_LED_ON_SET,
++				       MTK_GPHY_LED_RX_BLINK_SET,
++				       MTK_GPHY_LED_TX_BLINK_SET);
+ };
+ 
+ static int mt798x_phy_led_hw_control_set(struct phy_device *phydev, u8 index,
+ 					 unsigned long rules)
+ {
+-	unsigned int bit_netdev = MTK_PHY_LED_STATE_NETDEV + (index ? 16 : 0);
+-	struct mtk_socphy_priv *priv = phydev->priv;
+-	u16 on = 0, blink = 0;
+-	int ret;
+-
+-	if (index > 1)
+-		return -EINVAL;
+-
+-	if (rules & BIT(TRIGGER_NETDEV_FULL_DUPLEX))
+-		on |= MTK_PHY_LED_ON_FDX;
+-
+-	if (rules & BIT(TRIGGER_NETDEV_HALF_DUPLEX))
+-		on |= MTK_PHY_LED_ON_HDX;
+-
+-	if (rules & (BIT(TRIGGER_NETDEV_LINK_10) | BIT(TRIGGER_NETDEV_LINK)))
+-		on |= MTK_PHY_LED_ON_LINK10;
+-
+-	if (rules & (BIT(TRIGGER_NETDEV_LINK_100) | BIT(TRIGGER_NETDEV_LINK)))
+-		on |= MTK_PHY_LED_ON_LINK100;
+-
+-	if (rules & (BIT(TRIGGER_NETDEV_LINK_1000) | BIT(TRIGGER_NETDEV_LINK)))
+-		on |= MTK_PHY_LED_ON_LINK1000;
+-
+-	if (rules & BIT(TRIGGER_NETDEV_RX)) {
+-		blink |= (on & MTK_PHY_LED_ON_LINK) ?
+-			  (((on & MTK_PHY_LED_ON_LINK10) ?
+-			    MTK_PHY_LED_BLINK_10RX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK100) ?
+-			    MTK_PHY_LED_BLINK_100RX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK1000) ?
+-			    MTK_PHY_LED_BLINK_1000RX : 0)) :
+-			  MTK_PHY_LED_BLINK_RX;
+-	}
+-
+-	if (rules & BIT(TRIGGER_NETDEV_TX)) {
+-		blink |= (on & MTK_PHY_LED_ON_LINK) ?
+-			  (((on & MTK_PHY_LED_ON_LINK10) ?
+-			    MTK_PHY_LED_BLINK_10TX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK100) ?
+-			    MTK_PHY_LED_BLINK_100TX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK1000) ?
+-			    MTK_PHY_LED_BLINK_1000TX : 0)) :
+-			  MTK_PHY_LED_BLINK_TX;
+-	}
+-
+-	if (blink || on)
+-		set_bit(bit_netdev, &priv->led_state);
+-	else
+-		clear_bit(bit_netdev, &priv->led_state);
+-
+-	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				MTK_PHY_LED1_ON_CTRL :
+-				MTK_PHY_LED0_ON_CTRL,
+-			     MTK_PHY_LED_ON_FDX     |
+-			     MTK_PHY_LED_ON_HDX     |
+-			     MTK_PHY_LED_ON_LINK,
+-			     on);
+-
+-	if (ret)
+-		return ret;
+-
+-	return phy_write_mmd(phydev, MDIO_MMD_VEND2, index ?
+-				MTK_PHY_LED1_BLINK_CTRL :
+-				MTK_PHY_LED0_BLINK_CTRL, blink);
++	return mtk_phy_led_hw_ctrl_set(phydev, index, rules,
++				       MTK_GPHY_LED_ON_SET,
++				       MTK_GPHY_LED_RX_BLINK_SET,
++				       MTK_GPHY_LED_TX_BLINK_SET);
+ };
+ 
+ static bool mt7988_phy_led_get_polarity(struct phy_device *phydev, int led_num)
+@@ -1492,14 +1270,6 @@ static int mt7988_phy_probe_shared(struc
+ 	return 0;
+ }
+ 
+-static void mt798x_phy_leds_state_init(struct phy_device *phydev)
+-{
+-	int i;
+-
+-	for (i = 0; i < 2; ++i)
+-		mt798x_phy_led_hw_control_get(phydev, i, NULL);
+-}
+-
+ static int mt7988_phy_probe(struct phy_device *phydev)
+ {
+ 	struct mtk_socphy_shared *shared;
+@@ -1525,7 +1295,7 @@ static int mt7988_phy_probe(struct phy_d
+ 
+ 	phydev->priv = priv;
+ 
+-	mt798x_phy_leds_state_init(phydev);
++	mtk_phy_leds_state_init(phydev);
+ 
+ 	err = mt7988_phy_fix_leds_polarities(phydev);
+ 	if (err)
+@@ -1552,7 +1322,7 @@ static int mt7981_phy_probe(struct phy_d
+ 
+ 	phydev->priv = priv;
+ 
+-	mt798x_phy_leds_state_init(phydev);
++	mtk_phy_leds_state_init(phydev);
+ 
+ 	return mt798x_phy_calibration(phydev);
+ }
+--- /dev/null
++++ b/drivers/net/phy/mediatek/mtk-phy-lib.c
+@@ -0,0 +1,254 @@
++// SPDX-License-Identifier: GPL-2.0
++#include <linux/phy.h>
++#include <linux/module.h>
++
++#include <linux/netdevice.h>
++
++#include "mtk.h"
++
++int mtk_phy_led_hw_is_supported(struct phy_device *phydev, u8 index,
++				unsigned long rules,
++				unsigned long supported_triggers)
++{
++	if (index > 1)
++		return -EINVAL;
++
++	/* All combinations of the supported triggers are allowed */
++	if (rules & ~supported_triggers)
++		return -EOPNOTSUPP;
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(mtk_phy_led_hw_is_supported);
++
++int mtk_phy_led_hw_ctrl_get(struct phy_device *phydev, u8 index,
++			    unsigned long *rules, u16 on_set,
++			    u16 rx_blink_set, u16 tx_blink_set)
++{
++	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
++				 (index ? 16 : 0);
++	unsigned int bit_netdev = MTK_PHY_LED_STATE_NETDEV + (index ? 16 : 0);
++	unsigned int bit_on = MTK_PHY_LED_STATE_FORCE_ON + (index ? 16 : 0);
++	struct mtk_socphy_priv *priv = phydev->priv;
++	int on, blink;
++
++	if (index > 1)
++		return -EINVAL;
++
++	on = phy_read_mmd(phydev, MDIO_MMD_VEND2,
++			  index ? MTK_PHY_LED1_ON_CTRL : MTK_PHY_LED0_ON_CTRL);
++
++	if (on < 0)
++		return -EIO;
++
++	blink = phy_read_mmd(phydev, MDIO_MMD_VEND2,
++			     index ? MTK_PHY_LED1_BLINK_CTRL :
++				     MTK_PHY_LED0_BLINK_CTRL);
++	if (blink < 0)
++		return -EIO;
++
++	if ((on & (on_set | MTK_PHY_LED_ON_FDX |
++		   MTK_PHY_LED_ON_HDX | MTK_PHY_LED_ON_LINKDOWN)) ||
++	    (blink & (rx_blink_set | tx_blink_set)))
++		set_bit(bit_netdev, &priv->led_state);
++	else
++		clear_bit(bit_netdev, &priv->led_state);
++
++	if (on & MTK_PHY_LED_ON_FORCE_ON)
++		set_bit(bit_on, &priv->led_state);
++	else
++		clear_bit(bit_on, &priv->led_state);
++
++	if (blink & MTK_PHY_LED_BLINK_FORCE_BLINK)
++		set_bit(bit_blink, &priv->led_state);
++	else
++		clear_bit(bit_blink, &priv->led_state);
++
++	if (!rules)
++		return 0;
++
++	if (on & on_set)
++		*rules |= BIT(TRIGGER_NETDEV_LINK);
++
++	if (on & MTK_PHY_LED_ON_LINK10)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_10);
++
++	if (on & MTK_PHY_LED_ON_LINK100)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_100);
++
++	if (on & MTK_PHY_LED_ON_LINK1000)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_1000);
++
++	if (on & MTK_PHY_LED_ON_LINK2500)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_2500);
++
++	if (on & MTK_PHY_LED_ON_FDX)
++		*rules |= BIT(TRIGGER_NETDEV_FULL_DUPLEX);
++
++	if (on & MTK_PHY_LED_ON_HDX)
++		*rules |= BIT(TRIGGER_NETDEV_HALF_DUPLEX);
++
++	if (blink & rx_blink_set)
++		*rules |= BIT(TRIGGER_NETDEV_RX);
++
++	if (blink & tx_blink_set)
++		*rules |= BIT(TRIGGER_NETDEV_TX);
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(mtk_phy_led_hw_ctrl_get);
++
++int mtk_phy_led_hw_ctrl_set(struct phy_device *phydev, u8 index,
++			    unsigned long rules, u16 on_set,
++			    u16 rx_blink_set, u16 tx_blink_set)
++{
++	unsigned int bit_netdev = MTK_PHY_LED_STATE_NETDEV + (index ? 16 : 0);
++	struct mtk_socphy_priv *priv = phydev->priv;
++	u16 on = 0, blink = 0;
++	int ret;
++
++	if (index > 1)
++		return -EINVAL;
++
++	if (rules & BIT(TRIGGER_NETDEV_FULL_DUPLEX))
++		on |= MTK_PHY_LED_ON_FDX;
++
++	if (rules & BIT(TRIGGER_NETDEV_HALF_DUPLEX))
++		on |= MTK_PHY_LED_ON_HDX;
++
++	if (rules & (BIT(TRIGGER_NETDEV_LINK_10) | BIT(TRIGGER_NETDEV_LINK)))
++		on |= MTK_PHY_LED_ON_LINK10;
++
++	if (rules & (BIT(TRIGGER_NETDEV_LINK_100) | BIT(TRIGGER_NETDEV_LINK)))
++		on |= MTK_PHY_LED_ON_LINK100;
++
++	if (rules & (BIT(TRIGGER_NETDEV_LINK_1000) | BIT(TRIGGER_NETDEV_LINK)))
++		on |= MTK_PHY_LED_ON_LINK1000;
++
++	if (rules & (BIT(TRIGGER_NETDEV_LINK_2500) | BIT(TRIGGER_NETDEV_LINK)))
++		on |= MTK_PHY_LED_ON_LINK2500;
++
++	if (rules & BIT(TRIGGER_NETDEV_RX)) {
++		blink |= (on & on_set) ?
++			  (((on & MTK_PHY_LED_ON_LINK10) ?
++			    MTK_PHY_LED_BLINK_10RX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK100) ?
++			    MTK_PHY_LED_BLINK_100RX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK1000) ?
++			    MTK_PHY_LED_BLINK_1000RX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK2500) ?
++			    MTK_PHY_LED_BLINK_2500RX : 0)) :
++			  rx_blink_set;
++	}
++
++	if (rules & BIT(TRIGGER_NETDEV_TX)) {
++		blink |= (on & on_set) ?
++			  (((on & MTK_PHY_LED_ON_LINK10) ?
++			    MTK_PHY_LED_BLINK_10TX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK100) ?
++			    MTK_PHY_LED_BLINK_100TX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK1000) ?
++			    MTK_PHY_LED_BLINK_1000TX : 0) |
++			   ((on & MTK_PHY_LED_ON_LINK2500) ?
++			    MTK_PHY_LED_BLINK_2500TX : 0)) :
++			  tx_blink_set;
++	}
++
++	if (blink || on)
++		set_bit(bit_netdev, &priv->led_state);
++	else
++		clear_bit(bit_netdev, &priv->led_state);
++
++	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
++			     MTK_PHY_LED1_ON_CTRL : MTK_PHY_LED0_ON_CTRL,
++			     MTK_PHY_LED_ON_FDX | MTK_PHY_LED_ON_HDX | on_set,
++			     on);
++
++	if (ret)
++		return ret;
++
++	return phy_write_mmd(phydev, MDIO_MMD_VEND2, index ?
++			     MTK_PHY_LED1_BLINK_CTRL :
++			     MTK_PHY_LED0_BLINK_CTRL, blink);
++}
++EXPORT_SYMBOL_GPL(mtk_phy_led_hw_ctrl_set);
++
++int mtk_phy_led_num_dly_cfg(u8 index, unsigned long *delay_on,
++			    unsigned long *delay_off, bool *blinking)
++{
++	if (index > 1)
++		return -EINVAL;
++
++	if (delay_on && delay_off && (*delay_on > 0) && (*delay_off > 0)) {
++		*blinking = true;
++		*delay_on = 50;
++		*delay_off = 50;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(mtk_phy_led_num_dly_cfg);
++
++int mtk_phy_hw_led_on_set(struct phy_device *phydev, u8 index,
++			  u16 led_on_mask, bool on)
++{
++	unsigned int bit_on = MTK_PHY_LED_STATE_FORCE_ON + (index ? 16 : 0);
++	struct mtk_socphy_priv *priv = phydev->priv;
++	bool changed;
++
++	if (on)
++		changed = !test_and_set_bit(bit_on, &priv->led_state);
++	else
++		changed = !!test_and_clear_bit(bit_on, &priv->led_state);
++
++	changed |= !!test_and_clear_bit(MTK_PHY_LED_STATE_NETDEV +
++					(index ? 16 : 0), &priv->led_state);
++	if (changed)
++		return phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
++				      MTK_PHY_LED1_ON_CTRL :
++				      MTK_PHY_LED0_ON_CTRL,
++				      led_on_mask,
++				      on ? MTK_PHY_LED_ON_FORCE_ON : 0);
++	else
++		return 0;
++}
++EXPORT_SYMBOL_GPL(mtk_phy_hw_led_on_set);
++
++int mtk_phy_hw_led_blink_set(struct phy_device *phydev, u8 index, bool blinking)
++{
++	unsigned int bit_blink = MTK_PHY_LED_STATE_FORCE_BLINK +
++				 (index ? 16 : 0);
++	struct mtk_socphy_priv *priv = phydev->priv;
++	bool changed;
++
++	if (blinking)
++		changed = !test_and_set_bit(bit_blink, &priv->led_state);
++	else
++		changed = !!test_and_clear_bit(bit_blink, &priv->led_state);
++
++	changed |= !!test_bit(MTK_PHY_LED_STATE_NETDEV +
++			      (index ? 16 : 0), &priv->led_state);
++	if (changed)
++		return phy_write_mmd(phydev, MDIO_MMD_VEND2, index ?
++				     MTK_PHY_LED1_BLINK_CTRL :
++				     MTK_PHY_LED0_BLINK_CTRL,
++				     blinking ?
++				     MTK_PHY_LED_BLINK_FORCE_BLINK : 0);
++	else
++		return 0;
++}
++EXPORT_SYMBOL_GPL(mtk_phy_hw_led_blink_set);
++
++void mtk_phy_leds_state_init(struct phy_device *phydev)
++{
++	int i;
++
++	for (i = 0; i < 2; ++i)
++		phydev->drv->led_hw_control_get(phydev, i, NULL);
++}
++EXPORT_SYMBOL_GPL(mtk_phy_leds_state_init);
++
++MODULE_DESCRIPTION("MediaTek Ethernet PHY driver common");
++MODULE_AUTHOR("Sky Huang <SkyLake.Huang@mediatek.com>");
++MODULE_AUTHOR("Daniel Golle <daniel@makrotopia.org>");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/net/phy/mediatek/mtk.h
+@@ -0,0 +1,86 @@
++/* SPDX-License-Identifier: GPL-2.0
++ *
++ * Common definition for Mediatek Ethernet PHYs
++ * Author: SkyLake Huang <SkyLake.Huang@mediatek.com>
++ * Copyright (c) 2024 MediaTek Inc.
++ */
++
++#ifndef _MTK_EPHY_H_
++#define _MTK_EPHY_H_
++
++#define MTK_EXT_PAGE_ACCESS			0x1f
++
++/* Registers on MDIO_MMD_VEND2 */
++#define MTK_PHY_LED0_ON_CTRL			0x24
++#define MTK_PHY_LED1_ON_CTRL			0x26
++#define   MTK_GPHY_LED_ON_MASK			GENMASK(6, 0)
++#define   MTK_2P5GPHY_LED_ON_MASK		GENMASK(7, 0)
++#define   MTK_PHY_LED_ON_LINK1000		BIT(0)
++#define   MTK_PHY_LED_ON_LINK100		BIT(1)
++#define   MTK_PHY_LED_ON_LINK10			BIT(2)
++#define   MTK_PHY_LED_ON_LINKDOWN		BIT(3)
++#define   MTK_PHY_LED_ON_FDX			BIT(4) /* Full duplex */
++#define   MTK_PHY_LED_ON_HDX			BIT(5) /* Half duplex */
++#define   MTK_PHY_LED_ON_FORCE_ON		BIT(6)
++#define   MTK_PHY_LED_ON_LINK2500		BIT(7)
++#define   MTK_PHY_LED_ON_POLARITY		BIT(14)
++#define   MTK_PHY_LED_ON_ENABLE			BIT(15)
++
++#define MTK_PHY_LED0_BLINK_CTRL			0x25
++#define MTK_PHY_LED1_BLINK_CTRL			0x27
++#define   MTK_PHY_LED_BLINK_1000TX		BIT(0)
++#define   MTK_PHY_LED_BLINK_1000RX		BIT(1)
++#define   MTK_PHY_LED_BLINK_100TX		BIT(2)
++#define   MTK_PHY_LED_BLINK_100RX		BIT(3)
++#define   MTK_PHY_LED_BLINK_10TX		BIT(4)
++#define   MTK_PHY_LED_BLINK_10RX		BIT(5)
++#define   MTK_PHY_LED_BLINK_COLLISION		BIT(6)
++#define   MTK_PHY_LED_BLINK_RX_CRC_ERR		BIT(7)
++#define   MTK_PHY_LED_BLINK_RX_IDLE_ERR		BIT(8)
++#define   MTK_PHY_LED_BLINK_FORCE_BLINK		BIT(9)
++#define   MTK_PHY_LED_BLINK_2500TX		BIT(10)
++#define   MTK_PHY_LED_BLINK_2500RX		BIT(11)
++
++#define MTK_GPHY_LED_ON_SET			(MTK_PHY_LED_ON_LINK1000 | \
++						 MTK_PHY_LED_ON_LINK100 | \
++						 MTK_PHY_LED_ON_LINK10)
++#define MTK_GPHY_LED_RX_BLINK_SET		(MTK_PHY_LED_BLINK_1000RX | \
++						 MTK_PHY_LED_BLINK_100RX | \
++						 MTK_PHY_LED_BLINK_10RX)
++#define MTK_GPHY_LED_TX_BLINK_SET		(MTK_PHY_LED_BLINK_1000RX | \
++						 MTK_PHY_LED_BLINK_100RX | \
++						 MTK_PHY_LED_BLINK_10RX)
++
++#define MTK_2P5GPHY_LED_ON_SET			(MTK_PHY_LED_ON_LINK2500 | \
++						 MTK_GPHY_LED_ON_SET)
++#define MTK_2P5GPHY_LED_RX_BLINK_SET		(MTK_PHY_LED_BLINK_2500RX | \
++						 MTK_GPHY_LED_RX_BLINK_SET)
++#define MTK_2P5GPHY_LED_TX_BLINK_SET		(MTK_PHY_LED_BLINK_2500RX | \
++						 MTK_GPHY_LED_TX_BLINK_SET)
++
++#define MTK_PHY_LED_STATE_FORCE_ON	0
++#define MTK_PHY_LED_STATE_FORCE_BLINK	1
++#define MTK_PHY_LED_STATE_NETDEV	2
++
++struct mtk_socphy_priv {
++	unsigned long		led_state;
++};
++
++int mtk_phy_led_hw_is_supported(struct phy_device *phydev, u8 index,
++				unsigned long rules,
++				unsigned long supported_triggers);
++int mtk_phy_led_hw_ctrl_set(struct phy_device *phydev, u8 index,
++			    unsigned long rules, u16 on_set,
++			    u16 rx_blink_set, u16 tx_blink_set);
++int mtk_phy_led_hw_ctrl_get(struct phy_device *phydev, u8 index,
++			    unsigned long *rules, u16 on_set,
++			    u16 rx_blink_set, u16 tx_blink_set);
++int mtk_phy_led_num_dly_cfg(u8 index, unsigned long *delay_on,
++			    unsigned long *delay_off, bool *blinking);
++int mtk_phy_hw_led_on_set(struct phy_device *phydev, u8 index,
++			  u16 led_on_mask, bool on);
++int mtk_phy_hw_led_blink_set(struct phy_device *phydev, u8 index,
++			     bool blinking);
++void mtk_phy_leds_state_init(struct phy_device *phydev);
++
++#endif /* _MTK_EPHY_H_ */
diff --git a/target/linux/generic/backport-6.12/725-v6.13-net-phy-mediatek-Improve-readability-of-mtk-phy-lib..patch b/target/linux/generic/backport-6.12/725-v6.13-net-phy-mediatek-Improve-readability-of-mtk-phy-lib..patch
new file mode 100644
index 0000000000..19f3a84ad9
--- /dev/null
+++ b/target/linux/generic/backport-6.12/725-v6.13-net-phy-mediatek-Improve-readability-of-mtk-phy-lib..patch
@@ -0,0 +1,72 @@
+From 3efd0595fc7aaae300f5d9f4f0ae86f432c8d2c7 Mon Sep 17 00:00:00 2001
+From: "SkyLake.Huang" <skylake.huang@mediatek.com>
+Date: Sat, 9 Nov 2024 00:34:53 +0800
+Subject: [PATCH 06/20] net: phy: mediatek: Improve readability of
+ mtk-phy-lib.c's mtk_phy_led_hw_ctrl_set()
+
+This patch removes parens around TRIGGER_NETDEV_RX/TRIGGER_NETDEV_TX in
+mtk_phy_led_hw_ctrl_set(), which improves readability.
+
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: SkyLake.Huang <skylake.huang@mediatek.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/mediatek/mtk-phy-lib.c | 44 ++++++++++++++------------
+ 1 file changed, 24 insertions(+), 20 deletions(-)
+
+--- a/drivers/net/phy/mediatek/mtk-phy-lib.c
++++ b/drivers/net/phy/mediatek/mtk-phy-lib.c
+@@ -129,29 +129,33 @@ int mtk_phy_led_hw_ctrl_set(struct phy_d
+ 		on |= MTK_PHY_LED_ON_LINK2500;
+ 
+ 	if (rules & BIT(TRIGGER_NETDEV_RX)) {
+-		blink |= (on & on_set) ?
+-			  (((on & MTK_PHY_LED_ON_LINK10) ?
+-			    MTK_PHY_LED_BLINK_10RX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK100) ?
+-			    MTK_PHY_LED_BLINK_100RX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK1000) ?
+-			    MTK_PHY_LED_BLINK_1000RX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK2500) ?
+-			    MTK_PHY_LED_BLINK_2500RX : 0)) :
+-			  rx_blink_set;
++		if (on & on_set) {
++			if (on & MTK_PHY_LED_ON_LINK10)
++				blink |= MTK_PHY_LED_BLINK_10RX;
++			if (on & MTK_PHY_LED_ON_LINK100)
++				blink |= MTK_PHY_LED_BLINK_100RX;
++			if (on & MTK_PHY_LED_ON_LINK1000)
++				blink |= MTK_PHY_LED_BLINK_1000RX;
++			if (on & MTK_PHY_LED_ON_LINK2500)
++				blink |= MTK_PHY_LED_BLINK_2500RX;
++		} else {
++			blink |= rx_blink_set;
++		}
+ 	}
+ 
+ 	if (rules & BIT(TRIGGER_NETDEV_TX)) {
+-		blink |= (on & on_set) ?
+-			  (((on & MTK_PHY_LED_ON_LINK10) ?
+-			    MTK_PHY_LED_BLINK_10TX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK100) ?
+-			    MTK_PHY_LED_BLINK_100TX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK1000) ?
+-			    MTK_PHY_LED_BLINK_1000TX : 0) |
+-			   ((on & MTK_PHY_LED_ON_LINK2500) ?
+-			    MTK_PHY_LED_BLINK_2500TX : 0)) :
+-			  tx_blink_set;
++		if (on & on_set) {
++			if (on & MTK_PHY_LED_ON_LINK10)
++				blink |= MTK_PHY_LED_BLINK_10TX;
++			if (on & MTK_PHY_LED_ON_LINK100)
++				blink |= MTK_PHY_LED_BLINK_100TX;
++			if (on & MTK_PHY_LED_ON_LINK1000)
++				blink |= MTK_PHY_LED_BLINK_1000TX;
++			if (on & MTK_PHY_LED_ON_LINK2500)
++				blink |= MTK_PHY_LED_BLINK_2500TX;
++		} else {
++			blink |= tx_blink_set;
++		}
+ 	}
+ 
+ 	if (blink || on)
diff --git a/target/linux/generic/backport-6.12/726-v6.13-net-phy-mediatek-Integrate-read-write-page-helper-fu.patch b/target/linux/generic/backport-6.12/726-v6.13-net-phy-mediatek-Integrate-read-write-page-helper-fu.patch
new file mode 100644
index 0000000000..a5828bc759
--- /dev/null
+++ b/target/linux/generic/backport-6.12/726-v6.13-net-phy-mediatek-Integrate-read-write-page-helper-fu.patch
@@ -0,0 +1,153 @@
+From 50a97d716105a5f35aaecca0bdfe8e23cba0e87f Mon Sep 17 00:00:00 2001
+From: "SkyLake.Huang" <skylake.huang@mediatek.com>
+Date: Sat, 9 Nov 2024 00:34:54 +0800
+Subject: [PATCH 07/20] net: phy: mediatek: Integrate read/write page helper
+ functions
+
+This patch integrates read/write page helper functions as MTK phy lib.
+They are basically the same in mtk-ge.c & mtk-ge-soc.c.
+
+Signed-off-by: SkyLake.Huang <skylake.huang@mediatek.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/mediatek/Kconfig       |  1 +
+ drivers/net/phy/mediatek/mtk-ge-soc.c  | 18 ++++--------------
+ drivers/net/phy/mediatek/mtk-ge.c      | 20 ++++++--------------
+ drivers/net/phy/mediatek/mtk-phy-lib.c | 12 ++++++++++++
+ drivers/net/phy/mediatek/mtk.h         |  3 +++
+ 5 files changed, 26 insertions(+), 28 deletions(-)
+
+--- a/drivers/net/phy/mediatek/Kconfig
++++ b/drivers/net/phy/mediatek/Kconfig
+@@ -4,6 +4,7 @@ config MTK_NET_PHYLIB
+ 
+ config MEDIATEK_GE_PHY
+ 	tristate "MediaTek Gigabit Ethernet PHYs"
++	select MTK_NET_PHYLIB
+ 	help
+ 	  Supports the MediaTek non-built-in Gigabit Ethernet PHYs.
+ 
+--- a/drivers/net/phy/mediatek/mtk-ge-soc.c
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -271,16 +271,6 @@ struct mtk_socphy_shared {
+ 	struct mtk_socphy_priv	priv[4];
+ };
+ 
+-static int mtk_socphy_read_page(struct phy_device *phydev)
+-{
+-	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
+-}
+-
+-static int mtk_socphy_write_page(struct phy_device *phydev, int page)
+-{
+-	return __phy_write(phydev, MTK_EXT_PAGE_ACCESS, page);
+-}
+-
+ /* One calibration cycle consists of:
+  * 1.Set DA_CALIN_FLAG high to start calibration. Keep it high
+  *   until AD_CAL_COMP is ready to output calibration result.
+@@ -1337,8 +1327,8 @@ static struct phy_driver mtk_socphy_driv
+ 		.probe		= mt7981_phy_probe,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
+-		.read_page	= mtk_socphy_read_page,
+-		.write_page	= mtk_socphy_write_page,
++		.read_page	= mtk_phy_read_page,
++		.write_page	= mtk_phy_write_page,
+ 		.led_blink_set	= mt798x_phy_led_blink_set,
+ 		.led_brightness_set = mt798x_phy_led_brightness_set,
+ 		.led_hw_is_supported = mt798x_phy_led_hw_is_supported,
+@@ -1354,8 +1344,8 @@ static struct phy_driver mtk_socphy_driv
+ 		.probe		= mt7988_phy_probe,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
+-		.read_page	= mtk_socphy_read_page,
+-		.write_page	= mtk_socphy_write_page,
++		.read_page	= mtk_phy_read_page,
++		.write_page	= mtk_phy_write_page,
+ 		.led_blink_set	= mt798x_phy_led_blink_set,
+ 		.led_brightness_set = mt798x_phy_led_brightness_set,
+ 		.led_hw_is_supported = mt798x_phy_led_hw_is_supported,
+--- a/drivers/net/phy/mediatek/mtk-ge.c
++++ b/drivers/net/phy/mediatek/mtk-ge.c
+@@ -3,6 +3,8 @@
+ #include <linux/module.h>
+ #include <linux/phy.h>
+ 
++#include "mtk.h"
++
+ #define MTK_EXT_PAGE_ACCESS		0x1f
+ #define MTK_PHY_PAGE_STANDARD		0x0000
+ #define MTK_PHY_PAGE_EXTENDED		0x0001
+@@ -11,16 +13,6 @@
+ #define MTK_PHY_PAGE_EXTENDED_2A30	0x2a30
+ #define MTK_PHY_PAGE_EXTENDED_52B5	0x52b5
+ 
+-static int mtk_gephy_read_page(struct phy_device *phydev)
+-{
+-	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
+-}
+-
+-static int mtk_gephy_write_page(struct phy_device *phydev, int page)
+-{
+-	return __phy_write(phydev, MTK_EXT_PAGE_ACCESS, page);
+-}
+-
+ static void mtk_gephy_config_init(struct phy_device *phydev)
+ {
+ 	/* Enable HW auto downshift */
+@@ -77,8 +69,8 @@ static struct phy_driver mtk_gephy_drive
+ 		.handle_interrupt = genphy_handle_interrupt_no_ack,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
+-		.read_page	= mtk_gephy_read_page,
+-		.write_page	= mtk_gephy_write_page,
++		.read_page	= mtk_phy_read_page,
++		.write_page	= mtk_phy_write_page,
+ 	},
+ 	{
+ 		PHY_ID_MATCH_EXACT(0x03a29441),
+@@ -91,8 +83,8 @@ static struct phy_driver mtk_gephy_drive
+ 		.handle_interrupt = genphy_handle_interrupt_no_ack,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
+-		.read_page	= mtk_gephy_read_page,
+-		.write_page	= mtk_gephy_write_page,
++		.read_page	= mtk_phy_read_page,
++		.write_page	= mtk_phy_write_page,
+ 	},
+ };
+ 
+--- a/drivers/net/phy/mediatek/mtk-phy-lib.c
++++ b/drivers/net/phy/mediatek/mtk-phy-lib.c
+@@ -6,6 +6,18 @@
+ 
+ #include "mtk.h"
+ 
++int mtk_phy_read_page(struct phy_device *phydev)
++{
++	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
++}
++EXPORT_SYMBOL_GPL(mtk_phy_read_page);
++
++int mtk_phy_write_page(struct phy_device *phydev, int page)
++{
++	return __phy_write(phydev, MTK_EXT_PAGE_ACCESS, page);
++}
++EXPORT_SYMBOL_GPL(mtk_phy_write_page);
++
+ int mtk_phy_led_hw_is_supported(struct phy_device *phydev, u8 index,
+ 				unsigned long rules,
+ 				unsigned long supported_triggers)
+--- a/drivers/net/phy/mediatek/mtk.h
++++ b/drivers/net/phy/mediatek/mtk.h
+@@ -66,6 +66,9 @@ struct mtk_socphy_priv {
+ 	unsigned long		led_state;
+ };
+ 
++int mtk_phy_read_page(struct phy_device *phydev);
++int mtk_phy_write_page(struct phy_device *phydev, int page);
++
+ int mtk_phy_led_hw_is_supported(struct phy_device *phydev, u8 index,
+ 				unsigned long rules,
+ 				unsigned long supported_triggers);
diff --git a/target/linux/generic/backport-6.12/727-v6.13-net-phy-mediatek-add-MT7530-MT7531-s-PHY-ID-macros.patch b/target/linux/generic/backport-6.12/727-v6.13-net-phy-mediatek-add-MT7530-MT7531-s-PHY-ID-macros.patch
new file mode 100644
index 0000000000..1c8738408b
--- /dev/null
+++ b/target/linux/generic/backport-6.12/727-v6.13-net-phy-mediatek-add-MT7530-MT7531-s-PHY-ID-macros.patch
@@ -0,0 +1,56 @@
+From e6579df175d5b1baa605c82f8e759542262637cf Mon Sep 17 00:00:00 2001
+From: "SkyLake.Huang" <skylake.huang@mediatek.com>
+Date: Sat, 9 Nov 2024 00:34:55 +0800
+Subject: [PATCH 08/20] net: phy: mediatek: add MT7530 & MT7531's PHY ID macros
+
+This patch adds MT7530 & MT7531's PHY ID macros in mtk-ge.c so that
+it follows the same rule of mtk-ge-soc.c.
+
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: SkyLake.Huang <skylake.huang@mediatek.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/mediatek/mtk-ge.c | 11 +++++++----
+ 1 file changed, 7 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/phy/mediatek/mtk-ge.c
++++ b/drivers/net/phy/mediatek/mtk-ge.c
+@@ -5,6 +5,9 @@
+ 
+ #include "mtk.h"
+ 
++#define MTK_GPHY_ID_MT7530		0x03a29412
++#define MTK_GPHY_ID_MT7531		0x03a29441
++
+ #define MTK_EXT_PAGE_ACCESS		0x1f
+ #define MTK_PHY_PAGE_STANDARD		0x0000
+ #define MTK_PHY_PAGE_EXTENDED		0x0001
+@@ -59,7 +62,7 @@ static int mt7531_phy_config_init(struct
+ 
+ static struct phy_driver mtk_gephy_driver[] = {
+ 	{
+-		PHY_ID_MATCH_EXACT(0x03a29412),
++		PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7530),
+ 		.name		= "MediaTek MT7530 PHY",
+ 		.config_init	= mt7530_phy_config_init,
+ 		/* Interrupts are handled by the switch, not the PHY
+@@ -73,7 +76,7 @@ static struct phy_driver mtk_gephy_drive
+ 		.write_page	= mtk_phy_write_page,
+ 	},
+ 	{
+-		PHY_ID_MATCH_EXACT(0x03a29441),
++		PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7531),
+ 		.name		= "MediaTek MT7531 PHY",
+ 		.config_init	= mt7531_phy_config_init,
+ 		/* Interrupts are handled by the switch, not the PHY
+@@ -91,8 +94,8 @@ static struct phy_driver mtk_gephy_drive
+ module_phy_driver(mtk_gephy_driver);
+ 
+ static struct mdio_device_id __maybe_unused mtk_gephy_tbl[] = {
+-	{ PHY_ID_MATCH_EXACT(0x03a29441) },
+-	{ PHY_ID_MATCH_EXACT(0x03a29412) },
++	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7530) },
++	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7531) },
+ 	{ }
+ };
+ 
diff --git a/target/linux/generic/backport-6.12/728-v6.14-net-phy-Constify-struct-mdio_device_id.patch b/target/linux/generic/backport-6.12/728-v6.14-net-phy-Constify-struct-mdio_device_id.patch
new file mode 100644
index 0000000000..a64bc51d9c
--- /dev/null
+++ b/target/linux/generic/backport-6.12/728-v6.14-net-phy-Constify-struct-mdio_device_id.patch
@@ -0,0 +1,700 @@
+From e127f7380aaf2cd1614961d826a4af7ab297d37f Mon Sep 17 00:00:00 2001
+From: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
+Date: Sun, 12 Jan 2025 15:14:50 +0100
+Subject: [PATCH 09/20] net: phy: Constify struct mdio_device_id
+
+'struct mdio_device_id' is not modified in these drivers.
+
+Constifying these structures moves some data to a read-only section, so
+increase overall security.
+
+On a x86_64, with allmodconfig, as an example:
+Before:
+======
+   text	   data	    bss	    dec	    hex	filename
+  27014	  12792	      0	  39806	   9b7e	drivers/net/phy/broadcom.o
+
+After:
+=====
+   text	   data	    bss	    dec	    hex	filename
+  27206	  12600	      0	  39806	   9b7e	drivers/net/phy/broadcom.o
+
+Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/403c381b7d9156b67ad68ffc44b8eee70c5e86a9.1736691226.git.christophe.jaillet@wanadoo.fr
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/adin.c                   | 2 +-
+ drivers/net/phy/adin1100.c               | 2 +-
+ drivers/net/phy/air_en8811h.c            | 2 +-
+ drivers/net/phy/amd.c                    | 2 +-
+ drivers/net/phy/aquantia/aquantia_main.c | 2 +-
+ drivers/net/phy/ax88796b.c               | 2 +-
+ drivers/net/phy/bcm-cygnus.c             | 2 +-
+ drivers/net/phy/bcm54140.c               | 2 +-
+ drivers/net/phy/bcm63xx.c                | 2 +-
+ drivers/net/phy/bcm7xxx.c                | 2 +-
+ drivers/net/phy/bcm84881.c               | 2 +-
+ drivers/net/phy/broadcom.c               | 2 +-
+ drivers/net/phy/cicada.c                 | 2 +-
+ drivers/net/phy/cortina.c                | 2 +-
+ drivers/net/phy/davicom.c                | 2 +-
+ drivers/net/phy/dp83640.c                | 2 +-
+ drivers/net/phy/dp83822.c                | 2 +-
+ drivers/net/phy/dp83848.c                | 2 +-
+ drivers/net/phy/dp83867.c                | 2 +-
+ drivers/net/phy/dp83869.c                | 2 +-
+ drivers/net/phy/dp83tc811.c              | 2 +-
+ drivers/net/phy/dp83td510.c              | 2 +-
+ drivers/net/phy/dp83tg720.c              | 2 +-
+ drivers/net/phy/et1011c.c                | 2 +-
+ drivers/net/phy/icplus.c                 | 2 +-
+ drivers/net/phy/intel-xway.c             | 2 +-
+ drivers/net/phy/lxt.c                    | 2 +-
+ drivers/net/phy/marvell-88q2xxx.c        | 2 +-
+ drivers/net/phy/marvell-88x2222.c        | 2 +-
+ drivers/net/phy/marvell.c                | 2 +-
+ drivers/net/phy/marvell10g.c             | 2 +-
+ drivers/net/phy/mediatek/mtk-ge-soc.c    | 2 +-
+ drivers/net/phy/mediatek/mtk-ge.c        | 2 +-
+ drivers/net/phy/meson-gxl.c              | 2 +-
+ drivers/net/phy/micrel.c                 | 2 +-
+ drivers/net/phy/microchip.c              | 2 +-
+ drivers/net/phy/microchip_t1.c           | 2 +-
+ drivers/net/phy/microchip_t1s.c          | 2 +-
+ drivers/net/phy/mscc/mscc_main.c         | 2 +-
+ drivers/net/phy/mxl-gpy.c                | 2 +-
+ drivers/net/phy/national.c               | 2 +-
+ drivers/net/phy/ncn26000.c               | 2 +-
+ drivers/net/phy/nxp-c45-tja11xx.c        | 2 +-
+ drivers/net/phy/nxp-cbtx.c               | 2 +-
+ drivers/net/phy/nxp-tja11xx.c            | 2 +-
+ drivers/net/phy/qcom/at803x.c            | 2 +-
+ drivers/net/phy/qcom/qca807x.c           | 2 +-
+ drivers/net/phy/qcom/qca808x.c           | 2 +-
+ drivers/net/phy/qcom/qca83xx.c           | 2 +-
+ drivers/net/phy/qsemi.c                  | 2 +-
+ drivers/net/phy/rockchip.c               | 2 +-
+ drivers/net/phy/smsc.c                   | 2 +-
+ drivers/net/phy/ste10Xp.c                | 2 +-
+ drivers/net/phy/teranetics.c             | 2 +-
+ drivers/net/phy/uPD60620.c               | 2 +-
+ drivers/net/phy/vitesse.c                | 2 +-
+ 56 files changed, 56 insertions(+), 56 deletions(-)
+
+--- a/drivers/net/phy/adin.c
++++ b/drivers/net/phy/adin.c
+@@ -1040,7 +1040,7 @@ static struct phy_driver adin_driver[] =
+ 
+ module_phy_driver(adin_driver);
+ 
+-static struct mdio_device_id __maybe_unused adin_tbl[] = {
++static const struct mdio_device_id __maybe_unused adin_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN1200) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN1300) },
+ 	{ }
+--- a/drivers/net/phy/adin1100.c
++++ b/drivers/net/phy/adin1100.c
+@@ -340,7 +340,7 @@ static struct phy_driver adin_driver[] =
+ 
+ module_phy_driver(adin_driver);
+ 
+-static struct mdio_device_id __maybe_unused adin_tbl[] = {
++static const struct mdio_device_id __maybe_unused adin_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN1100) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN1110) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN2111) },
+--- a/drivers/net/phy/air_en8811h.c
++++ b/drivers/net/phy/air_en8811h.c
+@@ -1075,7 +1075,7 @@ static struct phy_driver en8811h_driver[
+ 
+ module_phy_driver(en8811h_driver);
+ 
+-static struct mdio_device_id __maybe_unused en8811h_tbl[] = {
++static const struct mdio_device_id __maybe_unused en8811h_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(EN8811H_PHY_ID) },
+ 	{ }
+ };
+--- a/drivers/net/phy/amd.c
++++ b/drivers/net/phy/amd.c
+@@ -111,7 +111,7 @@ static struct phy_driver am79c_drivers[]
+ 
+ module_phy_driver(am79c_drivers);
+ 
+-static struct mdio_device_id __maybe_unused amd_tbl[] = {
++static const struct mdio_device_id __maybe_unused amd_tbl[] = {
+ 	{ PHY_ID_AC101L, 0xfffffff0 },
+ 	{ PHY_ID_AM79C874, 0xfffffff0 },
+ 	{ }
+--- a/drivers/net/phy/aquantia/aquantia_main.c
++++ b/drivers/net/phy/aquantia/aquantia_main.c
+@@ -1096,7 +1096,7 @@ static struct phy_driver aqr_driver[] =
+ 
+ module_phy_driver(aqr_driver);
+ 
+-static struct mdio_device_id __maybe_unused aqr_tbl[] = {
++static const struct mdio_device_id __maybe_unused aqr_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQ1202) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQ2104) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR105) },
+--- a/drivers/net/phy/ax88796b.c
++++ b/drivers/net/phy/ax88796b.c
+@@ -121,7 +121,7 @@ static struct phy_driver asix_driver[] =
+ 
+ module_phy_driver(asix_driver);
+ 
+-static struct mdio_device_id __maybe_unused asix_tbl[] = {
++static const struct mdio_device_id __maybe_unused asix_tbl[] = {
+ 	{ PHY_ID_MATCH_EXACT(PHY_ID_ASIX_AX88772A) },
+ 	{ PHY_ID_MATCH_EXACT(PHY_ID_ASIX_AX88772C) },
+ 	{ PHY_ID_ASIX_AX88796B, 0xfffffff0 },
+--- a/drivers/net/phy/bcm-cygnus.c
++++ b/drivers/net/phy/bcm-cygnus.c
+@@ -278,7 +278,7 @@ static struct phy_driver bcm_cygnus_phy_
+ }
+ };
+ 
+-static struct mdio_device_id __maybe_unused bcm_cygnus_phy_tbl[] = {
++static const struct mdio_device_id __maybe_unused bcm_cygnus_phy_tbl[] = {
+ 	{ PHY_ID_BCM_CYGNUS, 0xfffffff0, },
+ 	{ PHY_ID_BCM_OMEGA, 0xfffffff0, },
+ 	{ }
+--- a/drivers/net/phy/bcm54140.c
++++ b/drivers/net/phy/bcm54140.c
+@@ -883,7 +883,7 @@ static struct phy_driver bcm54140_driver
+ };
+ module_phy_driver(bcm54140_drivers);
+ 
+-static struct mdio_device_id __maybe_unused bcm54140_tbl[] = {
++static const struct mdio_device_id __maybe_unused bcm54140_tbl[] = {
+ 	{ PHY_ID_BCM54140, BCM54140_PHY_ID_MASK },
+ 	{ }
+ };
+--- a/drivers/net/phy/bcm63xx.c
++++ b/drivers/net/phy/bcm63xx.c
+@@ -93,7 +93,7 @@ static struct phy_driver bcm63xx_driver[
+ 
+ module_phy_driver(bcm63xx_driver);
+ 
+-static struct mdio_device_id __maybe_unused bcm63xx_tbl[] = {
++static const struct mdio_device_id __maybe_unused bcm63xx_tbl[] = {
+ 	{ 0x00406000, 0xfffffc00 },
+ 	{ 0x002bdc00, 0xfffffc00 },
+ 	{ }
+--- a/drivers/net/phy/bcm7xxx.c
++++ b/drivers/net/phy/bcm7xxx.c
+@@ -929,7 +929,7 @@ static struct phy_driver bcm7xxx_driver[
+ 	BCM7XXX_16NM_EPHY(PHY_ID_BCM7712, "Broadcom BCM7712"),
+ };
+ 
+-static struct mdio_device_id __maybe_unused bcm7xxx_tbl[] = {
++static const struct mdio_device_id __maybe_unused bcm7xxx_tbl[] = {
+ 	{ PHY_ID_BCM72113, 0xfffffff0 },
+ 	{ PHY_ID_BCM72116, 0xfffffff0, },
+ 	{ PHY_ID_BCM72165, 0xfffffff0, },
+--- a/drivers/net/phy/bcm84881.c
++++ b/drivers/net/phy/bcm84881.c
+@@ -252,7 +252,7 @@ static struct phy_driver bcm84881_driver
+ module_phy_driver(bcm84881_drivers);
+ 
+ /* FIXME: module auto-loading for Clause 45 PHYs seems non-functional */
+-static struct mdio_device_id __maybe_unused bcm84881_tbl[] = {
++static const struct mdio_device_id __maybe_unused bcm84881_tbl[] = {
+ 	{ 0xae025150, 0xfffffff0 },
+ 	{ },
+ };
+--- a/drivers/net/phy/broadcom.c
++++ b/drivers/net/phy/broadcom.c
+@@ -1717,7 +1717,7 @@ static struct phy_driver broadcom_driver
+ 
+ module_phy_driver(broadcom_drivers);
+ 
+-static struct mdio_device_id __maybe_unused broadcom_tbl[] = {
++static const struct mdio_device_id __maybe_unused broadcom_tbl[] = {
+ 	{ PHY_ID_BCM5411, 0xfffffff0 },
+ 	{ PHY_ID_BCM5421, 0xfffffff0 },
+ 	{ PHY_ID_BCM54210E, 0xfffffff0 },
+--- a/drivers/net/phy/cicada.c
++++ b/drivers/net/phy/cicada.c
+@@ -145,7 +145,7 @@ static struct phy_driver cis820x_driver[
+ 
+ module_phy_driver(cis820x_driver);
+ 
+-static struct mdio_device_id __maybe_unused cicada_tbl[] = {
++static const struct mdio_device_id __maybe_unused cicada_tbl[] = {
+ 	{ 0x000fc410, 0x000ffff0 },
+ 	{ 0x000fc440, 0x000fffc0 },
+ 	{ }
+--- a/drivers/net/phy/cortina.c
++++ b/drivers/net/phy/cortina.c
+@@ -87,7 +87,7 @@ static struct phy_driver cortina_driver[
+ 
+ module_phy_driver(cortina_driver);
+ 
+-static struct mdio_device_id __maybe_unused cortina_tbl[] = {
++static const struct mdio_device_id __maybe_unused cortina_tbl[] = {
+ 	{ PHY_ID_CS4340, 0xffffffff},
+ 	{},
+ };
+--- a/drivers/net/phy/davicom.c
++++ b/drivers/net/phy/davicom.c
+@@ -209,7 +209,7 @@ static struct phy_driver dm91xx_driver[]
+ 
+ module_phy_driver(dm91xx_driver);
+ 
+-static struct mdio_device_id __maybe_unused davicom_tbl[] = {
++static const struct mdio_device_id __maybe_unused davicom_tbl[] = {
+ 	{ 0x0181b880, 0x0ffffff0 },
+ 	{ 0x0181b8b0, 0x0ffffff0 },
+ 	{ 0x0181b8a0, 0x0ffffff0 },
+--- a/drivers/net/phy/dp83640.c
++++ b/drivers/net/phy/dp83640.c
+@@ -1548,7 +1548,7 @@ MODULE_LICENSE("GPL");
+ module_init(dp83640_init);
+ module_exit(dp83640_exit);
+ 
+-static struct mdio_device_id __maybe_unused dp83640_tbl[] = {
++static const struct mdio_device_id __maybe_unused dp83640_tbl[] = {
+ 	{ DP83640_PHY_ID, 0xfffffff0 },
+ 	{ }
+ };
+--- a/drivers/net/phy/dp83822.c
++++ b/drivers/net/phy/dp83822.c
+@@ -825,7 +825,7 @@ static struct phy_driver dp83822_driver[
+ };
+ module_phy_driver(dp83822_driver);
+ 
+-static struct mdio_device_id __maybe_unused dp83822_tbl[] = {
++static const struct mdio_device_id __maybe_unused dp83822_tbl[] = {
+ 	{ DP83822_PHY_ID, 0xfffffff0 },
+ 	{ DP83825I_PHY_ID, 0xfffffff0 },
+ 	{ DP83826C_PHY_ID, 0xfffffff0 },
+--- a/drivers/net/phy/dp83848.c
++++ b/drivers/net/phy/dp83848.c
+@@ -123,7 +123,7 @@ static int dp83848_config_init(struct ph
+ 	return 0;
+ }
+ 
+-static struct mdio_device_id __maybe_unused dp83848_tbl[] = {
++static const struct mdio_device_id __maybe_unused dp83848_tbl[] = {
+ 	{ TI_DP83848C_PHY_ID, 0xfffffff0 },
+ 	{ NS_DP83848C_PHY_ID, 0xfffffff0 },
+ 	{ TI_DP83620_PHY_ID, 0xfffffff0 },
+--- a/drivers/net/phy/dp83867.c
++++ b/drivers/net/phy/dp83867.c
+@@ -1210,7 +1210,7 @@ static struct phy_driver dp83867_driver[
+ };
+ module_phy_driver(dp83867_driver);
+ 
+-static struct mdio_device_id __maybe_unused dp83867_tbl[] = {
++static const struct mdio_device_id __maybe_unused dp83867_tbl[] = {
+ 	{ DP83867_PHY_ID, 0xfffffff0 },
+ 	{ }
+ };
+--- a/drivers/net/phy/dp83869.c
++++ b/drivers/net/phy/dp83869.c
+@@ -928,7 +928,7 @@ static struct phy_driver dp83869_driver[
+ };
+ module_phy_driver(dp83869_driver);
+ 
+-static struct mdio_device_id __maybe_unused dp83869_tbl[] = {
++static const struct mdio_device_id __maybe_unused dp83869_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(DP83869_PHY_ID) },
+ 	{ PHY_ID_MATCH_MODEL(DP83561_PHY_ID) },
+ 	{ }
+--- a/drivers/net/phy/dp83tc811.c
++++ b/drivers/net/phy/dp83tc811.c
+@@ -403,7 +403,7 @@ static struct phy_driver dp83811_driver[
+ };
+ module_phy_driver(dp83811_driver);
+ 
+-static struct mdio_device_id __maybe_unused dp83811_tbl[] = {
++static const struct mdio_device_id __maybe_unused dp83811_tbl[] = {
+ 	{ DP83TC811_PHY_ID, 0xfffffff0 },
+ 	{ },
+ };
+--- a/drivers/net/phy/dp83td510.c
++++ b/drivers/net/phy/dp83td510.c
+@@ -605,7 +605,7 @@ static struct phy_driver dp83td510_drive
+ } };
+ module_phy_driver(dp83td510_driver);
+ 
+-static struct mdio_device_id __maybe_unused dp83td510_tbl[] = {
++static const struct mdio_device_id __maybe_unused dp83td510_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(DP83TD510E_PHY_ID) },
+ 	{ }
+ };
+--- a/drivers/net/phy/dp83tg720.c
++++ b/drivers/net/phy/dp83tg720.c
+@@ -361,7 +361,7 @@ static struct phy_driver dp83tg720_drive
+ } };
+ module_phy_driver(dp83tg720_driver);
+ 
+-static struct mdio_device_id __maybe_unused dp83tg720_tbl[] = {
++static const struct mdio_device_id __maybe_unused dp83tg720_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(DP83TG720S_PHY_ID) },
+ 	{ }
+ };
+--- a/drivers/net/phy/et1011c.c
++++ b/drivers/net/phy/et1011c.c
+@@ -94,7 +94,7 @@ static struct phy_driver et1011c_driver[
+ 
+ module_phy_driver(et1011c_driver);
+ 
+-static struct mdio_device_id __maybe_unused et1011c_tbl[] = {
++static const struct mdio_device_id __maybe_unused et1011c_tbl[] = {
+ 	{ 0x0282f014, 0xfffffff0 },
+ 	{ }
+ };
+--- a/drivers/net/phy/icplus.c
++++ b/drivers/net/phy/icplus.c
+@@ -624,7 +624,7 @@ static struct phy_driver icplus_driver[]
+ 
+ module_phy_driver(icplus_driver);
+ 
+-static struct mdio_device_id __maybe_unused icplus_tbl[] = {
++static const struct mdio_device_id __maybe_unused icplus_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(IP175C_PHY_ID) },
+ 	{ PHY_ID_MATCH_MODEL(IP1001_PHY_ID) },
+ 	{ PHY_ID_MATCH_EXACT(IP101A_PHY_ID) },
+--- a/drivers/net/phy/intel-xway.c
++++ b/drivers/net/phy/intel-xway.c
+@@ -456,7 +456,7 @@ static struct phy_driver xway_gphy[] = {
+ };
+ module_phy_driver(xway_gphy);
+ 
+-static struct mdio_device_id __maybe_unused xway_gphy_tbl[] = {
++static const struct mdio_device_id __maybe_unused xway_gphy_tbl[] = {
+ 	{ PHY_ID_PHY11G_1_3, 0xffffffff },
+ 	{ PHY_ID_PHY22F_1_3, 0xffffffff },
+ 	{ PHY_ID_PHY11G_1_4, 0xffffffff },
+--- a/drivers/net/phy/lxt.c
++++ b/drivers/net/phy/lxt.c
+@@ -348,7 +348,7 @@ static struct phy_driver lxt97x_driver[]
+ 
+ module_phy_driver(lxt97x_driver);
+ 
+-static struct mdio_device_id __maybe_unused lxt_tbl[] = {
++static const struct mdio_device_id __maybe_unused lxt_tbl[] = {
+ 	{ 0x78100000, 0xfffffff0 },
+ 	{ 0x001378e0, 0xfffffff0 },
+ 	{ 0x00137a10, 0xfffffff0 },
+--- a/drivers/net/phy/marvell-88q2xxx.c
++++ b/drivers/net/phy/marvell-88q2xxx.c
+@@ -940,7 +940,7 @@ static struct phy_driver mv88q2xxx_drive
+ 
+ module_phy_driver(mv88q2xxx_driver);
+ 
+-static struct mdio_device_id __maybe_unused mv88q2xxx_tbl[] = {
++static const struct mdio_device_id __maybe_unused mv88q2xxx_tbl[] = {
+ 	{ MARVELL_PHY_ID_88Q2110, MARVELL_PHY_ID_MASK },
+ 	{ MARVELL_PHY_ID_88Q2220, MARVELL_PHY_ID_MASK },
+ 	{ /*sentinel*/ }
+--- a/drivers/net/phy/marvell-88x2222.c
++++ b/drivers/net/phy/marvell-88x2222.c
+@@ -613,7 +613,7 @@ static struct phy_driver mv2222_drivers[
+ };
+ module_phy_driver(mv2222_drivers);
+ 
+-static struct mdio_device_id __maybe_unused mv2222_tbl[] = {
++static const struct mdio_device_id __maybe_unused mv2222_tbl[] = {
+ 	{ MARVELL_PHY_ID_88X2222, MARVELL_PHY_ID_MASK },
+ 	{ }
+ };
+--- a/drivers/net/phy/marvell.c
++++ b/drivers/net/phy/marvell.c
+@@ -4133,7 +4133,7 @@ static struct phy_driver marvell_drivers
+ 
+ module_phy_driver(marvell_drivers);
+ 
+-static struct mdio_device_id __maybe_unused marvell_tbl[] = {
++static const struct mdio_device_id __maybe_unused marvell_tbl[] = {
+ 	{ MARVELL_PHY_ID_88E1101, MARVELL_PHY_ID_MASK },
+ 	{ MARVELL_PHY_ID_88E3082, MARVELL_PHY_ID_MASK },
+ 	{ MARVELL_PHY_ID_88E1112, MARVELL_PHY_ID_MASK },
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -1484,7 +1484,7 @@ static struct phy_driver mv3310_drivers[
+ 
+ module_phy_driver(mv3310_drivers);
+ 
+-static struct mdio_device_id __maybe_unused mv3310_tbl[] = {
++static const struct mdio_device_id __maybe_unused mv3310_tbl[] = {
+ 	{ MARVELL_PHY_ID_88X3310, MARVELL_PHY_ID_MASK },
+ 	{ MARVELL_PHY_ID_88E2110, MARVELL_PHY_ID_MASK },
+ 	{ },
+--- a/drivers/net/phy/mediatek/mtk-ge-soc.c
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -1356,7 +1356,7 @@ static struct phy_driver mtk_socphy_driv
+ 
+ module_phy_driver(mtk_socphy_driver);
+ 
+-static struct mdio_device_id __maybe_unused mtk_socphy_tbl[] = {
++static const struct mdio_device_id __maybe_unused mtk_socphy_tbl[] = {
+ 	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7981) },
+ 	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7988) },
+ 	{ }
+--- a/drivers/net/phy/mediatek/mtk-ge.c
++++ b/drivers/net/phy/mediatek/mtk-ge.c
+@@ -93,7 +93,7 @@ static struct phy_driver mtk_gephy_drive
+ 
+ module_phy_driver(mtk_gephy_driver);
+ 
+-static struct mdio_device_id __maybe_unused mtk_gephy_tbl[] = {
++static const struct mdio_device_id __maybe_unused mtk_gephy_tbl[] = {
+ 	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7530) },
+ 	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7531) },
+ 	{ }
+--- a/drivers/net/phy/meson-gxl.c
++++ b/drivers/net/phy/meson-gxl.c
+@@ -221,7 +221,7 @@ static struct phy_driver meson_gxl_phy[]
+ 	},
+ };
+ 
+-static struct mdio_device_id __maybe_unused meson_gxl_tbl[] = {
++static const struct mdio_device_id __maybe_unused meson_gxl_tbl[] = {
+ 	{ PHY_ID_MATCH_VENDOR(0x01814400) },
+ 	{ PHY_ID_MATCH_VENDOR(0x01803301) },
+ 	{ }
+--- a/drivers/net/phy/micrel.c
++++ b/drivers/net/phy/micrel.c
+@@ -5691,7 +5691,7 @@ MODULE_DESCRIPTION("Micrel PHY driver");
+ MODULE_AUTHOR("David J. Choi");
+ MODULE_LICENSE("GPL");
+ 
+-static struct mdio_device_id __maybe_unused micrel_tbl[] = {
++static const struct mdio_device_id __maybe_unused micrel_tbl[] = {
+ 	{ PHY_ID_KSZ9021, 0x000ffffe },
+ 	{ PHY_ID_KSZ9031, MICREL_PHY_ID_MASK },
+ 	{ PHY_ID_KSZ9131, MICREL_PHY_ID_MASK },
+--- a/drivers/net/phy/microchip.c
++++ b/drivers/net/phy/microchip.c
+@@ -508,7 +508,7 @@ static struct phy_driver microchip_phy_d
+ 
+ module_phy_driver(microchip_phy_driver);
+ 
+-static struct mdio_device_id __maybe_unused microchip_tbl[] = {
++static const struct mdio_device_id __maybe_unused microchip_tbl[] = {
+ 	{ 0x0007c132, 0xfffffff2 },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_LAN937X_TX) },
+ 	{ }
+--- a/drivers/net/phy/microchip_t1.c
++++ b/drivers/net/phy/microchip_t1.c
+@@ -1886,7 +1886,7 @@ static struct phy_driver microchip_t1_ph
+ 
+ module_phy_driver(microchip_t1_phy_driver);
+ 
+-static struct mdio_device_id __maybe_unused microchip_t1_tbl[] = {
++static const struct mdio_device_id __maybe_unused microchip_t1_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_LAN87XX) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_LAN937X) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_LAN887X) },
+--- a/drivers/net/phy/microchip_t1s.c
++++ b/drivers/net/phy/microchip_t1s.c
+@@ -323,7 +323,7 @@ static struct phy_driver microchip_t1s_d
+ 
+ module_phy_driver(microchip_t1s_driver);
+ 
+-static struct mdio_device_id __maybe_unused tbl[] = {
++static const struct mdio_device_id __maybe_unused tbl[] = {
+ 	{ PHY_ID_MATCH_EXACT(PHY_ID_LAN867X_REVB1) },
+ 	{ PHY_ID_MATCH_EXACT(PHY_ID_LAN865X_REVB0) },
+ 	{ }
+--- a/drivers/net/phy/mscc/mscc_main.c
++++ b/drivers/net/phy/mscc/mscc_main.c
+@@ -2700,7 +2700,7 @@ static struct phy_driver vsc85xx_driver[
+ 
+ module_phy_driver(vsc85xx_driver);
+ 
+-static struct mdio_device_id __maybe_unused vsc85xx_tbl[] = {
++static const struct mdio_device_id __maybe_unused vsc85xx_tbl[] = {
+ 	{ PHY_ID_MATCH_VENDOR(PHY_VENDOR_MSCC) },
+ 	{ }
+ };
+--- a/drivers/net/phy/mxl-gpy.c
++++ b/drivers/net/phy/mxl-gpy.c
+@@ -1047,7 +1047,7 @@ static struct phy_driver gpy_drivers[] =
+ };
+ module_phy_driver(gpy_drivers);
+ 
+-static struct mdio_device_id __maybe_unused gpy_tbl[] = {
++static const struct mdio_device_id __maybe_unused gpy_tbl[] = {
+ 	{PHY_ID_MATCH_MODEL(PHY_ID_GPY2xx)},
+ 	{PHY_ID_GPY115B, PHY_ID_GPYx15B_MASK},
+ 	{PHY_ID_MATCH_MODEL(PHY_ID_GPY115C)},
+--- a/drivers/net/phy/national.c
++++ b/drivers/net/phy/national.c
+@@ -173,7 +173,7 @@ MODULE_DESCRIPTION("NatSemi PHY driver")
+ MODULE_AUTHOR("Stuart Menefy");
+ MODULE_LICENSE("GPL");
+ 
+-static struct mdio_device_id __maybe_unused ns_tbl[] = {
++static const struct mdio_device_id __maybe_unused ns_tbl[] = {
+ 	{ DP83865_PHY_ID, 0xfffffff0 },
+ 	{ }
+ };
+--- a/drivers/net/phy/ncn26000.c
++++ b/drivers/net/phy/ncn26000.c
+@@ -159,7 +159,7 @@ static struct phy_driver ncn26000_driver
+ 
+ module_phy_driver(ncn26000_driver);
+ 
+-static struct mdio_device_id __maybe_unused ncn26000_tbl[] = {
++static const struct mdio_device_id __maybe_unused ncn26000_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_NCN26000) },
+ 	{ }
+ };
+--- a/drivers/net/phy/nxp-c45-tja11xx.c
++++ b/drivers/net/phy/nxp-c45-tja11xx.c
+@@ -2052,7 +2052,7 @@ static struct phy_driver nxp_c45_driver[
+ 
+ module_phy_driver(nxp_c45_driver);
+ 
+-static struct mdio_device_id __maybe_unused nxp_c45_tbl[] = {
++static const struct mdio_device_id __maybe_unused nxp_c45_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_TJA_1103) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_TJA_1120) },
+ 	{ /*sentinel*/ },
+--- a/drivers/net/phy/nxp-cbtx.c
++++ b/drivers/net/phy/nxp-cbtx.c
+@@ -215,7 +215,7 @@ static struct phy_driver cbtx_driver[] =
+ 
+ module_phy_driver(cbtx_driver);
+ 
+-static struct mdio_device_id __maybe_unused cbtx_tbl[] = {
++static const struct mdio_device_id __maybe_unused cbtx_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_CBTX_SJA1110) },
+ 	{ },
+ };
+--- a/drivers/net/phy/nxp-tja11xx.c
++++ b/drivers/net/phy/nxp-tja11xx.c
+@@ -888,7 +888,7 @@ static struct phy_driver tja11xx_driver[
+ 
+ module_phy_driver(tja11xx_driver);
+ 
+-static struct mdio_device_id __maybe_unused tja11xx_tbl[] = {
++static const struct mdio_device_id __maybe_unused tja11xx_tbl[] = {
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_TJA1100) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_TJA1101) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_TJA1102) },
+--- a/drivers/net/phy/qcom/at803x.c
++++ b/drivers/net/phy/qcom/at803x.c
+@@ -1098,7 +1098,7 @@ static struct phy_driver at803x_driver[]
+ 
+ module_phy_driver(at803x_driver);
+ 
+-static struct mdio_device_id __maybe_unused atheros_tbl[] = {
++static const struct mdio_device_id __maybe_unused atheros_tbl[] = {
+ 	{ ATH8030_PHY_ID, AT8030_PHY_ID_MASK },
+ 	{ PHY_ID_MATCH_EXACT(ATH8031_PHY_ID) },
+ 	{ PHY_ID_MATCH_EXACT(ATH8032_PHY_ID) },
+--- a/drivers/net/phy/qcom/qca807x.c
++++ b/drivers/net/phy/qcom/qca807x.c
+@@ -828,7 +828,7 @@ static struct phy_driver qca807x_drivers
+ };
+ module_phy_driver(qca807x_drivers);
+ 
+-static struct mdio_device_id __maybe_unused qca807x_tbl[] = {
++static const struct mdio_device_id __maybe_unused qca807x_tbl[] = {
+ 	{ PHY_ID_MATCH_EXACT(PHY_ID_QCA8072) },
+ 	{ PHY_ID_MATCH_EXACT(PHY_ID_QCA8075) },
+ 	{ }
+--- a/drivers/net/phy/qcom/qca808x.c
++++ b/drivers/net/phy/qcom/qca808x.c
+@@ -655,7 +655,7 @@ static struct phy_driver qca808x_driver[
+ 
+ module_phy_driver(qca808x_driver);
+ 
+-static struct mdio_device_id __maybe_unused qca808x_tbl[] = {
++static const struct mdio_device_id __maybe_unused qca808x_tbl[] = {
+ 	{ PHY_ID_MATCH_EXACT(QCA8081_PHY_ID) },
+ 	{ }
+ };
+--- a/drivers/net/phy/qcom/qca83xx.c
++++ b/drivers/net/phy/qcom/qca83xx.c
+@@ -261,7 +261,7 @@ static struct phy_driver qca83xx_driver[
+ 
+ module_phy_driver(qca83xx_driver);
+ 
+-static struct mdio_device_id __maybe_unused qca83xx_tbl[] = {
++static const struct mdio_device_id __maybe_unused qca83xx_tbl[] = {
+ 	{ PHY_ID_MATCH_EXACT(QCA8337_PHY_ID) },
+ 	{ PHY_ID_MATCH_EXACT(QCA8327_A_PHY_ID) },
+ 	{ PHY_ID_MATCH_EXACT(QCA8327_B_PHY_ID) },
+--- a/drivers/net/phy/qsemi.c
++++ b/drivers/net/phy/qsemi.c
+@@ -155,7 +155,7 @@ static struct phy_driver qs6612_driver[]
+ 
+ module_phy_driver(qs6612_driver);
+ 
+-static struct mdio_device_id __maybe_unused qs6612_tbl[] = {
++static const struct mdio_device_id __maybe_unused qs6612_tbl[] = {
+ 	{ 0x00181440, 0xfffffff0 },
+ 	{ }
+ };
+--- a/drivers/net/phy/rockchip.c
++++ b/drivers/net/phy/rockchip.c
+@@ -188,7 +188,7 @@ static struct phy_driver rockchip_phy_dr
+ 
+ module_phy_driver(rockchip_phy_driver);
+ 
+-static struct mdio_device_id __maybe_unused rockchip_phy_tbl[] = {
++static const struct mdio_device_id __maybe_unused rockchip_phy_tbl[] = {
+ 	{ INTERNAL_EPHY_ID, 0xfffffff0 },
+ 	{ }
+ };
+--- a/drivers/net/phy/smsc.c
++++ b/drivers/net/phy/smsc.c
+@@ -837,7 +837,7 @@ MODULE_DESCRIPTION("SMSC PHY driver");
+ MODULE_AUTHOR("Herbert Valerio Riedel");
+ MODULE_LICENSE("GPL");
+ 
+-static struct mdio_device_id __maybe_unused smsc_tbl[] = {
++static const struct mdio_device_id __maybe_unused smsc_tbl[] = {
+ 	{ 0x0007c0a0, 0xfffffff0 },
+ 	{ 0x0007c0b0, 0xfffffff0 },
+ 	{ 0x0007c0c0, 0xfffffff0 },
+--- a/drivers/net/phy/ste10Xp.c
++++ b/drivers/net/phy/ste10Xp.c
+@@ -124,7 +124,7 @@ static struct phy_driver ste10xp_pdriver
+ 
+ module_phy_driver(ste10xp_pdriver);
+ 
+-static struct mdio_device_id __maybe_unused ste10Xp_tbl[] = {
++static const struct mdio_device_id __maybe_unused ste10Xp_tbl[] = {
+ 	{ STE101P_PHY_ID, 0xfffffff0 },
+ 	{ STE100P_PHY_ID, 0xffffffff },
+ 	{ }
+--- a/drivers/net/phy/teranetics.c
++++ b/drivers/net/phy/teranetics.c
+@@ -87,7 +87,7 @@ static struct phy_driver teranetics_driv
+ 
+ module_phy_driver(teranetics_driver);
+ 
+-static struct mdio_device_id __maybe_unused teranetics_tbl[] = {
++static const struct mdio_device_id __maybe_unused teranetics_tbl[] = {
+ 	{ PHY_ID_TN2020, 0xffffffff },
+ 	{ }
+ };
+--- a/drivers/net/phy/uPD60620.c
++++ b/drivers/net/phy/uPD60620.c
+@@ -90,7 +90,7 @@ static struct phy_driver upd60620_driver
+ 
+ module_phy_driver(upd60620_driver);
+ 
+-static struct mdio_device_id __maybe_unused upd60620_tbl[] = {
++static const struct mdio_device_id __maybe_unused upd60620_tbl[] = {
+ 	{ UPD60620_PHY_ID, 0xfffffffe },
+ 	{ }
+ };
+--- a/drivers/net/phy/vitesse.c
++++ b/drivers/net/phy/vitesse.c
+@@ -674,7 +674,7 @@ static struct phy_driver vsc82xx_driver[
+ 
+ module_phy_driver(vsc82xx_driver);
+ 
+-static struct mdio_device_id __maybe_unused vitesse_tbl[] = {
++static const struct mdio_device_id __maybe_unused vitesse_tbl[] = {
+ 	{ PHY_ID_VSC8234, 0x000ffff0 },
+ 	{ PHY_ID_VSC8244, 0x000fffc0 },
+ 	{ PHY_ID_VSC8572, 0x000ffff0 },
diff --git a/target/linux/generic/backport-6.12/729-v6.15-net-phy-mediatek-Change-to-more-meaningful-macros.patch b/target/linux/generic/backport-6.12/729-v6.15-net-phy-mediatek-Change-to-more-meaningful-macros.patch
new file mode 100644
index 0000000000..545e92987f
--- /dev/null
+++ b/target/linux/generic/backport-6.12/729-v6.15-net-phy-mediatek-Change-to-more-meaningful-macros.patch
@@ -0,0 +1,146 @@
+From 7e06c3dbfa5f1e39eba92eb79d854fab2a7ad5fe Mon Sep 17 00:00:00 2001
+From: Sky Huang <skylake.huang@mediatek.com>
+Date: Thu, 13 Feb 2025 16:05:49 +0800
+Subject: [PATCH 10/20] net: phy: mediatek: Change to more meaningful macros
+
+Replace magic number with more meaningful macros in mtk-ge.c.
+Also, move some common macros into mtk-phy-lib.c.
+
+Signed-off-by: Sky Huang <skylake.huang@mediatek.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/20250213080553.921434-2-SkyLake.Huang@mediatek.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mediatek/mtk-ge-soc.c |  1 -
+ drivers/net/phy/mediatek/mtk-ge.c     | 71 +++++++++++++++++++++------
+ drivers/net/phy/mediatek/mtk.h        |  2 +
+ 3 files changed, 57 insertions(+), 17 deletions(-)
+
+--- a/drivers/net/phy/mediatek/mtk-ge-soc.c
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -24,7 +24,6 @@
+ #define MTK_PHY_SMI_DET_ON_THRESH_MASK		GENMASK(13, 8)
+ 
+ #define MTK_PHY_PAGE_EXTENDED_2A30		0x2a30
+-#define MTK_PHY_PAGE_EXTENDED_52B5		0x52b5
+ 
+ #define ANALOG_INTERNAL_OPERATION_MAX_US	20
+ #define TXRESERVE_MIN				0
+--- a/drivers/net/phy/mediatek/mtk-ge.c
++++ b/drivers/net/phy/mediatek/mtk-ge.c
+@@ -8,18 +8,38 @@
+ #define MTK_GPHY_ID_MT7530		0x03a29412
+ #define MTK_GPHY_ID_MT7531		0x03a29441
+ 
+-#define MTK_EXT_PAGE_ACCESS		0x1f
+-#define MTK_PHY_PAGE_STANDARD		0x0000
+-#define MTK_PHY_PAGE_EXTENDED		0x0001
+-#define MTK_PHY_PAGE_EXTENDED_2		0x0002
+-#define MTK_PHY_PAGE_EXTENDED_3		0x0003
+-#define MTK_PHY_PAGE_EXTENDED_2A30	0x2a30
+-#define MTK_PHY_PAGE_EXTENDED_52B5	0x52b5
++#define MTK_PHY_PAGE_EXTENDED_1			0x0001
++#define MTK_PHY_AUX_CTRL_AND_STATUS		0x14
++#define   MTK_PHY_ENABLE_DOWNSHIFT		BIT(4)
++
++#define MTK_PHY_PAGE_EXTENDED_2			0x0002
++#define MTK_PHY_PAGE_EXTENDED_3			0x0003
++#define MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG11	0x11
++
++#define MTK_PHY_PAGE_EXTENDED_2A30		0x2a30
++
++/* Registers on MDIO_MMD_VEND1 */
++#define MTK_PHY_GBE_MODE_TX_DELAY_SEL		0x13
++#define MTK_PHY_TEST_MODE_TX_DELAY_SEL		0x14
++#define   MTK_TX_DELAY_PAIR_B_MASK		GENMASK(10, 8)
++#define   MTK_TX_DELAY_PAIR_D_MASK		GENMASK(2, 0)
++
++#define MTK_PHY_MCC_CTRL_AND_TX_POWER_CTRL	0xa6
++#define   MTK_MCC_NEARECHO_OFFSET_MASK		GENMASK(15, 8)
++
++#define MTK_PHY_RXADC_CTRL_RG7			0xc6
++#define   MTK_PHY_DA_AD_BUF_BIAS_LP_MASK	GENMASK(9, 8)
++
++#define MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG123	0x123
++#define   MTK_PHY_LPI_NORM_MSE_LO_THRESH100_MASK	GENMASK(15, 8)
++#define   MTK_PHY_LPI_NORM_MSE_HI_THRESH100_MASK	GENMASK(7, 0)
+ 
+ static void mtk_gephy_config_init(struct phy_device *phydev)
+ {
+ 	/* Enable HW auto downshift */
+-	phy_modify_paged(phydev, MTK_PHY_PAGE_EXTENDED, 0x14, 0, BIT(4));
++	phy_modify_paged(phydev, MTK_PHY_PAGE_EXTENDED_1,
++			 MTK_PHY_AUX_CTRL_AND_STATUS,
++			 0, MTK_PHY_ENABLE_DOWNSHIFT);
+ 
+ 	/* Increase SlvDPSready time */
+ 	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+@@ -29,10 +49,20 @@ static void mtk_gephy_config_init(struct
+ 	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+ 
+ 	/* Adjust 100_mse_threshold */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x123, 0xffff);
+-
+-	/* Disable mcc */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0xa6, 0x300);
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
++		       MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG123,
++		       MTK_PHY_LPI_NORM_MSE_LO_THRESH100_MASK |
++		       MTK_PHY_LPI_NORM_MSE_HI_THRESH100_MASK,
++		       FIELD_PREP(MTK_PHY_LPI_NORM_MSE_LO_THRESH100_MASK,
++				  0xff) |
++		       FIELD_PREP(MTK_PHY_LPI_NORM_MSE_HI_THRESH100_MASK,
++				  0xff));
++
++	/* If echo time is narrower than 0x3, it will be regarded as noise */
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
++		       MTK_PHY_MCC_CTRL_AND_TX_POWER_CTRL,
++		       MTK_MCC_NEARECHO_OFFSET_MASK,
++		       FIELD_PREP(MTK_MCC_NEARECHO_OFFSET_MASK, 0x3));
+ }
+ 
+ static int mt7530_phy_config_init(struct phy_device *phydev)
+@@ -40,7 +70,8 @@ static int mt7530_phy_config_init(struct
+ 	mtk_gephy_config_init(phydev);
+ 
+ 	/* Increase post_update_timer */
+-	phy_write_paged(phydev, MTK_PHY_PAGE_EXTENDED_3, 0x11, 0x4b);
++	phy_write_paged(phydev, MTK_PHY_PAGE_EXTENDED_3,
++			MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG11, 0x4b);
+ 
+ 	return 0;
+ }
+@@ -51,11 +82,19 @@ static int mt7531_phy_config_init(struct
+ 
+ 	/* PHY link down power saving enable */
+ 	phy_set_bits(phydev, 0x17, BIT(4));
+-	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, 0xc6, 0x300);
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RXADC_CTRL_RG7,
++		       MTK_PHY_DA_AD_BUF_BIAS_LP_MASK,
++		       FIELD_PREP(MTK_PHY_DA_AD_BUF_BIAS_LP_MASK, 0x3));
+ 
+ 	/* Set TX Pair delay selection */
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x13, 0x404);
+-	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x14, 0x404);
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_GBE_MODE_TX_DELAY_SEL,
++		       MTK_TX_DELAY_PAIR_B_MASK | MTK_TX_DELAY_PAIR_D_MASK,
++		       FIELD_PREP(MTK_TX_DELAY_PAIR_B_MASK, 0x4) |
++		       FIELD_PREP(MTK_TX_DELAY_PAIR_D_MASK, 0x4));
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_TEST_MODE_TX_DELAY_SEL,
++		       MTK_TX_DELAY_PAIR_B_MASK | MTK_TX_DELAY_PAIR_D_MASK,
++		       FIELD_PREP(MTK_TX_DELAY_PAIR_B_MASK, 0x4) |
++		       FIELD_PREP(MTK_TX_DELAY_PAIR_D_MASK, 0x4));
+ 
+ 	return 0;
+ }
+--- a/drivers/net/phy/mediatek/mtk.h
++++ b/drivers/net/phy/mediatek/mtk.h
+@@ -9,6 +9,8 @@
+ #define _MTK_EPHY_H_
+ 
+ #define MTK_EXT_PAGE_ACCESS			0x1f
++#define MTK_PHY_PAGE_STANDARD			0x0000
++#define MTK_PHY_PAGE_EXTENDED_52B5		0x52b5
+ 
+ /* Registers on MDIO_MMD_VEND2 */
+ #define MTK_PHY_LED0_ON_CTRL			0x24
diff --git a/target/linux/generic/backport-6.12/730-v6.15-net-phy-mediatek-Add-token-ring-access-helper-functi.patch b/target/linux/generic/backport-6.12/730-v6.15-net-phy-mediatek-Add-token-ring-access-helper-functi.patch
new file mode 100644
index 0000000000..40ce29fc51
--- /dev/null
+++ b/target/linux/generic/backport-6.12/730-v6.15-net-phy-mediatek-Add-token-ring-access-helper-functi.patch
@@ -0,0 +1,448 @@
+From 6e7370079669b0d55c9464bb7c3fb8fb7368b912 Mon Sep 17 00:00:00 2001
+From: Sky Huang <skylake.huang@mediatek.com>
+Date: Thu, 13 Feb 2025 16:05:50 +0800
+Subject: [PATCH 11/20] net: phy: mediatek: Add token ring access helper
+ functions in mtk-phy-lib
+
+This patch adds TR(token ring) manipulations and adds correct
+macro names for those magic numbers. TR is a way to access
+proprietary registers on page 52b5. Use these helper functions
+so we can see which fields we're going to modify/set/clear.
+
+TR functions with __* prefix mean that the operations inside
+aren't wrapped by page select/restore functions.
+
+This patch doesn't really change registers' settings but just
+enhances readability and maintainability.
+
+Signed-off-by: Sky Huang <skylake.huang@mediatek.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/20250213080553.921434-3-SkyLake.Huang@mediatek.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mediatek/mtk-ge-soc.c  | 231 +++++++++++++++++--------
+ drivers/net/phy/mediatek/mtk-ge.c      |  11 +-
+ drivers/net/phy/mediatek/mtk-phy-lib.c |  63 +++++++
+ drivers/net/phy/mediatek/mtk.h         |   5 +
+ 4 files changed, 230 insertions(+), 80 deletions(-)
+
+--- a/drivers/net/phy/mediatek/mtk-ge-soc.c
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -25,6 +25,90 @@
+ 
+ #define MTK_PHY_PAGE_EXTENDED_2A30		0x2a30
+ 
++/* Registers on Token Ring debug nodes */
++/* ch_addr = 0x0, node_addr = 0x7, data_addr = 0x15 */
++/* NormMseLoThresh */
++#define NORMAL_MSE_LO_THRESH_MASK		GENMASK(15, 8)
++
++/* ch_addr = 0x0, node_addr = 0xf, data_addr = 0x3c */
++/* RemAckCntLimitCtrl */
++#define REMOTE_ACK_COUNT_LIMIT_CTRL_MASK	GENMASK(2, 1)
++
++/* ch_addr = 0x1, node_addr = 0xd, data_addr = 0x20 */
++/* VcoSlicerThreshBitsHigh */
++#define VCO_SLICER_THRESH_HIGH_MASK		GENMASK(23, 0)
++
++/* ch_addr = 0x1, node_addr = 0xf, data_addr = 0x0 */
++/* DfeTailEnableVgaThresh1000 */
++#define DFE_TAIL_EANBLE_VGA_TRHESH_1000		GENMASK(5, 1)
++
++/* ch_addr = 0x1, node_addr = 0xf, data_addr = 0x1 */
++/* MrvlTrFix100Kp */
++#define MRVL_TR_FIX_100KP_MASK			GENMASK(22, 20)
++/* MrvlTrFix100Kf */
++#define MRVL_TR_FIX_100KF_MASK			GENMASK(19, 17)
++/* MrvlTrFix1000Kp */
++#define MRVL_TR_FIX_1000KP_MASK			GENMASK(16, 14)
++/* MrvlTrFix1000Kf */
++#define MRVL_TR_FIX_1000KF_MASK			GENMASK(13, 11)
++
++/* ch_addr = 0x1, node_addr = 0xf, data_addr = 0x12 */
++/* VgaDecRate */
++#define VGA_DECIMATION_RATE_MASK		GENMASK(8, 5)
++
++/* ch_addr = 0x1, node_addr = 0xf, data_addr = 0x17 */
++/* SlvDSPreadyTime */
++#define SLAVE_DSP_READY_TIME_MASK		GENMASK(22, 15)
++/* MasDSPreadyTime */
++#define MASTER_DSP_READY_TIME_MASK		GENMASK(14, 7)
++
++/* ch_addr = 0x1, node_addr = 0xf, data_addr = 0x20 */
++/* ResetSyncOffset */
++#define RESET_SYNC_OFFSET_MASK			GENMASK(11, 8)
++
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0x0 */
++/* FfeUpdGainForceVal */
++#define FFE_UPDATE_GAIN_FORCE_VAL_MASK		GENMASK(9, 7)
++/* FfeUpdGainForce */
++#define FFE_UPDATE_GAIN_FORCE			BIT(6)
++
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0x6 */
++/* SS: Steady-state, KP: Proportional Gain */
++/* SSTrKp100 */
++#define SS_TR_KP100_MASK			GENMASK(21, 19)
++/* SSTrKf100 */
++#define SS_TR_KF100_MASK			GENMASK(18, 16)
++/* SSTrKp1000Mas */
++#define SS_TR_KP1000_MASTER_MASK		GENMASK(15, 13)
++/* SSTrKf1000Mas */
++#define SS_TR_KF1000_MASTER_MASK		GENMASK(12, 10)
++/* SSTrKp1000Slv */
++#define SS_TR_KP1000_SLAVE_MASK			GENMASK(9, 7)
++/* SSTrKf1000Slv */
++#define SS_TR_KF1000_SLAVE_MASK			GENMASK(6, 4)
++
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0xd */
++/* RegEEE_st2TrKf1000 */
++#define EEE1000_STAGE2_TR_KF_MASK		GENMASK(13, 11)
++
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0xf */
++/* RegEEE_slv_waketr_timer_tar */
++#define SLAVE_WAKETR_TIMER_MASK			GENMASK(20, 11)
++/* RegEEE_slv_remtx_timer_tar */
++#define SLAVE_REMTX_TIMER_MASK			GENMASK(10, 1)
++
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0x10 */
++/* RegEEE_slv_wake_int_timer_tar */
++#define SLAVE_WAKEINT_TIMER_MASK		GENMASK(10, 1)
++
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0x14 */
++/* RegEEE_trfreeze_timer2 */
++#define TR_FREEZE_TIMER2_MASK			GENMASK(9, 0)
++
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0x1c */
++/* RegEEE100Stg1_tar */
++#define EEE100_LPSYNC_STAGE1_UPDATE_TIMER_MASK	GENMASK(8, 0)
++
+ #define ANALOG_INTERNAL_OPERATION_MAX_US	20
+ #define TXRESERVE_MIN				0
+ #define TXRESERVE_MAX				7
+@@ -700,40 +784,41 @@ restore:
+ static void mt798x_phy_common_finetune(struct phy_device *phydev)
+ {
+ 	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	/* SlvDSPreadyTime = 24, MasDSPreadyTime = 24 */
+-	__phy_write(phydev, 0x11, 0xc71);
+-	__phy_write(phydev, 0x12, 0xc);
+-	__phy_write(phydev, 0x10, 0x8fae);
++	__mtk_tr_modify(phydev, 0x1, 0xf, 0x17,
++			SLAVE_DSP_READY_TIME_MASK | MASTER_DSP_READY_TIME_MASK,
++			FIELD_PREP(SLAVE_DSP_READY_TIME_MASK, 0x18) |
++			FIELD_PREP(MASTER_DSP_READY_TIME_MASK, 0x18));
+ 
+ 	/* EnabRandUpdTrig = 1 */
+ 	__phy_write(phydev, 0x11, 0x2f00);
+ 	__phy_write(phydev, 0x12, 0xe);
+ 	__phy_write(phydev, 0x10, 0x8fb0);
+ 
+-	/* NormMseLoThresh = 85 */
+-	__phy_write(phydev, 0x11, 0x55a0);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x83aa);
+-
+-	/* FfeUpdGainForce = 1(Enable), FfeUpdGainForceVal = 4 */
+-	__phy_write(phydev, 0x11, 0x240);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x9680);
++	__mtk_tr_modify(phydev, 0x0, 0x7, 0x15,
++			NORMAL_MSE_LO_THRESH_MASK,
++			FIELD_PREP(NORMAL_MSE_LO_THRESH_MASK, 0x55));
++
++	__mtk_tr_modify(phydev, 0x2, 0xd, 0x0,
++			FFE_UPDATE_GAIN_FORCE_VAL_MASK,
++			FIELD_PREP(FFE_UPDATE_GAIN_FORCE_VAL_MASK, 0x4) |
++				   FFE_UPDATE_GAIN_FORCE);
+ 
+ 	/* TrFreeze = 0 (mt7988 default) */
+ 	__phy_write(phydev, 0x11, 0x0);
+ 	__phy_write(phydev, 0x12, 0x0);
+ 	__phy_write(phydev, 0x10, 0x9686);
+ 
+-	/* SSTrKp100 = 5 */
+-	/* SSTrKf100 = 6 */
+-	/* SSTrKp1000Mas = 5 */
+-	/* SSTrKf1000Mas = 6 */
+-	/* SSTrKp1000Slv = 5 */
+-	/* SSTrKf1000Slv = 6 */
+-	__phy_write(phydev, 0x11, 0xbaef);
+-	__phy_write(phydev, 0x12, 0x2e);
+-	__phy_write(phydev, 0x10, 0x968c);
++	__mtk_tr_modify(phydev, 0x2, 0xd, 0x6,
++			SS_TR_KP100_MASK | SS_TR_KF100_MASK |
++			SS_TR_KP1000_MASTER_MASK | SS_TR_KF1000_MASTER_MASK |
++			SS_TR_KP1000_SLAVE_MASK | SS_TR_KF1000_SLAVE_MASK,
++			FIELD_PREP(SS_TR_KP100_MASK, 0x5) |
++			FIELD_PREP(SS_TR_KF100_MASK, 0x6) |
++			FIELD_PREP(SS_TR_KP1000_MASTER_MASK, 0x5) |
++			FIELD_PREP(SS_TR_KF1000_MASTER_MASK, 0x6) |
++			FIELD_PREP(SS_TR_KP1000_SLAVE_MASK, 0x5) |
++			FIELD_PREP(SS_TR_KF1000_SLAVE_MASK, 0x6));
++
+ 	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+ }
+ 
+@@ -756,27 +841,29 @@ static void mt7981_phy_finetune(struct p
+ 	}
+ 
+ 	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	/* ResetSyncOffset = 6 */
+-	__phy_write(phydev, 0x11, 0x600);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x8fc0);
+-
+-	/* VgaDecRate = 1 */
+-	__phy_write(phydev, 0x11, 0x4c2a);
+-	__phy_write(phydev, 0x12, 0x3e);
+-	__phy_write(phydev, 0x10, 0x8fa4);
++	__mtk_tr_modify(phydev, 0x1, 0xf, 0x20,
++			RESET_SYNC_OFFSET_MASK,
++			FIELD_PREP(RESET_SYNC_OFFSET_MASK, 0x6));
++
++	__mtk_tr_modify(phydev, 0x1, 0xf, 0x12,
++			VGA_DECIMATION_RATE_MASK,
++			FIELD_PREP(VGA_DECIMATION_RATE_MASK, 0x1));
+ 
+ 	/* MrvlTrFix100Kp = 3, MrvlTrFix100Kf = 2,
+ 	 * MrvlTrFix1000Kp = 3, MrvlTrFix1000Kf = 2
+ 	 */
+-	__phy_write(phydev, 0x11, 0xd10a);
+-	__phy_write(phydev, 0x12, 0x34);
+-	__phy_write(phydev, 0x10, 0x8f82);
++	__mtk_tr_modify(phydev, 0x1, 0xf, 0x1,
++			MRVL_TR_FIX_100KP_MASK | MRVL_TR_FIX_100KF_MASK |
++			MRVL_TR_FIX_1000KP_MASK | MRVL_TR_FIX_1000KF_MASK,
++			FIELD_PREP(MRVL_TR_FIX_100KP_MASK, 0x3) |
++			FIELD_PREP(MRVL_TR_FIX_100KF_MASK, 0x2) |
++			FIELD_PREP(MRVL_TR_FIX_1000KP_MASK, 0x3) |
++			FIELD_PREP(MRVL_TR_FIX_1000KF_MASK, 0x2));
+ 
+ 	/* VcoSlicerThreshBitsHigh */
+-	__phy_write(phydev, 0x11, 0x5555);
+-	__phy_write(phydev, 0x12, 0x55);
+-	__phy_write(phydev, 0x10, 0x8ec0);
++	__mtk_tr_modify(phydev, 0x1, 0xd, 0x20,
++			VCO_SLICER_THRESH_HIGH_MASK,
++			FIELD_PREP(VCO_SLICER_THRESH_HIGH_MASK, 0x555555));
+ 	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+ 
+ 	/* TR_OPEN_LOOP_EN = 1, lpf_x_average = 9 */
+@@ -828,25 +915,23 @@ static void mt7988_phy_finetune(struct p
+ 	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_RG_TX_FILTER, 0x5);
+ 
+ 	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	/* ResetSyncOffset = 5 */
+-	__phy_write(phydev, 0x11, 0x500);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x8fc0);
++	__mtk_tr_modify(phydev, 0x1, 0xf, 0x20,
++			RESET_SYNC_OFFSET_MASK,
++			FIELD_PREP(RESET_SYNC_OFFSET_MASK, 0x5));
+ 
+ 	/* VgaDecRate is 1 at default on mt7988 */
+ 
+-	/* MrvlTrFix100Kp = 6, MrvlTrFix100Kf = 7,
+-	 * MrvlTrFix1000Kp = 6, MrvlTrFix1000Kf = 7
+-	 */
+-	__phy_write(phydev, 0x11, 0xb90a);
+-	__phy_write(phydev, 0x12, 0x6f);
+-	__phy_write(phydev, 0x10, 0x8f82);
+-
+-	/* RemAckCntLimitCtrl = 1 */
+-	__phy_write(phydev, 0x11, 0xfbba);
+-	__phy_write(phydev, 0x12, 0xc3);
+-	__phy_write(phydev, 0x10, 0x87f8);
+-
++	__mtk_tr_modify(phydev, 0x1, 0xf, 0x1,
++			MRVL_TR_FIX_100KP_MASK | MRVL_TR_FIX_100KF_MASK |
++			MRVL_TR_FIX_1000KP_MASK | MRVL_TR_FIX_1000KF_MASK,
++			FIELD_PREP(MRVL_TR_FIX_100KP_MASK, 0x6) |
++			FIELD_PREP(MRVL_TR_FIX_100KF_MASK, 0x7) |
++			FIELD_PREP(MRVL_TR_FIX_1000KP_MASK, 0x6) |
++			FIELD_PREP(MRVL_TR_FIX_1000KF_MASK, 0x7));
++
++	__mtk_tr_modify(phydev, 0x0, 0xf, 0x3c,
++			REMOTE_ACK_COUNT_LIMIT_CTRL_MASK,
++			FIELD_PREP(REMOTE_ACK_COUNT_LIMIT_CTRL_MASK, 0x1));
+ 	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+ 
+ 	/* TR_OPEN_LOOP_EN = 1, lpf_x_average = 10 */
+@@ -927,40 +1012,36 @@ static void mt798x_phy_eee(struct phy_de
+ 	__phy_write(phydev, 0x12, 0x0);
+ 	__phy_write(phydev, 0x10, 0x9690);
+ 
+-	/* REG_EEE_st2TrKf1000 = 2 */
+-	__phy_write(phydev, 0x11, 0x114f);
+-	__phy_write(phydev, 0x12, 0x2);
+-	__phy_write(phydev, 0x10, 0x969a);
+-
+-	/* RegEEE_slv_wake_tr_timer_tar = 6, RegEEE_slv_remtx_timer_tar = 20 */
+-	__phy_write(phydev, 0x11, 0x3028);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x969e);
+-
+-	/* RegEEE_slv_wake_int_timer_tar = 8 */
+-	__phy_write(phydev, 0x11, 0x5010);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x96a0);
+-
+-	/* RegEEE_trfreeze_timer2 = 586 */
+-	__phy_write(phydev, 0x11, 0x24a);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x96a8);
+-
+-	/* RegEEE100Stg1_tar = 16 */
+-	__phy_write(phydev, 0x11, 0x3210);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x96b8);
++	__mtk_tr_modify(phydev, 0x2, 0xd, 0xd,
++			EEE1000_STAGE2_TR_KF_MASK,
++			FIELD_PREP(EEE1000_STAGE2_TR_KF_MASK, 0x2));
++
++	__mtk_tr_modify(phydev, 0x2, 0xd, 0xf,
++			SLAVE_WAKETR_TIMER_MASK | SLAVE_REMTX_TIMER_MASK,
++			FIELD_PREP(SLAVE_WAKETR_TIMER_MASK, 0x6) |
++			FIELD_PREP(SLAVE_REMTX_TIMER_MASK, 0x14));
++
++	__mtk_tr_modify(phydev, 0x2, 0xd, 0x10,
++			SLAVE_WAKEINT_TIMER_MASK,
++			FIELD_PREP(SLAVE_WAKEINT_TIMER_MASK, 0x8));
++
++	__mtk_tr_modify(phydev, 0x2, 0xd, 0x14,
++			TR_FREEZE_TIMER2_MASK,
++			FIELD_PREP(TR_FREEZE_TIMER2_MASK, 0x24a));
++
++	__mtk_tr_modify(phydev, 0x2, 0xd, 0x1c,
++			EEE100_LPSYNC_STAGE1_UPDATE_TIMER_MASK,
++			FIELD_PREP(EEE100_LPSYNC_STAGE1_UPDATE_TIMER_MASK,
++				   0x10));
+ 
+ 	/* REGEEE_wake_slv_tr_wait_dfesigdet_en = 0 */
+ 	__phy_write(phydev, 0x11, 0x1463);
+ 	__phy_write(phydev, 0x12, 0x0);
+ 	__phy_write(phydev, 0x10, 0x96ca);
+ 
+-	/* DfeTailEnableVgaThresh1000 = 27 */
+-	__phy_write(phydev, 0x11, 0x36);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x8f80);
++	__mtk_tr_modify(phydev, 0x1, 0xf, 0x0,
++			DFE_TAIL_EANBLE_VGA_TRHESH_1000,
++			FIELD_PREP(DFE_TAIL_EANBLE_VGA_TRHESH_1000, 0x1b));
+ 	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
+ 
+ 	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_3);
+--- a/drivers/net/phy/mediatek/mtk-ge.c
++++ b/drivers/net/phy/mediatek/mtk-ge.c
+@@ -18,6 +18,10 @@
+ 
+ #define MTK_PHY_PAGE_EXTENDED_2A30		0x2a30
+ 
++/* Registers on Token Ring debug nodes */
++/* ch_addr = 0x1, node_addr = 0xf, data_addr = 0x17 */
++#define SLAVE_DSP_READY_TIME_MASK		GENMASK(22, 15)
++
+ /* Registers on MDIO_MMD_VEND1 */
+ #define MTK_PHY_GBE_MODE_TX_DELAY_SEL		0x13
+ #define MTK_PHY_TEST_MODE_TX_DELAY_SEL		0x14
+@@ -42,11 +46,8 @@ static void mtk_gephy_config_init(struct
+ 			 0, MTK_PHY_ENABLE_DOWNSHIFT);
+ 
+ 	/* Increase SlvDPSready time */
+-	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	__phy_write(phydev, 0x10, 0xafae);
+-	__phy_write(phydev, 0x12, 0x2f);
+-	__phy_write(phydev, 0x10, 0x8fae);
+-	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
++	mtk_tr_modify(phydev, 0x1, 0xf, 0x17, SLAVE_DSP_READY_TIME_MASK,
++		      FIELD_PREP(SLAVE_DSP_READY_TIME_MASK, 0x5e));
+ 
+ 	/* Adjust 100_mse_threshold */
+ 	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
+--- a/drivers/net/phy/mediatek/mtk-phy-lib.c
++++ b/drivers/net/phy/mediatek/mtk-phy-lib.c
+@@ -6,6 +6,69 @@
+ 
+ #include "mtk.h"
+ 
++/* Difference between functions with mtk_tr* and __mtk_tr* prefixes is
++ * mtk_tr* functions: wrapped by page switching operations
++ * __mtk_tr* functions: no page switching operations
++ */
++
++static void __mtk_tr_access(struct phy_device *phydev, bool read, u8 ch_addr,
++			    u8 node_addr, u8 data_addr)
++{
++	u16 tr_cmd = BIT(15); /* bit 14 & 0 are reserved */
++
++	if (read)
++		tr_cmd |= BIT(13);
++
++	tr_cmd |= (((ch_addr & 0x3) << 11) |
++		   ((node_addr & 0xf) << 7) |
++		   ((data_addr & 0x3f) << 1));
++	dev_dbg(&phydev->mdio.dev, "tr_cmd: 0x%x\n", tr_cmd);
++	__phy_write(phydev, 0x10, tr_cmd);
++}
++
++static void __mtk_tr_read(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++			  u8 data_addr, u16 *tr_high, u16 *tr_low)
++{
++	__mtk_tr_access(phydev, true, ch_addr, node_addr, data_addr);
++	*tr_low = __phy_read(phydev, 0x11);
++	*tr_high = __phy_read(phydev, 0x12);
++	dev_dbg(&phydev->mdio.dev, "tr_high read: 0x%x, tr_low read: 0x%x\n",
++		*tr_high, *tr_low);
++}
++
++static void __mtk_tr_write(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++			   u8 data_addr, u32 tr_data)
++{
++	__phy_write(phydev, 0x11, tr_data & 0xffff);
++	__phy_write(phydev, 0x12, tr_data >> 16);
++	dev_dbg(&phydev->mdio.dev, "tr_high write: 0x%x, tr_low write: 0x%x\n",
++		tr_data >> 16, tr_data & 0xffff);
++	__mtk_tr_access(phydev, false, ch_addr, node_addr, data_addr);
++}
++
++void __mtk_tr_modify(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++		     u8 data_addr, u32 mask, u32 set)
++{
++	u32 tr_data;
++	u16 tr_high;
++	u16 tr_low;
++
++	__mtk_tr_read(phydev, ch_addr, node_addr, data_addr, &tr_high, &tr_low);
++	tr_data = (tr_high << 16) | tr_low;
++	tr_data = (tr_data & ~mask) | set;
++	__mtk_tr_write(phydev, ch_addr, node_addr, data_addr, tr_data);
++}
++EXPORT_SYMBOL_GPL(__mtk_tr_modify);
++
++void mtk_tr_modify(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++		   u8 data_addr, u32 mask, u32 set)
++{
++	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
++	__mtk_tr_modify(phydev, ch_addr, node_addr, data_addr, mask, set);
++	phy_restore_page(phydev, MTK_PHY_PAGE_STANDARD, 0);
++}
++EXPORT_SYMBOL_GPL(mtk_tr_modify);
++
+ int mtk_phy_read_page(struct phy_device *phydev)
+ {
+ 	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
+--- a/drivers/net/phy/mediatek/mtk.h
++++ b/drivers/net/phy/mediatek/mtk.h
+@@ -68,6 +68,11 @@ struct mtk_socphy_priv {
+ 	unsigned long		led_state;
+ };
+ 
++void __mtk_tr_modify(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++		     u8 data_addr, u32 mask, u32 set);
++void mtk_tr_modify(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++		   u8 data_addr, u32 mask, u32 set);
++
+ int mtk_phy_read_page(struct phy_device *phydev);
+ int mtk_phy_write_page(struct phy_device *phydev, int page);
+ 
diff --git a/target/linux/generic/backport-6.12/731-v6.15-net-phy-mediatek-Add-token-ring-set-bit-operation-su.patch b/target/linux/generic/backport-6.12/731-v6.15-net-phy-mediatek-Add-token-ring-set-bit-operation-su.patch
new file mode 100644
index 0000000000..972a9c0a7e
--- /dev/null
+++ b/target/linux/generic/backport-6.12/731-v6.15-net-phy-mediatek-Add-token-ring-set-bit-operation-su.patch
@@ -0,0 +1,73 @@
+From c7e2fb3421ef5ebbb4c91f44bd735ab10edd755a Mon Sep 17 00:00:00 2001
+From: Sky Huang <skylake.huang@mediatek.com>
+Date: Thu, 13 Feb 2025 16:05:51 +0800
+Subject: [PATCH 12/20] net: phy: mediatek: Add token ring set bit operation
+ support
+
+Previously in mtk-ge-soc.c, we set some register bits via token
+ring, which were implemented in three __phy_write().
+Now we can do the same thing via __mtk_tr_set_bits() helper.
+
+Signed-off-by: Sky Huang <skylake.huang@mediatek.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/20250213080553.921434-4-SkyLake.Huang@mediatek.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mediatek/mtk-ge-soc.c  | 10 ++++++----
+ drivers/net/phy/mediatek/mtk-phy-lib.c |  7 +++++++
+ drivers/net/phy/mediatek/mtk.h         |  2 ++
+ 3 files changed, 15 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/phy/mediatek/mtk-ge-soc.c
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -62,6 +62,10 @@
+ /* MasDSPreadyTime */
+ #define MASTER_DSP_READY_TIME_MASK		GENMASK(14, 7)
+ 
++/* ch_addr = 0x1, node_addr = 0xf, data_addr = 0x18 */
++/* EnabRandUpdTrig */
++#define ENABLE_RANDOM_UPDOWN_COUNTER_TRIGGER	BIT(8)
++
+ /* ch_addr = 0x1, node_addr = 0xf, data_addr = 0x20 */
+ /* ResetSyncOffset */
+ #define RESET_SYNC_OFFSET_MASK			GENMASK(11, 8)
+@@ -789,10 +793,8 @@ static void mt798x_phy_common_finetune(s
+ 			FIELD_PREP(SLAVE_DSP_READY_TIME_MASK, 0x18) |
+ 			FIELD_PREP(MASTER_DSP_READY_TIME_MASK, 0x18));
+ 
+-	/* EnabRandUpdTrig = 1 */
+-	__phy_write(phydev, 0x11, 0x2f00);
+-	__phy_write(phydev, 0x12, 0xe);
+-	__phy_write(phydev, 0x10, 0x8fb0);
++	__mtk_tr_set_bits(phydev, 0x1, 0xf, 0x18,
++			  ENABLE_RANDOM_UPDOWN_COUNTER_TRIGGER);
+ 
+ 	__mtk_tr_modify(phydev, 0x0, 0x7, 0x15,
+ 			NORMAL_MSE_LO_THRESH_MASK,
+--- a/drivers/net/phy/mediatek/mtk-phy-lib.c
++++ b/drivers/net/phy/mediatek/mtk-phy-lib.c
+@@ -69,6 +69,13 @@ void mtk_tr_modify(struct phy_device *ph
+ }
+ EXPORT_SYMBOL_GPL(mtk_tr_modify);
+ 
++void __mtk_tr_set_bits(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++		       u8 data_addr, u32 set)
++{
++	__mtk_tr_modify(phydev, ch_addr, node_addr, data_addr, 0, set);
++}
++EXPORT_SYMBOL_GPL(__mtk_tr_set_bits);
++
+ int mtk_phy_read_page(struct phy_device *phydev)
+ {
+ 	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
+--- a/drivers/net/phy/mediatek/mtk.h
++++ b/drivers/net/phy/mediatek/mtk.h
+@@ -72,6 +72,8 @@ void __mtk_tr_modify(struct phy_device *
+ 		     u8 data_addr, u32 mask, u32 set);
+ void mtk_tr_modify(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
+ 		   u8 data_addr, u32 mask, u32 set);
++void __mtk_tr_set_bits(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++		       u8 data_addr, u32 set);
+ 
+ int mtk_phy_read_page(struct phy_device *phydev);
+ int mtk_phy_write_page(struct phy_device *phydev, int page);
diff --git a/target/linux/generic/backport-6.12/732-v6.15-net-phy-mediatek-Add-token-ring-clear-bit-operation-.patch b/target/linux/generic/backport-6.12/732-v6.15-net-phy-mediatek-Add-token-ring-clear-bit-operation-.patch
new file mode 100644
index 0000000000..47d891ea69
--- /dev/null
+++ b/target/linux/generic/backport-6.12/732-v6.15-net-phy-mediatek-Add-token-ring-clear-bit-operation-.patch
@@ -0,0 +1,122 @@
+From 7851c73a416b15aff6f9ada9c88affc5f48ff011 Mon Sep 17 00:00:00 2001
+From: Sky Huang <skylake.huang@mediatek.com>
+Date: Thu, 13 Feb 2025 16:05:52 +0800
+Subject: [PATCH 13/20] net: phy: mediatek: Add token ring clear bit operation
+ support
+
+Similar to __mtk_tr_set_bits() support. Previously in mtk-ge-soc.c,
+we clear some register bits via token ring, which were also implemented
+in three __phy_write(). Now we can do the same thing via
+__mtk_tr_clr_bits() helper.
+
+Signed-off-by: Sky Huang <skylake.huang@mediatek.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/20250213080553.921434-5-SkyLake.Huang@mediatek.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mediatek/mtk-ge-soc.c  | 30 +++++++++++++++-----------
+ drivers/net/phy/mediatek/mtk-phy-lib.c |  7 ++++++
+ drivers/net/phy/mediatek/mtk.h         |  2 ++
+ 3 files changed, 27 insertions(+), 12 deletions(-)
+
+--- a/drivers/net/phy/mediatek/mtk-ge-soc.c
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -76,6 +76,10 @@
+ /* FfeUpdGainForce */
+ #define FFE_UPDATE_GAIN_FORCE			BIT(6)
+ 
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0x3 */
++/* TrFreeze */
++#define TR_FREEZE_MASK				GENMASK(11, 0)
++
+ /* ch_addr = 0x2, node_addr = 0xd, data_addr = 0x6 */
+ /* SS: Steady-state, KP: Proportional Gain */
+ /* SSTrKp100 */
+@@ -91,6 +95,11 @@
+ /* SSTrKf1000Slv */
+ #define SS_TR_KF1000_SLAVE_MASK			GENMASK(6, 4)
+ 
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0x8 */
++/* clear this bit if wanna select from AFE */
++/* Regsigdet_sel_1000 */
++#define EEE1000_SELECT_SIGNAL_DETECTION_FROM_DFE	BIT(4)
++
+ /* ch_addr = 0x2, node_addr = 0xd, data_addr = 0xd */
+ /* RegEEE_st2TrKf1000 */
+ #define EEE1000_STAGE2_TR_KF_MASK		GENMASK(13, 11)
+@@ -113,6 +122,10 @@
+ /* RegEEE100Stg1_tar */
+ #define EEE100_LPSYNC_STAGE1_UPDATE_TIMER_MASK	GENMASK(8, 0)
+ 
++/* ch_addr = 0x2, node_addr = 0xd, data_addr = 0x25 */
++/* REGEEE_wake_slv_tr_wait_dfesigdet_en */
++#define WAKE_SLAVE_TR_WAIT_DFE_DETECTION_EN	BIT(11)
++
+ #define ANALOG_INTERNAL_OPERATION_MAX_US	20
+ #define TXRESERVE_MIN				0
+ #define TXRESERVE_MAX				7
+@@ -805,10 +818,7 @@ static void mt798x_phy_common_finetune(s
+ 			FIELD_PREP(FFE_UPDATE_GAIN_FORCE_VAL_MASK, 0x4) |
+ 				   FFE_UPDATE_GAIN_FORCE);
+ 
+-	/* TrFreeze = 0 (mt7988 default) */
+-	__phy_write(phydev, 0x11, 0x0);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x9686);
++	__mtk_tr_clr_bits(phydev, 0x2, 0xd, 0x3, TR_FREEZE_MASK);
+ 
+ 	__mtk_tr_modify(phydev, 0x2, 0xd, 0x6,
+ 			SS_TR_KP100_MASK | SS_TR_KF100_MASK |
+@@ -1009,10 +1019,8 @@ static void mt798x_phy_eee(struct phy_de
+ 			 MTK_PHY_TR_READY_SKIP_AFE_WAKEUP);
+ 
+ 	phy_select_page(phydev, MTK_PHY_PAGE_EXTENDED_52B5);
+-	/* Regsigdet_sel_1000 = 0 */
+-	__phy_write(phydev, 0x11, 0xb);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x9690);
++	__mtk_tr_clr_bits(phydev, 0x2, 0xd, 0x8,
++			  EEE1000_SELECT_SIGNAL_DETECTION_FROM_DFE);
+ 
+ 	__mtk_tr_modify(phydev, 0x2, 0xd, 0xd,
+ 			EEE1000_STAGE2_TR_KF_MASK,
+@@ -1036,10 +1044,8 @@ static void mt798x_phy_eee(struct phy_de
+ 			FIELD_PREP(EEE100_LPSYNC_STAGE1_UPDATE_TIMER_MASK,
+ 				   0x10));
+ 
+-	/* REGEEE_wake_slv_tr_wait_dfesigdet_en = 0 */
+-	__phy_write(phydev, 0x11, 0x1463);
+-	__phy_write(phydev, 0x12, 0x0);
+-	__phy_write(phydev, 0x10, 0x96ca);
++	__mtk_tr_clr_bits(phydev, 0x2, 0xd, 0x25,
++			  WAKE_SLAVE_TR_WAIT_DFE_DETECTION_EN);
+ 
+ 	__mtk_tr_modify(phydev, 0x1, 0xf, 0x0,
+ 			DFE_TAIL_EANBLE_VGA_TRHESH_1000,
+--- a/drivers/net/phy/mediatek/mtk-phy-lib.c
++++ b/drivers/net/phy/mediatek/mtk-phy-lib.c
+@@ -76,6 +76,13 @@ void __mtk_tr_set_bits(struct phy_device
+ }
+ EXPORT_SYMBOL_GPL(__mtk_tr_set_bits);
+ 
++void __mtk_tr_clr_bits(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++		       u8 data_addr, u32 clr)
++{
++	__mtk_tr_modify(phydev, ch_addr, node_addr, data_addr, clr, 0);
++}
++EXPORT_SYMBOL_GPL(__mtk_tr_clr_bits);
++
+ int mtk_phy_read_page(struct phy_device *phydev)
+ {
+ 	return __phy_read(phydev, MTK_EXT_PAGE_ACCESS);
+--- a/drivers/net/phy/mediatek/mtk.h
++++ b/drivers/net/phy/mediatek/mtk.h
+@@ -74,6 +74,8 @@ void mtk_tr_modify(struct phy_device *ph
+ 		   u8 data_addr, u32 mask, u32 set);
+ void __mtk_tr_set_bits(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
+ 		       u8 data_addr, u32 set);
++void __mtk_tr_clr_bits(struct phy_device *phydev, u8 ch_addr, u8 node_addr,
++		       u8 data_addr, u32 clr);
+ 
+ int mtk_phy_read_page(struct phy_device *phydev);
+ int mtk_phy_write_page(struct phy_device *phydev, int page);
diff --git a/target/linux/generic/backport-6.12/733-v6.15-net-phy-mediatek-Move-some-macros-to-phy-lib-for-lat.patch b/target/linux/generic/backport-6.12/733-v6.15-net-phy-mediatek-Move-some-macros-to-phy-lib-for-lat.patch
new file mode 100644
index 0000000000..858de093a2
--- /dev/null
+++ b/target/linux/generic/backport-6.12/733-v6.15-net-phy-mediatek-Move-some-macros-to-phy-lib-for-lat.patch
@@ -0,0 +1,45 @@
+From bae8c61522c4d5a5250a24dcb57d120ea593fab1 Mon Sep 17 00:00:00 2001
+From: Sky Huang <skylake.huang@mediatek.com>
+Date: Thu, 13 Feb 2025 16:05:53 +0800
+Subject: [PATCH 14/20] net: phy: mediatek: Move some macros to phy-lib for
+ later use
+
+Move some macros to phy-lib because MediaTek's 2.5G built-in
+ethernet PHY will also use them.
+
+Signed-off-by: Sky Huang <skylake.huang@mediatek.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/20250213080553.921434-6-SkyLake.Huang@mediatek.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mediatek/mtk-ge.c | 4 ----
+ drivers/net/phy/mediatek/mtk.h    | 4 ++++
+ 2 files changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/phy/mediatek/mtk-ge.c
++++ b/drivers/net/phy/mediatek/mtk-ge.c
+@@ -8,10 +8,6 @@
+ #define MTK_GPHY_ID_MT7530		0x03a29412
+ #define MTK_GPHY_ID_MT7531		0x03a29441
+ 
+-#define MTK_PHY_PAGE_EXTENDED_1			0x0001
+-#define MTK_PHY_AUX_CTRL_AND_STATUS		0x14
+-#define   MTK_PHY_ENABLE_DOWNSHIFT		BIT(4)
+-
+ #define MTK_PHY_PAGE_EXTENDED_2			0x0002
+ #define MTK_PHY_PAGE_EXTENDED_3			0x0003
+ #define MTK_PHY_RG_LPI_PCS_DSP_CTRL_REG11	0x11
+--- a/drivers/net/phy/mediatek/mtk.h
++++ b/drivers/net/phy/mediatek/mtk.h
+@@ -8,7 +8,11 @@
+ #ifndef _MTK_EPHY_H_
+ #define _MTK_EPHY_H_
+ 
++#define MTK_PHY_AUX_CTRL_AND_STATUS		0x14
++#define   MTK_PHY_ENABLE_DOWNSHIFT		BIT(4)
++
+ #define MTK_EXT_PAGE_ACCESS			0x1f
++#define MTK_PHY_PAGE_EXTENDED_1			0x0001
+ #define MTK_PHY_PAGE_STANDARD			0x0000
+ #define MTK_PHY_PAGE_EXTENDED_52B5		0x52b5
+ 
diff --git a/target/linux/generic/backport-6.12/735-v6.16-net-phy-mediatek-permit-to-compile-test-GE-SOC-PHY-d.patch b/target/linux/generic/backport-6.12/735-v6.16-net-phy-mediatek-permit-to-compile-test-GE-SOC-PHY-d.patch
new file mode 100644
index 0000000000..9778ea158b
--- /dev/null
+++ b/target/linux/generic/backport-6.12/735-v6.16-net-phy-mediatek-permit-to-compile-test-GE-SOC-PHY-d.patch
@@ -0,0 +1,37 @@
+From e5566162af8b9690e096d2e6089e4ed955a0d13d Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Thu, 10 Apr 2025 12:04:03 +0200
+Subject: [PATCH] net: phy: mediatek: permit to compile test GE SOC PHY driver
+
+When commit 462a3daad679 ("net: phy: mediatek: fix compile-test
+dependencies") fixed the dependency, it should have also introduced
+an or on COMPILE_TEST to permit this driver to be compile-tested even if
+NVMEM_MTK_EFUSE wasn't selected. The driver makes use of NVMEM API that
+are always compiled (return error) so the driver can actually be
+compiled even without that config.
+
+Fix and simplify the dependency condition of this kernel config.
+
+Fixes: 462a3daad679 ("net: phy: mediatek: fix compile-test dependencies")
+Acked-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+Acked-by: Arnd Bergmann <arnd@arndb.de>
+Link: https://patch.msgid.link/20250410100410.348-1-ansuelsmth@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mediatek/Kconfig | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+--- a/drivers/net/phy/mediatek/Kconfig
++++ b/drivers/net/phy/mediatek/Kconfig
+@@ -15,8 +15,7 @@ config MEDIATEK_GE_PHY
+ 
+ config MEDIATEK_GE_SOC_PHY
+ 	tristate "MediaTek SoC Ethernet PHYs"
+-	depends on (ARM64 && ARCH_MEDIATEK) || COMPILE_TEST
+-	depends on NVMEM_MTK_EFUSE
++	depends on (ARM64 && ARCH_MEDIATEK && NVMEM_MTK_EFUSE) || COMPILE_TEST
+ 	select MTK_NET_PHYLIB
+ 	help
+ 	  Supports MediaTek SoC built-in Gigabit Ethernet PHYs.
diff --git a/target/linux/generic/backport-6.12/736-v6.16-net-phy-mediatek-add-Airoha-PHY-ID-to-SoC-driver.patch b/target/linux/generic/backport-6.12/736-v6.16-net-phy-mediatek-add-Airoha-PHY-ID-to-SoC-driver.patch
new file mode 100644
index 0000000000..5498ecbd21
--- /dev/null
+++ b/target/linux/generic/backport-6.12/736-v6.16-net-phy-mediatek-add-Airoha-PHY-ID-to-SoC-driver.patch
@@ -0,0 +1,129 @@
+From 4590c8bc10951feee3e439bf7fff1b458c2e6fad Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Thu, 10 Apr 2025 12:04:04 +0200
+Subject: [PATCH 17/20] net: phy: mediatek: add Airoha PHY ID to SoC driver
+
+Airoha AN7581 SoC ship with a Switch based on the MT753x Switch embedded
+in other SoC like the MT7581 and the MT7988. Similar to these they
+require configuring some pin to enable LED PHYs.
+
+Add support for the PHY ID for the Airoha embedded Switch and define a
+simple probe function to toggle these pins. Also fill the LED functions
+and add dedicated function to define LED polarity.
+
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+Link: https://patch.msgid.link/20250410100410.348-2-ansuelsmth@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mediatek/Kconfig      |  4 +-
+ drivers/net/phy/mediatek/mtk-ge-soc.c | 62 +++++++++++++++++++++++++++
+ 2 files changed, 65 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/phy/mediatek/Kconfig
++++ b/drivers/net/phy/mediatek/Kconfig
+@@ -15,7 +15,9 @@ config MEDIATEK_GE_PHY
+ 
+ config MEDIATEK_GE_SOC_PHY
+ 	tristate "MediaTek SoC Ethernet PHYs"
+-	depends on (ARM64 && ARCH_MEDIATEK && NVMEM_MTK_EFUSE) || COMPILE_TEST
++	depends on ARM64 || COMPILE_TEST
++	depends on ARCH_AIROHA || (ARCH_MEDIATEK && NVMEM_MTK_EFUSE) || \
++		   COMPILE_TEST
+ 	select MTK_NET_PHYLIB
+ 	help
+ 	  Supports MediaTek SoC built-in Gigabit Ethernet PHYs.
+--- a/drivers/net/phy/mediatek/mtk-ge-soc.c
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -10,8 +10,11 @@
+ 
+ #include "mtk.h"
+ 
++#define MTK_PHY_MAX_LEDS			2
++
+ #define MTK_GPHY_ID_MT7981			0x03a29461
+ #define MTK_GPHY_ID_MT7988			0x03a29481
++#define MTK_GPHY_ID_AN7581			0x03a294c1
+ 
+ #define MTK_EXT_PAGE_ACCESS			0x1f
+ #define MTK_PHY_PAGE_STANDARD			0x0000
+@@ -1405,6 +1408,53 @@ static int mt7981_phy_probe(struct phy_d
+ 	return mt798x_phy_calibration(phydev);
+ }
+ 
++static int an7581_phy_probe(struct phy_device *phydev)
++{
++	struct mtk_socphy_priv *priv;
++	struct pinctrl *pinctrl;
++
++	/* Toggle pinctrl to enable PHY LED */
++	pinctrl = devm_pinctrl_get_select(&phydev->mdio.dev, "gbe-led");
++	if (IS_ERR(pinctrl))
++		dev_err(&phydev->mdio.bus->dev,
++			"Failed to setup PHY LED pinctrl\n");
++
++	priv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);
++	if (!priv)
++		return -ENOMEM;
++
++	phydev->priv = priv;
++
++	return 0;
++}
++
++static int an7581_phy_led_polarity_set(struct phy_device *phydev, int index,
++				       unsigned long modes)
++{
++	u32 mode;
++	u16 val;
++
++	if (index >= MTK_PHY_MAX_LEDS)
++		return -EINVAL;
++
++	for_each_set_bit(mode, &modes, __PHY_LED_MODES_NUM) {
++		switch (mode) {
++		case PHY_LED_ACTIVE_LOW:
++			val = MTK_PHY_LED_ON_POLARITY;
++			break;
++		case PHY_LED_ACTIVE_HIGH:
++			val = 0;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	return phy_modify_mmd(phydev, MDIO_MMD_VEND2, index ?
++			      MTK_PHY_LED1_ON_CTRL : MTK_PHY_LED0_ON_CTRL,
++			      MTK_PHY_LED_ON_POLARITY, val);
++}
++
+ static struct phy_driver mtk_socphy_driver[] = {
+ 	{
+ 		PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7981),
+@@ -1440,6 +1490,17 @@ static struct phy_driver mtk_socphy_driv
+ 		.led_hw_control_set = mt798x_phy_led_hw_control_set,
+ 		.led_hw_control_get = mt798x_phy_led_hw_control_get,
+ 	},
++	{
++		PHY_ID_MATCH_EXACT(MTK_GPHY_ID_AN7581),
++		.name		= "Airoha AN7581 PHY",
++		.probe		= an7581_phy_probe,
++		.led_blink_set	= mt798x_phy_led_blink_set,
++		.led_brightness_set = mt798x_phy_led_brightness_set,
++		.led_hw_is_supported = mt798x_phy_led_hw_is_supported,
++		.led_hw_control_set = mt798x_phy_led_hw_control_set,
++		.led_hw_control_get = mt798x_phy_led_hw_control_get,
++		.led_polarity_set = an7581_phy_led_polarity_set,
++	},
+ };
+ 
+ module_phy_driver(mtk_socphy_driver);
+@@ -1447,6 +1508,7 @@ module_phy_driver(mtk_socphy_driver);
+ static const struct mdio_device_id __maybe_unused mtk_socphy_tbl[] = {
+ 	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7981) },
+ 	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_MT7988) },
++	{ PHY_ID_MATCH_EXACT(MTK_GPHY_ID_AN7581) },
+ 	{ }
+ };
+ 
diff --git a/target/linux/generic/backport-6.12/737-v6.16-net-phy-mediatek-init-val-in-.phy_led_polarity_set-f.patch b/target/linux/generic/backport-6.12/737-v6.16-net-phy-mediatek-init-val-in-.phy_led_polarity_set-f.patch
new file mode 100644
index 0000000000..1b1dda2327
--- /dev/null
+++ b/target/linux/generic/backport-6.12/737-v6.16-net-phy-mediatek-init-val-in-.phy_led_polarity_set-f.patch
@@ -0,0 +1,40 @@
+From 34501d047ac0a6cbb13285ba9d15f75c1deb7da7 Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Tue, 15 Apr 2025 12:53:05 +0200
+Subject: [PATCH 18/20] net: phy: mediatek: init val in .phy_led_polarity_set
+ for AN7581
+
+Fix smatch warning for uninitialised val in .phy_led_polarity_set for
+AN7581 driver.
+
+Correctly init to 0 to set polarity high by default.
+
+Reported-by: Simon Horman <horms@kernel.org>
+Fixes: 6a325aed130b ("net: phy: mediatek: add Airoha PHY ID to SoC driver")
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+Link: https://patch.msgid.link/20250415105313.3409-1-ansuelsmth@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mediatek/mtk-ge-soc.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+--- a/drivers/net/phy/mediatek/mtk-ge-soc.c
++++ b/drivers/net/phy/mediatek/mtk-ge-soc.c
+@@ -1431,8 +1431,8 @@ static int an7581_phy_probe(struct phy_d
+ static int an7581_phy_led_polarity_set(struct phy_device *phydev, int index,
+ 				       unsigned long modes)
+ {
++	u16 val = 0;
+ 	u32 mode;
+-	u16 val;
+ 
+ 	if (index >= MTK_PHY_MAX_LEDS)
+ 		return -EINVAL;
+@@ -1443,7 +1443,6 @@ static int an7581_phy_led_polarity_set(s
+ 			val = MTK_PHY_LED_ON_POLARITY;
+ 			break;
+ 		case PHY_LED_ACTIVE_HIGH:
+-			val = 0;
+ 			break;
+ 		default:
+ 			return -EINVAL;
diff --git a/target/linux/generic/backport-6.12/753-v6.15-net-ethernet-mediatek-add-EEE-support.patch b/target/linux/generic/backport-6.12/753-v6.15-net-ethernet-mediatek-add-EEE-support.patch
new file mode 100644
index 0000000000..a63e052f29
--- /dev/null
+++ b/target/linux/generic/backport-6.12/753-v6.15-net-ethernet-mediatek-add-EEE-support.patch
@@ -0,0 +1,157 @@
+From 952d7325362ffbefa6ce5619fb4e53c2159ec7a7 Mon Sep 17 00:00:00 2001
+From: Qingfang Deng <dqfext@gmail.com>
+Date: Mon, 17 Feb 2025 17:40:21 +0800
+Subject: [PATCH] net: ethernet: mediatek: add EEE support
+
+Add EEE support to MediaTek SoC Ethernet. The register fields are
+similar to the ones in MT7531, except that the LPI threshold is in
+milliseconds.
+
+Signed-off-by: Qingfang Deng <dqfext@gmail.com>
+---
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c | 64 +++++++++++++++++++++
+ drivers/net/ethernet/mediatek/mtk_eth_soc.h | 11 ++++
+ 2 files changed, 75 insertions(+)
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -782,6 +782,7 @@ static void mtk_mac_link_up(struct phyli
+ 
+ 	mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
+ 	mcr &= ~(MAC_MCR_SPEED_100 | MAC_MCR_SPEED_1000 |
++		 MAC_MCR_EEE100M | MAC_MCR_EEE1G |
+ 		 MAC_MCR_FORCE_DPX | MAC_MCR_FORCE_TX_FC |
+ 		 MAC_MCR_FORCE_RX_FC);
+ 
+@@ -807,6 +808,15 @@ static void mtk_mac_link_up(struct phyli
+ 	if (rx_pause)
+ 		mcr |= MAC_MCR_FORCE_RX_FC;
+ 
++	if (mode == MLO_AN_PHY && phy && mac->tx_lpi_enabled && phy_init_eee(phy, false) >= 0) {
++		mcr |= MAC_MCR_EEE100M | MAC_MCR_EEE1G;
++		mtk_w32(mac->hw,
++			FIELD_PREP(MAC_EEE_WAKEUP_TIME_1000, 17) |
++			FIELD_PREP(MAC_EEE_WAKEUP_TIME_100, 36) |
++			FIELD_PREP(MAC_EEE_LPI_TXIDLE_THD, mac->txidle_thd_ms),
++			MTK_MAC_EEECR(mac->id));
++	}
++
+ 	mcr |= MAC_MCR_TX_EN | MAC_MCR_RX_EN | MAC_MCR_FORCE_LINK;
+ 	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
+ }
+@@ -4501,6 +4511,61 @@ static int mtk_set_pauseparam(struct net
+ 	return phylink_ethtool_set_pauseparam(mac->phylink, pause);
+ }
+ 
++static int mtk_get_eee(struct net_device *dev, struct ethtool_keee *eee)
++{
++	struct mtk_mac *mac = netdev_priv(dev);
++	u32 reg;
++	int ret;
++
++	ret = phylink_ethtool_get_eee(mac->phylink, eee);
++	if (ret)
++		return ret;
++
++	reg = mtk_r32(mac->hw, MTK_MAC_EEECR(mac->id));
++	eee->tx_lpi_enabled = mac->tx_lpi_enabled;
++	eee->tx_lpi_timer = FIELD_GET(MAC_EEE_LPI_TXIDLE_THD, reg) * 1000;
++
++	return 0;
++}
++
++static int mtk_set_eee(struct net_device *dev, struct ethtool_keee *eee)
++{
++	struct mtk_mac *mac = netdev_priv(dev);
++	u32 txidle_thd_ms, reg;
++	int ret;
++
++	/* Tx idle timer in ms */
++	txidle_thd_ms = DIV_ROUND_UP(eee->tx_lpi_timer, 1000);
++	if (!FIELD_FIT(MAC_EEE_LPI_TXIDLE_THD, txidle_thd_ms))
++		return -EINVAL;
++
++	reg = FIELD_PREP(MAC_EEE_LPI_TXIDLE_THD, txidle_thd_ms);
++
++	/* PHY Wake-up time, this field does not have a reset value, so use the
++	 * reset value from MT7531 (36us for 100BaseT and 17us for 1000BaseT).
++	 */
++	reg |= FIELD_PREP(MAC_EEE_WAKEUP_TIME_1000, 17) |
++	       FIELD_PREP(MAC_EEE_WAKEUP_TIME_100, 36);
++
++	if (!txidle_thd_ms)
++		/* Force LPI Mode without a delay */
++		reg |= MAC_EEE_LPI_MODE;
++
++	ret = phylink_ethtool_set_eee(mac->phylink, eee);
++	if (ret)
++		return ret;
++
++	mac->tx_lpi_enabled = eee->tx_lpi_enabled;
++	mac->txidle_thd_ms = txidle_thd_ms;
++	mtk_w32(mac->hw, reg, MTK_MAC_EEECR(mac->id));
++	if (eee->eee_enabled && eee->eee_active && eee->tx_lpi_enabled)
++		mtk_m32(mac->hw, 0, MAC_MCR_EEE100M | MAC_MCR_EEE1G, MTK_MAC_MCR(mac->id));
++	else
++		mtk_m32(mac->hw, MAC_MCR_EEE100M | MAC_MCR_EEE1G, 0, MTK_MAC_MCR(mac->id));
++
++	return 0;
++}
++
+ static u16 mtk_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			    struct net_device *sb_dev)
+ {
+@@ -4533,6 +4598,8 @@ static const struct ethtool_ops mtk_etht
+ 	.set_pauseparam		= mtk_set_pauseparam,
+ 	.get_rxnfc		= mtk_get_rxnfc,
+ 	.set_rxnfc		= mtk_set_rxnfc,
++	.get_eee		= mtk_get_eee,
++	.set_eee		= mtk_set_eee,
+ };
+ 
+ static const struct net_device_ops mtk_netdev_ops = {
+@@ -4593,6 +4660,8 @@ static int mtk_add_mac(struct mtk_eth *e
+ 	}
+ 	mac = netdev_priv(eth->netdev[id]);
+ 	eth->mac[id] = mac;
++	mac->tx_lpi_enabled = true;
++	mac->txidle_thd_ms = 1;
+ 	mac->id = id;
+ 	mac->hw = eth;
+ 	mac->of_node = np;
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+@@ -461,6 +461,8 @@
+ #define MAC_MCR_RX_FIFO_CLR_DIS	BIT(12)
+ #define MAC_MCR_BACKOFF_EN	BIT(9)
+ #define MAC_MCR_BACKPR_EN	BIT(8)
++#define MAC_MCR_EEE1G		BIT(7)
++#define MAC_MCR_EEE100M		BIT(6)
+ #define MAC_MCR_FORCE_RX_FC	BIT(5)
+ #define MAC_MCR_FORCE_TX_FC	BIT(4)
+ #define MAC_MCR_SPEED_1000	BIT(3)
+@@ -469,6 +471,15 @@
+ #define MAC_MCR_FORCE_LINK	BIT(0)
+ #define MAC_MCR_FORCE_LINK_DOWN	(MAC_MCR_FORCE_MODE)
+ 
++/* Mac EEE control registers */
++#define MTK_MAC_EEECR(x)		(0x10104 + (x * 0x100))
++#define MAC_EEE_WAKEUP_TIME_1000	GENMASK(31, 24)
++#define MAC_EEE_WAKEUP_TIME_100		GENMASK(23, 16)
++#define MAC_EEE_LPI_TXIDLE_THD		GENMASK(15, 8)
++#define MAC_EEE_CKG_TXIDLE		BIT(3)
++#define MAC_EEE_CKG_RXLPI		BIT(2)
++#define MAC_EEE_LPI_MODE		BIT(0)
++
+ /* Mac status registers */
+ #define MTK_MAC_MSR(x)		(0x10108 + (x * 0x100))
+ #define MAC_MSR_EEE1G		BIT(7)
+@@ -1316,6 +1327,8 @@ struct mtk_mac {
+ 	int				id;
+ 	phy_interface_t			interface;
+ 	u8				ppe_idx;
++	bool				tx_lpi_enabled;
++	u8				txidle_thd_ms;
+ 	int				speed;
+ 	struct device_node		*of_node;
+ 	struct phylink			*phylink;
diff --git a/target/linux/generic/backport-6.12/780-01-v6.13-r8169-remove-original-workaround-for-RTL8125-broken-.patch b/target/linux/generic/backport-6.12/780-01-v6.13-r8169-remove-original-workaround-for-RTL8125-broken-.patch
new file mode 100644
index 0000000000..46d41fb262
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-01-v6.13-r8169-remove-original-workaround-for-RTL8125-broken-.patch
@@ -0,0 +1,33 @@
+From 854d71c555dfc3383c1fde7d9989b6046e21093d Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 9 Oct 2024 07:48:05 +0200
+Subject: [PATCH] r8169: remove original workaround for RTL8125 broken rx issue
+
+Now that we have b9c7ac4fe22c ("r8169: disable ALDPS per default for
+RTL8125"), the first attempt to fix the issue shouldn't be needed
+any longer. So let's effectively revert 621735f59064 ("r8169: fix
+rare issue with broken rx after link-down on RTL8125") and see
+whether anybody complains.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/382d8c88-cbce-400f-ad62-fda0181c7e38@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 4 ----
+ 1 file changed, 4 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -4777,11 +4777,7 @@ static void r8169_phylink_handler(struct
+ 	if (netif_carrier_ok(ndev)) {
+ 		rtl_link_chg_patch(tp);
+ 		pm_request_resume(d);
+-		netif_wake_queue(tp->dev);
+ 	} else {
+-		/* In few cases rx is broken after link-down otherwise */
+-		if (rtl_is_8125(tp))
+-			rtl_schedule_task(tp, RTL_FLAG_TASK_RESET_NO_QUEUE_WAKE);
+ 		pm_runtime_idle(d);
+ 	}
+ 
diff --git a/target/linux/generic/backport-6.12/780-02-v6.13-r8169-enable-SG-TSO-on-selected-chip-versions-per-de.patch b/target/linux/generic/backport-6.12/780-02-v6.13-r8169-enable-SG-TSO-on-selected-chip-versions-per-de.patch
new file mode 100644
index 0000000000..5a27cc4b52
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-02-v6.13-r8169-enable-SG-TSO-on-selected-chip-versions-per-de.patch
@@ -0,0 +1,52 @@
+From b8bf38440ba94e8ed8e2ae55c5dfb0276d30e843 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 10 Oct 2024 12:58:02 +0200
+Subject: [PATCH] r8169: enable SG/TSO on selected chip versions per default
+
+Due to problem reports in the past SG and TSO/TSO6 are disabled per
+default. It's not fully clear which chip versions are affected, so we
+may impact also users of unaffected chip versions, unless they know
+how to use ethtool for enabling SG/TSO/TSO6.
+Vendor drivers r8168/r8125 enable SG/TSO/TSO6 for selected chip
+versions per default, I'd interpret this as confirmation that these
+chip versions are unaffected. So let's do the same here.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 16 +++++++++++-----
+ 1 file changed, 11 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -5489,11 +5489,6 @@ static int rtl_init_one(struct pci_dev *
+ 
+ 	dev->features |= dev->hw_features;
+ 
+-	/* There has been a number of reports that using SG/TSO results in
+-	 * tx timeouts. However for a lot of people SG/TSO works fine.
+-	 * Therefore disable both features by default, but allow users to
+-	 * enable them. Use at own risk!
+-	 */
+ 	if (rtl_chip_supports_csum_v2(tp)) {
+ 		dev->hw_features |= NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6;
+ 		netif_set_tso_max_size(dev, RTL_GSO_MAX_SIZE_V2);
+@@ -5504,6 +5499,17 @@ static int rtl_init_one(struct pci_dev *
+ 		netif_set_tso_max_segs(dev, RTL_GSO_MAX_SEGS_V1);
+ 	}
+ 
++	/* There has been a number of reports that using SG/TSO results in
++	 * tx timeouts. However for a lot of people SG/TSO works fine.
++	 * It's not fully clear which chip versions are affected. Vendor
++	 * drivers enable SG/TSO for certain chip versions per default,
++	 * let's mimic this here. On other chip versions users can
++	 * use ethtool to enable SG/TSO, use at own risk!
++	 */
++	if (tp->mac_version >= RTL_GIGA_MAC_VER_46 &&
++	    tp->mac_version != RTL_GIGA_MAC_VER_61)
++		dev->features |= dev->hw_features;
++
+ 	dev->hw_features |= NETIF_F_RXALL;
+ 	dev->hw_features |= NETIF_F_RXFCS;
+ 
diff --git a/target/linux/generic/backport-6.12/780-03-v6.13-r8169-implement-additional-ethtool-stats-ops.patch b/target/linux/generic/backport-6.12/780-03-v6.13-r8169-implement-additional-ethtool-stats-ops.patch
new file mode 100644
index 0000000000..bb0b77e6a3
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-03-v6.13-r8169-implement-additional-ethtool-stats-ops.patch
@@ -0,0 +1,130 @@
+From e3fc5139bd8ffaa1498adc21be4e8ecbc6aed508 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Sun, 13 Oct 2024 11:17:39 +0200
+Subject: [PATCH] r8169: implement additional ethtool stats ops
+
+This adds support for ethtool standard statistics, and makes use of the
+extended hardware statistics being available from RTl8125.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/58e0da73-a7dd-4be3-82ae-d5b3f9069bde@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 82 +++++++++++++++++++++++
+ 1 file changed, 82 insertions(+)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -2160,6 +2160,19 @@ static void rtl8169_get_ringparam(struct
+ 	data->tx_pending = NUM_TX_DESC;
+ }
+ 
++static void rtl8169_get_pause_stats(struct net_device *dev,
++				    struct ethtool_pause_stats *pause_stats)
++{
++	struct rtl8169_private *tp = netdev_priv(dev);
++
++	if (!rtl_is_8125(tp))
++		return;
++
++	rtl8169_update_counters(tp);
++	pause_stats->tx_pause_frames = le32_to_cpu(tp->counters->tx_pause_on);
++	pause_stats->rx_pause_frames = le32_to_cpu(tp->counters->rx_pause_on);
++}
++
+ static void rtl8169_get_pauseparam(struct net_device *dev,
+ 				   struct ethtool_pauseparam *data)
+ {
+@@ -2186,6 +2199,69 @@ static int rtl8169_set_pauseparam(struct
+ 	return 0;
+ }
+ 
++static void rtl8169_get_eth_mac_stats(struct net_device *dev,
++				      struct ethtool_eth_mac_stats *mac_stats)
++{
++	struct rtl8169_private *tp = netdev_priv(dev);
++
++	rtl8169_update_counters(tp);
++
++	mac_stats->FramesTransmittedOK =
++		le64_to_cpu(tp->counters->tx_packets);
++	mac_stats->SingleCollisionFrames =
++		le32_to_cpu(tp->counters->tx_one_collision);
++	mac_stats->MultipleCollisionFrames =
++		le32_to_cpu(tp->counters->tx_multi_collision);
++	mac_stats->FramesReceivedOK =
++		le64_to_cpu(tp->counters->rx_packets);
++	mac_stats->AlignmentErrors =
++		le16_to_cpu(tp->counters->align_errors);
++	mac_stats->FramesLostDueToIntMACXmitError =
++		le64_to_cpu(tp->counters->tx_errors);
++	mac_stats->BroadcastFramesReceivedOK =
++		le64_to_cpu(tp->counters->rx_broadcast);
++	mac_stats->MulticastFramesReceivedOK =
++		le32_to_cpu(tp->counters->rx_multicast);
++
++	if (!rtl_is_8125(tp))
++		return;
++
++	mac_stats->AlignmentErrors =
++		le32_to_cpu(tp->counters->align_errors32);
++	mac_stats->OctetsTransmittedOK =
++		le64_to_cpu(tp->counters->tx_octets);
++	mac_stats->LateCollisions =
++		le32_to_cpu(tp->counters->tx_late_collision);
++	mac_stats->FramesAbortedDueToXSColls =
++		le32_to_cpu(tp->counters->tx_aborted32);
++	mac_stats->OctetsReceivedOK =
++		le64_to_cpu(tp->counters->rx_octets);
++	mac_stats->FramesLostDueToIntMACRcvError =
++		le32_to_cpu(tp->counters->rx_mac_error);
++	mac_stats->MulticastFramesXmittedOK =
++		le64_to_cpu(tp->counters->tx_multicast64);
++	mac_stats->BroadcastFramesXmittedOK =
++		le64_to_cpu(tp->counters->tx_broadcast64);
++	mac_stats->MulticastFramesReceivedOK =
++		le64_to_cpu(tp->counters->rx_multicast64);
++	 mac_stats->FrameTooLongErrors =
++		le32_to_cpu(tp->counters->rx_frame_too_long);
++}
++
++static void rtl8169_get_eth_ctrl_stats(struct net_device *dev,
++				       struct ethtool_eth_ctrl_stats *ctrl_stats)
++{
++	struct rtl8169_private *tp = netdev_priv(dev);
++
++	if (!rtl_is_8125(tp))
++		return;
++
++	rtl8169_update_counters(tp);
++
++	ctrl_stats->UnsupportedOpcodesReceived =
++		le32_to_cpu(tp->counters->rx_unknown_opcode);
++}
++
+ static const struct ethtool_ops rtl8169_ethtool_ops = {
+ 	.supported_coalesce_params = ETHTOOL_COALESCE_USECS |
+ 				     ETHTOOL_COALESCE_MAX_FRAMES,
+@@ -2207,8 +2283,11 @@ static const struct ethtool_ops rtl8169_
+ 	.get_link_ksettings	= phy_ethtool_get_link_ksettings,
+ 	.set_link_ksettings	= phy_ethtool_set_link_ksettings,
+ 	.get_ringparam		= rtl8169_get_ringparam,
++	.get_pause_stats	= rtl8169_get_pause_stats,
+ 	.get_pauseparam		= rtl8169_get_pauseparam,
+ 	.set_pauseparam		= rtl8169_set_pauseparam,
++	.get_eth_mac_stats	= rtl8169_get_eth_mac_stats,
++	.get_eth_ctrl_stats	= rtl8169_get_eth_ctrl_stats,
+ };
+ 
+ static enum mac_version rtl8169_get_mac_version(u16 xid, bool gmii)
+@@ -3893,6 +3972,9 @@ static void rtl_hw_start_8125(struct rtl
+ 		break;
+ 	}
+ 
++	/* enable extended tally counter */
++	r8168_mac_ocp_modify(tp, 0xea84, 0, BIT(1) | BIT(0));
++
+ 	rtl_hw_config(tp);
+ }
+ 
diff --git a/target/linux/generic/backport-6.12/780-04-v6.13-r8169-don-t-take-RTNL-lock-in-rtl_task.patch b/target/linux/generic/backport-6.12/780-04-v6.13-r8169-don-t-take-RTNL-lock-in-rtl_task.patch
new file mode 100644
index 0000000000..77e7b4321e
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-04-v6.13-r8169-don-t-take-RTNL-lock-in-rtl_task.patch
@@ -0,0 +1,50 @@
+From ac48430368c1a4f4e6c2fa92243b4b93fd25bee4 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 16 Oct 2024 22:05:57 +0200
+Subject: [PATCH] r8169: don't take RTNL lock in rtl_task()
+
+There's not really a benefit here in taking the RTNL lock. The task
+handler does exception handling only, so we're in trouble anyway when
+we come here, and there's no need to protect against e.g. a parallel
+ethtool call.
+A benefit of removing the RTNL lock here is that we now can
+synchronously cancel the workqueue from a context holding the RTNL mutex.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 8 ++------
+ 1 file changed, 2 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -4800,10 +4800,8 @@ static void rtl_task(struct work_struct
+ 		container_of(work, struct rtl8169_private, wk.work);
+ 	int ret;
+ 
+-	rtnl_lock();
+-
+ 	if (!test_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags))
+-		goto out_unlock;
++		return;
+ 
+ 	if (test_and_clear_bit(RTL_FLAG_TASK_TX_TIMEOUT, tp->wk.flags)) {
+ 		/* if chip isn't accessible, reset bus to revive it */
+@@ -4812,7 +4810,7 @@ static void rtl_task(struct work_struct
+ 			if (ret < 0) {
+ 				netdev_err(tp->dev, "Can't reset secondary PCI bus, detach NIC\n");
+ 				netif_device_detach(tp->dev);
+-				goto out_unlock;
++				return;
+ 			}
+ 		}
+ 
+@@ -4831,8 +4829,6 @@ reset:
+ 	} else if (test_and_clear_bit(RTL_FLAG_TASK_RESET_NO_QUEUE_WAKE, tp->wk.flags)) {
+ 		rtl_reset_work(tp);
+ 	}
+-out_unlock:
+-	rtnl_unlock();
+ }
+ 
+ static int rtl8169_poll(struct napi_struct *napi, int budget)
diff --git a/target/linux/generic/backport-6.12/780-05-v6.13-replace-custom-flag-with-disable_work-et-al.patch b/target/linux/generic/backport-6.12/780-05-v6.13-replace-custom-flag-with-disable_work-et-al.patch
new file mode 100644
index 0000000000..f6409c321c
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-05-v6.13-replace-custom-flag-with-disable_work-et-al.patch
@@ -0,0 +1,94 @@
+From e2015942e90a021151a5751776f35830ba063be7 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 16 Oct 2024 22:06:53 +0200
+Subject: [PATCH] r8169: replace custom flag with disable_work() et al
+
+So far we use a custom flag to define when a task can be scheduled and
+when not. Let's use the standard mechanism with disable_work() et al
+instead.
+Note that in rtl8169_close() we can remove the call to cancel_work()
+because we now call disable_work_sync() in rtl8169_down() already.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 18 ++++++------------
+ 1 file changed, 6 insertions(+), 12 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -617,7 +617,6 @@ struct rtl8169_tc_offsets {
+ };
+ 
+ enum rtl_flag {
+-	RTL_FLAG_TASK_ENABLED = 0,
+ 	RTL_FLAG_TASK_RESET_PENDING,
+ 	RTL_FLAG_TASK_RESET_NO_QUEUE_WAKE,
+ 	RTL_FLAG_TASK_TX_TIMEOUT,
+@@ -2502,11 +2501,9 @@ u16 rtl8168h_2_get_adc_bias_ioffset(stru
+ 
+ static void rtl_schedule_task(struct rtl8169_private *tp, enum rtl_flag flag)
+ {
+-	if (!test_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags))
+-		return;
+-
+ 	set_bit(flag, tp->wk.flags);
+-	schedule_work(&tp->wk.work);
++	if (!schedule_work(&tp->wk.work))
++		clear_bit(flag, tp->wk.flags);
+ }
+ 
+ static void rtl8169_init_phy(struct rtl8169_private *tp)
+@@ -4800,9 +4797,6 @@ static void rtl_task(struct work_struct
+ 		container_of(work, struct rtl8169_private, wk.work);
+ 	int ret;
+ 
+-	if (!test_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags))
+-		return;
+-
+ 	if (test_and_clear_bit(RTL_FLAG_TASK_TX_TIMEOUT, tp->wk.flags)) {
+ 		/* if chip isn't accessible, reset bus to revive it */
+ 		if (RTL_R32(tp, TxConfig) == ~0) {
+@@ -4886,6 +4880,7 @@ static int r8169_phy_connect(struct rtl8
+ 
+ static void rtl8169_down(struct rtl8169_private *tp)
+ {
++	disable_work_sync(&tp->wk.work);
+ 	/* Clear all task flags */
+ 	bitmap_zero(tp->wk.flags, RTL_FLAG_MAX);
+ 
+@@ -4914,7 +4909,7 @@ static void rtl8169_up(struct rtl8169_pr
+ 	phy_resume(tp->phydev);
+ 	rtl8169_init_phy(tp);
+ 	napi_enable(&tp->napi);
+-	set_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags);
++	enable_work(&tp->wk.work);
+ 	rtl_reset_work(tp);
+ 
+ 	phy_start(tp->phydev);
+@@ -4931,8 +4926,6 @@ static int rtl8169_close(struct net_devi
+ 	rtl8169_down(tp);
+ 	rtl8169_rx_clear(tp);
+ 
+-	cancel_work(&tp->wk.work);
+-
+ 	free_irq(tp->irq, tp);
+ 
+ 	phy_disconnect(tp->phydev);
+@@ -5165,7 +5158,7 @@ static void rtl_remove_one(struct pci_de
+ 	if (pci_dev_run_wake(pdev))
+ 		pm_runtime_get_noresume(&pdev->dev);
+ 
+-	cancel_work_sync(&tp->wk.work);
++	disable_work_sync(&tp->wk.work);
+ 
+ 	if (IS_ENABLED(CONFIG_R8169_LEDS))
+ 		r8169_remove_leds(tp->leds);
+@@ -5542,6 +5535,7 @@ static int rtl_init_one(struct pci_dev *
+ 	tp->irq = pci_irq_vector(pdev, 0);
+ 
+ 	INIT_WORK(&tp->wk.work, rtl_task);
++	disable_work(&tp->wk.work);
+ 
+ 	rtl_init_mac_address(tp);
+ 
diff --git a/target/linux/generic/backport-6.12/780-06-v6.13-r8169-avoid-duplicated-messages-if-loading-firmware-.patch b/target/linux/generic/backport-6.12/780-06-v6.13-r8169-avoid-duplicated-messages-if-loading-firmware-.patch
new file mode 100644
index 0000000000..6430d32252
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-06-v6.13-r8169-avoid-duplicated-messages-if-loading-firmware-.patch
@@ -0,0 +1,41 @@
+From 1c105bacb160b5918e917ab811552b7be69fc69c Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 16 Oct 2024 22:29:39 +0200
+Subject: [PATCH] r8169: avoid duplicated messages if loading firmware fails
+ and switch to warn level
+
+In case of a problem with firmware loading we inform at the driver level,
+in addition the firmware load code itself issues warnings. Therefore
+switch to firmware_request_nowarn() to avoid duplicated error messages.
+In addition switch to warn level because the firmware is optional and
+typically just fixes compatibility issues.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Message-ID: <d9c5094c-89a6-40e2-b5fe-8df7df4624ef@gmail.com>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/ethernet/realtek/r8169_firmware.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_firmware.c
++++ b/drivers/net/ethernet/realtek/r8169_firmware.c
+@@ -215,7 +215,7 @@ int rtl_fw_request_firmware(struct rtl_f
+ {
+ 	int rc;
+ 
+-	rc = request_firmware(&rtl_fw->fw, rtl_fw->fw_name, rtl_fw->dev);
++	rc = firmware_request_nowarn(&rtl_fw->fw, rtl_fw->fw_name, rtl_fw->dev);
+ 	if (rc < 0)
+ 		goto out;
+ 
+@@ -227,7 +227,7 @@ int rtl_fw_request_firmware(struct rtl_f
+ 
+ 	return 0;
+ out:
+-	dev_err(rtl_fw->dev, "Unable to load firmware %s (%d)\n",
+-		rtl_fw->fw_name, rc);
++	dev_warn(rtl_fw->dev, "Unable to load firmware %s (%d)\n",
++		 rtl_fw->fw_name, rc);
+ 	return rc;
+ }
diff --git a/target/linux/generic/backport-6.12/780-07-v6.13-r8169-remove-rtl_dash_loop_wait_high-low.patch b/target/linux/generic/backport-6.12/780-07-v6.13-r8169-remove-rtl_dash_loop_wait_high-low.patch
new file mode 100644
index 0000000000..1e3c47f089
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-07-v6.13-r8169-remove-rtl_dash_loop_wait_high-low.patch
@@ -0,0 +1,82 @@
+From d64113c6bb5ea5a70b7c9c3a6bcadef307638187 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 16 Oct 2024 22:31:10 +0200
+Subject: [PATCH] r8169: remove rtl_dash_loop_wait_high/low
+
+Remove rtl_dash_loop_wait_high/low to simplify the code.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Message-ID: <fb8c490c-2d92-48f5-8bbf-1fc1f2ee1649@gmail.com>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 35 ++++++-----------------
+ 1 file changed, 8 insertions(+), 27 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -1345,40 +1345,19 @@ static void rtl8168ep_stop_cmac(struct r
+ 	RTL_W8(tp, IBCR0, RTL_R8(tp, IBCR0) & ~0x01);
+ }
+ 
+-static void rtl_dash_loop_wait(struct rtl8169_private *tp,
+-			       const struct rtl_cond *c,
+-			       unsigned long usecs, int n, bool high)
+-{
+-	if (!tp->dash_enabled)
+-		return;
+-	rtl_loop_wait(tp, c, usecs, n, high);
+-}
+-
+-static void rtl_dash_loop_wait_high(struct rtl8169_private *tp,
+-				    const struct rtl_cond *c,
+-				    unsigned long d, int n)
+-{
+-	rtl_dash_loop_wait(tp, c, d, n, true);
+-}
+-
+-static void rtl_dash_loop_wait_low(struct rtl8169_private *tp,
+-				   const struct rtl_cond *c,
+-				   unsigned long d, int n)
+-{
+-	rtl_dash_loop_wait(tp, c, d, n, false);
+-}
+-
+ static void rtl8168dp_driver_start(struct rtl8169_private *tp)
+ {
+ 	r8168dp_oob_notify(tp, OOB_CMD_DRIVER_START);
+-	rtl_dash_loop_wait_high(tp, &rtl_dp_ocp_read_cond, 10000, 10);
++	if (tp->dash_enabled)
++		rtl_loop_wait_high(tp, &rtl_dp_ocp_read_cond, 10000, 10);
+ }
+ 
+ static void rtl8168ep_driver_start(struct rtl8169_private *tp)
+ {
+ 	r8168ep_ocp_write(tp, 0x01, 0x180, OOB_CMD_DRIVER_START);
+ 	r8168ep_ocp_write(tp, 0x01, 0x30, r8168ep_ocp_read(tp, 0x30) | 0x01);
+-	rtl_dash_loop_wait_high(tp, &rtl_ep_ocp_read_cond, 10000, 30);
++	if (tp->dash_enabled)
++		rtl_loop_wait_high(tp, &rtl_ep_ocp_read_cond, 10000, 30);
+ }
+ 
+ static void rtl8168_driver_start(struct rtl8169_private *tp)
+@@ -1392,7 +1371,8 @@ static void rtl8168_driver_start(struct
+ static void rtl8168dp_driver_stop(struct rtl8169_private *tp)
+ {
+ 	r8168dp_oob_notify(tp, OOB_CMD_DRIVER_STOP);
+-	rtl_dash_loop_wait_low(tp, &rtl_dp_ocp_read_cond, 10000, 10);
++	if (tp->dash_enabled)
++		rtl_loop_wait_low(tp, &rtl_dp_ocp_read_cond, 10000, 10);
+ }
+ 
+ static void rtl8168ep_driver_stop(struct rtl8169_private *tp)
+@@ -1400,7 +1380,8 @@ static void rtl8168ep_driver_stop(struct
+ 	rtl8168ep_stop_cmac(tp);
+ 	r8168ep_ocp_write(tp, 0x01, 0x180, OOB_CMD_DRIVER_STOP);
+ 	r8168ep_ocp_write(tp, 0x01, 0x30, r8168ep_ocp_read(tp, 0x30) | 0x01);
+-	rtl_dash_loop_wait_low(tp, &rtl_ep_ocp_read_cond, 10000, 10);
++	if (tp->dash_enabled)
++		rtl_loop_wait_low(tp, &rtl_ep_ocp_read_cond, 10000, 10);
+ }
+ 
+ static void rtl8168_driver_stop(struct rtl8169_private *tp)
diff --git a/target/linux/generic/backport-6.12/780-08-v6.13-r8169-enable-EEE-at-2.5G-per-default-on-RTL8125B.patch b/target/linux/generic/backport-6.12/780-08-v6.13-r8169-enable-EEE-at-2.5G-per-default-on-RTL8125B.patch
new file mode 100644
index 0000000000..4ec06cc601
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-08-v6.13-r8169-enable-EEE-at-2.5G-per-default-on-RTL8125B.patch
@@ -0,0 +1,28 @@
+From c4e64095c00cb2de413cd6b90be047c273bcd491 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 17 Oct 2024 22:27:44 +0200
+Subject: [PATCH] r8169: enable EEE at 2.5G per default on RTL8125B
+
+Register a6d/12 is shadowing register MDIO_AN_EEE_ADV2. So this line
+disables advertisement of EEE at 2.5G. Latest vendor driver r8125
+doesn't do this (any longer?), so this mode seems to be safe.
+EEE saves quite some energy, therefore enable this mode per default.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Message-ID: <95dd5a0c-09ea-4847-94d9-b7aa3063e8ff@gmail.com>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/ethernet/realtek/r8169_phy_config.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -99,7 +99,6 @@ static void rtl8125a_config_eee_phy(stru
+ 
+ static void rtl8125b_config_eee_phy(struct phy_device *phydev)
+ {
+-	phy_modify_paged(phydev, 0xa6d, 0x12, 0x0001, 0x0000);
+ 	phy_modify_paged(phydev, 0xa6d, 0x14, 0x0010, 0x0000);
+ 	phy_modify_paged(phydev, 0xa42, 0x14, 0x0080, 0x0000);
+ 	phy_modify_paged(phydev, 0xa4a, 0x11, 0x0200, 0x0000);
diff --git a/target/linux/generic/backport-6.12/780-09-v6.13-r8169-add-support-for-RTL8125D.patch b/target/linux/generic/backport-6.12/780-09-v6.13-r8169-add-support-for-RTL8125D.patch
new file mode 100644
index 0000000000..8bb9916cee
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-09-v6.13-r8169-add-support-for-RTL8125D.patch
@@ -0,0 +1,143 @@
+From f75d1fbe7809bc5ed134204b920fd9e2fc5db1df Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 24 Oct 2024 22:42:33 +0200
+Subject: [PATCH] r8169: add support for RTL8125D
+
+This adds support for new chip version RTL8125D, which can be found on
+boards like Gigabyte X870E AORUS ELITE WIFI7. Firmware rtl8125d-1.fw
+for this chip version is available in linux-firmware already.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/d0306912-e88e-4c25-8b5d-545ae8834c0c@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169.h          |  1 +
+ drivers/net/ethernet/realtek/r8169_main.c     | 23 +++++++++++++------
+ .../net/ethernet/realtek/r8169_phy_config.c   | 10 ++++++++
+ 3 files changed, 27 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169.h
++++ b/drivers/net/ethernet/realtek/r8169.h
+@@ -68,6 +68,7 @@ enum mac_version {
+ 	/* support for RTL_GIGA_MAC_VER_60 has been removed */
+ 	RTL_GIGA_MAC_VER_61,
+ 	RTL_GIGA_MAC_VER_63,
++	RTL_GIGA_MAC_VER_64,
+ 	RTL_GIGA_MAC_VER_65,
+ 	RTL_GIGA_MAC_VER_66,
+ 	RTL_GIGA_MAC_NONE
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -55,6 +55,7 @@
+ #define FIRMWARE_8107E_2	"rtl_nic/rtl8107e-2.fw"
+ #define FIRMWARE_8125A_3	"rtl_nic/rtl8125a-3.fw"
+ #define FIRMWARE_8125B_2	"rtl_nic/rtl8125b-2.fw"
++#define FIRMWARE_8125D_1	"rtl_nic/rtl8125d-1.fw"
+ #define FIRMWARE_8126A_2	"rtl_nic/rtl8126a-2.fw"
+ #define FIRMWARE_8126A_3	"rtl_nic/rtl8126a-3.fw"
+ 
+@@ -138,6 +139,7 @@ static const struct {
+ 	[RTL_GIGA_MAC_VER_61] = {"RTL8125A",		FIRMWARE_8125A_3},
+ 	/* reserve 62 for CFG_METHOD_4 in the vendor driver */
+ 	[RTL_GIGA_MAC_VER_63] = {"RTL8125B",		FIRMWARE_8125B_2},
++	[RTL_GIGA_MAC_VER_64] = {"RTL8125D",		FIRMWARE_8125D_1},
+ 	[RTL_GIGA_MAC_VER_65] = {"RTL8126A",		FIRMWARE_8126A_2},
+ 	[RTL_GIGA_MAC_VER_66] = {"RTL8126A",		FIRMWARE_8126A_3},
+ };
+@@ -706,6 +708,7 @@ MODULE_FIRMWARE(FIRMWARE_8168FP_3);
+ MODULE_FIRMWARE(FIRMWARE_8107E_2);
+ MODULE_FIRMWARE(FIRMWARE_8125A_3);
+ MODULE_FIRMWARE(FIRMWARE_8125B_2);
++MODULE_FIRMWARE(FIRMWARE_8125D_1);
+ MODULE_FIRMWARE(FIRMWARE_8126A_2);
+ MODULE_FIRMWARE(FIRMWARE_8126A_3);
+ 
+@@ -2078,10 +2081,7 @@ static void rtl_set_eee_txidle_timer(str
+ 		tp->tx_lpi_timer = timer_val;
+ 		r8168_mac_ocp_write(tp, 0xe048, timer_val);
+ 		break;
+-	case RTL_GIGA_MAC_VER_61:
+-	case RTL_GIGA_MAC_VER_63:
+-	case RTL_GIGA_MAC_VER_65:
+-	case RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_66:
+ 		tp->tx_lpi_timer = timer_val;
+ 		RTL_W16(tp, EEE_TXIDLE_TIMER_8125, timer_val);
+ 		break;
+@@ -2292,6 +2292,9 @@ static enum mac_version rtl8169_get_mac_
+ 		{ 0x7cf, 0x64a,	RTL_GIGA_MAC_VER_66 },
+ 		{ 0x7cf, 0x649,	RTL_GIGA_MAC_VER_65 },
+ 
++		/* 8125D family. */
++		{ 0x7cf, 0x688,	RTL_GIGA_MAC_VER_64 },
++
+ 		/* 8125B family. */
+ 		{ 0x7cf, 0x641,	RTL_GIGA_MAC_VER_63 },
+ 
+@@ -2557,9 +2560,7 @@ static void rtl_init_rxcfg(struct rtl816
+ 	case RTL_GIGA_MAC_VER_61:
+ 		RTL_W32(tp, RxConfig, RX_FETCH_DFLT_8125 | RX_DMA_BURST);
+ 		break;
+-	case RTL_GIGA_MAC_VER_63:
+-	case RTL_GIGA_MAC_VER_65:
+-	case RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_63 ... RTL_GIGA_MAC_VER_66:
+ 		RTL_W32(tp, RxConfig, RX_FETCH_DFLT_8125 | RX_DMA_BURST |
+ 			RX_PAUSE_SLOT_ON);
+ 		break;
+@@ -3871,6 +3872,12 @@ static void rtl_hw_start_8125b(struct rt
+ 	rtl_hw_start_8125_common(tp);
+ }
+ 
++static void rtl_hw_start_8125d(struct rtl8169_private *tp)
++{
++	rtl_set_def_aspm_entry_latency(tp);
++	rtl_hw_start_8125_common(tp);
++}
++
+ static void rtl_hw_start_8126a(struct rtl8169_private *tp)
+ {
+ 	rtl_set_def_aspm_entry_latency(tp);
+@@ -3919,6 +3926,7 @@ static void rtl_hw_config(struct rtl8169
+ 		[RTL_GIGA_MAC_VER_53] = rtl_hw_start_8117,
+ 		[RTL_GIGA_MAC_VER_61] = rtl_hw_start_8125a_2,
+ 		[RTL_GIGA_MAC_VER_63] = rtl_hw_start_8125b,
++		[RTL_GIGA_MAC_VER_64] = rtl_hw_start_8125d,
+ 		[RTL_GIGA_MAC_VER_65] = rtl_hw_start_8126a,
+ 		[RTL_GIGA_MAC_VER_66] = rtl_hw_start_8126a,
+ 	};
+@@ -3936,6 +3944,7 @@ static void rtl_hw_start_8125(struct rtl
+ 	/* disable interrupt coalescing */
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_61:
++	case RTL_GIGA_MAC_VER_64:
+ 		for (i = 0xa00; i < 0xb00; i += 4)
+ 			RTL_W32(tp, i, 0);
+ 		break;
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -1103,6 +1103,15 @@ static void rtl8125b_hw_phy_config(struc
+ 	rtl8125b_config_eee_phy(phydev);
+ }
+ 
++static void rtl8125d_hw_phy_config(struct rtl8169_private *tp,
++				   struct phy_device *phydev)
++{
++	r8169_apply_firmware(tp);
++	rtl8125_legacy_force_mode(phydev);
++	rtl8168g_disable_aldps(phydev);
++	rtl8125b_config_eee_phy(phydev);
++}
++
+ static void rtl8126a_hw_phy_config(struct rtl8169_private *tp,
+ 				   struct phy_device *phydev)
+ {
+@@ -1159,6 +1168,7 @@ void r8169_hw_phy_config(struct rtl8169_
+ 		[RTL_GIGA_MAC_VER_53] = rtl8117_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_61] = rtl8125a_2_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_63] = rtl8125b_hw_phy_config,
++		[RTL_GIGA_MAC_VER_64] = rtl8125d_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_65] = rtl8126a_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_66] = rtl8126a_hw_phy_config,
+ 	};
diff --git a/target/linux/generic/backport-6.12/780-10-v6.13-r8169-fix-inconsistent-indenting-in-rtl8169_get_eth_.patch b/target/linux/generic/backport-6.12/780-10-v6.13-r8169-fix-inconsistent-indenting-in-rtl8169_get_eth_.patch
new file mode 100644
index 0000000000..41bab55366
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-10-v6.13-r8169-fix-inconsistent-indenting-in-rtl8169_get_eth_.patch
@@ -0,0 +1,30 @@
+From b8bd8c44a266c9a7dcb907eab10fbb119e3f6494 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 24 Oct 2024 22:48:59 +0200
+Subject: [PATCH] r8169: fix inconsistent indenting in
+ rtl8169_get_eth_mac_stats
+
+This fixes an inconsistent indenting introduced with e3fc5139bd8f
+("r8169: implement additional ethtool stats ops").
+
+Reported-by: kernel test robot <lkp@intel.com>
+Closes: https://lore.kernel.org/oe-kbuild-all/202410220413.1gAxIJ4t-lkp@intel.com/
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/20fd6f39-3c1b-4af0-9adc-7d1f49728fad@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -2224,7 +2224,7 @@ static void rtl8169_get_eth_mac_stats(st
+ 		le64_to_cpu(tp->counters->tx_broadcast64);
+ 	mac_stats->MulticastFramesReceivedOK =
+ 		le64_to_cpu(tp->counters->rx_multicast64);
+-	 mac_stats->FrameTooLongErrors =
++	mac_stats->FrameTooLongErrors =
+ 		le32_to_cpu(tp->counters->rx_frame_too_long);
+ }
+ 
diff --git a/target/linux/generic/backport-6.12/780-11-v6.13-r8169-align-RTL8125-EEE-config-with-vendor-driver.patch b/target/linux/generic/backport-6.12/780-11-v6.13-r8169-align-RTL8125-EEE-config-with-vendor-driver.patch
new file mode 100644
index 0000000000..de2be0165c
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-11-v6.13-r8169-align-RTL8125-EEE-config-with-vendor-driver.patch
@@ -0,0 +1,49 @@
+From eb90f876b7961d702d7fc549e14614860f531e60 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 31 Oct 2024 22:42:52 +0100
+Subject: [PATCH] r8169: align RTL8125 EEE config with vendor driver
+
+Align the EEE config for RTL8125A/RTL8125B with vendor driver r8125.
+This should help to avoid compatibility issues.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/044c925e-8669-4b98-87df-95b4056f4f5f@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ .../net/ethernet/realtek/r8169_phy_config.c    | 18 ++++++++++++------
+ 1 file changed, 12 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -89,19 +89,25 @@ static void rtl8168h_config_eee_phy(stru
+ 	phy_modify_paged(phydev, 0xa42, 0x14, 0x0000, 0x0080);
+ }
+ 
+-static void rtl8125a_config_eee_phy(struct phy_device *phydev)
++static void rtl8125_common_config_eee_phy(struct phy_device *phydev)
+ {
+-	rtl8168h_config_eee_phy(phydev);
++	phy_modify_paged(phydev, 0xa6d, 0x14, 0x0010, 0x0000);
++	phy_modify_paged(phydev, 0xa42, 0x14, 0x0080, 0x0000);
++	phy_modify_paged(phydev, 0xa4a, 0x11, 0x0200, 0x0000);
++}
+ 
++static void rtl8125a_config_eee_phy(struct phy_device *phydev)
++{
++	rtl8168g_config_eee_phy(phydev);
++	/* disable EEE at 2.5Gbps */
+ 	phy_modify_paged(phydev, 0xa6d, 0x12, 0x0001, 0x0000);
+-	phy_modify_paged(phydev, 0xa6d, 0x14, 0x0010, 0x0000);
++	rtl8125_common_config_eee_phy(phydev);
+ }
+ 
+ static void rtl8125b_config_eee_phy(struct phy_device *phydev)
+ {
+-	phy_modify_paged(phydev, 0xa6d, 0x14, 0x0010, 0x0000);
+-	phy_modify_paged(phydev, 0xa42, 0x14, 0x0080, 0x0000);
+-	phy_modify_paged(phydev, 0xa4a, 0x11, 0x0200, 0x0000);
++	rtl8168g_config_eee_phy(phydev);
++	rtl8125_common_config_eee_phy(phydev);
+ }
+ 
+ static void rtl8169s_hw_phy_config(struct rtl8169_private *tp,
diff --git a/target/linux/generic/backport-6.12/780-12-v6.13-r8169-align-RTL8125-RTL8126-PHY-config-with-vendor-d.patch b/target/linux/generic/backport-6.12/780-12-v6.13-r8169-align-RTL8125-RTL8126-PHY-config-with-vendor-d.patch
new file mode 100644
index 0000000000..a546c426b4
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-12-v6.13-r8169-align-RTL8125-RTL8126-PHY-config-with-vendor-d.patch
@@ -0,0 +1,46 @@
+From 4af2f60bf7378bd5c92b15a528d8c6c7d02bed6c Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 31 Oct 2024 22:43:45 +0100
+Subject: [PATCH] r8169: align RTL8125/RTL8126 PHY config with vendor driver
+
+This aligns some parameters with vendor driver r8125/r8126 to avoid
+compatibility issues. Note that for RTL8125B there's no functional
+change, just the open-coded version of the function is replaced.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/a8a9d896-fbe6-41f2-bf87-666567d3cdb3@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_phy_config.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -1073,8 +1073,8 @@ static void rtl8125b_hw_phy_config(struc
+ 				   struct phy_device *phydev)
+ {
+ 	r8169_apply_firmware(tp);
++	rtl8168g_enable_gphy_10m(phydev);
+ 
+-	phy_modify_paged(phydev, 0xa44, 0x11, 0x0000, 0x0800);
+ 	phy_modify_paged(phydev, 0xac4, 0x13, 0x00f0, 0x0090);
+ 	phy_modify_paged(phydev, 0xad3, 0x10, 0x0003, 0x0001);
+ 
+@@ -1113,6 +1113,7 @@ static void rtl8125d_hw_phy_config(struc
+ 				   struct phy_device *phydev)
+ {
+ 	r8169_apply_firmware(tp);
++	rtl8168g_enable_gphy_10m(phydev);
+ 	rtl8125_legacy_force_mode(phydev);
+ 	rtl8168g_disable_aldps(phydev);
+ 	rtl8125b_config_eee_phy(phydev);
+@@ -1122,6 +1123,9 @@ static void rtl8126a_hw_phy_config(struc
+ 				   struct phy_device *phydev)
+ {
+ 	r8169_apply_firmware(tp);
++	rtl8168g_enable_gphy_10m(phydev);
++	rtl8125_legacy_force_mode(phydev);
++	rtl8168g_disable_aldps(phydev);
+ }
+ 
+ void r8169_hw_phy_config(struct rtl8169_private *tp, struct phy_device *phydev,
diff --git a/target/linux/generic/backport-6.12/780-13-v6.13-r8169-align-RTL8126-EEE-config-with-vendor-driver.patch b/target/linux/generic/backport-6.12/780-13-v6.13-r8169-align-RTL8126-EEE-config-with-vendor-driver.patch
new file mode 100644
index 0000000000..36c8041c94
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-13-v6.13-r8169-align-RTL8126-EEE-config-with-vendor-driver.patch
@@ -0,0 +1,25 @@
+From a3d8520e6a19ab018da6c7fc22512c913697a829 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 31 Oct 2024 22:44:36 +0100
+Subject: [PATCH] r8169: align RTL8126 EEE config with vendor driver
+
+Align the EEE config for RTL8126A with vendor driver r8126 to avoid
+compatibility issues.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/71e4859e-4cd0-4b6b-b7fa-621d7721992f@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_phy_config.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -1126,6 +1126,7 @@ static void rtl8126a_hw_phy_config(struc
+ 	rtl8168g_enable_gphy_10m(phydev);
+ 	rtl8125_legacy_force_mode(phydev);
+ 	rtl8168g_disable_aldps(phydev);
++	rtl8125_common_config_eee_phy(phydev);
+ }
+ 
+ void r8169_hw_phy_config(struct rtl8169_private *tp, struct phy_device *phydev,
diff --git a/target/linux/generic/backport-6.12/780-14-v6.13-r8169-improve-initialization-of-RSS-registers-on-RTL.patch b/target/linux/generic/backport-6.12/780-14-v6.13-r8169-improve-initialization-of-RSS-registers-on-RTL.patch
new file mode 100644
index 0000000000..fc6ea34b59
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-14-v6.13-r8169-improve-initialization-of-RSS-registers-on-RTL.patch
@@ -0,0 +1,38 @@
+From 2cd02f2fdd8a92e5b6b85ff64eab0fc549b30c07 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Sat, 2 Nov 2024 14:49:01 +0100
+Subject: [PATCH] r8169: improve initialization of RSS registers on
+ RTL8125/RTL8126
+
+Replace the register addresses with the names used in r8125/r8126
+vendor driver, and consider that RSS_CTRL_8125 is a 32 bit register.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/3bf2f340-b369-4174-97bf-fd38d4217492@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 6 ++++--
+ 1 file changed, 4 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -346,6 +346,8 @@ enum rtl8125_registers {
+ 	TxPoll_8125		= 0x90,
+ 	LEDSEL3			= 0x96,
+ 	MAC0_BKP		= 0x19e0,
++	RSS_CTRL_8125		= 0x4500,
++	Q_NUM_CTRL_8125		= 0x4800,
+ 	EEE_TXIDLE_TIMER_8125	= 0x6048,
+ };
+ 
+@@ -3765,8 +3767,8 @@ static void rtl_hw_start_8125_common(str
+ 	rtl_pcie_state_l2l3_disable(tp);
+ 
+ 	RTL_W16(tp, 0x382, 0x221b);
+-	RTL_W8(tp, 0x4500, 0);
+-	RTL_W16(tp, 0x4800, 0);
++	RTL_W32(tp, RSS_CTRL_8125, 0);
++	RTL_W16(tp, Q_NUM_CTRL_8125, 0);
+ 
+ 	/* disable UPS */
+ 	r8168_mac_ocp_modify(tp, 0xd40a, 0x0010, 0x0000);
diff --git a/target/linux/generic/backport-6.12/780-15-v6.13-r8169-remove-leftover-locks-after-reverted-change.patch b/target/linux/generic/backport-6.12/780-15-v6.13-r8169-remove-leftover-locks-after-reverted-change.patch
new file mode 100644
index 0000000000..d8a3eb0029
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-15-v6.13-r8169-remove-leftover-locks-after-reverted-change.patch
@@ -0,0 +1,113 @@
+From 83cb4b470c66b37b19a347a35cea01e0cbdd258d Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Mon, 4 Nov 2024 23:16:20 +0100
+Subject: [PATCH] r8169: remove leftover locks after reverted change
+
+After e31a9fedc7d8 ("Revert "r8169: disable ASPM during NAPI poll"")
+these locks aren't needed any longer.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/680f2606-ac7d-4ced-8694-e5033855da9b@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 29 ++---------------------
+ 1 file changed, 2 insertions(+), 27 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -661,13 +661,9 @@ struct rtl8169_private {
+ 		struct work_struct work;
+ 	} wk;
+ 
+-	raw_spinlock_t config25_lock;
+ 	raw_spinlock_t mac_ocp_lock;
+ 	struct mutex led_lock;	/* serialize LED ctrl RMW access */
+ 
+-	raw_spinlock_t cfg9346_usage_lock;
+-	int cfg9346_usage_count;
+-
+ 	unsigned supports_gmii:1;
+ 	unsigned aspm_manageable:1;
+ 	unsigned dash_enabled:1;
+@@ -721,22 +717,12 @@ static inline struct device *tp_to_dev(s
+ 
+ static void rtl_lock_config_regs(struct rtl8169_private *tp)
+ {
+-	unsigned long flags;
+-
+-	raw_spin_lock_irqsave(&tp->cfg9346_usage_lock, flags);
+-	if (!--tp->cfg9346_usage_count)
+-		RTL_W8(tp, Cfg9346, Cfg9346_Lock);
+-	raw_spin_unlock_irqrestore(&tp->cfg9346_usage_lock, flags);
++	RTL_W8(tp, Cfg9346, Cfg9346_Lock);
+ }
+ 
+ static void rtl_unlock_config_regs(struct rtl8169_private *tp)
+ {
+-	unsigned long flags;
+-
+-	raw_spin_lock_irqsave(&tp->cfg9346_usage_lock, flags);
+-	if (!tp->cfg9346_usage_count++)
+-		RTL_W8(tp, Cfg9346, Cfg9346_Unlock);
+-	raw_spin_unlock_irqrestore(&tp->cfg9346_usage_lock, flags);
++	RTL_W8(tp, Cfg9346, Cfg9346_Unlock);
+ }
+ 
+ static void rtl_pci_commit(struct rtl8169_private *tp)
+@@ -747,24 +733,18 @@ static void rtl_pci_commit(struct rtl816
+ 
+ static void rtl_mod_config2(struct rtl8169_private *tp, u8 clear, u8 set)
+ {
+-	unsigned long flags;
+ 	u8 val;
+ 
+-	raw_spin_lock_irqsave(&tp->config25_lock, flags);
+ 	val = RTL_R8(tp, Config2);
+ 	RTL_W8(tp, Config2, (val & ~clear) | set);
+-	raw_spin_unlock_irqrestore(&tp->config25_lock, flags);
+ }
+ 
+ static void rtl_mod_config5(struct rtl8169_private *tp, u8 clear, u8 set)
+ {
+-	unsigned long flags;
+ 	u8 val;
+ 
+-	raw_spin_lock_irqsave(&tp->config25_lock, flags);
+ 	val = RTL_R8(tp, Config5);
+ 	RTL_W8(tp, Config5, (val & ~clear) | set);
+-	raw_spin_unlock_irqrestore(&tp->config25_lock, flags);
+ }
+ 
+ static bool rtl_is_8125(struct rtl8169_private *tp)
+@@ -1570,7 +1550,6 @@ static void __rtl8169_set_wol(struct rtl
+ 		{ WAKE_MAGIC, Config3, MagicPacket }
+ 	};
+ 	unsigned int i, tmp = ARRAY_SIZE(cfg);
+-	unsigned long flags;
+ 	u8 options;
+ 
+ 	rtl_unlock_config_regs(tp);
+@@ -1589,14 +1568,12 @@ static void __rtl8169_set_wol(struct rtl
+ 			r8168_mac_ocp_modify(tp, 0xc0b6, BIT(0), 0);
+ 	}
+ 
+-	raw_spin_lock_irqsave(&tp->config25_lock, flags);
+ 	for (i = 0; i < tmp; i++) {
+ 		options = RTL_R8(tp, cfg[i].reg) & ~cfg[i].mask;
+ 		if (wolopts & cfg[i].opt)
+ 			options |= cfg[i].mask;
+ 		RTL_W8(tp, cfg[i].reg, options);
+ 	}
+-	raw_spin_unlock_irqrestore(&tp->config25_lock, flags);
+ 
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_02 ... RTL_GIGA_MAC_VER_06:
+@@ -5451,8 +5428,6 @@ static int rtl_init_one(struct pci_dev *
+ 	tp->supports_gmii = ent->driver_data == RTL_CFG_NO_GBIT ? 0 : 1;
+ 	tp->ocp_base = OCP_STD_PHY_BASE;
+ 
+-	raw_spin_lock_init(&tp->cfg9346_usage_lock);
+-	raw_spin_lock_init(&tp->config25_lock);
+ 	raw_spin_lock_init(&tp->mac_ocp_lock);
+ 	mutex_init(&tp->led_lock);
+ 
diff --git a/target/linux/generic/backport-6.12/780-16-v6.13-r8169-improve-__rtl8169_set_wol.patch b/target/linux/generic/backport-6.12/780-16-v6.13-r8169-improve-__rtl8169_set_wol.patch
new file mode 100644
index 0000000000..3158ac5171
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-16-v6.13-r8169-improve-__rtl8169_set_wol.patch
@@ -0,0 +1,108 @@
+From c507e96b5763b36b63ad50ad804341f72ea000e4 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 6 Nov 2024 17:55:45 +0100
+Subject: [PATCH] r8169: improve __rtl8169_set_wol
+
+Add helper r8169_mod_reg8_cond() what allows to significantly simplify
+__rtl8169_set_wol().
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/697b197a-8eac-40c6-8847-27093cacec36@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 55 ++++++++++-------------
+ 1 file changed, 24 insertions(+), 31 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -747,6 +747,20 @@ static void rtl_mod_config5(struct rtl81
+ 	RTL_W8(tp, Config5, (val & ~clear) | set);
+ }
+ 
++static void r8169_mod_reg8_cond(struct rtl8169_private *tp, int reg,
++				u8 bits, bool cond)
++{
++	u8 val, old_val;
++
++	old_val = RTL_R8(tp, reg);
++	if (cond)
++		val = old_val | bits;
++	else
++		val = old_val & ~bits;
++	if (val != old_val)
++		RTL_W8(tp, reg, val);
++}
++
+ static bool rtl_is_8125(struct rtl8169_private *tp)
+ {
+ 	return tp->mac_version >= RTL_GIGA_MAC_VER_61;
+@@ -1537,58 +1551,37 @@ static void rtl8169_get_wol(struct net_d
+ 
+ static void __rtl8169_set_wol(struct rtl8169_private *tp, u32 wolopts)
+ {
+-	static const struct {
+-		u32 opt;
+-		u16 reg;
+-		u8  mask;
+-	} cfg[] = {
+-		{ WAKE_PHY,   Config3, LinkUp },
+-		{ WAKE_UCAST, Config5, UWF },
+-		{ WAKE_BCAST, Config5, BWF },
+-		{ WAKE_MCAST, Config5, MWF },
+-		{ WAKE_ANY,   Config5, LanWake },
+-		{ WAKE_MAGIC, Config3, MagicPacket }
+-	};
+-	unsigned int i, tmp = ARRAY_SIZE(cfg);
+-	u8 options;
+-
+ 	rtl_unlock_config_regs(tp);
+ 
+ 	if (rtl_is_8168evl_up(tp)) {
+-		tmp--;
+ 		if (wolopts & WAKE_MAGIC)
+ 			rtl_eri_set_bits(tp, 0x0dc, MagicPacket_v2);
+ 		else
+ 			rtl_eri_clear_bits(tp, 0x0dc, MagicPacket_v2);
+ 	} else if (rtl_is_8125(tp)) {
+-		tmp--;
+ 		if (wolopts & WAKE_MAGIC)
+ 			r8168_mac_ocp_modify(tp, 0xc0b6, 0, BIT(0));
+ 		else
+ 			r8168_mac_ocp_modify(tp, 0xc0b6, BIT(0), 0);
++	} else {
++		r8169_mod_reg8_cond(tp, Config3, MagicPacket,
++				    wolopts & WAKE_MAGIC);
+ 	}
+ 
+-	for (i = 0; i < tmp; i++) {
+-		options = RTL_R8(tp, cfg[i].reg) & ~cfg[i].mask;
+-		if (wolopts & cfg[i].opt)
+-			options |= cfg[i].mask;
+-		RTL_W8(tp, cfg[i].reg, options);
+-	}
++	r8169_mod_reg8_cond(tp, Config3, LinkUp, wolopts & WAKE_PHY);
++	r8169_mod_reg8_cond(tp, Config5, UWF, wolopts & WAKE_UCAST);
++	r8169_mod_reg8_cond(tp, Config5, BWF, wolopts & WAKE_BCAST);
++	r8169_mod_reg8_cond(tp, Config5, MWF, wolopts & WAKE_MCAST);
++	r8169_mod_reg8_cond(tp, Config5, LanWake, wolopts);
+ 
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_02 ... RTL_GIGA_MAC_VER_06:
+-		options = RTL_R8(tp, Config1) & ~PMEnable;
+-		if (wolopts)
+-			options |= PMEnable;
+-		RTL_W8(tp, Config1, options);
++		r8169_mod_reg8_cond(tp, Config1, PMEnable, wolopts);
+ 		break;
+ 	case RTL_GIGA_MAC_VER_34:
+ 	case RTL_GIGA_MAC_VER_37:
+ 	case RTL_GIGA_MAC_VER_39 ... RTL_GIGA_MAC_VER_66:
+-		if (wolopts)
+-			rtl_mod_config2(tp, 0, PME_SIGNAL);
+-		else
+-			rtl_mod_config2(tp, PME_SIGNAL, 0);
++		r8169_mod_reg8_cond(tp, Config2, PME_SIGNAL, wolopts);
+ 		break;
+ 	default:
+ 		break;
diff --git a/target/linux/generic/backport-6.12/780-17-v6.13-r8169-improve-rtl_set_d3_pll_down.patch b/target/linux/generic/backport-6.12/780-17-v6.13-r8169-improve-rtl_set_d3_pll_down.patch
new file mode 100644
index 0000000000..ede589ee73
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-17-v6.13-r8169-improve-rtl_set_d3_pll_down.patch
@@ -0,0 +1,44 @@
+From 330dc2297c82953dff402e0b4176a5383a618538 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 6 Nov 2024 17:56:28 +0100
+Subject: [PATCH] r8169: improve rtl_set_d3_pll_down
+
+Make use of new helper r8169_mod_reg8_cond() and move from a switch()
+to an if() clause. Benefit is that we don't have to touch this piece of
+code each time support for a new chip version is added.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/e1ccdb85-a4ed-4800-89c2-89770ff06452@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 18 +++++-------------
+ 1 file changed, 5 insertions(+), 13 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -1430,19 +1430,11 @@ static enum rtl_dash_type rtl_get_dash_t
+ 
+ static void rtl_set_d3_pll_down(struct rtl8169_private *tp, bool enable)
+ {
+-	switch (tp->mac_version) {
+-	case RTL_GIGA_MAC_VER_25 ... RTL_GIGA_MAC_VER_26:
+-	case RTL_GIGA_MAC_VER_29 ... RTL_GIGA_MAC_VER_30:
+-	case RTL_GIGA_MAC_VER_32 ... RTL_GIGA_MAC_VER_37:
+-	case RTL_GIGA_MAC_VER_39 ... RTL_GIGA_MAC_VER_66:
+-		if (enable)
+-			RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) & ~D3_NO_PLL_DOWN);
+-		else
+-			RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) | D3_NO_PLL_DOWN);
+-		break;
+-	default:
+-		break;
+-	}
++	if (tp->mac_version >= RTL_GIGA_MAC_VER_25 &&
++	    tp->mac_version != RTL_GIGA_MAC_VER_28 &&
++	    tp->mac_version != RTL_GIGA_MAC_VER_31 &&
++	    tp->mac_version != RTL_GIGA_MAC_VER_38)
++		r8169_mod_reg8_cond(tp, PMCH, D3_NO_PLL_DOWN, !enable);
+ }
+ 
+ static void rtl_reset_packet_filter(struct rtl8169_private *tp)
diff --git a/target/linux/generic/backport-6.12/780-18-v6.13-r8169-align-WAKE_PHY-handling-with-r8125-r8126-vendo.patch b/target/linux/generic/backport-6.12/780-18-v6.13-r8169-align-WAKE_PHY-handling-with-r8125-r8126-vendo.patch
new file mode 100644
index 0000000000..ceb8c1239f
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-18-v6.13-r8169-align-WAKE_PHY-handling-with-r8125-r8126-vendo.patch
@@ -0,0 +1,29 @@
+From e3e9e9039fa6ae885c7d5c954d7b9f105fa23e8f Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 6 Nov 2024 17:57:08 +0100
+Subject: [PATCH] r8169: align WAKE_PHY handling with r8125/r8126 vendor
+ drivers
+
+Vendor drivers r8125/r8126 apply this additional magic setting when
+enabling WAKE_PHY, so do the same here.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/51130715-45be-4db5-abb7-05d87e1f5df9@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -1561,6 +1561,9 @@ static void __rtl8169_set_wol(struct rtl
+ 	}
+ 
+ 	r8169_mod_reg8_cond(tp, Config3, LinkUp, wolopts & WAKE_PHY);
++	if (rtl_is_8125(tp))
++		r8168_mac_ocp_modify(tp, 0xe0c6, 0x3f,
++				     wolopts & WAKE_PHY ? 0x13 : 0);
+ 	r8169_mod_reg8_cond(tp, Config5, UWF, wolopts & WAKE_UCAST);
+ 	r8169_mod_reg8_cond(tp, Config5, BWF, wolopts & WAKE_BCAST);
+ 	r8169_mod_reg8_cond(tp, Config5, MWF, wolopts & WAKE_MCAST);
diff --git a/target/linux/generic/backport-6.12/780-19-v6.13-r8169-use-helper-r8169_mod_reg8_cond-to-simplify-rtl.patch b/target/linux/generic/backport-6.12/780-19-v6.13-r8169-use-helper-r8169_mod_reg8_cond-to-simplify-rtl.patch
new file mode 100644
index 0000000000..d6332dfa14
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-19-v6.13-r8169-use-helper-r8169_mod_reg8_cond-to-simplify-rtl.patch
@@ -0,0 +1,117 @@
+From 7a3bcd39ae1f0e3ab896d9df62339ab4297a0bfd Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Sat, 9 Nov 2024 23:12:12 +0100
+Subject: [PATCH] r8169: use helper r8169_mod_reg8_cond to simplify
+ rtl_jumbo_config
+
+Use recently added helper r8169_mod_reg8_cond() to simplify jumbo
+mode configuration.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/3df1d484-a02e-46e7-8f75-db5b428e422e@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 77 ++++-------------------
+ 1 file changed, 11 insertions(+), 66 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -2542,86 +2542,31 @@ static void rtl8169_init_ring_indexes(st
+ 	tp->dirty_tx = tp->cur_tx = tp->cur_rx = 0;
+ }
+ 
+-static void r8168c_hw_jumbo_enable(struct rtl8169_private *tp)
+-{
+-	RTL_W8(tp, Config3, RTL_R8(tp, Config3) | Jumbo_En0);
+-	RTL_W8(tp, Config4, RTL_R8(tp, Config4) | Jumbo_En1);
+-}
+-
+-static void r8168c_hw_jumbo_disable(struct rtl8169_private *tp)
+-{
+-	RTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Jumbo_En0);
+-	RTL_W8(tp, Config4, RTL_R8(tp, Config4) & ~Jumbo_En1);
+-}
+-
+-static void r8168dp_hw_jumbo_enable(struct rtl8169_private *tp)
+-{
+-	RTL_W8(tp, Config3, RTL_R8(tp, Config3) | Jumbo_En0);
+-}
+-
+-static void r8168dp_hw_jumbo_disable(struct rtl8169_private *tp)
+-{
+-	RTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Jumbo_En0);
+-}
+-
+-static void r8168e_hw_jumbo_enable(struct rtl8169_private *tp)
+-{
+-	RTL_W8(tp, MaxTxPacketSize, 0x24);
+-	RTL_W8(tp, Config3, RTL_R8(tp, Config3) | Jumbo_En0);
+-	RTL_W8(tp, Config4, RTL_R8(tp, Config4) | 0x01);
+-}
+-
+-static void r8168e_hw_jumbo_disable(struct rtl8169_private *tp)
+-{
+-	RTL_W8(tp, MaxTxPacketSize, 0x3f);
+-	RTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Jumbo_En0);
+-	RTL_W8(tp, Config4, RTL_R8(tp, Config4) & ~0x01);
+-}
+-
+-static void r8168b_1_hw_jumbo_enable(struct rtl8169_private *tp)
+-{
+-	RTL_W8(tp, Config4, RTL_R8(tp, Config4) | (1 << 0));
+-}
+-
+-static void r8168b_1_hw_jumbo_disable(struct rtl8169_private *tp)
+-{
+-	RTL_W8(tp, Config4, RTL_R8(tp, Config4) & ~(1 << 0));
+-}
+-
+ static void rtl_jumbo_config(struct rtl8169_private *tp)
+ {
+ 	bool jumbo = tp->dev->mtu > ETH_DATA_LEN;
+ 	int readrq = 4096;
+ 
++	if (jumbo && tp->mac_version >= RTL_GIGA_MAC_VER_17 &&
++	    tp->mac_version <= RTL_GIGA_MAC_VER_26)
++		readrq = 512;
++
+ 	rtl_unlock_config_regs(tp);
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_17:
+-		if (jumbo) {
+-			readrq = 512;
+-			r8168b_1_hw_jumbo_enable(tp);
+-		} else {
+-			r8168b_1_hw_jumbo_disable(tp);
+-		}
++		r8169_mod_reg8_cond(tp, Config4, BIT(0), jumbo);
+ 		break;
+ 	case RTL_GIGA_MAC_VER_18 ... RTL_GIGA_MAC_VER_26:
+-		if (jumbo) {
+-			readrq = 512;
+-			r8168c_hw_jumbo_enable(tp);
+-		} else {
+-			r8168c_hw_jumbo_disable(tp);
+-		}
++		r8169_mod_reg8_cond(tp, Config3, Jumbo_En0, jumbo);
++		r8169_mod_reg8_cond(tp, Config4, Jumbo_En1, jumbo);
+ 		break;
+ 	case RTL_GIGA_MAC_VER_28:
+-		if (jumbo)
+-			r8168dp_hw_jumbo_enable(tp);
+-		else
+-			r8168dp_hw_jumbo_disable(tp);
++		r8169_mod_reg8_cond(tp, Config3, Jumbo_En0, jumbo);
+ 		break;
+ 	case RTL_GIGA_MAC_VER_31 ... RTL_GIGA_MAC_VER_33:
+-		if (jumbo)
+-			r8168e_hw_jumbo_enable(tp);
+-		else
+-			r8168e_hw_jumbo_disable(tp);
++		RTL_W8(tp, MaxTxPacketSize, jumbo ? 0x24 : 0x3f);
++		r8169_mod_reg8_cond(tp, Config3, Jumbo_En0, jumbo);
++		r8169_mod_reg8_cond(tp, Config4, BIT(0), jumbo);
+ 		break;
+ 	default:
+ 		break;
diff --git a/target/linux/generic/backport-6.12/780-20-v6.13-r8169-copy-vendor-driver-2.5G-5G-EEE-advertisement-c.patch b/target/linux/generic/backport-6.12/780-20-v6.13-r8169-copy-vendor-driver-2.5G-5G-EEE-advertisement-c.patch
new file mode 100644
index 0000000000..96518cc6c4
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-20-v6.13-r8169-copy-vendor-driver-2.5G-5G-EEE-advertisement-c.patch
@@ -0,0 +1,82 @@
+From e340bff27e63ed61a1e9895bed546107859e48a7 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Fri, 8 Nov 2024 08:08:24 +0100
+Subject: [PATCH] r8169: copy vendor driver 2.5G/5G EEE advertisement
+ constraints
+
+Vendor driver r8125 doesn't advertise 2.5G EEE on RTL8125A, and r8126
+doesn't advertise 5G EEE. Likely there are compatibility issues,
+therefore do the same in r8169.
+With this change we don't have to disable 2.5G EEE advertisement in
+rtl8125a_config_eee_phy() any longer.
+We use new phylib accessor phy_set_eee_broken() to mark the respective
+EEE modes as broken.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/ce185e10-8a2f-4cf8-a49b-fd8fb3c3c8a1@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c       |  6 ++++++
+ drivers/net/ethernet/realtek/r8169_phy_config.c | 16 ++++------------
+ 2 files changed, 10 insertions(+), 12 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -5227,6 +5227,11 @@ static int r8169_mdio_register(struct rt
+ 		phy_support_eee(tp->phydev);
+ 	phy_support_asym_pause(tp->phydev);
+ 
++	/* mimic behavior of r8125/r8126 vendor drivers */
++	if (tp->mac_version == RTL_GIGA_MAC_VER_61)
++		tp->phydev->eee_broken_modes |= MDIO_EEE_2_5GT;
++	tp->phydev->eee_broken_modes |= MDIO_EEE_5GT;
++
+ 	/* PHY will be woken up in rtl_open() */
+ 	phy_suspend(tp->phydev);
+ 
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -96,15 +96,7 @@ static void rtl8125_common_config_eee_ph
+ 	phy_modify_paged(phydev, 0xa4a, 0x11, 0x0200, 0x0000);
+ }
+ 
+-static void rtl8125a_config_eee_phy(struct phy_device *phydev)
+-{
+-	rtl8168g_config_eee_phy(phydev);
+-	/* disable EEE at 2.5Gbps */
+-	phy_modify_paged(phydev, 0xa6d, 0x12, 0x0001, 0x0000);
+-	rtl8125_common_config_eee_phy(phydev);
+-}
+-
+-static void rtl8125b_config_eee_phy(struct phy_device *phydev)
++static void rtl8125_config_eee_phy(struct phy_device *phydev)
+ {
+ 	rtl8168g_config_eee_phy(phydev);
+ 	rtl8125_common_config_eee_phy(phydev);
+@@ -1066,7 +1058,7 @@ static void rtl8125a_2_hw_phy_config(str
+ 	rtl8168g_enable_gphy_10m(phydev);
+ 
+ 	rtl8168g_disable_aldps(phydev);
+-	rtl8125a_config_eee_phy(phydev);
++	rtl8125_config_eee_phy(phydev);
+ }
+ 
+ static void rtl8125b_hw_phy_config(struct rtl8169_private *tp,
+@@ -1106,7 +1098,7 @@ static void rtl8125b_hw_phy_config(struc
+ 
+ 	rtl8125_legacy_force_mode(phydev);
+ 	rtl8168g_disable_aldps(phydev);
+-	rtl8125b_config_eee_phy(phydev);
++	rtl8125_config_eee_phy(phydev);
+ }
+ 
+ static void rtl8125d_hw_phy_config(struct rtl8169_private *tp,
+@@ -1116,7 +1108,7 @@ static void rtl8125d_hw_phy_config(struc
+ 	rtl8168g_enable_gphy_10m(phydev);
+ 	rtl8125_legacy_force_mode(phydev);
+ 	rtl8168g_disable_aldps(phydev);
+-	rtl8125b_config_eee_phy(phydev);
++	rtl8125_config_eee_phy(phydev);
+ }
+ 
+ static void rtl8126a_hw_phy_config(struct rtl8169_private *tp,
diff --git a/target/linux/generic/backport-6.12/780-21-v6.14-r8169-remove-unused-flag-RTL_FLAG_TASK_RESET_NO_QUEU.patch b/target/linux/generic/backport-6.12/780-21-v6.14-r8169-remove-unused-flag-RTL_FLAG_TASK_RESET_NO_QUEU.patch
new file mode 100644
index 0000000000..5b1e633a63
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-21-v6.14-r8169-remove-unused-flag-RTL_FLAG_TASK_RESET_NO_QUEU.patch
@@ -0,0 +1,35 @@
+From 2e20bf8cc05766dcd0357cdfcada49e1bc45512b Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Mon, 2 Dec 2024 21:14:35 +0100
+Subject: [PATCH] r8169: remove unused flag RTL_FLAG_TASK_RESET_NO_QUEUE_WAKE
+
+After 854d71c555dfc3 ("r8169: remove original workaround for RTL8125
+broken rx issue") this flag isn't used any longer. So remove it.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
+Link: https://patch.msgid.link/d9dd214b-3027-4f60-b0e8-6f34a0c76582@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 3 ---
+ 1 file changed, 3 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -622,7 +622,6 @@ struct rtl8169_tc_offsets {
+ 
+ enum rtl_flag {
+ 	RTL_FLAG_TASK_RESET_PENDING,
+-	RTL_FLAG_TASK_RESET_NO_QUEUE_WAKE,
+ 	RTL_FLAG_TASK_TX_TIMEOUT,
+ 	RTL_FLAG_MAX
+ };
+@@ -4722,8 +4721,6 @@ static void rtl_task(struct work_struct
+ reset:
+ 		rtl_reset_work(tp);
+ 		netif_wake_queue(tp->dev);
+-	} else if (test_and_clear_bit(RTL_FLAG_TASK_RESET_NO_QUEUE_WAKE, tp->wk.flags)) {
+-		rtl_reset_work(tp);
+ 	}
+ }
+ 
diff --git a/target/linux/generic/backport-6.12/780-22-v6.14-r8169-remove-support-for-chip-version-11.patch b/target/linux/generic/backport-6.12/780-22-v6.14-r8169-remove-support-for-chip-version-11.patch
new file mode 100644
index 0000000000..e67e41d676
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-22-v6.14-r8169-remove-support-for-chip-version-11.patch
@@ -0,0 +1,114 @@
+From bb18265c3aba92b91a1355609769f3e967b65dee Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Mon, 2 Dec 2024 21:20:02 +0100
+Subject: [PATCH] r8169: remove support for chip version 11
+
+This is a follow-up to 982300c115d2 ("r8169: remove detection of chip
+version 11 (early RTL8168b)"). Nobody complained yet, so remove
+support for this chip version.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/b689ab6d-20b5-4b64-bd7e-531a0a972ba3@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169.h            |  2 +-
+ drivers/net/ethernet/realtek/r8169_main.c       | 14 +-------------
+ drivers/net/ethernet/realtek/r8169_phy_config.c | 10 ----------
+ 3 files changed, 2 insertions(+), 24 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169.h
++++ b/drivers/net/ethernet/realtek/r8169.h
+@@ -23,7 +23,7 @@ enum mac_version {
+ 	RTL_GIGA_MAC_VER_08,
+ 	RTL_GIGA_MAC_VER_09,
+ 	RTL_GIGA_MAC_VER_10,
+-	RTL_GIGA_MAC_VER_11,
++	/* support for RTL_GIGA_MAC_VER_11 has been removed */
+ 	/* RTL_GIGA_MAC_VER_12 was handled the same as VER_17 */
+ 	/* RTL_GIGA_MAC_VER_13 was merged with VER_10 */
+ 	RTL_GIGA_MAC_VER_14,
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -103,7 +103,6 @@ static const struct {
+ 	[RTL_GIGA_MAC_VER_08] = {"RTL8102e"				},
+ 	[RTL_GIGA_MAC_VER_09] = {"RTL8102e/RTL8103e"			},
+ 	[RTL_GIGA_MAC_VER_10] = {"RTL8101e/RTL8100e"			},
+-	[RTL_GIGA_MAC_VER_11] = {"RTL8168b/8111b"			},
+ 	[RTL_GIGA_MAC_VER_14] = {"RTL8401"				},
+ 	[RTL_GIGA_MAC_VER_17] = {"RTL8168b/8111b"			},
+ 	[RTL_GIGA_MAC_VER_18] = {"RTL8168cp/8111cp"			},
+@@ -2334,7 +2333,7 @@ static enum mac_version rtl8169_get_mac_
+ 
+ 		/* 8168B family. */
+ 		{ 0x7c8, 0x380,	RTL_GIGA_MAC_VER_17 },
+-		/* This one is very old and rare, let's see if anybody complains.
++		/* This one is very old and rare, support has been removed.
+ 		 * { 0x7c8, 0x300,	RTL_GIGA_MAC_VER_11 },
+ 		 */
+ 
+@@ -3802,7 +3801,6 @@ static void rtl_hw_config(struct rtl8169
+ 		[RTL_GIGA_MAC_VER_08] = rtl_hw_start_8102e_3,
+ 		[RTL_GIGA_MAC_VER_09] = rtl_hw_start_8102e_2,
+ 		[RTL_GIGA_MAC_VER_10] = NULL,
+-		[RTL_GIGA_MAC_VER_11] = rtl_hw_start_8168b,
+ 		[RTL_GIGA_MAC_VER_14] = rtl_hw_start_8401,
+ 		[RTL_GIGA_MAC_VER_17] = rtl_hw_start_8168b,
+ 		[RTL_GIGA_MAC_VER_18] = rtl_hw_start_8168cp_1,
+@@ -4678,12 +4676,6 @@ static irqreturn_t rtl8169_interrupt(int
+ 	if (status & LinkChg)
+ 		phy_mac_interrupt(tp->phydev);
+ 
+-	if (unlikely(status & RxFIFOOver &&
+-	    tp->mac_version == RTL_GIGA_MAC_VER_11)) {
+-		netif_stop_queue(tp->dev);
+-		rtl_schedule_task(tp, RTL_FLAG_TASK_RESET_PENDING);
+-	}
+-
+ 	rtl_irq_disable(tp);
+ 	napi_schedule(&tp->napi);
+ out:
+@@ -5099,9 +5091,6 @@ static void rtl_set_irq_mask(struct rtl8
+ 
+ 	if (tp->mac_version <= RTL_GIGA_MAC_VER_06)
+ 		tp->irq_mask |= SYSErr | RxFIFOOver;
+-	else if (tp->mac_version == RTL_GIGA_MAC_VER_11)
+-		/* special workaround needed */
+-		tp->irq_mask |= RxFIFOOver;
+ }
+ 
+ static int rtl_alloc_irq(struct rtl8169_private *tp)
+@@ -5295,7 +5284,6 @@ static int rtl_jumbo_max(struct rtl8169_
+ 	case RTL_GIGA_MAC_VER_02 ... RTL_GIGA_MAC_VER_06:
+ 		return JUMBO_7K;
+ 	/* RTL8168b */
+-	case RTL_GIGA_MAC_VER_11:
+ 	case RTL_GIGA_MAC_VER_17:
+ 		return JUMBO_4K;
+ 	/* RTL8168c */
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -276,15 +276,6 @@ static void rtl8169sce_hw_phy_config(str
+ 	rtl_writephy_batch(phydev, phy_reg_init);
+ }
+ 
+-static void rtl8168bb_hw_phy_config(struct rtl8169_private *tp,
+-				    struct phy_device *phydev)
+-{
+-	phy_write(phydev, 0x1f, 0x0001);
+-	phy_set_bits(phydev, 0x16, BIT(0));
+-	phy_write(phydev, 0x10, 0xf41b);
+-	phy_write(phydev, 0x1f, 0x0000);
+-}
+-
+ static void rtl8168bef_hw_phy_config(struct rtl8169_private *tp,
+ 				     struct phy_device *phydev)
+ {
+@@ -1136,7 +1127,6 @@ void r8169_hw_phy_config(struct rtl8169_
+ 		[RTL_GIGA_MAC_VER_08] = rtl8102e_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_09] = rtl8102e_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_10] = NULL,
+-		[RTL_GIGA_MAC_VER_11] = rtl8168bb_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_14] = rtl8401_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_17] = rtl8168bef_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_18] = rtl8168cp_1_hw_phy_config,
diff --git a/target/linux/generic/backport-6.12/780-23-v6.14-r8169-adjust-version-numbering-for-RTL8126.patch b/target/linux/generic/backport-6.12/780-23-v6.14-r8169-adjust-version-numbering-for-RTL8126.patch
new file mode 100644
index 0000000000..f769744444
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-23-v6.14-r8169-adjust-version-numbering-for-RTL8126.patch
@@ -0,0 +1,257 @@
+From b299ea0069284186b0d3d54aebe87f0d195d457a Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Fri, 13 Dec 2024 20:01:41 +0100
+Subject: [PATCH] r8169: adjust version numbering for RTL8126
+
+Adjust version numbering for RTL8126, so that it doesn't overlap with
+new RTL8125 versions.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/6a354364-20e9-48ad-a198-468264288757@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169.h          |  4 +-
+ drivers/net/ethernet/realtek/r8169_main.c     | 62 +++++++++----------
+ .../net/ethernet/realtek/r8169_phy_config.c   |  4 +-
+ 3 files changed, 35 insertions(+), 35 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169.h
++++ b/drivers/net/ethernet/realtek/r8169.h
+@@ -69,8 +69,8 @@ enum mac_version {
+ 	RTL_GIGA_MAC_VER_61,
+ 	RTL_GIGA_MAC_VER_63,
+ 	RTL_GIGA_MAC_VER_64,
+-	RTL_GIGA_MAC_VER_65,
+-	RTL_GIGA_MAC_VER_66,
++	RTL_GIGA_MAC_VER_70,
++	RTL_GIGA_MAC_VER_71,
+ 	RTL_GIGA_MAC_NONE
+ };
+ 
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -139,8 +139,8 @@ static const struct {
+ 	/* reserve 62 for CFG_METHOD_4 in the vendor driver */
+ 	[RTL_GIGA_MAC_VER_63] = {"RTL8125B",		FIRMWARE_8125B_2},
+ 	[RTL_GIGA_MAC_VER_64] = {"RTL8125D",		FIRMWARE_8125D_1},
+-	[RTL_GIGA_MAC_VER_65] = {"RTL8126A",		FIRMWARE_8126A_2},
+-	[RTL_GIGA_MAC_VER_66] = {"RTL8126A",		FIRMWARE_8126A_3},
++	[RTL_GIGA_MAC_VER_70] = {"RTL8126A",		FIRMWARE_8126A_2},
++	[RTL_GIGA_MAC_VER_71] = {"RTL8126A",		FIRMWARE_8126A_3},
+ };
+ 
+ static const struct pci_device_id rtl8169_pci_tbl[] = {
+@@ -1227,7 +1227,7 @@ static void rtl_writephy(struct rtl8169_
+ 	case RTL_GIGA_MAC_VER_31:
+ 		r8168dp_2_mdio_write(tp, location, val);
+ 		break;
+-	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_71:
+ 		r8168g_mdio_write(tp, location, val);
+ 		break;
+ 	default:
+@@ -1242,7 +1242,7 @@ static int rtl_readphy(struct rtl8169_pr
+ 	case RTL_GIGA_MAC_VER_28:
+ 	case RTL_GIGA_MAC_VER_31:
+ 		return r8168dp_2_mdio_read(tp, location);
+-	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_71:
+ 		return r8168g_mdio_read(tp, location);
+ 	default:
+ 		return r8169_mdio_read(tp, location);
+@@ -1573,7 +1573,7 @@ static void __rtl8169_set_wol(struct rtl
+ 		break;
+ 	case RTL_GIGA_MAC_VER_34:
+ 	case RTL_GIGA_MAC_VER_37:
+-	case RTL_GIGA_MAC_VER_39 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_39 ... RTL_GIGA_MAC_VER_71:
+ 		r8169_mod_reg8_cond(tp, Config2, PME_SIGNAL, wolopts);
+ 		break;
+ 	default:
+@@ -2046,7 +2046,7 @@ static void rtl_set_eee_txidle_timer(str
+ 		tp->tx_lpi_timer = timer_val;
+ 		r8168_mac_ocp_write(tp, 0xe048, timer_val);
+ 		break;
+-	case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_71:
+ 		tp->tx_lpi_timer = timer_val;
+ 		RTL_W16(tp, EEE_TXIDLE_TIMER_8125, timer_val);
+ 		break;
+@@ -2254,8 +2254,8 @@ static enum mac_version rtl8169_get_mac_
+ 		enum mac_version ver;
+ 	} mac_info[] = {
+ 		/* 8126A family. */
+-		{ 0x7cf, 0x64a,	RTL_GIGA_MAC_VER_66 },
+-		{ 0x7cf, 0x649,	RTL_GIGA_MAC_VER_65 },
++		{ 0x7cf, 0x64a,	RTL_GIGA_MAC_VER_71 },
++		{ 0x7cf, 0x649,	RTL_GIGA_MAC_VER_70 },
+ 
+ 		/* 8125D family. */
+ 		{ 0x7cf, 0x688,	RTL_GIGA_MAC_VER_64 },
+@@ -2525,7 +2525,7 @@ static void rtl_init_rxcfg(struct rtl816
+ 	case RTL_GIGA_MAC_VER_61:
+ 		RTL_W32(tp, RxConfig, RX_FETCH_DFLT_8125 | RX_DMA_BURST);
+ 		break;
+-	case RTL_GIGA_MAC_VER_63 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_63 ... RTL_GIGA_MAC_VER_71:
+ 		RTL_W32(tp, RxConfig, RX_FETCH_DFLT_8125 | RX_DMA_BURST |
+ 			RX_PAUSE_SLOT_ON);
+ 		break;
+@@ -2657,7 +2657,7 @@ static void rtl_wait_txrx_fifo_empty(str
+ 	case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_61:
+ 		rtl_loop_wait_high(tp, &rtl_rxtx_empty_cond, 100, 42);
+ 		break;
+-	case RTL_GIGA_MAC_VER_63 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_63 ... RTL_GIGA_MAC_VER_71:
+ 		RTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) | StopReq);
+ 		rtl_loop_wait_high(tp, &rtl_rxtx_empty_cond, 100, 42);
+ 		rtl_loop_wait_high(tp, &rtl_rxtx_empty_cond_2, 100, 42);
+@@ -2900,7 +2900,7 @@ static void rtl_enable_exit_l1(struct rt
+ 	case RTL_GIGA_MAC_VER_37 ... RTL_GIGA_MAC_VER_38:
+ 		rtl_eri_set_bits(tp, 0xd4, 0x0c00);
+ 		break;
+-	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_71:
+ 		r8168_mac_ocp_modify(tp, 0xc0ac, 0, 0x1f80);
+ 		break;
+ 	default:
+@@ -2914,7 +2914,7 @@ static void rtl_disable_exit_l1(struct r
+ 	case RTL_GIGA_MAC_VER_34 ... RTL_GIGA_MAC_VER_38:
+ 		rtl_eri_clear_bits(tp, 0xd4, 0x1f00);
+ 		break;
+-	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_71:
+ 		r8168_mac_ocp_modify(tp, 0xc0ac, 0x1f80, 0);
+ 		break;
+ 	default:
+@@ -2940,8 +2940,8 @@ static void rtl_hw_aspm_clkreq_enable(st
+ 
+ 		rtl_mod_config5(tp, 0, ASPM_en);
+ 		switch (tp->mac_version) {
+-		case RTL_GIGA_MAC_VER_65:
+-		case RTL_GIGA_MAC_VER_66:
++		case RTL_GIGA_MAC_VER_70:
++		case RTL_GIGA_MAC_VER_71:
+ 			val8 = RTL_R8(tp, INT_CFG0_8125) | INT_CFG0_CLKREQEN;
+ 			RTL_W8(tp, INT_CFG0_8125, val8);
+ 			break;
+@@ -2952,7 +2952,7 @@ static void rtl_hw_aspm_clkreq_enable(st
+ 
+ 		switch (tp->mac_version) {
+ 		case RTL_GIGA_MAC_VER_46 ... RTL_GIGA_MAC_VER_48:
+-		case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_66:
++		case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_71:
+ 			/* reset ephy tx/rx disable timer */
+ 			r8168_mac_ocp_modify(tp, 0xe094, 0xff00, 0);
+ 			/* chip can trigger L1.2 */
+@@ -2964,7 +2964,7 @@ static void rtl_hw_aspm_clkreq_enable(st
+ 	} else {
+ 		switch (tp->mac_version) {
+ 		case RTL_GIGA_MAC_VER_46 ... RTL_GIGA_MAC_VER_48:
+-		case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_66:
++		case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_71:
+ 			r8168_mac_ocp_modify(tp, 0xe092, 0x00ff, 0);
+ 			break;
+ 		default:
+@@ -2972,8 +2972,8 @@ static void rtl_hw_aspm_clkreq_enable(st
+ 		}
+ 
+ 		switch (tp->mac_version) {
+-		case RTL_GIGA_MAC_VER_65:
+-		case RTL_GIGA_MAC_VER_66:
++		case RTL_GIGA_MAC_VER_70:
++		case RTL_GIGA_MAC_VER_71:
+ 			val8 = RTL_R8(tp, INT_CFG0_8125) & ~INT_CFG0_CLKREQEN;
+ 			RTL_W8(tp, INT_CFG0_8125, val8);
+ 			break;
+@@ -3693,12 +3693,12 @@ static void rtl_hw_start_8125_common(str
+ 	/* disable new tx descriptor format */
+ 	r8168_mac_ocp_modify(tp, 0xeb58, 0x0001, 0x0000);
+ 
+-	if (tp->mac_version == RTL_GIGA_MAC_VER_65 ||
+-	    tp->mac_version == RTL_GIGA_MAC_VER_66)
++	if (tp->mac_version == RTL_GIGA_MAC_VER_70 ||
++	    tp->mac_version == RTL_GIGA_MAC_VER_71)
+ 		RTL_W8(tp, 0xD8, RTL_R8(tp, 0xD8) & ~0x02);
+ 
+-	if (tp->mac_version == RTL_GIGA_MAC_VER_65 ||
+-	    tp->mac_version == RTL_GIGA_MAC_VER_66)
++	if (tp->mac_version == RTL_GIGA_MAC_VER_70 ||
++	    tp->mac_version == RTL_GIGA_MAC_VER_71)
+ 		r8168_mac_ocp_modify(tp, 0xe614, 0x0700, 0x0400);
+ 	else if (tp->mac_version == RTL_GIGA_MAC_VER_63)
+ 		r8168_mac_ocp_modify(tp, 0xe614, 0x0700, 0x0200);
+@@ -3716,8 +3716,8 @@ static void rtl_hw_start_8125_common(str
+ 	r8168_mac_ocp_modify(tp, 0xe056, 0x00f0, 0x0030);
+ 	r8168_mac_ocp_modify(tp, 0xe040, 0x1000, 0x0000);
+ 	r8168_mac_ocp_modify(tp, 0xea1c, 0x0003, 0x0001);
+-	if (tp->mac_version == RTL_GIGA_MAC_VER_65 ||
+-	    tp->mac_version == RTL_GIGA_MAC_VER_66)
++	if (tp->mac_version == RTL_GIGA_MAC_VER_70 ||
++	    tp->mac_version == RTL_GIGA_MAC_VER_71)
+ 		r8168_mac_ocp_modify(tp, 0xea1c, 0x0300, 0x0000);
+ 	else
+ 		r8168_mac_ocp_modify(tp, 0xea1c, 0x0004, 0x0000);
+@@ -3836,8 +3836,8 @@ static void rtl_hw_config(struct rtl8169
+ 		[RTL_GIGA_MAC_VER_61] = rtl_hw_start_8125a_2,
+ 		[RTL_GIGA_MAC_VER_63] = rtl_hw_start_8125b,
+ 		[RTL_GIGA_MAC_VER_64] = rtl_hw_start_8125d,
+-		[RTL_GIGA_MAC_VER_65] = rtl_hw_start_8126a,
+-		[RTL_GIGA_MAC_VER_66] = rtl_hw_start_8126a,
++		[RTL_GIGA_MAC_VER_70] = rtl_hw_start_8126a,
++		[RTL_GIGA_MAC_VER_71] = rtl_hw_start_8126a,
+ 	};
+ 
+ 	if (hw_configs[tp->mac_version])
+@@ -3858,8 +3858,8 @@ static void rtl_hw_start_8125(struct rtl
+ 			RTL_W32(tp, i, 0);
+ 		break;
+ 	case RTL_GIGA_MAC_VER_63:
+-	case RTL_GIGA_MAC_VER_65:
+-	case RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_70:
++	case RTL_GIGA_MAC_VER_71:
+ 		for (i = 0xa00; i < 0xa80; i += 4)
+ 			RTL_W32(tp, i, 0);
+ 		RTL_W16(tp, INT_CFG1_8125, 0x0000);
+@@ -4091,7 +4091,7 @@ static void rtl8169_cleanup(struct rtl81
+ 		RTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) | StopReq);
+ 		rtl_loop_wait_high(tp, &rtl_txcfg_empty_cond, 100, 666);
+ 		break;
+-	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_71:
+ 		rtl_enable_rxdvgate(tp);
+ 		fsleep(2000);
+ 		break;
+@@ -4248,7 +4248,7 @@ static unsigned int rtl_quirk_packet_pad
+ 
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_34:
+-	case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_71:
+ 		padto = max_t(unsigned int, padto, ETH_ZLEN);
+ 		break;
+ 	default:
+@@ -5265,7 +5265,7 @@ static void rtl_hw_initialize(struct rtl
+ 	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_48:
+ 		rtl_hw_init_8168g(tp);
+ 		break;
+-	case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_66:
++	case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_71:
+ 		rtl_hw_init_8125(tp);
+ 		break;
+ 	default:
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -1162,8 +1162,8 @@ void r8169_hw_phy_config(struct rtl8169_
+ 		[RTL_GIGA_MAC_VER_61] = rtl8125a_2_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_63] = rtl8125b_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_64] = rtl8125d_hw_phy_config,
+-		[RTL_GIGA_MAC_VER_65] = rtl8126a_hw_phy_config,
+-		[RTL_GIGA_MAC_VER_66] = rtl8126a_hw_phy_config,
++		[RTL_GIGA_MAC_VER_70] = rtl8126a_hw_phy_config,
++		[RTL_GIGA_MAC_VER_71] = rtl8126a_hw_phy_config,
+ 	};
+ 
+ 	if (phy_configs[ver])
diff --git a/target/linux/generic/backport-6.12/780-24-v6.14-r8169-add-support-for-RTL8125D-rev.b.patch b/target/linux/generic/backport-6.12/780-24-v6.14-r8169-add-support-for-RTL8125D-rev.b.patch
new file mode 100644
index 0000000000..eb565b751d
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-24-v6.14-r8169-add-support-for-RTL8125D-rev.b.patch
@@ -0,0 +1,90 @@
+From b3593df26ab19f114d613693fa8a92ab202803d0 Mon Sep 17 00:00:00 2001
+From: ChunHao Lin <hau@realtek.com>
+Date: Fri, 13 Dec 2024 20:02:58 +0100
+Subject: [PATCH] r8169: add support for RTL8125D rev.b
+
+Add support for RTL8125D rev.b. Its XID is 0x689. It is basically
+based on the one with XID 0x688, but with different firmware file.
+
+Signed-off-by: ChunHao Lin <hau@realtek.com>
+[hkallweit1@gmail.com: rebased after adjusted version numbering]
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/75e5e9ec-d01f-43ac-b0f4-e7456baf18d1@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169.h            | 1 +
+ drivers/net/ethernet/realtek/r8169_main.c       | 6 ++++++
+ drivers/net/ethernet/realtek/r8169_phy_config.c | 1 +
+ 3 files changed, 8 insertions(+)
+
+--- a/drivers/net/ethernet/realtek/r8169.h
++++ b/drivers/net/ethernet/realtek/r8169.h
+@@ -69,6 +69,7 @@ enum mac_version {
+ 	RTL_GIGA_MAC_VER_61,
+ 	RTL_GIGA_MAC_VER_63,
+ 	RTL_GIGA_MAC_VER_64,
++	RTL_GIGA_MAC_VER_65,
+ 	RTL_GIGA_MAC_VER_70,
+ 	RTL_GIGA_MAC_VER_71,
+ 	RTL_GIGA_MAC_NONE
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -56,6 +56,7 @@
+ #define FIRMWARE_8125A_3	"rtl_nic/rtl8125a-3.fw"
+ #define FIRMWARE_8125B_2	"rtl_nic/rtl8125b-2.fw"
+ #define FIRMWARE_8125D_1	"rtl_nic/rtl8125d-1.fw"
++#define FIRMWARE_8125D_2	"rtl_nic/rtl8125d-2.fw"
+ #define FIRMWARE_8126A_2	"rtl_nic/rtl8126a-2.fw"
+ #define FIRMWARE_8126A_3	"rtl_nic/rtl8126a-3.fw"
+ 
+@@ -139,6 +140,7 @@ static const struct {
+ 	/* reserve 62 for CFG_METHOD_4 in the vendor driver */
+ 	[RTL_GIGA_MAC_VER_63] = {"RTL8125B",		FIRMWARE_8125B_2},
+ 	[RTL_GIGA_MAC_VER_64] = {"RTL8125D",		FIRMWARE_8125D_1},
++	[RTL_GIGA_MAC_VER_65] = {"RTL8125D",		FIRMWARE_8125D_2},
+ 	[RTL_GIGA_MAC_VER_70] = {"RTL8126A",		FIRMWARE_8126A_2},
+ 	[RTL_GIGA_MAC_VER_71] = {"RTL8126A",		FIRMWARE_8126A_3},
+ };
+@@ -705,6 +707,7 @@ MODULE_FIRMWARE(FIRMWARE_8107E_2);
+ MODULE_FIRMWARE(FIRMWARE_8125A_3);
+ MODULE_FIRMWARE(FIRMWARE_8125B_2);
+ MODULE_FIRMWARE(FIRMWARE_8125D_1);
++MODULE_FIRMWARE(FIRMWARE_8125D_2);
+ MODULE_FIRMWARE(FIRMWARE_8126A_2);
+ MODULE_FIRMWARE(FIRMWARE_8126A_3);
+ 
+@@ -2258,6 +2261,7 @@ static enum mac_version rtl8169_get_mac_
+ 		{ 0x7cf, 0x649,	RTL_GIGA_MAC_VER_70 },
+ 
+ 		/* 8125D family. */
++		{ 0x7cf, 0x689,	RTL_GIGA_MAC_VER_65 },
+ 		{ 0x7cf, 0x688,	RTL_GIGA_MAC_VER_64 },
+ 
+ 		/* 8125B family. */
+@@ -3836,6 +3840,7 @@ static void rtl_hw_config(struct rtl8169
+ 		[RTL_GIGA_MAC_VER_61] = rtl_hw_start_8125a_2,
+ 		[RTL_GIGA_MAC_VER_63] = rtl_hw_start_8125b,
+ 		[RTL_GIGA_MAC_VER_64] = rtl_hw_start_8125d,
++		[RTL_GIGA_MAC_VER_65] = rtl_hw_start_8125d,
+ 		[RTL_GIGA_MAC_VER_70] = rtl_hw_start_8126a,
+ 		[RTL_GIGA_MAC_VER_71] = rtl_hw_start_8126a,
+ 	};
+@@ -3854,6 +3859,7 @@ static void rtl_hw_start_8125(struct rtl
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_61:
+ 	case RTL_GIGA_MAC_VER_64:
++	case RTL_GIGA_MAC_VER_65:
+ 		for (i = 0xa00; i < 0xb00; i += 4)
+ 			RTL_W32(tp, i, 0);
+ 		break;
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -1162,6 +1162,7 @@ void r8169_hw_phy_config(struct rtl8169_
+ 		[RTL_GIGA_MAC_VER_61] = rtl8125a_2_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_63] = rtl8125b_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_64] = rtl8125d_hw_phy_config,
++		[RTL_GIGA_MAC_VER_65] = rtl8125d_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_70] = rtl8126a_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_71] = rtl8126a_hw_phy_config,
+ 	};
diff --git a/target/linux/generic/backport-6.12/780-25-v6.14-r8169-add-support-for-RTL8125BP-rev.b.patch b/target/linux/generic/backport-6.12/780-25-v6.14-r8169-add-support-for-RTL8125BP-rev.b.patch
new file mode 100644
index 0000000000..35b68bb9c9
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-25-v6.14-r8169-add-support-for-RTL8125BP-rev.b.patch
@@ -0,0 +1,184 @@
+From b11bff90f2ad52c5c55c822ecd20326619a73898 Mon Sep 17 00:00:00 2001
+From: ChunHao Lin <hau@realtek.com>
+Date: Tue, 7 Jan 2025 14:43:55 +0800
+Subject: [PATCH] r8169: add support for RTL8125BP rev.b
+
+Add support for RTL8125BP rev.b. Its XID is 0x689. This chip supports
+DASH and its dash type is "RTL_DASH_25_BP".
+
+Signed-off-by: ChunHao Lin <hau@realtek.com>
+Reviewed-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/20250107064355.104711-1-hau@realtek.com
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/ethernet/realtek/r8169.h          |  1 +
+ drivers/net/ethernet/realtek/r8169_main.c     | 30 +++++++++++++++++++
+ .../net/ethernet/realtek/r8169_phy_config.c   | 23 ++++++++++++++
+ 3 files changed, 54 insertions(+)
+
+--- a/drivers/net/ethernet/realtek/r8169.h
++++ b/drivers/net/ethernet/realtek/r8169.h
+@@ -70,6 +70,7 @@ enum mac_version {
+ 	RTL_GIGA_MAC_VER_63,
+ 	RTL_GIGA_MAC_VER_64,
+ 	RTL_GIGA_MAC_VER_65,
++	RTL_GIGA_MAC_VER_66,
+ 	RTL_GIGA_MAC_VER_70,
+ 	RTL_GIGA_MAC_VER_71,
+ 	RTL_GIGA_MAC_NONE
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -57,6 +57,7 @@
+ #define FIRMWARE_8125B_2	"rtl_nic/rtl8125b-2.fw"
+ #define FIRMWARE_8125D_1	"rtl_nic/rtl8125d-1.fw"
+ #define FIRMWARE_8125D_2	"rtl_nic/rtl8125d-2.fw"
++#define FIRMWARE_8125BP_2	"rtl_nic/rtl8125bp-2.fw"
+ #define FIRMWARE_8126A_2	"rtl_nic/rtl8126a-2.fw"
+ #define FIRMWARE_8126A_3	"rtl_nic/rtl8126a-3.fw"
+ 
+@@ -141,6 +142,7 @@ static const struct {
+ 	[RTL_GIGA_MAC_VER_63] = {"RTL8125B",		FIRMWARE_8125B_2},
+ 	[RTL_GIGA_MAC_VER_64] = {"RTL8125D",		FIRMWARE_8125D_1},
+ 	[RTL_GIGA_MAC_VER_65] = {"RTL8125D",		FIRMWARE_8125D_2},
++	[RTL_GIGA_MAC_VER_66] = {"RTL8125BP",		FIRMWARE_8125BP_2},
+ 	[RTL_GIGA_MAC_VER_70] = {"RTL8126A",		FIRMWARE_8126A_2},
+ 	[RTL_GIGA_MAC_VER_71] = {"RTL8126A",		FIRMWARE_8126A_3},
+ };
+@@ -631,6 +633,7 @@ enum rtl_dash_type {
+ 	RTL_DASH_NONE,
+ 	RTL_DASH_DP,
+ 	RTL_DASH_EP,
++	RTL_DASH_25_BP,
+ };
+ 
+ struct rtl8169_private {
+@@ -708,6 +711,7 @@ MODULE_FIRMWARE(FIRMWARE_8125A_3);
+ MODULE_FIRMWARE(FIRMWARE_8125B_2);
+ MODULE_FIRMWARE(FIRMWARE_8125D_1);
+ MODULE_FIRMWARE(FIRMWARE_8125D_2);
++MODULE_FIRMWARE(FIRMWARE_8125BP_2);
+ MODULE_FIRMWARE(FIRMWARE_8126A_2);
+ MODULE_FIRMWARE(FIRMWARE_8126A_3);
+ 
+@@ -1360,10 +1364,19 @@ static void rtl8168ep_driver_start(struc
+ 		rtl_loop_wait_high(tp, &rtl_ep_ocp_read_cond, 10000, 30);
+ }
+ 
++static void rtl8125bp_driver_start(struct rtl8169_private *tp)
++{
++	r8168ep_ocp_write(tp, 0x01, 0x14, OOB_CMD_DRIVER_START);
++	r8168ep_ocp_write(tp, 0x01, 0x18, 0x00);
++	r8168ep_ocp_write(tp, 0x01, 0x10, 0x01);
++}
++
+ static void rtl8168_driver_start(struct rtl8169_private *tp)
+ {
+ 	if (tp->dash_type == RTL_DASH_DP)
+ 		rtl8168dp_driver_start(tp);
++	else if (tp->dash_type == RTL_DASH_25_BP)
++		rtl8125bp_driver_start(tp);
+ 	else
+ 		rtl8168ep_driver_start(tp);
+ }
+@@ -1384,10 +1397,19 @@ static void rtl8168ep_driver_stop(struct
+ 		rtl_loop_wait_low(tp, &rtl_ep_ocp_read_cond, 10000, 10);
+ }
+ 
++static void rtl8125bp_driver_stop(struct rtl8169_private *tp)
++{
++	r8168ep_ocp_write(tp, 0x01, 0x14, OOB_CMD_DRIVER_STOP);
++	r8168ep_ocp_write(tp, 0x01, 0x18, 0x00);
++	r8168ep_ocp_write(tp, 0x01, 0x10, 0x01);
++}
++
+ static void rtl8168_driver_stop(struct rtl8169_private *tp)
+ {
+ 	if (tp->dash_type == RTL_DASH_DP)
+ 		rtl8168dp_driver_stop(tp);
++	else if (tp->dash_type == RTL_DASH_25_BP)
++		rtl8125bp_driver_stop(tp);
+ 	else
+ 		rtl8168ep_driver_stop(tp);
+ }
+@@ -1410,6 +1432,7 @@ static bool rtl_dash_is_enabled(struct r
+ 	case RTL_DASH_DP:
+ 		return r8168dp_check_dash(tp);
+ 	case RTL_DASH_EP:
++	case RTL_DASH_25_BP:
+ 		return r8168ep_check_dash(tp);
+ 	default:
+ 		return false;
+@@ -1424,6 +1447,8 @@ static enum rtl_dash_type rtl_get_dash_t
+ 		return RTL_DASH_DP;
+ 	case RTL_GIGA_MAC_VER_51 ... RTL_GIGA_MAC_VER_53:
+ 		return RTL_DASH_EP;
++	case RTL_GIGA_MAC_VER_66:
++		return RTL_DASH_25_BP;
+ 	default:
+ 		return RTL_DASH_NONE;
+ 	}
+@@ -2260,6 +2285,9 @@ static enum mac_version rtl8169_get_mac_
+ 		{ 0x7cf, 0x64a,	RTL_GIGA_MAC_VER_71 },
+ 		{ 0x7cf, 0x649,	RTL_GIGA_MAC_VER_70 },
+ 
++		/* 8125BP family. */
++		{ 0x7cf, 0x681,	RTL_GIGA_MAC_VER_66 },
++
+ 		/* 8125D family. */
+ 		{ 0x7cf, 0x689,	RTL_GIGA_MAC_VER_65 },
+ 		{ 0x7cf, 0x688,	RTL_GIGA_MAC_VER_64 },
+@@ -3841,6 +3869,7 @@ static void rtl_hw_config(struct rtl8169
+ 		[RTL_GIGA_MAC_VER_63] = rtl_hw_start_8125b,
+ 		[RTL_GIGA_MAC_VER_64] = rtl_hw_start_8125d,
+ 		[RTL_GIGA_MAC_VER_65] = rtl_hw_start_8125d,
++		[RTL_GIGA_MAC_VER_66] = rtl_hw_start_8125d,
+ 		[RTL_GIGA_MAC_VER_70] = rtl_hw_start_8126a,
+ 		[RTL_GIGA_MAC_VER_71] = rtl_hw_start_8126a,
+ 	};
+@@ -3860,6 +3889,7 @@ static void rtl_hw_start_8125(struct rtl
+ 	case RTL_GIGA_MAC_VER_61:
+ 	case RTL_GIGA_MAC_VER_64:
+ 	case RTL_GIGA_MAC_VER_65:
++	case RTL_GIGA_MAC_VER_66:
+ 		for (i = 0xa00; i < 0xb00; i += 4)
+ 			RTL_W32(tp, i, 0);
+ 		break;
+--- a/drivers/net/ethernet/realtek/r8169_phy_config.c
++++ b/drivers/net/ethernet/realtek/r8169_phy_config.c
+@@ -1102,6 +1102,28 @@ static void rtl8125d_hw_phy_config(struc
+ 	rtl8125_config_eee_phy(phydev);
+ }
+ 
++static void rtl8125bp_hw_phy_config(struct rtl8169_private *tp,
++				    struct phy_device *phydev)
++{
++	r8169_apply_firmware(tp);
++	rtl8168g_enable_gphy_10m(phydev);
++
++	r8168g_phy_param(phydev, 0x8010, 0x0800, 0x0000);
++
++	phy_write(phydev, 0x1f, 0x0b87);
++	phy_write(phydev, 0x16, 0x8088);
++	phy_modify(phydev, 0x17, 0xff00, 0x9000);
++	phy_write(phydev, 0x16, 0x808f);
++	phy_modify(phydev, 0x17, 0xff00, 0x9000);
++	phy_write(phydev, 0x1f, 0x0000);
++
++	r8168g_phy_param(phydev, 0x8174, 0x2000, 0x1800);
++
++	rtl8125_legacy_force_mode(phydev);
++	rtl8168g_disable_aldps(phydev);
++	rtl8125_config_eee_phy(phydev);
++}
++
+ static void rtl8126a_hw_phy_config(struct rtl8169_private *tp,
+ 				   struct phy_device *phydev)
+ {
+@@ -1163,6 +1185,7 @@ void r8169_hw_phy_config(struct rtl8169_
+ 		[RTL_GIGA_MAC_VER_63] = rtl8125b_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_64] = rtl8125d_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_65] = rtl8125d_hw_phy_config,
++		[RTL_GIGA_MAC_VER_66] = rtl8125bp_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_70] = rtl8126a_hw_phy_config,
+ 		[RTL_GIGA_MAC_VER_71] = rtl8126a_hw_phy_config,
+ 	};
diff --git a/target/linux/generic/backport-6.12/780-26-v6.15-r8169-make-Kconfig-option-for-LED-support-user-visib.patch b/target/linux/generic/backport-6.12/780-26-v6.15-r8169-make-Kconfig-option-for-LED-support-user-visib.patch
new file mode 100644
index 0000000000..62acd26963
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-26-v6.15-r8169-make-Kconfig-option-for-LED-support-user-visib.patch
@@ -0,0 +1,28 @@
+From 135c3c86a7cef4ba3d368da15b16c275b74582d3 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Mon, 3 Feb 2025 21:35:24 +0100
+Subject: [PATCH] r8169: make Kconfig option for LED support user-visible
+
+Make config option R8169_LEDS user-visible, so that users can remove
+support if not needed.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/d29f0cdb-32bf-435f-b59d-dc96bca1e3ab@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/Kconfig | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/realtek/Kconfig
++++ b/drivers/net/ethernet/realtek/Kconfig
+@@ -114,7 +114,8 @@ config R8169
+ 	  will be called r8169.  This is recommended.
+ 
+ config R8169_LEDS
+-	def_bool R8169 && LEDS_TRIGGER_NETDEV
++	bool "Support for controlling the NIC LEDs"
++	depends on R8169 && LEDS_TRIGGER_NETDEV
+ 	depends on !(R8169=y && LEDS_CLASS=m)
+ 	help
+ 	  Optional support for controlling the NIC LED's with the netdev
diff --git a/target/linux/generic/backport-6.12/780-27-v6.15-r8169-don-t-scan-PHY-addresses-0.patch b/target/linux/generic/backport-6.12/780-27-v6.15-r8169-don-t-scan-PHY-addresses-0.patch
new file mode 100644
index 0000000000..b6ddc76ca8
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-27-v6.15-r8169-don-t-scan-PHY-addresses-0.patch
@@ -0,0 +1,26 @@
+From faac69a4ae5abb49e62c79c66b51bb905c9aa5ec Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Tue, 4 Feb 2025 07:58:17 +0100
+Subject: [PATCH] r8169: don't scan PHY addresses > 0
+
+The PHY address is a dummy, because r8169 PHY access registers
+don't support a PHY address. Therefore scan address 0 only.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/830637dd-4016-4a68-92b3-618fcac6589d@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -5222,6 +5222,7 @@ static int r8169_mdio_register(struct rt
+ 	new_bus->priv = tp;
+ 	new_bus->parent = &pdev->dev;
+ 	new_bus->irq[0] = PHY_MAC_INTERRUPT;
++	new_bus->phy_mask = GENMASK(31, 1);
+ 	snprintf(new_bus->id, MII_BUS_ID_SIZE, "r8169-%x-%x",
+ 		 pci_domain_nr(pdev->bus), pci_dev_id(pdev));
+ 
diff --git a/target/linux/generic/backport-6.12/780-28-v6.15-r8169-add-support-for-Intel-Killer-E5000.patch b/target/linux/generic/backport-6.12/780-28-v6.15-r8169-add-support-for-Intel-Killer-E5000.patch
new file mode 100644
index 0000000000..d741d193ab
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-28-v6.15-r8169-add-support-for-Intel-Killer-E5000.patch
@@ -0,0 +1,25 @@
+From d30460f42675fef5cd4b44ffbc49b545524555e3 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 12 Feb 2025 08:03:56 +0100
+Subject: [PATCH] r8169: add support for Intel Killer E5000
+
+This adds support for the Intel Killer E5000 which seems to be a
+rebranded RTL8126. Copied from r8126 vendor driver.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/9db73e9b-e2e8-45de-97a5-041c5f71d774@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -169,6 +169,7 @@ static const struct pci_device_id rtl816
+ 	{ PCI_VDEVICE(REALTEK,	0x8125) },
+ 	{ PCI_VDEVICE(REALTEK,	0x8126) },
+ 	{ PCI_VDEVICE(REALTEK,	0x3000) },
++	{ PCI_VDEVICE(REALTEK,	0x5000) },
+ 	{}
+ };
+ 
diff --git a/target/linux/generic/backport-6.12/780-29-v6.15-r8169-add-PHY-c45-ops-for-MDIO_MMD_VENDOR2-registers.patch b/target/linux/generic/backport-6.12/780-29-v6.15-r8169-add-PHY-c45-ops-for-MDIO_MMD_VENDOR2-registers.patch
new file mode 100644
index 0000000000..165d7da1be
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-29-v6.15-r8169-add-PHY-c45-ops-for-MDIO_MMD_VENDOR2-registers.patch
@@ -0,0 +1,67 @@
+From 853e80369cfceb2331bf34f251ba11c6602cc67f Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 13 Feb 2025 20:15:42 +0100
+Subject: [PATCH] r8169: add PHY c45 ops for MDIO_MMD_VENDOR2 registers
+
+The integrated PHYs on chip versions from RTL8168g allow to address
+MDIO_MMD_VEND2 registers. All c22 standard registers are mapped to
+MDIO_MMD_VEND2 registers. So far the paging mechanism is used to
+address PHY registers. Add support for c45 ops to address MDIO_MMD_VEND2
+registers directly, w/o the paging.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/d6f97eaa-0f13-468f-89cb-75a41087bc4a@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 32 +++++++++++++++++++++++
+ 1 file changed, 32 insertions(+)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -5200,6 +5200,33 @@ static int r8169_mdio_write_reg(struct m
+ 	return 0;
+ }
+ 
++static int r8169_mdio_read_reg_c45(struct mii_bus *mii_bus, int addr,
++				   int devnum, int regnum)
++{
++	struct rtl8169_private *tp = mii_bus->priv;
++
++	if (addr > 0)
++		return -ENODEV;
++
++	if (devnum == MDIO_MMD_VEND2 && regnum > MDIO_STAT2)
++		return r8168_phy_ocp_read(tp, regnum);
++
++	return 0;
++}
++
++static int r8169_mdio_write_reg_c45(struct mii_bus *mii_bus, int addr,
++				    int devnum, int regnum, u16 val)
++{
++	struct rtl8169_private *tp = mii_bus->priv;
++
++	if (addr > 0 || devnum != MDIO_MMD_VEND2 || regnum <= MDIO_STAT2)
++		return -ENODEV;
++
++	r8168_phy_ocp_write(tp, regnum, val);
++
++	return 0;
++}
++
+ static int r8169_mdio_register(struct rtl8169_private *tp)
+ {
+ 	struct pci_dev *pdev = tp->pci_dev;
+@@ -5230,6 +5257,11 @@ static int r8169_mdio_register(struct rt
+ 	new_bus->read = r8169_mdio_read_reg;
+ 	new_bus->write = r8169_mdio_write_reg;
+ 
++	if (tp->mac_version >= RTL_GIGA_MAC_VER_40) {
++		new_bus->read_c45 = r8169_mdio_read_reg_c45;
++		new_bus->write_c45 = r8169_mdio_write_reg_c45;
++	}
++
+ 	ret = devm_mdiobus_register(&pdev->dev, new_bus);
+ 	if (ret)
+ 		return ret;
diff --git a/target/linux/generic/backport-6.12/780-30-v6.15-r8169-increase-max-jumbo-packet-size-on-RTL8125-RTL8.patch b/target/linux/generic/backport-6.12/780-30-v6.15-r8169-increase-max-jumbo-packet-size-on-RTL8125-RTL8.patch
new file mode 100644
index 0000000000..559f742ebe
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-30-v6.15-r8169-increase-max-jumbo-packet-size-on-RTL8125-RTL8.patch
@@ -0,0 +1,40 @@
+From 473367a5ffe1607a61be481e2feda684eb5faea9 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Fri, 7 Mar 2025 08:29:47 +0100
+Subject: [PATCH] r8169: increase max jumbo packet size on RTL8125/RTL8126
+
+Realtek confirmed that all RTL8125/RTL8126 chip versions support up to
+16K jumbo packets. Reflect this in the driver.
+
+Tested by Rui on RTL8125B with 12K jumbo packets.
+
+Suggested-by: Rui Salvaterra <rsalvaterra@gmail.com>
+Tested-by: Rui Salvaterra <rsalvaterra@gmail.com>
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/396762ad-cc65-4e60-b01e-8847db89e98b@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -89,6 +89,7 @@
+ #define JUMBO_6K	(6 * SZ_1K - VLAN_ETH_HLEN - ETH_FCS_LEN)
+ #define JUMBO_7K	(7 * SZ_1K - VLAN_ETH_HLEN - ETH_FCS_LEN)
+ #define JUMBO_9K	(9 * SZ_1K - VLAN_ETH_HLEN - ETH_FCS_LEN)
++#define JUMBO_16K	(SZ_16K - VLAN_ETH_HLEN - ETH_FCS_LEN)
+ 
+ static const struct {
+ 	const char *name;
+@@ -5359,6 +5360,9 @@ static int rtl_jumbo_max(struct rtl8169_
+ 	/* RTL8168c */
+ 	case RTL_GIGA_MAC_VER_18 ... RTL_GIGA_MAC_VER_24:
+ 		return JUMBO_6K;
++	/* RTL8125/8126 */
++	case RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_71:
++		return JUMBO_16K;
+ 	default:
+ 		return JUMBO_9K;
+ 	}
diff --git a/target/linux/generic/backport-6.12/780-31-v6.15-r8169-switch-away-from-deprecated-pcim_iomap_table.patch b/target/linux/generic/backport-6.12/780-31-v6.15-r8169-switch-away-from-deprecated-pcim_iomap_table.patch
new file mode 100644
index 0000000000..93b79d7823
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-31-v6.15-r8169-switch-away-from-deprecated-pcim_iomap_table.patch
@@ -0,0 +1,35 @@
+From 34e5ededf4b8ad4c9e58f0cab8596e26c8fa59a2 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Wed, 12 Mar 2025 20:21:42 +0100
+Subject: [PATCH] r8169: switch away from deprecated pcim_iomap_table
+
+Avoid using deprecated pcim_iomap_table by switching to
+pcim_iomap_region.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/a36b4cf3-c792-40fa-8164-5dc9d5f14dd0@gmail.com
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 9 ++++-----
+ 1 file changed, 4 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -5446,11 +5446,10 @@ static int rtl_init_one(struct pci_dev *
+ 	if (region < 0)
+ 		return dev_err_probe(&pdev->dev, -ENODEV, "no MMIO resource found\n");
+ 
+-	rc = pcim_iomap_regions(pdev, BIT(region), KBUILD_MODNAME);
+-	if (rc < 0)
+-		return dev_err_probe(&pdev->dev, rc, "cannot remap MMIO, aborting\n");
+-
+-	tp->mmio_addr = pcim_iomap_table(pdev)[region];
++	tp->mmio_addr = pcim_iomap_region(pdev, region, KBUILD_MODNAME);
++	if (IS_ERR(tp->mmio_addr))
++		return dev_err_probe(&pdev->dev, PTR_ERR(tp->mmio_addr),
++				     "cannot remap MMIO, aborting\n");
+ 
+ 	txconfig = RTL_R32(tp, TxConfig);
+ 	if (txconfig == ~0U)
diff --git a/target/linux/generic/backport-6.12/780-32-v6.15-r8169-enable-RTL8168H-RTL8168EP-RTL8168FP-ASPM-suppo.patch b/target/linux/generic/backport-6.12/780-32-v6.15-r8169-enable-RTL8168H-RTL8168EP-RTL8168FP-ASPM-suppo.patch
new file mode 100644
index 0000000000..5c6ce70d29
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-32-v6.15-r8169-enable-RTL8168H-RTL8168EP-RTL8168FP-ASPM-suppo.patch
@@ -0,0 +1,27 @@
+From 3d9b8ac5341269d31e59fd5d58d47266ac78bc32 Mon Sep 17 00:00:00 2001
+From: ChunHao Lin <hau@realtek.com>
+Date: Tue, 18 Mar 2025 16:37:20 +0800
+Subject: [PATCH] r8169: enable RTL8168H/RTL8168EP/RTL8168FP ASPM support
+
+This patch will enable RTL8168H/RTL8168EP/RTL8168FP ASPM support on
+the platforms that have tested with ASPM enabled.
+
+Signed-off-by: ChunHao Lin <hau@realtek.com>
+Reviewed-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/20250318083721.4127-2-hau@realtek.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -5397,7 +5397,7 @@ done:
+ /* register is set if system vendor successfully tested ASPM 1.2 */
+ static bool rtl_aspm_is_safe(struct rtl8169_private *tp)
+ {
+-	if (tp->mac_version >= RTL_GIGA_MAC_VER_61 &&
++	if (tp->mac_version >= RTL_GIGA_MAC_VER_46 &&
+ 	    r8168_mac_ocp_read(tp, 0xc0b2) & 0xf)
+ 		return true;
+ 
diff --git a/target/linux/generic/backport-6.12/780-33-v6.15-r8169-disable-RTL8126-ZRX-DC-timeout.patch b/target/linux/generic/backport-6.12/780-33-v6.15-r8169-disable-RTL8126-ZRX-DC-timeout.patch
new file mode 100644
index 0000000000..1f4240e879
--- /dev/null
+++ b/target/linux/generic/backport-6.12/780-33-v6.15-r8169-disable-RTL8126-ZRX-DC-timeout.patch
@@ -0,0 +1,60 @@
+From b48688ea3c9ac8d5d910c6e91fb7f80d846581f0 Mon Sep 17 00:00:00 2001
+From: ChunHao Lin <hau@realtek.com>
+Date: Tue, 18 Mar 2025 16:37:21 +0800
+Subject: [PATCH] r8169: disable RTL8126 ZRX-DC timeout
+
+Disable it due to it dose not meet ZRX-DC specification. If it is enabled,
+device will exit L1 substate every 100ms. Disable it for saving more power
+in L1 substate.
+
+Signed-off-by: ChunHao Lin <hau@realtek.com>
+Reviewed-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/20250318083721.4127-3-hau@realtek.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/ethernet/realtek/r8169_main.c | 27 +++++++++++++++++++++++
+ 1 file changed, 27 insertions(+)
+
+--- a/drivers/net/ethernet/realtek/r8169_main.c
++++ b/drivers/net/ethernet/realtek/r8169_main.c
+@@ -2852,6 +2852,32 @@ static u32 rtl_csi_read(struct rtl8169_p
+ 		RTL_R32(tp, CSIDR) : ~0;
+ }
+ 
++static void rtl_disable_zrxdc_timeout(struct rtl8169_private *tp)
++{
++	struct pci_dev *pdev = tp->pci_dev;
++	u32 csi;
++	int rc;
++	u8 val;
++
++#define RTL_GEN3_RELATED_OFF	0x0890
++#define RTL_GEN3_ZRXDC_NONCOMPL	0x1
++	if (pdev->cfg_size > RTL_GEN3_RELATED_OFF) {
++		rc = pci_read_config_byte(pdev, RTL_GEN3_RELATED_OFF, &val);
++		if (rc == PCIBIOS_SUCCESSFUL) {
++			val &= ~RTL_GEN3_ZRXDC_NONCOMPL;
++			rc = pci_write_config_byte(pdev, RTL_GEN3_RELATED_OFF,
++						   val);
++			if (rc == PCIBIOS_SUCCESSFUL)
++				return;
++		}
++	}
++
++	netdev_notice_once(tp->dev,
++		"No native access to PCI extended config space, falling back to CSI\n");
++	csi = rtl_csi_read(tp, RTL_GEN3_RELATED_OFF);
++	rtl_csi_write(tp, RTL_GEN3_RELATED_OFF, csi & ~RTL_GEN3_ZRXDC_NONCOMPL);
++}
++
+ static void rtl_set_aspm_entry_latency(struct rtl8169_private *tp, u8 val)
+ {
+ 	struct pci_dev *pdev = tp->pci_dev;
+@@ -3824,6 +3850,7 @@ static void rtl_hw_start_8125d(struct rt
+ 
+ static void rtl_hw_start_8126a(struct rtl8169_private *tp)
+ {
++	rtl_disable_zrxdc_timeout(tp);
+ 	rtl_set_def_aspm_entry_latency(tp);
+ 	rtl_hw_start_8125_common(tp);
+ }
diff --git a/target/linux/generic/backport-6.12/781-01-v6.13-net-phy-realtek-read-duplex-and-gbit-master-from-PHY.patch b/target/linux/generic/backport-6.12/781-01-v6.13-net-phy-realtek-read-duplex-and-gbit-master-from-PHY.patch
new file mode 100644
index 0000000000..2a1726ac80
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-01-v6.13-net-phy-realtek-read-duplex-and-gbit-master-from-PHY.patch
@@ -0,0 +1,106 @@
+From 081c9c0265c91b8333165aa6230c20bcbc6f7cbf Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 10 Oct 2024 14:07:16 +0100
+Subject: [PATCH] net: phy: realtek: read duplex and gbit master from PHYSR
+ register
+
+The PHYSR MMD register is present and defined equally for all RTL82xx
+Ethernet PHYs.
+Read duplex and Gbit master bits from rtlgen_decode_speed() and rename
+it to rtlgen_decode_physr().
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Link: https://patch.msgid.link/b9a76341da851a18c985bc4774fa295babec79bb.1728565530.git.daniel@makrotopia.org
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/phy/realtek.c | 41 +++++++++++++++++++++++++++++++--------
+ 1 file changed, 33 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -80,15 +80,18 @@
+ 
+ #define RTL822X_VND2_GANLPAR				0xa414
+ 
+-#define RTL822X_VND2_PHYSR				0xa434
+-
+ #define RTL8366RB_POWER_SAVE			0x15
+ #define RTL8366RB_POWER_SAVE_ON			BIT(12)
+ 
+ #define RTL9000A_GINMR				0x14
+ #define RTL9000A_GINMR_LINK_STATUS		BIT(4)
+ 
+-#define RTLGEN_SPEED_MASK			0x0630
++#define RTL_VND2_PHYSR				0xa434
++#define RTL_VND2_PHYSR_DUPLEX			BIT(3)
++#define RTL_VND2_PHYSR_SPEEDL			GENMASK(5, 4)
++#define RTL_VND2_PHYSR_SPEEDH			GENMASK(10, 9)
++#define RTL_VND2_PHYSR_MASTER			BIT(11)
++#define RTL_VND2_PHYSR_SPEED_MASK		(RTL_VND2_PHYSR_SPEEDL | RTL_VND2_PHYSR_SPEEDH)
+ 
+ #define RTL_GENERIC_PHYID			0x001cc800
+ #define RTL_8211FVD_PHYID			0x001cc878
+@@ -660,9 +663,18 @@ static int rtl8366rb_config_init(struct
+ }
+ 
+ /* get actual speed to cover the downshift case */
+-static void rtlgen_decode_speed(struct phy_device *phydev, int val)
++static void rtlgen_decode_physr(struct phy_device *phydev, int val)
+ {
+-	switch (val & RTLGEN_SPEED_MASK) {
++	/* bit 3
++	 * 0: Half Duplex
++	 * 1: Full Duplex
++	 */
++	if (val & RTL_VND2_PHYSR_DUPLEX)
++		phydev->duplex = DUPLEX_FULL;
++	else
++		phydev->duplex = DUPLEX_HALF;
++
++	switch (val & RTL_VND2_PHYSR_SPEED_MASK) {
+ 	case 0x0000:
+ 		phydev->speed = SPEED_10;
+ 		break;
+@@ -684,6 +696,19 @@ static void rtlgen_decode_speed(struct p
+ 	default:
+ 		break;
+ 	}
++
++	/* bit 11
++	 * 0: Slave Mode
++	 * 1: Master Mode
++	 */
++	if (phydev->speed >= 1000) {
++		if (val & RTL_VND2_PHYSR_MASTER)
++			phydev->master_slave_state = MASTER_SLAVE_STATE_MASTER;
++		else
++			phydev->master_slave_state = MASTER_SLAVE_STATE_SLAVE;
++	} else {
++		phydev->master_slave_state = MASTER_SLAVE_STATE_UNSUPPORTED;
++	}
+ }
+ 
+ static int rtlgen_read_status(struct phy_device *phydev)
+@@ -701,7 +726,7 @@ static int rtlgen_read_status(struct phy
+ 	if (val < 0)
+ 		return val;
+ 
+-	rtlgen_decode_speed(phydev, val);
++	rtlgen_decode_physr(phydev, val);
+ 
+ 	return 0;
+ }
+@@ -1007,11 +1032,11 @@ static int rtl822x_c45_read_status(struc
+ 		return 0;
+ 
+ 	/* Read actual speed from vendor register. */
+-	val = phy_read_mmd(phydev, MDIO_MMD_VEND2, RTL822X_VND2_PHYSR);
++	val = phy_read_mmd(phydev, MDIO_MMD_VEND2, RTL_VND2_PHYSR);
+ 	if (val < 0)
+ 		return val;
+ 
+-	rtlgen_decode_speed(phydev, val);
++	rtlgen_decode_physr(phydev, val);
+ 
+ 	return 0;
+ }
diff --git a/target/linux/generic/backport-6.12/781-02-v6.13-net-phy-realtek-change-order-of-calls-in-C22-read_st.patch b/target/linux/generic/backport-6.12/781-02-v6.13-net-phy-realtek-change-order-of-calls-in-C22-read_st.patch
new file mode 100644
index 0000000000..4341adb878
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-02-v6.13-net-phy-realtek-change-order-of-calls-in-C22-read_st.patch
@@ -0,0 +1,53 @@
+From 68d5cd09e8919679ce13b85950debea4b2e98e04 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 10 Oct 2024 14:07:26 +0100
+Subject: [PATCH] net: phy: realtek: change order of calls in C22 read_status()
+
+Always call rtlgen_read_status() first, so genphy_read_status() which
+is called by it clears bits in case auto-negotiation has not completed.
+Also clear 10GBT link-partner advertisement bits in case auto-negotiation
+is disabled or has not completed.
+
+Suggested-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Link: https://patch.msgid.link/b15929a41621d215c6b2b57393368086589569ec.1728565530.git.daniel@makrotopia.org
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/phy/realtek.c | 22 +++++++++++++++-------
+ 1 file changed, 15 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -949,17 +949,25 @@ static void rtl822xb_update_interface(st
+ 
+ static int rtl822x_read_status(struct phy_device *phydev)
+ {
+-	if (phydev->autoneg == AUTONEG_ENABLE) {
+-		int lpadv = phy_read_paged(phydev, 0xa5d, 0x13);
++	int lpadv, ret;
+ 
+-		if (lpadv < 0)
+-			return lpadv;
++	ret = rtlgen_read_status(phydev);
++	if (ret < 0)
++		return ret;
+ 
+-		mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising,
+-						  lpadv);
++	if (phydev->autoneg == AUTONEG_DISABLE ||
++	    !phydev->autoneg_complete) {
++		mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
++		return 0;
+ 	}
+ 
+-	return rtlgen_read_status(phydev);
++	lpadv = phy_read_paged(phydev, 0xa5d, 0x13);
++	if (lpadv < 0)
++		return lpadv;
++
++	mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, lpadv);
++
++	return 0;
+ }
+ 
+ static int rtl822xb_read_status(struct phy_device *phydev)
diff --git a/target/linux/generic/backport-6.12/781-03-v6.13-net-phy-realtek-clear-1000Base-T-link-partner-advert.patch b/target/linux/generic/backport-6.12/781-03-v6.13-net-phy-realtek-clear-1000Base-T-link-partner-advert.patch
new file mode 100644
index 0000000000..60cd125a22
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-03-v6.13-net-phy-realtek-clear-1000Base-T-link-partner-advert.patch
@@ -0,0 +1,30 @@
+From 5cb409b3960e75467cbb0a8e1e5596b4490570e3 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 10 Oct 2024 14:07:39 +0100
+Subject: [PATCH] net: phy: realtek: clear 1000Base-T link partner
+ advertisement
+
+Clear 1000Base-T link partner advertisement bits in Clause-45
+read_status() function in case auto-negotiation is disabled or has not
+been completed.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Link: https://patch.msgid.link/9dc9b47b2d675708afef3ad366bfd78eb584d958.1728565530.git.daniel@makrotopia.org
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/phy/realtek.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -1026,6 +1026,10 @@ static int rtl822x_c45_read_status(struc
+ 	if (ret < 0)
+ 		return ret;
+ 
++	if (phydev->autoneg == AUTONEG_DISABLE ||
++	    !genphy_c45_aneg_done(phydev))
++		mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
++
+ 	/* Vendor register as C45 has no standardized support for 1000BaseT */
+ 	if (phydev->autoneg == AUTONEG_ENABLE) {
+ 		val = phy_read_mmd(phydev, MDIO_MMD_VEND2,
diff --git a/target/linux/generic/backport-6.12/781-04-v6.13-net-phy-realtek-merge-the-drivers-for-internal-NBase.patch b/target/linux/generic/backport-6.12/781-04-v6.13-net-phy-realtek-merge-the-drivers-for-internal-NBase.patch
new file mode 100644
index 0000000000..771f60df91
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-04-v6.13-net-phy-realtek-merge-the-drivers-for-internal-NBase.patch
@@ -0,0 +1,136 @@
+From f87a17ed3b51fba4dfdd8f8b643b5423a85fc551 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Tue, 15 Oct 2024 07:47:14 +0200
+Subject: [PATCH] net: phy: realtek: merge the drivers for internal NBase-T
+ PHY's
+
+The Realtek RTL8125/RTL8126 NBase-T MAC/PHY chips have internal PHY's
+which are register-compatible, at least for the registers we use here.
+So let's use just one PHY driver to support all of them.
+These internal PHY's exist also as external C45 PHY's, but on the
+internal PHY's no access to MMD registers is possible. This can be
+used to differentiate between the internal and external version.
+
+As a side effect the drivers for two now external-only drivers don't
+require read_mmd/write_mmd hooks any longer.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Link: https://patch.msgid.link/c57081a6-811f-4571-ab35-34f4ca6de9af@gmail.com
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/phy/realtek.c | 53 +++++++++++++++++++++++++++++++--------
+ 1 file changed, 43 insertions(+), 10 deletions(-)
+
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -95,6 +95,7 @@
+ 
+ #define RTL_GENERIC_PHYID			0x001cc800
+ #define RTL_8211FVD_PHYID			0x001cc878
++#define RTL_8221B				0x001cc840
+ #define RTL_8221B_VB_CG				0x001cc849
+ #define RTL_8221B_VN_CG				0x001cc84a
+ #define RTL_8251B				0x001cc862
+@@ -1077,6 +1078,23 @@ static bool rtlgen_supports_2_5gbps(stru
+ 	return val >= 0 && val & MDIO_PMA_SPEED_2_5G;
+ }
+ 
++/* On internal PHY's MMD reads over C22 always return 0.
++ * Check a MMD register which is known to be non-zero.
++ */
++static bool rtlgen_supports_mmd(struct phy_device *phydev)
++{
++	int val;
++
++	phy_lock_mdio_bus(phydev);
++	__phy_write(phydev, MII_MMD_CTRL, MDIO_MMD_PCS);
++	__phy_write(phydev, MII_MMD_DATA, MDIO_PCS_EEE_ABLE);
++	__phy_write(phydev, MII_MMD_CTRL, MDIO_MMD_PCS | MII_MMD_CTRL_NOINCR);
++	val = __phy_read(phydev, MII_MMD_DATA);
++	phy_unlock_mdio_bus(phydev);
++
++	return val > 0;
++}
++
+ static int rtlgen_match_phy_device(struct phy_device *phydev)
+ {
+ 	return phydev->phy_id == RTL_GENERIC_PHYID &&
+@@ -1086,7 +1104,8 @@ static int rtlgen_match_phy_device(struc
+ static int rtl8226_match_phy_device(struct phy_device *phydev)
+ {
+ 	return phydev->phy_id == RTL_GENERIC_PHYID &&
+-	       rtlgen_supports_2_5gbps(phydev);
++	       rtlgen_supports_2_5gbps(phydev) &&
++	       rtlgen_supports_mmd(phydev);
+ }
+ 
+ static int rtlgen_is_c45_match(struct phy_device *phydev, unsigned int id,
+@@ -1098,6 +1117,11 @@ static int rtlgen_is_c45_match(struct ph
+ 		return !is_c45 && (id == phydev->phy_id);
+ }
+ 
++static int rtl8221b_match_phy_device(struct phy_device *phydev)
++{
++	return phydev->phy_id == RTL_8221B && rtlgen_supports_mmd(phydev);
++}
++
+ static int rtl8221b_vb_cg_c22_match_phy_device(struct phy_device *phydev)
+ {
+ 	return rtlgen_is_c45_match(phydev, RTL_8221B_VB_CG, false);
+@@ -1118,9 +1142,21 @@ static int rtl8221b_vn_cg_c45_match_phy_
+ 	return rtlgen_is_c45_match(phydev, RTL_8221B_VN_CG, true);
+ }
+ 
+-static int rtl8251b_c22_match_phy_device(struct phy_device *phydev)
++static int rtl_internal_nbaset_match_phy_device(struct phy_device *phydev)
+ {
+-	return rtlgen_is_c45_match(phydev, RTL_8251B, false);
++	if (phydev->is_c45)
++		return false;
++
++	switch (phydev->phy_id) {
++	case RTL_GENERIC_PHYID:
++	case RTL_8221B:
++	case RTL_8251B:
++		break;
++	default:
++		return false;
++	}
++
++	return rtlgen_supports_2_5gbps(phydev) && !rtlgen_supports_mmd(phydev);
+ }
+ 
+ static int rtl8251b_c45_match_phy_device(struct phy_device *phydev)
+@@ -1382,10 +1418,8 @@ static struct phy_driver realtek_drvs[]
+ 		.resume		= rtlgen_resume,
+ 		.read_page	= rtl821x_read_page,
+ 		.write_page	= rtl821x_write_page,
+-		.read_mmd	= rtl822x_read_mmd,
+-		.write_mmd	= rtl822x_write_mmd,
+ 	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc840),
++		.match_phy_device = rtl8221b_match_phy_device,
+ 		.name		= "RTL8226B_RTL8221B 2.5Gbps PHY",
+ 		.get_features	= rtl822x_get_features,
+ 		.config_aneg	= rtl822x_config_aneg,
+@@ -1396,8 +1430,6 @@ static struct phy_driver realtek_drvs[]
+ 		.resume		= rtlgen_resume,
+ 		.read_page	= rtl821x_read_page,
+ 		.write_page	= rtl821x_write_page,
+-		.read_mmd	= rtl822x_read_mmd,
+-		.write_mmd	= rtl822x_write_mmd,
+ 	}, {
+ 		PHY_ID_MATCH_EXACT(0x001cc838),
+ 		.name           = "RTL8226-CG 2.5Gbps PHY",
+@@ -1475,8 +1507,9 @@ static struct phy_driver realtek_drvs[]
+ 		.read_page      = rtl821x_read_page,
+ 		.write_page     = rtl821x_write_page,
+ 	}, {
+-		.match_phy_device = rtl8251b_c22_match_phy_device,
+-		.name           = "RTL8126A-internal 5Gbps PHY",
++		.match_phy_device = rtl_internal_nbaset_match_phy_device,
++		.name           = "Realtek Internal NBASE-T PHY",
++		.flags		= PHY_IS_INTERNAL,
+ 		.get_features   = rtl822x_get_features,
+ 		.config_aneg    = rtl822x_config_aneg,
+ 		.read_status    = rtl822x_read_status,
diff --git a/target/linux/generic/backport-6.12/781-05-v6.13-net-phy-realtek-add-RTL8125D-internal-PHY.patch b/target/linux/generic/backport-6.12/781-05-v6.13-net-phy-realtek-add-RTL8125D-internal-PHY.patch
new file mode 100644
index 0000000000..4b9b9e8d48
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-05-v6.13-net-phy-realtek-add-RTL8125D-internal-PHY.patch
@@ -0,0 +1,29 @@
+From 8989bad541133c43550bff2b80edbe37b8fb9659 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 17 Oct 2024 18:01:13 +0200
+Subject: [PATCH] net: phy: realtek: add RTL8125D-internal PHY
+
+The first boards show up with Realtek's RTL8125D. This MAC/PHY chip
+comes with an integrated 2.5Gbps PHY with ID 0x001cc841. It's not
+clear yet whether there's an external version of this PHY and how
+Realtek calls it, therefore use the numeric id for now.
+
+Link: https://lore.kernel.org/netdev/2ada65e1-5dfa-456c-9334-2bc51272e9da@gmail.com/T/
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Message-ID: <7d2924de-053b-44d2-a479-870dc3878170@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/phy/realtek.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -1151,6 +1151,7 @@ static int rtl_internal_nbaset_match_phy
+ 	case RTL_GENERIC_PHYID:
+ 	case RTL_8221B:
+ 	case RTL_8251B:
++	case 0x001cc841:
+ 		break;
+ 	default:
+ 		return false;
diff --git a/target/linux/generic/backport-6.12/781-06-v6.14-net-phy-realtek-add-support-for-reading-MDIO_MMD_VEN.patch b/target/linux/generic/backport-6.12/781-06-v6.14-net-phy-realtek-add-support-for-reading-MDIO_MMD_VEN.patch
new file mode 100644
index 0000000000..2add672f44
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-06-v6.14-net-phy-realtek-add-support-for-reading-MDIO_MMD_VEN.patch
@@ -0,0 +1,47 @@
+From 3d483a10327f38595f714f9f9e9dde43a622cb0f Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Sat, 11 Jan 2025 21:49:31 +0100
+Subject: [PATCH] net: phy: realtek: add support for reading MDIO_MMD_VEND2
+ regs on RTL8125/RTL8126
+
+RTL8125/RTL8126 don't support MMD access to the internal PHY, but
+provide a mechanism to access at least all MDIO_MMD_VEND2 registers.
+By exposing this mechanism standard MMD access functions can be used
+to access the MDIO_MMD_VEND2 registers.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/e821b302-5fe6-49ab-aabd-05da500581c0@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/realtek.c | 12 ++++++++++--
+ 1 file changed, 10 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -736,7 +736,11 @@ static int rtlgen_read_mmd(struct phy_de
+ {
+ 	int ret;
+ 
+-	if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE) {
++	if (devnum == MDIO_MMD_VEND2) {
++		rtl821x_write_page(phydev, regnum >> 4);
++		ret = __phy_read(phydev, 0x10 + ((regnum & 0xf) >> 1));
++		rtl821x_write_page(phydev, 0);
++	} else if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE) {
+ 		rtl821x_write_page(phydev, 0xa5c);
+ 		ret = __phy_read(phydev, 0x12);
+ 		rtl821x_write_page(phydev, 0);
+@@ -760,7 +764,11 @@ static int rtlgen_write_mmd(struct phy_d
+ {
+ 	int ret;
+ 
+-	if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {
++	if (devnum == MDIO_MMD_VEND2) {
++		rtl821x_write_page(phydev, regnum >> 4);
++		ret = __phy_write(phydev, 0x10 + ((regnum & 0xf) >> 1), val);
++		rtl821x_write_page(phydev, 0);
++	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {
+ 		rtl821x_write_page(phydev, 0xa5d);
+ 		ret = __phy_write(phydev, 0x10, val);
+ 		rtl821x_write_page(phydev, 0);
diff --git a/target/linux/generic/backport-6.12/781-07-v6.14-net-phy-realtek-clear-1000Base-T-lpa-if-link-is-down.patch b/target/linux/generic/backport-6.12/781-07-v6.14-net-phy-realtek-clear-1000Base-T-lpa-if-link-is-down.patch
new file mode 100644
index 0000000000..002b99e4d5
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-07-v6.14-net-phy-realtek-clear-1000Base-T-lpa-if-link-is-down.patch
@@ -0,0 +1,52 @@
+From 34d5a86ff7bbe225fba3ad91f9b4dc85fb408e18 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Wed, 15 Jan 2025 14:43:35 +0000
+Subject: [PATCH] net: phy: realtek: clear 1000Base-T lpa if link is down
+
+Only read 1000Base-T link partner advertisement if autonegotiation has
+completed and otherwise 1000Base-T link partner advertisement bits.
+
+This fixes bogus 1000Base-T link partner advertisement after link goes
+down (eg. by disconnecting the wire).
+Fixes: 5cb409b3960e ("net: phy: realtek: clear 1000Base-T link partner advertisement")
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/realtek.c | 19 ++++++++-----------
+ 1 file changed, 8 insertions(+), 11 deletions(-)
+
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -1031,23 +1031,20 @@ static int rtl822x_c45_read_status(struc
+ {
+ 	int ret, val;
+ 
+-	ret = genphy_c45_read_status(phydev);
+-	if (ret < 0)
+-		return ret;
+-
+-	if (phydev->autoneg == AUTONEG_DISABLE ||
+-	    !genphy_c45_aneg_done(phydev))
+-		mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
+-
+ 	/* Vendor register as C45 has no standardized support for 1000BaseT */
+-	if (phydev->autoneg == AUTONEG_ENABLE) {
++	if (phydev->autoneg == AUTONEG_ENABLE && genphy_c45_aneg_done(phydev)) {
+ 		val = phy_read_mmd(phydev, MDIO_MMD_VEND2,
+ 				   RTL822X_VND2_GANLPAR);
+ 		if (val < 0)
+ 			return val;
+-
+-		mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, val);
++	} else {
++		val = 0;
+ 	}
++	mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, val);
++
++	ret = genphy_c45_read_status(phydev);
++	if (ret < 0)
++		return ret;
+ 
+ 	if (!phydev->link)
+ 		return 0;
diff --git a/target/linux/generic/backport-6.12/781-08-v6.14-net-phy-realtek-clear-master_slave_state-if-link-is-.patch b/target/linux/generic/backport-6.12/781-08-v6.14-net-phy-realtek-clear-master_slave_state-if-link-is-.patch
new file mode 100644
index 0000000000..f8cfc4d131
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-08-v6.14-net-phy-realtek-clear-master_slave_state-if-link-is-.patch
@@ -0,0 +1,35 @@
+From ea8318cb33e593bbfc59d637eae45a69732c5387 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Wed, 15 Jan 2025 14:43:43 +0000
+Subject: [PATCH] net: phy: realtek: clear master_slave_state if link is down
+
+rtlgen_decode_physr() which sets master_slave_state isn't called in case
+the link is down and other than rtlgen_read_status(),
+rtl822x_c45_read_status() doesn't implicitely clear master_slave_state.
+
+Avoid stale master_slave_state by always setting it to
+MASTER_SLAVE_STATE_UNKNOWN in rtl822x_c45_read_status() in case the link
+is down.
+
+Fixes: 081c9c0265c9 ("net: phy: realtek: read duplex and gbit master from PHYSR register")
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/realtek.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -1046,8 +1046,10 @@ static int rtl822x_c45_read_status(struc
+ 	if (ret < 0)
+ 		return ret;
+ 
+-	if (!phydev->link)
++	if (!phydev->link) {
++		phydev->master_slave_state = MASTER_SLAVE_STATE_UNKNOWN;
+ 		return 0;
++	}
+ 
+ 	/* Read actual speed from vendor register. */
+ 	val = phy_read_mmd(phydev, MDIO_MMD_VEND2, RTL_VND2_PHYSR);
diff --git a/target/linux/generic/backport-6.12/781-09-v6.14-net-phy-realtek-always-clear-NBase-T-lpa.patch b/target/linux/generic/backport-6.12/781-09-v6.14-net-phy-realtek-always-clear-NBase-T-lpa.patch
new file mode 100644
index 0000000000..e628bed6b4
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-09-v6.14-net-phy-realtek-always-clear-NBase-T-lpa.patch
@@ -0,0 +1,42 @@
+From d3eb58549842c60ed46f37da7f4da969e3d6ecd3 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Wed, 15 Jan 2025 14:45:00 +0000
+Subject: [PATCH] net: phy: realtek: always clear NBase-T lpa
+
+Clear NBase-T link partner advertisement before calling
+rtlgen_read_status() to avoid phy_resolve_aneg_linkmode() wrongly
+setting speed and duplex.
+
+This fixes bogus 2.5G/5G/10G link partner advertisement and thus
+speed and duplex being set by phy_resolve_aneg_linkmode() due to stale
+NBase-T lpa.
+
+Fixes: 68d5cd09e891 ("net: phy: realtek: change order of calls in C22 read_status()")
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Michal Swiatkowski <michal.swiatkowski@linux.intel.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/realtek.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/phy/realtek.c
++++ b/drivers/net/phy/realtek.c
+@@ -960,15 +960,15 @@ static int rtl822x_read_status(struct ph
+ {
+ 	int lpadv, ret;
+ 
++	mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
++
+ 	ret = rtlgen_read_status(phydev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (phydev->autoneg == AUTONEG_DISABLE ||
+-	    !phydev->autoneg_complete) {
+-		mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
++	    !phydev->autoneg_complete)
+ 		return 0;
+-	}
+ 
+ 	lpadv = phy_read_paged(phydev, 0xa5d, 0x13);
+ 	if (lpadv < 0)
diff --git a/target/linux/generic/backport-6.12/781-10-v6.14-net-phy-move-realtek-PHY-driver-to-its-own-subdirect.patch b/target/linux/generic/backport-6.12/781-10-v6.14-net-phy-move-realtek-PHY-driver-to-its-own-subdirect.patch
new file mode 100644
index 0000000000..633468f93a
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-10-v6.14-net-phy-move-realtek-PHY-driver-to-its-own-subdirect.patch
@@ -0,0 +1,3247 @@
+From 1416a9b2ba710d31954131c06d46f298e340aa2c Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Sat, 11 Jan 2025 21:50:19 +0100
+Subject: [PATCH] net: phy: move realtek PHY driver to its own subdirectory
+
+In preparation of adding a source file with hwmon support, move the
+Realtek PHY driver to its own subdirectory and rename realtek.c to
+realtek_main.c.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/c566551b-c915-4e34-9b33-129a6ddd6e4c@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/Kconfig                               | 5 +----
+ drivers/net/phy/Makefile                              | 2 +-
+ drivers/net/phy/realtek/Kconfig                       | 5 +++++
+ drivers/net/phy/realtek/Makefile                      | 3 +++
+ drivers/net/phy/{realtek.c => realtek/realtek_main.c} | 0
+ 5 files changed, 10 insertions(+), 5 deletions(-)
+ create mode 100644 drivers/net/phy/realtek/Kconfig
+ create mode 100644 drivers/net/phy/realtek/Makefile
+ rename drivers/net/phy/{realtek.c => realtek/realtek_main.c} (100%)
+
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -343,10 +343,7 @@ config QSEMI_PHY
+ 	help
+ 	  Currently supports the qs6612
+ 
+-config REALTEK_PHY
+-	tristate "Realtek PHYs"
+-	help
+-	  Supports the Realtek 821x PHY.
++source "drivers/net/phy/realtek/Kconfig"
+ 
+ config RENESAS_PHY
+ 	tristate "Renesas PHYs"
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -94,7 +94,7 @@ obj-$(CONFIG_NXP_CBTX_PHY)	+= nxp-cbtx.o
+ obj-$(CONFIG_NXP_TJA11XX_PHY)	+= nxp-tja11xx.o
+ obj-y				+= qcom/
+ obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
+-obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
++obj-$(CONFIG_REALTEK_PHY)	+= realtek/
+ obj-$(CONFIG_RENESAS_PHY)	+= uPD60620.o
+ obj-$(CONFIG_ROCKCHIP_PHY)	+= rockchip.o
+ obj-$(CONFIG_SMSC_PHY)		+= smsc.o
+--- /dev/null
++++ b/drivers/net/phy/realtek/Kconfig
+@@ -0,0 +1,5 @@
++# SPDX-License-Identifier: GPL-2.0-only
++config REALTEK_PHY
++	tristate "Realtek PHYs"
++	help
++	  Currently supports RTL821x/RTL822x and fast ethernet PHYs
+--- /dev/null
++++ b/drivers/net/phy/realtek/Makefile
+@@ -0,0 +1,3 @@
++# SPDX-License-Identifier: GPL-2.0
++realtek-y			+= realtek_main.o
++obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+--- a/drivers/net/phy/realtek.c
++++ /dev/null
+@@ -1,1589 +0,0 @@
+-// SPDX-License-Identifier: GPL-2.0+
+-/* drivers/net/phy/realtek.c
+- *
+- * Driver for Realtek PHYs
+- *
+- * Author: Johnson Leung <r58129@freescale.com>
+- *
+- * Copyright (c) 2004 Freescale Semiconductor, Inc.
+- */
+-#include <linux/bitops.h>
+-#include <linux/of.h>
+-#include <linux/phy.h>
+-#include <linux/module.h>
+-#include <linux/delay.h>
+-#include <linux/clk.h>
+-
+-#define RTL821x_PHYSR				0x11
+-#define RTL821x_PHYSR_DUPLEX			BIT(13)
+-#define RTL821x_PHYSR_SPEED			GENMASK(15, 14)
+-
+-#define RTL821x_INER				0x12
+-#define RTL8211B_INER_INIT			0x6400
+-#define RTL8211E_INER_LINK_STATUS		BIT(10)
+-#define RTL8211F_INER_LINK_STATUS		BIT(4)
+-
+-#define RTL821x_INSR				0x13
+-
+-#define RTL821x_EXT_PAGE_SELECT			0x1e
+-#define RTL821x_PAGE_SELECT			0x1f
+-
+-#define RTL8211F_PHYCR1				0x18
+-#define RTL8211F_PHYCR2				0x19
+-#define RTL8211F_INSR				0x1d
+-
+-#define RTL8211F_LEDCR				0x10
+-#define RTL8211F_LEDCR_MODE			BIT(15)
+-#define RTL8211F_LEDCR_ACT_TXRX			BIT(4)
+-#define RTL8211F_LEDCR_LINK_1000		BIT(3)
+-#define RTL8211F_LEDCR_LINK_100			BIT(1)
+-#define RTL8211F_LEDCR_LINK_10			BIT(0)
+-#define RTL8211F_LEDCR_MASK			GENMASK(4, 0)
+-#define RTL8211F_LEDCR_SHIFT			5
+-
+-#define RTL8211F_TX_DELAY			BIT(8)
+-#define RTL8211F_RX_DELAY			BIT(3)
+-
+-#define RTL8211F_ALDPS_PLL_OFF			BIT(1)
+-#define RTL8211F_ALDPS_ENABLE			BIT(2)
+-#define RTL8211F_ALDPS_XTAL_OFF			BIT(12)
+-
+-#define RTL8211E_CTRL_DELAY			BIT(13)
+-#define RTL8211E_TX_DELAY			BIT(12)
+-#define RTL8211E_RX_DELAY			BIT(11)
+-
+-#define RTL8211F_CLKOUT_EN			BIT(0)
+-
+-#define RTL8201F_ISR				0x1e
+-#define RTL8201F_ISR_ANERR			BIT(15)
+-#define RTL8201F_ISR_DUPLEX			BIT(13)
+-#define RTL8201F_ISR_LINK			BIT(11)
+-#define RTL8201F_ISR_MASK			(RTL8201F_ISR_ANERR | \
+-						 RTL8201F_ISR_DUPLEX | \
+-						 RTL8201F_ISR_LINK)
+-#define RTL8201F_IER				0x13
+-
+-#define RTL822X_VND1_SERDES_OPTION			0x697a
+-#define RTL822X_VND1_SERDES_OPTION_MODE_MASK		GENMASK(5, 0)
+-#define RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX_SGMII		0
+-#define RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX		2
+-
+-#define RTL822X_VND1_SERDES_CTRL3			0x7580
+-#define RTL822X_VND1_SERDES_CTRL3_MODE_MASK		GENMASK(5, 0)
+-#define RTL822X_VND1_SERDES_CTRL3_MODE_SGMII			0x02
+-#define RTL822X_VND1_SERDES_CTRL3_MODE_2500BASEX		0x16
+-
+-/* RTL822X_VND2_XXXXX registers are only accessible when phydev->is_c45
+- * is set, they cannot be accessed by C45-over-C22.
+- */
+-#define RTL822X_VND2_GBCR				0xa412
+-
+-#define RTL822X_VND2_GANLPAR				0xa414
+-
+-#define RTL8366RB_POWER_SAVE			0x15
+-#define RTL8366RB_POWER_SAVE_ON			BIT(12)
+-
+-#define RTL9000A_GINMR				0x14
+-#define RTL9000A_GINMR_LINK_STATUS		BIT(4)
+-
+-#define RTL_VND2_PHYSR				0xa434
+-#define RTL_VND2_PHYSR_DUPLEX			BIT(3)
+-#define RTL_VND2_PHYSR_SPEEDL			GENMASK(5, 4)
+-#define RTL_VND2_PHYSR_SPEEDH			GENMASK(10, 9)
+-#define RTL_VND2_PHYSR_MASTER			BIT(11)
+-#define RTL_VND2_PHYSR_SPEED_MASK		(RTL_VND2_PHYSR_SPEEDL | RTL_VND2_PHYSR_SPEEDH)
+-
+-#define RTL_GENERIC_PHYID			0x001cc800
+-#define RTL_8211FVD_PHYID			0x001cc878
+-#define RTL_8221B				0x001cc840
+-#define RTL_8221B_VB_CG				0x001cc849
+-#define RTL_8221B_VN_CG				0x001cc84a
+-#define RTL_8251B				0x001cc862
+-
+-#define RTL8211F_LED_COUNT			3
+-
+-MODULE_DESCRIPTION("Realtek PHY driver");
+-MODULE_AUTHOR("Johnson Leung");
+-MODULE_LICENSE("GPL");
+-
+-struct rtl821x_priv {
+-	u16 phycr1;
+-	u16 phycr2;
+-	bool has_phycr2;
+-	struct clk *clk;
+-};
+-
+-static int rtl821x_read_page(struct phy_device *phydev)
+-{
+-	return __phy_read(phydev, RTL821x_PAGE_SELECT);
+-}
+-
+-static int rtl821x_write_page(struct phy_device *phydev, int page)
+-{
+-	return __phy_write(phydev, RTL821x_PAGE_SELECT, page);
+-}
+-
+-static int rtl821x_probe(struct phy_device *phydev)
+-{
+-	struct device *dev = &phydev->mdio.dev;
+-	struct rtl821x_priv *priv;
+-	u32 phy_id = phydev->drv->phy_id;
+-	int ret;
+-
+-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+-	if (!priv)
+-		return -ENOMEM;
+-
+-	priv->clk = devm_clk_get_optional_enabled(dev, NULL);
+-	if (IS_ERR(priv->clk))
+-		return dev_err_probe(dev, PTR_ERR(priv->clk),
+-				     "failed to get phy clock\n");
+-
+-	ret = phy_read_paged(phydev, 0xa43, RTL8211F_PHYCR1);
+-	if (ret < 0)
+-		return ret;
+-
+-	priv->phycr1 = ret & (RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF);
+-	if (of_property_read_bool(dev->of_node, "realtek,aldps-enable"))
+-		priv->phycr1 |= RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF;
+-
+-	priv->has_phycr2 = !(phy_id == RTL_8211FVD_PHYID);
+-	if (priv->has_phycr2) {
+-		ret = phy_read_paged(phydev, 0xa43, RTL8211F_PHYCR2);
+-		if (ret < 0)
+-			return ret;
+-
+-		priv->phycr2 = ret & RTL8211F_CLKOUT_EN;
+-		if (of_property_read_bool(dev->of_node, "realtek,clkout-disable"))
+-			priv->phycr2 &= ~RTL8211F_CLKOUT_EN;
+-	}
+-
+-	phydev->priv = priv;
+-
+-	return 0;
+-}
+-
+-static int rtl8201_ack_interrupt(struct phy_device *phydev)
+-{
+-	int err;
+-
+-	err = phy_read(phydev, RTL8201F_ISR);
+-
+-	return (err < 0) ? err : 0;
+-}
+-
+-static int rtl821x_ack_interrupt(struct phy_device *phydev)
+-{
+-	int err;
+-
+-	err = phy_read(phydev, RTL821x_INSR);
+-
+-	return (err < 0) ? err : 0;
+-}
+-
+-static int rtl8211f_ack_interrupt(struct phy_device *phydev)
+-{
+-	int err;
+-
+-	err = phy_read_paged(phydev, 0xa43, RTL8211F_INSR);
+-
+-	return (err < 0) ? err : 0;
+-}
+-
+-static int rtl8201_config_intr(struct phy_device *phydev)
+-{
+-	u16 val;
+-	int err;
+-
+-	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
+-		err = rtl8201_ack_interrupt(phydev);
+-		if (err)
+-			return err;
+-
+-		val = BIT(13) | BIT(12) | BIT(11);
+-		err = phy_write_paged(phydev, 0x7, RTL8201F_IER, val);
+-	} else {
+-		val = 0;
+-		err = phy_write_paged(phydev, 0x7, RTL8201F_IER, val);
+-		if (err)
+-			return err;
+-
+-		err = rtl8201_ack_interrupt(phydev);
+-	}
+-
+-	return err;
+-}
+-
+-static int rtl8211b_config_intr(struct phy_device *phydev)
+-{
+-	int err;
+-
+-	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
+-		err = rtl821x_ack_interrupt(phydev);
+-		if (err)
+-			return err;
+-
+-		err = phy_write(phydev, RTL821x_INER,
+-				RTL8211B_INER_INIT);
+-	} else {
+-		err = phy_write(phydev, RTL821x_INER, 0);
+-		if (err)
+-			return err;
+-
+-		err = rtl821x_ack_interrupt(phydev);
+-	}
+-
+-	return err;
+-}
+-
+-static int rtl8211e_config_intr(struct phy_device *phydev)
+-{
+-	int err;
+-
+-	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
+-		err = rtl821x_ack_interrupt(phydev);
+-		if (err)
+-			return err;
+-
+-		err = phy_write(phydev, RTL821x_INER,
+-				RTL8211E_INER_LINK_STATUS);
+-	} else {
+-		err = phy_write(phydev, RTL821x_INER, 0);
+-		if (err)
+-			return err;
+-
+-		err = rtl821x_ack_interrupt(phydev);
+-	}
+-
+-	return err;
+-}
+-
+-static int rtl8211f_config_intr(struct phy_device *phydev)
+-{
+-	u16 val;
+-	int err;
+-
+-	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
+-		err = rtl8211f_ack_interrupt(phydev);
+-		if (err)
+-			return err;
+-
+-		val = RTL8211F_INER_LINK_STATUS;
+-		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
+-	} else {
+-		val = 0;
+-		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
+-		if (err)
+-			return err;
+-
+-		err = rtl8211f_ack_interrupt(phydev);
+-	}
+-
+-	return err;
+-}
+-
+-static irqreturn_t rtl8201_handle_interrupt(struct phy_device *phydev)
+-{
+-	int irq_status;
+-
+-	irq_status = phy_read(phydev, RTL8201F_ISR);
+-	if (irq_status < 0) {
+-		phy_error(phydev);
+-		return IRQ_NONE;
+-	}
+-
+-	if (!(irq_status & RTL8201F_ISR_MASK))
+-		return IRQ_NONE;
+-
+-	phy_trigger_machine(phydev);
+-
+-	return IRQ_HANDLED;
+-}
+-
+-static irqreturn_t rtl821x_handle_interrupt(struct phy_device *phydev)
+-{
+-	int irq_status, irq_enabled;
+-
+-	irq_status = phy_read(phydev, RTL821x_INSR);
+-	if (irq_status < 0) {
+-		phy_error(phydev);
+-		return IRQ_NONE;
+-	}
+-
+-	irq_enabled = phy_read(phydev, RTL821x_INER);
+-	if (irq_enabled < 0) {
+-		phy_error(phydev);
+-		return IRQ_NONE;
+-	}
+-
+-	if (!(irq_status & irq_enabled))
+-		return IRQ_NONE;
+-
+-	phy_trigger_machine(phydev);
+-
+-	return IRQ_HANDLED;
+-}
+-
+-static irqreturn_t rtl8211f_handle_interrupt(struct phy_device *phydev)
+-{
+-	int irq_status;
+-
+-	irq_status = phy_read_paged(phydev, 0xa43, RTL8211F_INSR);
+-	if (irq_status < 0) {
+-		phy_error(phydev);
+-		return IRQ_NONE;
+-	}
+-
+-	if (!(irq_status & RTL8211F_INER_LINK_STATUS))
+-		return IRQ_NONE;
+-
+-	phy_trigger_machine(phydev);
+-
+-	return IRQ_HANDLED;
+-}
+-
+-static int rtl8211_config_aneg(struct phy_device *phydev)
+-{
+-	int ret;
+-
+-	ret = genphy_config_aneg(phydev);
+-	if (ret < 0)
+-		return ret;
+-
+-	/* Quirk was copied from vendor driver. Unfortunately it includes no
+-	 * description of the magic numbers.
+-	 */
+-	if (phydev->speed == SPEED_100 && phydev->autoneg == AUTONEG_DISABLE) {
+-		phy_write(phydev, 0x17, 0x2138);
+-		phy_write(phydev, 0x0e, 0x0260);
+-	} else {
+-		phy_write(phydev, 0x17, 0x2108);
+-		phy_write(phydev, 0x0e, 0x0000);
+-	}
+-
+-	return 0;
+-}
+-
+-static int rtl8211c_config_init(struct phy_device *phydev)
+-{
+-	/* RTL8211C has an issue when operating in Gigabit slave mode */
+-	return phy_set_bits(phydev, MII_CTRL1000,
+-			    CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);
+-}
+-
+-static int rtl8211f_config_init(struct phy_device *phydev)
+-{
+-	struct rtl821x_priv *priv = phydev->priv;
+-	struct device *dev = &phydev->mdio.dev;
+-	u16 val_txdly, val_rxdly;
+-	int ret;
+-
+-	ret = phy_modify_paged_changed(phydev, 0xa43, RTL8211F_PHYCR1,
+-				       RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF,
+-				       priv->phycr1);
+-	if (ret < 0) {
+-		dev_err(dev, "aldps mode  configuration failed: %pe\n",
+-			ERR_PTR(ret));
+-		return ret;
+-	}
+-
+-	switch (phydev->interface) {
+-	case PHY_INTERFACE_MODE_RGMII:
+-		val_txdly = 0;
+-		val_rxdly = 0;
+-		break;
+-
+-	case PHY_INTERFACE_MODE_RGMII_RXID:
+-		val_txdly = 0;
+-		val_rxdly = RTL8211F_RX_DELAY;
+-		break;
+-
+-	case PHY_INTERFACE_MODE_RGMII_TXID:
+-		val_txdly = RTL8211F_TX_DELAY;
+-		val_rxdly = 0;
+-		break;
+-
+-	case PHY_INTERFACE_MODE_RGMII_ID:
+-		val_txdly = RTL8211F_TX_DELAY;
+-		val_rxdly = RTL8211F_RX_DELAY;
+-		break;
+-
+-	default: /* the rest of the modes imply leaving delay as is. */
+-		return 0;
+-	}
+-
+-	ret = phy_modify_paged_changed(phydev, 0xd08, 0x11, RTL8211F_TX_DELAY,
+-				       val_txdly);
+-	if (ret < 0) {
+-		dev_err(dev, "Failed to update the TX delay register\n");
+-		return ret;
+-	} else if (ret) {
+-		dev_dbg(dev,
+-			"%s 2ns TX delay (and changing the value from pin-strapping RXD1 or the bootloader)\n",
+-			val_txdly ? "Enabling" : "Disabling");
+-	} else {
+-		dev_dbg(dev,
+-			"2ns TX delay was already %s (by pin-strapping RXD1 or bootloader configuration)\n",
+-			val_txdly ? "enabled" : "disabled");
+-	}
+-
+-	ret = phy_modify_paged_changed(phydev, 0xd08, 0x15, RTL8211F_RX_DELAY,
+-				       val_rxdly);
+-	if (ret < 0) {
+-		dev_err(dev, "Failed to update the RX delay register\n");
+-		return ret;
+-	} else if (ret) {
+-		dev_dbg(dev,
+-			"%s 2ns RX delay (and changing the value from pin-strapping RXD0 or the bootloader)\n",
+-			val_rxdly ? "Enabling" : "Disabling");
+-	} else {
+-		dev_dbg(dev,
+-			"2ns RX delay was already %s (by pin-strapping RXD0 or bootloader configuration)\n",
+-			val_rxdly ? "enabled" : "disabled");
+-	}
+-
+-	if (priv->has_phycr2) {
+-		ret = phy_modify_paged(phydev, 0xa43, RTL8211F_PHYCR2,
+-				       RTL8211F_CLKOUT_EN, priv->phycr2);
+-		if (ret < 0) {
+-			dev_err(dev, "clkout configuration failed: %pe\n",
+-				ERR_PTR(ret));
+-			return ret;
+-		}
+-
+-		return genphy_soft_reset(phydev);
+-	}
+-
+-	return 0;
+-}
+-
+-static int rtl821x_suspend(struct phy_device *phydev)
+-{
+-	struct rtl821x_priv *priv = phydev->priv;
+-	int ret = 0;
+-
+-	if (!phydev->wol_enabled) {
+-		ret = genphy_suspend(phydev);
+-
+-		if (ret)
+-			return ret;
+-
+-		clk_disable_unprepare(priv->clk);
+-	}
+-
+-	return ret;
+-}
+-
+-static int rtl821x_resume(struct phy_device *phydev)
+-{
+-	struct rtl821x_priv *priv = phydev->priv;
+-	int ret;
+-
+-	if (!phydev->wol_enabled)
+-		clk_prepare_enable(priv->clk);
+-
+-	ret = genphy_resume(phydev);
+-	if (ret < 0)
+-		return ret;
+-
+-	msleep(20);
+-
+-	return 0;
+-}
+-
+-static int rtl8211f_led_hw_is_supported(struct phy_device *phydev, u8 index,
+-					unsigned long rules)
+-{
+-	const unsigned long mask = BIT(TRIGGER_NETDEV_LINK_10) |
+-				   BIT(TRIGGER_NETDEV_LINK_100) |
+-				   BIT(TRIGGER_NETDEV_LINK_1000) |
+-				   BIT(TRIGGER_NETDEV_RX) |
+-				   BIT(TRIGGER_NETDEV_TX);
+-
+-	/* The RTL8211F PHY supports these LED settings on up to three LEDs:
+-	 * - Link: Configurable subset of 10/100/1000 link rates
+-	 * - Active: Blink on activity, RX or TX is not differentiated
+-	 * The Active option has two modes, A and B:
+-	 * - A: Link and Active indication at configurable, but matching,
+-	 *      subset of 10/100/1000 link rates
+-	 * - B: Link indication at configurable subset of 10/100/1000 link
+-	 *      rates and Active indication always at all three 10+100+1000
+-	 *      link rates.
+-	 * This code currently uses mode B only.
+-	 */
+-
+-	if (index >= RTL8211F_LED_COUNT)
+-		return -EINVAL;
+-
+-	/* Filter out any other unsupported triggers. */
+-	if (rules & ~mask)
+-		return -EOPNOTSUPP;
+-
+-	/* RX and TX are not differentiated, either both are set or not set. */
+-	if (!(rules & BIT(TRIGGER_NETDEV_RX)) ^ !(rules & BIT(TRIGGER_NETDEV_TX)))
+-		return -EOPNOTSUPP;
+-
+-	return 0;
+-}
+-
+-static int rtl8211f_led_hw_control_get(struct phy_device *phydev, u8 index,
+-				       unsigned long *rules)
+-{
+-	int val;
+-
+-	if (index >= RTL8211F_LED_COUNT)
+-		return -EINVAL;
+-
+-	val = phy_read_paged(phydev, 0xd04, RTL8211F_LEDCR);
+-	if (val < 0)
+-		return val;
+-
+-	val >>= RTL8211F_LEDCR_SHIFT * index;
+-	val &= RTL8211F_LEDCR_MASK;
+-
+-	if (val & RTL8211F_LEDCR_LINK_10)
+-		set_bit(TRIGGER_NETDEV_LINK_10, rules);
+-
+-	if (val & RTL8211F_LEDCR_LINK_100)
+-		set_bit(TRIGGER_NETDEV_LINK_100, rules);
+-
+-	if (val & RTL8211F_LEDCR_LINK_1000)
+-		set_bit(TRIGGER_NETDEV_LINK_1000, rules);
+-
+-	if (val & RTL8211F_LEDCR_ACT_TXRX) {
+-		set_bit(TRIGGER_NETDEV_RX, rules);
+-		set_bit(TRIGGER_NETDEV_TX, rules);
+-	}
+-
+-	return 0;
+-}
+-
+-static int rtl8211f_led_hw_control_set(struct phy_device *phydev, u8 index,
+-				       unsigned long rules)
+-{
+-	const u16 mask = RTL8211F_LEDCR_MASK << (RTL8211F_LEDCR_SHIFT * index);
+-	u16 reg = 0;
+-
+-	if (index >= RTL8211F_LED_COUNT)
+-		return -EINVAL;
+-
+-	if (test_bit(TRIGGER_NETDEV_LINK_10, &rules))
+-		reg |= RTL8211F_LEDCR_LINK_10;
+-
+-	if (test_bit(TRIGGER_NETDEV_LINK_100, &rules))
+-		reg |= RTL8211F_LEDCR_LINK_100;
+-
+-	if (test_bit(TRIGGER_NETDEV_LINK_1000, &rules))
+-		reg |= RTL8211F_LEDCR_LINK_1000;
+-
+-	if (test_bit(TRIGGER_NETDEV_RX, &rules) ||
+-	    test_bit(TRIGGER_NETDEV_TX, &rules)) {
+-		reg |= RTL8211F_LEDCR_ACT_TXRX;
+-	}
+-
+-	reg <<= RTL8211F_LEDCR_SHIFT * index;
+-	reg |= RTL8211F_LEDCR_MODE;	 /* Mode B */
+-
+-	return phy_modify_paged(phydev, 0xd04, RTL8211F_LEDCR, mask, reg);
+-}
+-
+-static int rtl8211e_config_init(struct phy_device *phydev)
+-{
+-	int ret = 0, oldpage;
+-	u16 val;
+-
+-	/* enable TX/RX delay for rgmii-* modes, and disable them for rgmii. */
+-	switch (phydev->interface) {
+-	case PHY_INTERFACE_MODE_RGMII:
+-		val = RTL8211E_CTRL_DELAY | 0;
+-		break;
+-	case PHY_INTERFACE_MODE_RGMII_ID:
+-		val = RTL8211E_CTRL_DELAY | RTL8211E_TX_DELAY | RTL8211E_RX_DELAY;
+-		break;
+-	case PHY_INTERFACE_MODE_RGMII_RXID:
+-		val = RTL8211E_CTRL_DELAY | RTL8211E_RX_DELAY;
+-		break;
+-	case PHY_INTERFACE_MODE_RGMII_TXID:
+-		val = RTL8211E_CTRL_DELAY | RTL8211E_TX_DELAY;
+-		break;
+-	default: /* the rest of the modes imply leaving delays as is. */
+-		return 0;
+-	}
+-
+-	/* According to a sample driver there is a 0x1c config register on the
+-	 * 0xa4 extension page (0x7) layout. It can be used to disable/enable
+-	 * the RX/TX delays otherwise controlled by RXDLY/TXDLY pins.
+-	 * The configuration register definition:
+-	 * 14 = reserved
+-	 * 13 = Force Tx RX Delay controlled by bit12 bit11,
+-	 * 12 = RX Delay, 11 = TX Delay
+-	 * 10:0 = Test && debug settings reserved by realtek
+-	 */
+-	oldpage = phy_select_page(phydev, 0x7);
+-	if (oldpage < 0)
+-		goto err_restore_page;
+-
+-	ret = __phy_write(phydev, RTL821x_EXT_PAGE_SELECT, 0xa4);
+-	if (ret)
+-		goto err_restore_page;
+-
+-	ret = __phy_modify(phydev, 0x1c, RTL8211E_CTRL_DELAY
+-			   | RTL8211E_TX_DELAY | RTL8211E_RX_DELAY,
+-			   val);
+-
+-err_restore_page:
+-	return phy_restore_page(phydev, oldpage, ret);
+-}
+-
+-static int rtl8211b_suspend(struct phy_device *phydev)
+-{
+-	phy_write(phydev, MII_MMD_DATA, BIT(9));
+-
+-	return genphy_suspend(phydev);
+-}
+-
+-static int rtl8211b_resume(struct phy_device *phydev)
+-{
+-	phy_write(phydev, MII_MMD_DATA, 0);
+-
+-	return genphy_resume(phydev);
+-}
+-
+-static int rtl8366rb_config_init(struct phy_device *phydev)
+-{
+-	int ret;
+-
+-	ret = phy_set_bits(phydev, RTL8366RB_POWER_SAVE,
+-			   RTL8366RB_POWER_SAVE_ON);
+-	if (ret) {
+-		dev_err(&phydev->mdio.dev,
+-			"error enabling power management\n");
+-	}
+-
+-	return ret;
+-}
+-
+-/* get actual speed to cover the downshift case */
+-static void rtlgen_decode_physr(struct phy_device *phydev, int val)
+-{
+-	/* bit 3
+-	 * 0: Half Duplex
+-	 * 1: Full Duplex
+-	 */
+-	if (val & RTL_VND2_PHYSR_DUPLEX)
+-		phydev->duplex = DUPLEX_FULL;
+-	else
+-		phydev->duplex = DUPLEX_HALF;
+-
+-	switch (val & RTL_VND2_PHYSR_SPEED_MASK) {
+-	case 0x0000:
+-		phydev->speed = SPEED_10;
+-		break;
+-	case 0x0010:
+-		phydev->speed = SPEED_100;
+-		break;
+-	case 0x0020:
+-		phydev->speed = SPEED_1000;
+-		break;
+-	case 0x0200:
+-		phydev->speed = SPEED_10000;
+-		break;
+-	case 0x0210:
+-		phydev->speed = SPEED_2500;
+-		break;
+-	case 0x0220:
+-		phydev->speed = SPEED_5000;
+-		break;
+-	default:
+-		break;
+-	}
+-
+-	/* bit 11
+-	 * 0: Slave Mode
+-	 * 1: Master Mode
+-	 */
+-	if (phydev->speed >= 1000) {
+-		if (val & RTL_VND2_PHYSR_MASTER)
+-			phydev->master_slave_state = MASTER_SLAVE_STATE_MASTER;
+-		else
+-			phydev->master_slave_state = MASTER_SLAVE_STATE_SLAVE;
+-	} else {
+-		phydev->master_slave_state = MASTER_SLAVE_STATE_UNSUPPORTED;
+-	}
+-}
+-
+-static int rtlgen_read_status(struct phy_device *phydev)
+-{
+-	int ret, val;
+-
+-	ret = genphy_read_status(phydev);
+-	if (ret < 0)
+-		return ret;
+-
+-	if (!phydev->link)
+-		return 0;
+-
+-	val = phy_read_paged(phydev, 0xa43, 0x12);
+-	if (val < 0)
+-		return val;
+-
+-	rtlgen_decode_physr(phydev, val);
+-
+-	return 0;
+-}
+-
+-static int rtlgen_read_mmd(struct phy_device *phydev, int devnum, u16 regnum)
+-{
+-	int ret;
+-
+-	if (devnum == MDIO_MMD_VEND2) {
+-		rtl821x_write_page(phydev, regnum >> 4);
+-		ret = __phy_read(phydev, 0x10 + ((regnum & 0xf) >> 1));
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE) {
+-		rtl821x_write_page(phydev, 0xa5c);
+-		ret = __phy_read(phydev, 0x12);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {
+-		rtl821x_write_page(phydev, 0xa5d);
+-		ret = __phy_read(phydev, 0x10);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE) {
+-		rtl821x_write_page(phydev, 0xa5d);
+-		ret = __phy_read(phydev, 0x11);
+-		rtl821x_write_page(phydev, 0);
+-	} else {
+-		ret = -EOPNOTSUPP;
+-	}
+-
+-	return ret;
+-}
+-
+-static int rtlgen_write_mmd(struct phy_device *phydev, int devnum, u16 regnum,
+-			    u16 val)
+-{
+-	int ret;
+-
+-	if (devnum == MDIO_MMD_VEND2) {
+-		rtl821x_write_page(phydev, regnum >> 4);
+-		ret = __phy_write(phydev, 0x10 + ((regnum & 0xf) >> 1), val);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {
+-		rtl821x_write_page(phydev, 0xa5d);
+-		ret = __phy_write(phydev, 0x10, val);
+-		rtl821x_write_page(phydev, 0);
+-	} else {
+-		ret = -EOPNOTSUPP;
+-	}
+-
+-	return ret;
+-}
+-
+-static int rtl822x_read_mmd(struct phy_device *phydev, int devnum, u16 regnum)
+-{
+-	int ret = rtlgen_read_mmd(phydev, devnum, regnum);
+-
+-	if (ret != -EOPNOTSUPP)
+-		return ret;
+-
+-	if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE2) {
+-		rtl821x_write_page(phydev, 0xa6e);
+-		ret = __phy_read(phydev, 0x16);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2) {
+-		rtl821x_write_page(phydev, 0xa6d);
+-		ret = __phy_read(phydev, 0x12);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE2) {
+-		rtl821x_write_page(phydev, 0xa6d);
+-		ret = __phy_read(phydev, 0x10);
+-		rtl821x_write_page(phydev, 0);
+-	}
+-
+-	return ret;
+-}
+-
+-static int rtl822x_write_mmd(struct phy_device *phydev, int devnum, u16 regnum,
+-			     u16 val)
+-{
+-	int ret = rtlgen_write_mmd(phydev, devnum, regnum, val);
+-
+-	if (ret != -EOPNOTSUPP)
+-		return ret;
+-
+-	if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2) {
+-		rtl821x_write_page(phydev, 0xa6d);
+-		ret = __phy_write(phydev, 0x12, val);
+-		rtl821x_write_page(phydev, 0);
+-	}
+-
+-	return ret;
+-}
+-
+-static int rtl822xb_config_init(struct phy_device *phydev)
+-{
+-	bool has_2500, has_sgmii;
+-	u16 mode;
+-	int ret;
+-
+-	has_2500 = test_bit(PHY_INTERFACE_MODE_2500BASEX,
+-			    phydev->host_interfaces) ||
+-		   phydev->interface == PHY_INTERFACE_MODE_2500BASEX;
+-
+-	has_sgmii = test_bit(PHY_INTERFACE_MODE_SGMII,
+-			     phydev->host_interfaces) ||
+-		    phydev->interface == PHY_INTERFACE_MODE_SGMII;
+-
+-	/* fill in possible interfaces */
+-	__assign_bit(PHY_INTERFACE_MODE_2500BASEX, phydev->possible_interfaces,
+-		     has_2500);
+-	__assign_bit(PHY_INTERFACE_MODE_SGMII, phydev->possible_interfaces,
+-		     has_sgmii);
+-
+-	if (!has_2500 && !has_sgmii)
+-		return 0;
+-
+-	/* determine SerDes option mode */
+-	if (has_2500 && !has_sgmii) {
+-		mode = RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX;
+-		phydev->rate_matching = RATE_MATCH_PAUSE;
+-	} else {
+-		mode = RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX_SGMII;
+-		phydev->rate_matching = RATE_MATCH_NONE;
+-	}
+-
+-	/* the following sequence with magic numbers sets up the SerDes
+-	 * option mode
+-	 */
+-	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x75f3, 0);
+-	if (ret < 0)
+-		return ret;
+-
+-	ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND1,
+-				     RTL822X_VND1_SERDES_OPTION,
+-				     RTL822X_VND1_SERDES_OPTION_MODE_MASK,
+-				     mode);
+-	if (ret < 0)
+-		return ret;
+-
+-	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x6a04, 0x0503);
+-	if (ret < 0)
+-		return ret;
+-
+-	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x6f10, 0xd455);
+-	if (ret < 0)
+-		return ret;
+-
+-	return phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x6f11, 0x8020);
+-}
+-
+-static int rtl822xb_get_rate_matching(struct phy_device *phydev,
+-				      phy_interface_t iface)
+-{
+-	int val;
+-
+-	/* Only rate matching at 2500base-x */
+-	if (iface != PHY_INTERFACE_MODE_2500BASEX)
+-		return RATE_MATCH_NONE;
+-
+-	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, RTL822X_VND1_SERDES_OPTION);
+-	if (val < 0)
+-		return val;
+-
+-	if ((val & RTL822X_VND1_SERDES_OPTION_MODE_MASK) ==
+-	    RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX)
+-		return RATE_MATCH_PAUSE;
+-
+-	/* RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX_SGMII */
+-	return RATE_MATCH_NONE;
+-}
+-
+-static int rtl822x_get_features(struct phy_device *phydev)
+-{
+-	int val;
+-
+-	val = phy_read_paged(phydev, 0xa61, 0x13);
+-	if (val < 0)
+-		return val;
+-
+-	linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+-			 phydev->supported, val & MDIO_PMA_SPEED_2_5G);
+-	linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+-			 phydev->supported, val & MDIO_PMA_SPEED_5G);
+-	linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+-			 phydev->supported, val & MDIO_SPEED_10G);
+-
+-	return genphy_read_abilities(phydev);
+-}
+-
+-static int rtl822x_config_aneg(struct phy_device *phydev)
+-{
+-	int ret = 0;
+-
+-	if (phydev->autoneg == AUTONEG_ENABLE) {
+-		u16 adv = linkmode_adv_to_mii_10gbt_adv_t(phydev->advertising);
+-
+-		ret = phy_modify_paged_changed(phydev, 0xa5d, 0x12,
+-					       MDIO_AN_10GBT_CTRL_ADV2_5G |
+-					       MDIO_AN_10GBT_CTRL_ADV5G,
+-					       adv);
+-		if (ret < 0)
+-			return ret;
+-	}
+-
+-	return __genphy_config_aneg(phydev, ret);
+-}
+-
+-static void rtl822xb_update_interface(struct phy_device *phydev)
+-{
+-	int val;
+-
+-	if (!phydev->link)
+-		return;
+-
+-	/* Change interface according to serdes mode */
+-	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, RTL822X_VND1_SERDES_CTRL3);
+-	if (val < 0)
+-		return;
+-
+-	switch (val & RTL822X_VND1_SERDES_CTRL3_MODE_MASK) {
+-	case RTL822X_VND1_SERDES_CTRL3_MODE_2500BASEX:
+-		phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
+-		break;
+-	case RTL822X_VND1_SERDES_CTRL3_MODE_SGMII:
+-		phydev->interface = PHY_INTERFACE_MODE_SGMII;
+-		break;
+-	}
+-}
+-
+-static int rtl822x_read_status(struct phy_device *phydev)
+-{
+-	int lpadv, ret;
+-
+-	mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
+-
+-	ret = rtlgen_read_status(phydev);
+-	if (ret < 0)
+-		return ret;
+-
+-	if (phydev->autoneg == AUTONEG_DISABLE ||
+-	    !phydev->autoneg_complete)
+-		return 0;
+-
+-	lpadv = phy_read_paged(phydev, 0xa5d, 0x13);
+-	if (lpadv < 0)
+-		return lpadv;
+-
+-	mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, lpadv);
+-
+-	return 0;
+-}
+-
+-static int rtl822xb_read_status(struct phy_device *phydev)
+-{
+-	int ret;
+-
+-	ret = rtl822x_read_status(phydev);
+-	if (ret < 0)
+-		return ret;
+-
+-	rtl822xb_update_interface(phydev);
+-
+-	return 0;
+-}
+-
+-static int rtl822x_c45_get_features(struct phy_device *phydev)
+-{
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_TP_BIT,
+-			 phydev->supported);
+-
+-	return genphy_c45_pma_read_abilities(phydev);
+-}
+-
+-static int rtl822x_c45_config_aneg(struct phy_device *phydev)
+-{
+-	bool changed = false;
+-	int ret, val;
+-
+-	if (phydev->autoneg == AUTONEG_DISABLE)
+-		return genphy_c45_pma_setup_forced(phydev);
+-
+-	ret = genphy_c45_an_config_aneg(phydev);
+-	if (ret < 0)
+-		return ret;
+-	if (ret > 0)
+-		changed = true;
+-
+-	val = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);
+-
+-	/* Vendor register as C45 has no standardized support for 1000BaseT */
+-	ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2, RTL822X_VND2_GBCR,
+-				     ADVERTISE_1000FULL, val);
+-	if (ret < 0)
+-		return ret;
+-	if (ret > 0)
+-		changed = true;
+-
+-	return genphy_c45_check_and_restart_aneg(phydev, changed);
+-}
+-
+-static int rtl822x_c45_read_status(struct phy_device *phydev)
+-{
+-	int ret, val;
+-
+-	/* Vendor register as C45 has no standardized support for 1000BaseT */
+-	if (phydev->autoneg == AUTONEG_ENABLE && genphy_c45_aneg_done(phydev)) {
+-		val = phy_read_mmd(phydev, MDIO_MMD_VEND2,
+-				   RTL822X_VND2_GANLPAR);
+-		if (val < 0)
+-			return val;
+-	} else {
+-		val = 0;
+-	}
+-	mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, val);
+-
+-	ret = genphy_c45_read_status(phydev);
+-	if (ret < 0)
+-		return ret;
+-
+-	if (!phydev->link) {
+-		phydev->master_slave_state = MASTER_SLAVE_STATE_UNKNOWN;
+-		return 0;
+-	}
+-
+-	/* Read actual speed from vendor register. */
+-	val = phy_read_mmd(phydev, MDIO_MMD_VEND2, RTL_VND2_PHYSR);
+-	if (val < 0)
+-		return val;
+-
+-	rtlgen_decode_physr(phydev, val);
+-
+-	return 0;
+-}
+-
+-static int rtl822xb_c45_read_status(struct phy_device *phydev)
+-{
+-	int ret;
+-
+-	ret = rtl822x_c45_read_status(phydev);
+-	if (ret < 0)
+-		return ret;
+-
+-	rtl822xb_update_interface(phydev);
+-
+-	return 0;
+-}
+-
+-static bool rtlgen_supports_2_5gbps(struct phy_device *phydev)
+-{
+-	int val;
+-
+-	phy_write(phydev, RTL821x_PAGE_SELECT, 0xa61);
+-	val = phy_read(phydev, 0x13);
+-	phy_write(phydev, RTL821x_PAGE_SELECT, 0);
+-
+-	return val >= 0 && val & MDIO_PMA_SPEED_2_5G;
+-}
+-
+-/* On internal PHY's MMD reads over C22 always return 0.
+- * Check a MMD register which is known to be non-zero.
+- */
+-static bool rtlgen_supports_mmd(struct phy_device *phydev)
+-{
+-	int val;
+-
+-	phy_lock_mdio_bus(phydev);
+-	__phy_write(phydev, MII_MMD_CTRL, MDIO_MMD_PCS);
+-	__phy_write(phydev, MII_MMD_DATA, MDIO_PCS_EEE_ABLE);
+-	__phy_write(phydev, MII_MMD_CTRL, MDIO_MMD_PCS | MII_MMD_CTRL_NOINCR);
+-	val = __phy_read(phydev, MII_MMD_DATA);
+-	phy_unlock_mdio_bus(phydev);
+-
+-	return val > 0;
+-}
+-
+-static int rtlgen_match_phy_device(struct phy_device *phydev)
+-{
+-	return phydev->phy_id == RTL_GENERIC_PHYID &&
+-	       !rtlgen_supports_2_5gbps(phydev);
+-}
+-
+-static int rtl8226_match_phy_device(struct phy_device *phydev)
+-{
+-	return phydev->phy_id == RTL_GENERIC_PHYID &&
+-	       rtlgen_supports_2_5gbps(phydev) &&
+-	       rtlgen_supports_mmd(phydev);
+-}
+-
+-static int rtlgen_is_c45_match(struct phy_device *phydev, unsigned int id,
+-			       bool is_c45)
+-{
+-	if (phydev->is_c45)
+-		return is_c45 && (id == phydev->c45_ids.device_ids[1]);
+-	else
+-		return !is_c45 && (id == phydev->phy_id);
+-}
+-
+-static int rtl8221b_match_phy_device(struct phy_device *phydev)
+-{
+-	return phydev->phy_id == RTL_8221B && rtlgen_supports_mmd(phydev);
+-}
+-
+-static int rtl8221b_vb_cg_c22_match_phy_device(struct phy_device *phydev)
+-{
+-	return rtlgen_is_c45_match(phydev, RTL_8221B_VB_CG, false);
+-}
+-
+-static int rtl8221b_vb_cg_c45_match_phy_device(struct phy_device *phydev)
+-{
+-	return rtlgen_is_c45_match(phydev, RTL_8221B_VB_CG, true);
+-}
+-
+-static int rtl8221b_vn_cg_c22_match_phy_device(struct phy_device *phydev)
+-{
+-	return rtlgen_is_c45_match(phydev, RTL_8221B_VN_CG, false);
+-}
+-
+-static int rtl8221b_vn_cg_c45_match_phy_device(struct phy_device *phydev)
+-{
+-	return rtlgen_is_c45_match(phydev, RTL_8221B_VN_CG, true);
+-}
+-
+-static int rtl_internal_nbaset_match_phy_device(struct phy_device *phydev)
+-{
+-	if (phydev->is_c45)
+-		return false;
+-
+-	switch (phydev->phy_id) {
+-	case RTL_GENERIC_PHYID:
+-	case RTL_8221B:
+-	case RTL_8251B:
+-	case 0x001cc841:
+-		break;
+-	default:
+-		return false;
+-	}
+-
+-	return rtlgen_supports_2_5gbps(phydev) && !rtlgen_supports_mmd(phydev);
+-}
+-
+-static int rtl8251b_c45_match_phy_device(struct phy_device *phydev)
+-{
+-	return rtlgen_is_c45_match(phydev, RTL_8251B, true);
+-}
+-
+-static int rtlgen_resume(struct phy_device *phydev)
+-{
+-	int ret = genphy_resume(phydev);
+-
+-	/* Internal PHY's from RTL8168h up may not be instantly ready */
+-	msleep(20);
+-
+-	return ret;
+-}
+-
+-static int rtlgen_c45_resume(struct phy_device *phydev)
+-{
+-	int ret = genphy_c45_pma_resume(phydev);
+-
+-	msleep(20);
+-
+-	return ret;
+-}
+-
+-static int rtl9000a_config_init(struct phy_device *phydev)
+-{
+-	phydev->autoneg = AUTONEG_DISABLE;
+-	phydev->speed = SPEED_100;
+-	phydev->duplex = DUPLEX_FULL;
+-
+-	return 0;
+-}
+-
+-static int rtl9000a_config_aneg(struct phy_device *phydev)
+-{
+-	int ret;
+-	u16 ctl = 0;
+-
+-	switch (phydev->master_slave_set) {
+-	case MASTER_SLAVE_CFG_MASTER_FORCE:
+-		ctl |= CTL1000_AS_MASTER;
+-		break;
+-	case MASTER_SLAVE_CFG_SLAVE_FORCE:
+-		break;
+-	case MASTER_SLAVE_CFG_UNKNOWN:
+-	case MASTER_SLAVE_CFG_UNSUPPORTED:
+-		return 0;
+-	default:
+-		phydev_warn(phydev, "Unsupported Master/Slave mode\n");
+-		return -EOPNOTSUPP;
+-	}
+-
+-	ret = phy_modify_changed(phydev, MII_CTRL1000, CTL1000_AS_MASTER, ctl);
+-	if (ret == 1)
+-		ret = genphy_soft_reset(phydev);
+-
+-	return ret;
+-}
+-
+-static int rtl9000a_read_status(struct phy_device *phydev)
+-{
+-	int ret;
+-
+-	phydev->master_slave_get = MASTER_SLAVE_CFG_UNKNOWN;
+-	phydev->master_slave_state = MASTER_SLAVE_STATE_UNKNOWN;
+-
+-	ret = genphy_update_link(phydev);
+-	if (ret)
+-		return ret;
+-
+-	ret = phy_read(phydev, MII_CTRL1000);
+-	if (ret < 0)
+-		return ret;
+-	if (ret & CTL1000_AS_MASTER)
+-		phydev->master_slave_get = MASTER_SLAVE_CFG_MASTER_FORCE;
+-	else
+-		phydev->master_slave_get = MASTER_SLAVE_CFG_SLAVE_FORCE;
+-
+-	ret = phy_read(phydev, MII_STAT1000);
+-	if (ret < 0)
+-		return ret;
+-	if (ret & LPA_1000MSRES)
+-		phydev->master_slave_state = MASTER_SLAVE_STATE_MASTER;
+-	else
+-		phydev->master_slave_state = MASTER_SLAVE_STATE_SLAVE;
+-
+-	return 0;
+-}
+-
+-static int rtl9000a_ack_interrupt(struct phy_device *phydev)
+-{
+-	int err;
+-
+-	err = phy_read(phydev, RTL8211F_INSR);
+-
+-	return (err < 0) ? err : 0;
+-}
+-
+-static int rtl9000a_config_intr(struct phy_device *phydev)
+-{
+-	u16 val;
+-	int err;
+-
+-	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
+-		err = rtl9000a_ack_interrupt(phydev);
+-		if (err)
+-			return err;
+-
+-		val = (u16)~RTL9000A_GINMR_LINK_STATUS;
+-		err = phy_write_paged(phydev, 0xa42, RTL9000A_GINMR, val);
+-	} else {
+-		val = ~0;
+-		err = phy_write_paged(phydev, 0xa42, RTL9000A_GINMR, val);
+-		if (err)
+-			return err;
+-
+-		err = rtl9000a_ack_interrupt(phydev);
+-	}
+-
+-	return phy_write_paged(phydev, 0xa42, RTL9000A_GINMR, val);
+-}
+-
+-static irqreturn_t rtl9000a_handle_interrupt(struct phy_device *phydev)
+-{
+-	int irq_status;
+-
+-	irq_status = phy_read(phydev, RTL8211F_INSR);
+-	if (irq_status < 0) {
+-		phy_error(phydev);
+-		return IRQ_NONE;
+-	}
+-
+-	if (!(irq_status & RTL8211F_INER_LINK_STATUS))
+-		return IRQ_NONE;
+-
+-	phy_trigger_machine(phydev);
+-
+-	return IRQ_HANDLED;
+-}
+-
+-static struct phy_driver realtek_drvs[] = {
+-	{
+-		PHY_ID_MATCH_EXACT(0x00008201),
+-		.name           = "RTL8201CP Ethernet",
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc816),
+-		.name		= "RTL8201F Fast Ethernet",
+-		.config_intr	= &rtl8201_config_intr,
+-		.handle_interrupt = rtl8201_handle_interrupt,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_MODEL(0x001cc880),
+-		.name		= "RTL8208 Fast Ethernet",
+-		.read_mmd	= genphy_read_mmd_unsupported,
+-		.write_mmd	= genphy_write_mmd_unsupported,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc910),
+-		.name		= "RTL8211 Gigabit Ethernet",
+-		.config_aneg	= rtl8211_config_aneg,
+-		.read_mmd	= &genphy_read_mmd_unsupported,
+-		.write_mmd	= &genphy_write_mmd_unsupported,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc912),
+-		.name		= "RTL8211B Gigabit Ethernet",
+-		.config_intr	= &rtl8211b_config_intr,
+-		.handle_interrupt = rtl821x_handle_interrupt,
+-		.read_mmd	= &genphy_read_mmd_unsupported,
+-		.write_mmd	= &genphy_write_mmd_unsupported,
+-		.suspend	= rtl8211b_suspend,
+-		.resume		= rtl8211b_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc913),
+-		.name		= "RTL8211C Gigabit Ethernet",
+-		.config_init	= rtl8211c_config_init,
+-		.read_mmd	= &genphy_read_mmd_unsupported,
+-		.write_mmd	= &genphy_write_mmd_unsupported,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc914),
+-		.name		= "RTL8211DN Gigabit Ethernet",
+-		.config_intr	= rtl8211e_config_intr,
+-		.handle_interrupt = rtl821x_handle_interrupt,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc915),
+-		.name		= "RTL8211E Gigabit Ethernet",
+-		.config_init	= &rtl8211e_config_init,
+-		.config_intr	= &rtl8211e_config_intr,
+-		.handle_interrupt = rtl821x_handle_interrupt,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc916),
+-		.name		= "RTL8211F Gigabit Ethernet",
+-		.probe		= rtl821x_probe,
+-		.config_init	= &rtl8211f_config_init,
+-		.read_status	= rtlgen_read_status,
+-		.config_intr	= &rtl8211f_config_intr,
+-		.handle_interrupt = rtl8211f_handle_interrupt,
+-		.suspend	= rtl821x_suspend,
+-		.resume		= rtl821x_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-		.flags		= PHY_ALWAYS_CALL_SUSPEND,
+-		.led_hw_is_supported = rtl8211f_led_hw_is_supported,
+-		.led_hw_control_get = rtl8211f_led_hw_control_get,
+-		.led_hw_control_set = rtl8211f_led_hw_control_set,
+-	}, {
+-		PHY_ID_MATCH_EXACT(RTL_8211FVD_PHYID),
+-		.name		= "RTL8211F-VD Gigabit Ethernet",
+-		.probe		= rtl821x_probe,
+-		.config_init	= &rtl8211f_config_init,
+-		.read_status	= rtlgen_read_status,
+-		.config_intr	= &rtl8211f_config_intr,
+-		.handle_interrupt = rtl8211f_handle_interrupt,
+-		.suspend	= rtl821x_suspend,
+-		.resume		= rtl821x_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-		.flags		= PHY_ALWAYS_CALL_SUSPEND,
+-	}, {
+-		.name		= "Generic FE-GE Realtek PHY",
+-		.match_phy_device = rtlgen_match_phy_device,
+-		.read_status	= rtlgen_read_status,
+-		.suspend	= genphy_suspend,
+-		.resume		= rtlgen_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-		.read_mmd	= rtlgen_read_mmd,
+-		.write_mmd	= rtlgen_write_mmd,
+-	}, {
+-		.name		= "RTL8226 2.5Gbps PHY",
+-		.match_phy_device = rtl8226_match_phy_device,
+-		.get_features	= rtl822x_get_features,
+-		.config_aneg	= rtl822x_config_aneg,
+-		.read_status	= rtl822x_read_status,
+-		.suspend	= genphy_suspend,
+-		.resume		= rtlgen_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		.match_phy_device = rtl8221b_match_phy_device,
+-		.name		= "RTL8226B_RTL8221B 2.5Gbps PHY",
+-		.get_features	= rtl822x_get_features,
+-		.config_aneg	= rtl822x_config_aneg,
+-		.config_init    = rtl822xb_config_init,
+-		.get_rate_matching = rtl822xb_get_rate_matching,
+-		.read_status	= rtl822xb_read_status,
+-		.suspend	= genphy_suspend,
+-		.resume		= rtlgen_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc838),
+-		.name           = "RTL8226-CG 2.5Gbps PHY",
+-		.get_features   = rtl822x_get_features,
+-		.config_aneg    = rtl822x_config_aneg,
+-		.read_status    = rtl822x_read_status,
+-		.suspend        = genphy_suspend,
+-		.resume         = rtlgen_resume,
+-		.read_page      = rtl821x_read_page,
+-		.write_page     = rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc848),
+-		.name           = "RTL8226B-CG_RTL8221B-CG 2.5Gbps PHY",
+-		.get_features   = rtl822x_get_features,
+-		.config_aneg    = rtl822x_config_aneg,
+-		.config_init    = rtl822xb_config_init,
+-		.get_rate_matching = rtl822xb_get_rate_matching,
+-		.read_status    = rtl822xb_read_status,
+-		.suspend        = genphy_suspend,
+-		.resume         = rtlgen_resume,
+-		.read_page      = rtl821x_read_page,
+-		.write_page     = rtl821x_write_page,
+-	}, {
+-		.match_phy_device = rtl8221b_vb_cg_c22_match_phy_device,
+-		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C22)",
+-		.get_features   = rtl822x_get_features,
+-		.config_aneg    = rtl822x_config_aneg,
+-		.config_init    = rtl822xb_config_init,
+-		.get_rate_matching = rtl822xb_get_rate_matching,
+-		.read_status    = rtl822xb_read_status,
+-		.suspend        = genphy_suspend,
+-		.resume         = rtlgen_resume,
+-		.read_page      = rtl821x_read_page,
+-		.write_page     = rtl821x_write_page,
+-	}, {
+-		.match_phy_device = rtl8221b_vb_cg_c45_match_phy_device,
+-		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C45)",
+-		.config_init    = rtl822xb_config_init,
+-		.get_rate_matching = rtl822xb_get_rate_matching,
+-		.get_features   = rtl822x_c45_get_features,
+-		.config_aneg    = rtl822x_c45_config_aneg,
+-		.read_status    = rtl822xb_c45_read_status,
+-		.suspend        = genphy_c45_pma_suspend,
+-		.resume         = rtlgen_c45_resume,
+-	}, {
+-		.match_phy_device = rtl8221b_vn_cg_c22_match_phy_device,
+-		.name           = "RTL8221B-VM-CG 2.5Gbps PHY (C22)",
+-		.get_features   = rtl822x_get_features,
+-		.config_aneg    = rtl822x_config_aneg,
+-		.config_init    = rtl822xb_config_init,
+-		.get_rate_matching = rtl822xb_get_rate_matching,
+-		.read_status    = rtl822xb_read_status,
+-		.suspend        = genphy_suspend,
+-		.resume         = rtlgen_resume,
+-		.read_page      = rtl821x_read_page,
+-		.write_page     = rtl821x_write_page,
+-	}, {
+-		.match_phy_device = rtl8221b_vn_cg_c45_match_phy_device,
+-		.name           = "RTL8221B-VN-CG 2.5Gbps PHY (C45)",
+-		.config_init    = rtl822xb_config_init,
+-		.get_rate_matching = rtl822xb_get_rate_matching,
+-		.get_features   = rtl822x_c45_get_features,
+-		.config_aneg    = rtl822x_c45_config_aneg,
+-		.read_status    = rtl822xb_c45_read_status,
+-		.suspend        = genphy_c45_pma_suspend,
+-		.resume         = rtlgen_c45_resume,
+-	}, {
+-		.match_phy_device = rtl8251b_c45_match_phy_device,
+-		.name           = "RTL8251B 5Gbps PHY",
+-		.get_features   = rtl822x_get_features,
+-		.config_aneg    = rtl822x_config_aneg,
+-		.read_status    = rtl822x_read_status,
+-		.suspend        = genphy_suspend,
+-		.resume         = rtlgen_resume,
+-		.read_page      = rtl821x_read_page,
+-		.write_page     = rtl821x_write_page,
+-	}, {
+-		.match_phy_device = rtl_internal_nbaset_match_phy_device,
+-		.name           = "Realtek Internal NBASE-T PHY",
+-		.flags		= PHY_IS_INTERNAL,
+-		.get_features   = rtl822x_get_features,
+-		.config_aneg    = rtl822x_config_aneg,
+-		.read_status    = rtl822x_read_status,
+-		.suspend        = genphy_suspend,
+-		.resume         = rtlgen_resume,
+-		.read_page      = rtl821x_read_page,
+-		.write_page     = rtl821x_write_page,
+-		.read_mmd	= rtl822x_read_mmd,
+-		.write_mmd	= rtl822x_write_mmd,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001ccad0),
+-		.name		= "RTL8224 2.5Gbps PHY",
+-		.get_features   = rtl822x_c45_get_features,
+-		.config_aneg    = rtl822x_c45_config_aneg,
+-		.read_status    = rtl822x_c45_read_status,
+-		.suspend        = genphy_c45_pma_suspend,
+-		.resume         = rtlgen_c45_resume,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc961),
+-		.name		= "RTL8366RB Gigabit Ethernet",
+-		.config_init	= &rtl8366rb_config_init,
+-		/* These interrupts are handled by the irq controller
+-		 * embedded inside the RTL8366RB, they get unmasked when the
+-		 * irq is requested and ACKed by reading the status register,
+-		 * which is done by the irqchip code.
+-		 */
+-		.config_intr	= genphy_no_config_intr,
+-		.handle_interrupt = genphy_handle_interrupt_no_ack,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001ccb00),
+-		.name		= "RTL9000AA_RTL9000AN Ethernet",
+-		.features       = PHY_BASIC_T1_FEATURES,
+-		.config_init	= rtl9000a_config_init,
+-		.config_aneg	= rtl9000a_config_aneg,
+-		.read_status	= rtl9000a_read_status,
+-		.config_intr	= rtl9000a_config_intr,
+-		.handle_interrupt = rtl9000a_handle_interrupt,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_page	= rtl821x_read_page,
+-		.write_page	= rtl821x_write_page,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc942),
+-		.name		= "RTL8365MB-VC Gigabit Ethernet",
+-		/* Interrupt handling analogous to RTL8366RB */
+-		.config_intr	= genphy_no_config_intr,
+-		.handle_interrupt = genphy_handle_interrupt_no_ack,
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-	}, {
+-		PHY_ID_MATCH_EXACT(0x001cc960),
+-		.name		= "RTL8366S Gigabit Ethernet",
+-		.suspend	= genphy_suspend,
+-		.resume		= genphy_resume,
+-		.read_mmd	= genphy_read_mmd_unsupported,
+-		.write_mmd	= genphy_write_mmd_unsupported,
+-	},
+-};
+-
+-module_phy_driver(realtek_drvs);
+-
+-static const struct mdio_device_id __maybe_unused realtek_tbl[] = {
+-	{ PHY_ID_MATCH_VENDOR(0x001cc800) },
+-	{ }
+-};
+-
+-MODULE_DEVICE_TABLE(mdio, realtek_tbl);
+--- /dev/null
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -0,0 +1,1589 @@
++// SPDX-License-Identifier: GPL-2.0+
++/* drivers/net/phy/realtek.c
++ *
++ * Driver for Realtek PHYs
++ *
++ * Author: Johnson Leung <r58129@freescale.com>
++ *
++ * Copyright (c) 2004 Freescale Semiconductor, Inc.
++ */
++#include <linux/bitops.h>
++#include <linux/of.h>
++#include <linux/phy.h>
++#include <linux/module.h>
++#include <linux/delay.h>
++#include <linux/clk.h>
++
++#define RTL821x_PHYSR				0x11
++#define RTL821x_PHYSR_DUPLEX			BIT(13)
++#define RTL821x_PHYSR_SPEED			GENMASK(15, 14)
++
++#define RTL821x_INER				0x12
++#define RTL8211B_INER_INIT			0x6400
++#define RTL8211E_INER_LINK_STATUS		BIT(10)
++#define RTL8211F_INER_LINK_STATUS		BIT(4)
++
++#define RTL821x_INSR				0x13
++
++#define RTL821x_EXT_PAGE_SELECT			0x1e
++#define RTL821x_PAGE_SELECT			0x1f
++
++#define RTL8211F_PHYCR1				0x18
++#define RTL8211F_PHYCR2				0x19
++#define RTL8211F_INSR				0x1d
++
++#define RTL8211F_LEDCR				0x10
++#define RTL8211F_LEDCR_MODE			BIT(15)
++#define RTL8211F_LEDCR_ACT_TXRX			BIT(4)
++#define RTL8211F_LEDCR_LINK_1000		BIT(3)
++#define RTL8211F_LEDCR_LINK_100			BIT(1)
++#define RTL8211F_LEDCR_LINK_10			BIT(0)
++#define RTL8211F_LEDCR_MASK			GENMASK(4, 0)
++#define RTL8211F_LEDCR_SHIFT			5
++
++#define RTL8211F_TX_DELAY			BIT(8)
++#define RTL8211F_RX_DELAY			BIT(3)
++
++#define RTL8211F_ALDPS_PLL_OFF			BIT(1)
++#define RTL8211F_ALDPS_ENABLE			BIT(2)
++#define RTL8211F_ALDPS_XTAL_OFF			BIT(12)
++
++#define RTL8211E_CTRL_DELAY			BIT(13)
++#define RTL8211E_TX_DELAY			BIT(12)
++#define RTL8211E_RX_DELAY			BIT(11)
++
++#define RTL8211F_CLKOUT_EN			BIT(0)
++
++#define RTL8201F_ISR				0x1e
++#define RTL8201F_ISR_ANERR			BIT(15)
++#define RTL8201F_ISR_DUPLEX			BIT(13)
++#define RTL8201F_ISR_LINK			BIT(11)
++#define RTL8201F_ISR_MASK			(RTL8201F_ISR_ANERR | \
++						 RTL8201F_ISR_DUPLEX | \
++						 RTL8201F_ISR_LINK)
++#define RTL8201F_IER				0x13
++
++#define RTL822X_VND1_SERDES_OPTION			0x697a
++#define RTL822X_VND1_SERDES_OPTION_MODE_MASK		GENMASK(5, 0)
++#define RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX_SGMII		0
++#define RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX		2
++
++#define RTL822X_VND1_SERDES_CTRL3			0x7580
++#define RTL822X_VND1_SERDES_CTRL3_MODE_MASK		GENMASK(5, 0)
++#define RTL822X_VND1_SERDES_CTRL3_MODE_SGMII			0x02
++#define RTL822X_VND1_SERDES_CTRL3_MODE_2500BASEX		0x16
++
++/* RTL822X_VND2_XXXXX registers are only accessible when phydev->is_c45
++ * is set, they cannot be accessed by C45-over-C22.
++ */
++#define RTL822X_VND2_GBCR				0xa412
++
++#define RTL822X_VND2_GANLPAR				0xa414
++
++#define RTL8366RB_POWER_SAVE			0x15
++#define RTL8366RB_POWER_SAVE_ON			BIT(12)
++
++#define RTL9000A_GINMR				0x14
++#define RTL9000A_GINMR_LINK_STATUS		BIT(4)
++
++#define RTL_VND2_PHYSR				0xa434
++#define RTL_VND2_PHYSR_DUPLEX			BIT(3)
++#define RTL_VND2_PHYSR_SPEEDL			GENMASK(5, 4)
++#define RTL_VND2_PHYSR_SPEEDH			GENMASK(10, 9)
++#define RTL_VND2_PHYSR_MASTER			BIT(11)
++#define RTL_VND2_PHYSR_SPEED_MASK		(RTL_VND2_PHYSR_SPEEDL | RTL_VND2_PHYSR_SPEEDH)
++
++#define RTL_GENERIC_PHYID			0x001cc800
++#define RTL_8211FVD_PHYID			0x001cc878
++#define RTL_8221B				0x001cc840
++#define RTL_8221B_VB_CG				0x001cc849
++#define RTL_8221B_VN_CG				0x001cc84a
++#define RTL_8251B				0x001cc862
++
++#define RTL8211F_LED_COUNT			3
++
++MODULE_DESCRIPTION("Realtek PHY driver");
++MODULE_AUTHOR("Johnson Leung");
++MODULE_LICENSE("GPL");
++
++struct rtl821x_priv {
++	u16 phycr1;
++	u16 phycr2;
++	bool has_phycr2;
++	struct clk *clk;
++};
++
++static int rtl821x_read_page(struct phy_device *phydev)
++{
++	return __phy_read(phydev, RTL821x_PAGE_SELECT);
++}
++
++static int rtl821x_write_page(struct phy_device *phydev, int page)
++{
++	return __phy_write(phydev, RTL821x_PAGE_SELECT, page);
++}
++
++static int rtl821x_probe(struct phy_device *phydev)
++{
++	struct device *dev = &phydev->mdio.dev;
++	struct rtl821x_priv *priv;
++	u32 phy_id = phydev->drv->phy_id;
++	int ret;
++
++	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
++	if (!priv)
++		return -ENOMEM;
++
++	priv->clk = devm_clk_get_optional_enabled(dev, NULL);
++	if (IS_ERR(priv->clk))
++		return dev_err_probe(dev, PTR_ERR(priv->clk),
++				     "failed to get phy clock\n");
++
++	ret = phy_read_paged(phydev, 0xa43, RTL8211F_PHYCR1);
++	if (ret < 0)
++		return ret;
++
++	priv->phycr1 = ret & (RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF);
++	if (of_property_read_bool(dev->of_node, "realtek,aldps-enable"))
++		priv->phycr1 |= RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF;
++
++	priv->has_phycr2 = !(phy_id == RTL_8211FVD_PHYID);
++	if (priv->has_phycr2) {
++		ret = phy_read_paged(phydev, 0xa43, RTL8211F_PHYCR2);
++		if (ret < 0)
++			return ret;
++
++		priv->phycr2 = ret & RTL8211F_CLKOUT_EN;
++		if (of_property_read_bool(dev->of_node, "realtek,clkout-disable"))
++			priv->phycr2 &= ~RTL8211F_CLKOUT_EN;
++	}
++
++	phydev->priv = priv;
++
++	return 0;
++}
++
++static int rtl8201_ack_interrupt(struct phy_device *phydev)
++{
++	int err;
++
++	err = phy_read(phydev, RTL8201F_ISR);
++
++	return (err < 0) ? err : 0;
++}
++
++static int rtl821x_ack_interrupt(struct phy_device *phydev)
++{
++	int err;
++
++	err = phy_read(phydev, RTL821x_INSR);
++
++	return (err < 0) ? err : 0;
++}
++
++static int rtl8211f_ack_interrupt(struct phy_device *phydev)
++{
++	int err;
++
++	err = phy_read_paged(phydev, 0xa43, RTL8211F_INSR);
++
++	return (err < 0) ? err : 0;
++}
++
++static int rtl8201_config_intr(struct phy_device *phydev)
++{
++	u16 val;
++	int err;
++
++	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
++		err = rtl8201_ack_interrupt(phydev);
++		if (err)
++			return err;
++
++		val = BIT(13) | BIT(12) | BIT(11);
++		err = phy_write_paged(phydev, 0x7, RTL8201F_IER, val);
++	} else {
++		val = 0;
++		err = phy_write_paged(phydev, 0x7, RTL8201F_IER, val);
++		if (err)
++			return err;
++
++		err = rtl8201_ack_interrupt(phydev);
++	}
++
++	return err;
++}
++
++static int rtl8211b_config_intr(struct phy_device *phydev)
++{
++	int err;
++
++	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
++		err = rtl821x_ack_interrupt(phydev);
++		if (err)
++			return err;
++
++		err = phy_write(phydev, RTL821x_INER,
++				RTL8211B_INER_INIT);
++	} else {
++		err = phy_write(phydev, RTL821x_INER, 0);
++		if (err)
++			return err;
++
++		err = rtl821x_ack_interrupt(phydev);
++	}
++
++	return err;
++}
++
++static int rtl8211e_config_intr(struct phy_device *phydev)
++{
++	int err;
++
++	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
++		err = rtl821x_ack_interrupt(phydev);
++		if (err)
++			return err;
++
++		err = phy_write(phydev, RTL821x_INER,
++				RTL8211E_INER_LINK_STATUS);
++	} else {
++		err = phy_write(phydev, RTL821x_INER, 0);
++		if (err)
++			return err;
++
++		err = rtl821x_ack_interrupt(phydev);
++	}
++
++	return err;
++}
++
++static int rtl8211f_config_intr(struct phy_device *phydev)
++{
++	u16 val;
++	int err;
++
++	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
++		err = rtl8211f_ack_interrupt(phydev);
++		if (err)
++			return err;
++
++		val = RTL8211F_INER_LINK_STATUS;
++		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
++	} else {
++		val = 0;
++		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
++		if (err)
++			return err;
++
++		err = rtl8211f_ack_interrupt(phydev);
++	}
++
++	return err;
++}
++
++static irqreturn_t rtl8201_handle_interrupt(struct phy_device *phydev)
++{
++	int irq_status;
++
++	irq_status = phy_read(phydev, RTL8201F_ISR);
++	if (irq_status < 0) {
++		phy_error(phydev);
++		return IRQ_NONE;
++	}
++
++	if (!(irq_status & RTL8201F_ISR_MASK))
++		return IRQ_NONE;
++
++	phy_trigger_machine(phydev);
++
++	return IRQ_HANDLED;
++}
++
++static irqreturn_t rtl821x_handle_interrupt(struct phy_device *phydev)
++{
++	int irq_status, irq_enabled;
++
++	irq_status = phy_read(phydev, RTL821x_INSR);
++	if (irq_status < 0) {
++		phy_error(phydev);
++		return IRQ_NONE;
++	}
++
++	irq_enabled = phy_read(phydev, RTL821x_INER);
++	if (irq_enabled < 0) {
++		phy_error(phydev);
++		return IRQ_NONE;
++	}
++
++	if (!(irq_status & irq_enabled))
++		return IRQ_NONE;
++
++	phy_trigger_machine(phydev);
++
++	return IRQ_HANDLED;
++}
++
++static irqreturn_t rtl8211f_handle_interrupt(struct phy_device *phydev)
++{
++	int irq_status;
++
++	irq_status = phy_read_paged(phydev, 0xa43, RTL8211F_INSR);
++	if (irq_status < 0) {
++		phy_error(phydev);
++		return IRQ_NONE;
++	}
++
++	if (!(irq_status & RTL8211F_INER_LINK_STATUS))
++		return IRQ_NONE;
++
++	phy_trigger_machine(phydev);
++
++	return IRQ_HANDLED;
++}
++
++static int rtl8211_config_aneg(struct phy_device *phydev)
++{
++	int ret;
++
++	ret = genphy_config_aneg(phydev);
++	if (ret < 0)
++		return ret;
++
++	/* Quirk was copied from vendor driver. Unfortunately it includes no
++	 * description of the magic numbers.
++	 */
++	if (phydev->speed == SPEED_100 && phydev->autoneg == AUTONEG_DISABLE) {
++		phy_write(phydev, 0x17, 0x2138);
++		phy_write(phydev, 0x0e, 0x0260);
++	} else {
++		phy_write(phydev, 0x17, 0x2108);
++		phy_write(phydev, 0x0e, 0x0000);
++	}
++
++	return 0;
++}
++
++static int rtl8211c_config_init(struct phy_device *phydev)
++{
++	/* RTL8211C has an issue when operating in Gigabit slave mode */
++	return phy_set_bits(phydev, MII_CTRL1000,
++			    CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);
++}
++
++static int rtl8211f_config_init(struct phy_device *phydev)
++{
++	struct rtl821x_priv *priv = phydev->priv;
++	struct device *dev = &phydev->mdio.dev;
++	u16 val_txdly, val_rxdly;
++	int ret;
++
++	ret = phy_modify_paged_changed(phydev, 0xa43, RTL8211F_PHYCR1,
++				       RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF,
++				       priv->phycr1);
++	if (ret < 0) {
++		dev_err(dev, "aldps mode  configuration failed: %pe\n",
++			ERR_PTR(ret));
++		return ret;
++	}
++
++	switch (phydev->interface) {
++	case PHY_INTERFACE_MODE_RGMII:
++		val_txdly = 0;
++		val_rxdly = 0;
++		break;
++
++	case PHY_INTERFACE_MODE_RGMII_RXID:
++		val_txdly = 0;
++		val_rxdly = RTL8211F_RX_DELAY;
++		break;
++
++	case PHY_INTERFACE_MODE_RGMII_TXID:
++		val_txdly = RTL8211F_TX_DELAY;
++		val_rxdly = 0;
++		break;
++
++	case PHY_INTERFACE_MODE_RGMII_ID:
++		val_txdly = RTL8211F_TX_DELAY;
++		val_rxdly = RTL8211F_RX_DELAY;
++		break;
++
++	default: /* the rest of the modes imply leaving delay as is. */
++		return 0;
++	}
++
++	ret = phy_modify_paged_changed(phydev, 0xd08, 0x11, RTL8211F_TX_DELAY,
++				       val_txdly);
++	if (ret < 0) {
++		dev_err(dev, "Failed to update the TX delay register\n");
++		return ret;
++	} else if (ret) {
++		dev_dbg(dev,
++			"%s 2ns TX delay (and changing the value from pin-strapping RXD1 or the bootloader)\n",
++			val_txdly ? "Enabling" : "Disabling");
++	} else {
++		dev_dbg(dev,
++			"2ns TX delay was already %s (by pin-strapping RXD1 or bootloader configuration)\n",
++			val_txdly ? "enabled" : "disabled");
++	}
++
++	ret = phy_modify_paged_changed(phydev, 0xd08, 0x15, RTL8211F_RX_DELAY,
++				       val_rxdly);
++	if (ret < 0) {
++		dev_err(dev, "Failed to update the RX delay register\n");
++		return ret;
++	} else if (ret) {
++		dev_dbg(dev,
++			"%s 2ns RX delay (and changing the value from pin-strapping RXD0 or the bootloader)\n",
++			val_rxdly ? "Enabling" : "Disabling");
++	} else {
++		dev_dbg(dev,
++			"2ns RX delay was already %s (by pin-strapping RXD0 or bootloader configuration)\n",
++			val_rxdly ? "enabled" : "disabled");
++	}
++
++	if (priv->has_phycr2) {
++		ret = phy_modify_paged(phydev, 0xa43, RTL8211F_PHYCR2,
++				       RTL8211F_CLKOUT_EN, priv->phycr2);
++		if (ret < 0) {
++			dev_err(dev, "clkout configuration failed: %pe\n",
++				ERR_PTR(ret));
++			return ret;
++		}
++
++		return genphy_soft_reset(phydev);
++	}
++
++	return 0;
++}
++
++static int rtl821x_suspend(struct phy_device *phydev)
++{
++	struct rtl821x_priv *priv = phydev->priv;
++	int ret = 0;
++
++	if (!phydev->wol_enabled) {
++		ret = genphy_suspend(phydev);
++
++		if (ret)
++			return ret;
++
++		clk_disable_unprepare(priv->clk);
++	}
++
++	return ret;
++}
++
++static int rtl821x_resume(struct phy_device *phydev)
++{
++	struct rtl821x_priv *priv = phydev->priv;
++	int ret;
++
++	if (!phydev->wol_enabled)
++		clk_prepare_enable(priv->clk);
++
++	ret = genphy_resume(phydev);
++	if (ret < 0)
++		return ret;
++
++	msleep(20);
++
++	return 0;
++}
++
++static int rtl8211f_led_hw_is_supported(struct phy_device *phydev, u8 index,
++					unsigned long rules)
++{
++	const unsigned long mask = BIT(TRIGGER_NETDEV_LINK_10) |
++				   BIT(TRIGGER_NETDEV_LINK_100) |
++				   BIT(TRIGGER_NETDEV_LINK_1000) |
++				   BIT(TRIGGER_NETDEV_RX) |
++				   BIT(TRIGGER_NETDEV_TX);
++
++	/* The RTL8211F PHY supports these LED settings on up to three LEDs:
++	 * - Link: Configurable subset of 10/100/1000 link rates
++	 * - Active: Blink on activity, RX or TX is not differentiated
++	 * The Active option has two modes, A and B:
++	 * - A: Link and Active indication at configurable, but matching,
++	 *      subset of 10/100/1000 link rates
++	 * - B: Link indication at configurable subset of 10/100/1000 link
++	 *      rates and Active indication always at all three 10+100+1000
++	 *      link rates.
++	 * This code currently uses mode B only.
++	 */
++
++	if (index >= RTL8211F_LED_COUNT)
++		return -EINVAL;
++
++	/* Filter out any other unsupported triggers. */
++	if (rules & ~mask)
++		return -EOPNOTSUPP;
++
++	/* RX and TX are not differentiated, either both are set or not set. */
++	if (!(rules & BIT(TRIGGER_NETDEV_RX)) ^ !(rules & BIT(TRIGGER_NETDEV_TX)))
++		return -EOPNOTSUPP;
++
++	return 0;
++}
++
++static int rtl8211f_led_hw_control_get(struct phy_device *phydev, u8 index,
++				       unsigned long *rules)
++{
++	int val;
++
++	if (index >= RTL8211F_LED_COUNT)
++		return -EINVAL;
++
++	val = phy_read_paged(phydev, 0xd04, RTL8211F_LEDCR);
++	if (val < 0)
++		return val;
++
++	val >>= RTL8211F_LEDCR_SHIFT * index;
++	val &= RTL8211F_LEDCR_MASK;
++
++	if (val & RTL8211F_LEDCR_LINK_10)
++		set_bit(TRIGGER_NETDEV_LINK_10, rules);
++
++	if (val & RTL8211F_LEDCR_LINK_100)
++		set_bit(TRIGGER_NETDEV_LINK_100, rules);
++
++	if (val & RTL8211F_LEDCR_LINK_1000)
++		set_bit(TRIGGER_NETDEV_LINK_1000, rules);
++
++	if (val & RTL8211F_LEDCR_ACT_TXRX) {
++		set_bit(TRIGGER_NETDEV_RX, rules);
++		set_bit(TRIGGER_NETDEV_TX, rules);
++	}
++
++	return 0;
++}
++
++static int rtl8211f_led_hw_control_set(struct phy_device *phydev, u8 index,
++				       unsigned long rules)
++{
++	const u16 mask = RTL8211F_LEDCR_MASK << (RTL8211F_LEDCR_SHIFT * index);
++	u16 reg = 0;
++
++	if (index >= RTL8211F_LED_COUNT)
++		return -EINVAL;
++
++	if (test_bit(TRIGGER_NETDEV_LINK_10, &rules))
++		reg |= RTL8211F_LEDCR_LINK_10;
++
++	if (test_bit(TRIGGER_NETDEV_LINK_100, &rules))
++		reg |= RTL8211F_LEDCR_LINK_100;
++
++	if (test_bit(TRIGGER_NETDEV_LINK_1000, &rules))
++		reg |= RTL8211F_LEDCR_LINK_1000;
++
++	if (test_bit(TRIGGER_NETDEV_RX, &rules) ||
++	    test_bit(TRIGGER_NETDEV_TX, &rules)) {
++		reg |= RTL8211F_LEDCR_ACT_TXRX;
++	}
++
++	reg <<= RTL8211F_LEDCR_SHIFT * index;
++	reg |= RTL8211F_LEDCR_MODE;	 /* Mode B */
++
++	return phy_modify_paged(phydev, 0xd04, RTL8211F_LEDCR, mask, reg);
++}
++
++static int rtl8211e_config_init(struct phy_device *phydev)
++{
++	int ret = 0, oldpage;
++	u16 val;
++
++	/* enable TX/RX delay for rgmii-* modes, and disable them for rgmii. */
++	switch (phydev->interface) {
++	case PHY_INTERFACE_MODE_RGMII:
++		val = RTL8211E_CTRL_DELAY | 0;
++		break;
++	case PHY_INTERFACE_MODE_RGMII_ID:
++		val = RTL8211E_CTRL_DELAY | RTL8211E_TX_DELAY | RTL8211E_RX_DELAY;
++		break;
++	case PHY_INTERFACE_MODE_RGMII_RXID:
++		val = RTL8211E_CTRL_DELAY | RTL8211E_RX_DELAY;
++		break;
++	case PHY_INTERFACE_MODE_RGMII_TXID:
++		val = RTL8211E_CTRL_DELAY | RTL8211E_TX_DELAY;
++		break;
++	default: /* the rest of the modes imply leaving delays as is. */
++		return 0;
++	}
++
++	/* According to a sample driver there is a 0x1c config register on the
++	 * 0xa4 extension page (0x7) layout. It can be used to disable/enable
++	 * the RX/TX delays otherwise controlled by RXDLY/TXDLY pins.
++	 * The configuration register definition:
++	 * 14 = reserved
++	 * 13 = Force Tx RX Delay controlled by bit12 bit11,
++	 * 12 = RX Delay, 11 = TX Delay
++	 * 10:0 = Test && debug settings reserved by realtek
++	 */
++	oldpage = phy_select_page(phydev, 0x7);
++	if (oldpage < 0)
++		goto err_restore_page;
++
++	ret = __phy_write(phydev, RTL821x_EXT_PAGE_SELECT, 0xa4);
++	if (ret)
++		goto err_restore_page;
++
++	ret = __phy_modify(phydev, 0x1c, RTL8211E_CTRL_DELAY
++			   | RTL8211E_TX_DELAY | RTL8211E_RX_DELAY,
++			   val);
++
++err_restore_page:
++	return phy_restore_page(phydev, oldpage, ret);
++}
++
++static int rtl8211b_suspend(struct phy_device *phydev)
++{
++	phy_write(phydev, MII_MMD_DATA, BIT(9));
++
++	return genphy_suspend(phydev);
++}
++
++static int rtl8211b_resume(struct phy_device *phydev)
++{
++	phy_write(phydev, MII_MMD_DATA, 0);
++
++	return genphy_resume(phydev);
++}
++
++static int rtl8366rb_config_init(struct phy_device *phydev)
++{
++	int ret;
++
++	ret = phy_set_bits(phydev, RTL8366RB_POWER_SAVE,
++			   RTL8366RB_POWER_SAVE_ON);
++	if (ret) {
++		dev_err(&phydev->mdio.dev,
++			"error enabling power management\n");
++	}
++
++	return ret;
++}
++
++/* get actual speed to cover the downshift case */
++static void rtlgen_decode_physr(struct phy_device *phydev, int val)
++{
++	/* bit 3
++	 * 0: Half Duplex
++	 * 1: Full Duplex
++	 */
++	if (val & RTL_VND2_PHYSR_DUPLEX)
++		phydev->duplex = DUPLEX_FULL;
++	else
++		phydev->duplex = DUPLEX_HALF;
++
++	switch (val & RTL_VND2_PHYSR_SPEED_MASK) {
++	case 0x0000:
++		phydev->speed = SPEED_10;
++		break;
++	case 0x0010:
++		phydev->speed = SPEED_100;
++		break;
++	case 0x0020:
++		phydev->speed = SPEED_1000;
++		break;
++	case 0x0200:
++		phydev->speed = SPEED_10000;
++		break;
++	case 0x0210:
++		phydev->speed = SPEED_2500;
++		break;
++	case 0x0220:
++		phydev->speed = SPEED_5000;
++		break;
++	default:
++		break;
++	}
++
++	/* bit 11
++	 * 0: Slave Mode
++	 * 1: Master Mode
++	 */
++	if (phydev->speed >= 1000) {
++		if (val & RTL_VND2_PHYSR_MASTER)
++			phydev->master_slave_state = MASTER_SLAVE_STATE_MASTER;
++		else
++			phydev->master_slave_state = MASTER_SLAVE_STATE_SLAVE;
++	} else {
++		phydev->master_slave_state = MASTER_SLAVE_STATE_UNSUPPORTED;
++	}
++}
++
++static int rtlgen_read_status(struct phy_device *phydev)
++{
++	int ret, val;
++
++	ret = genphy_read_status(phydev);
++	if (ret < 0)
++		return ret;
++
++	if (!phydev->link)
++		return 0;
++
++	val = phy_read_paged(phydev, 0xa43, 0x12);
++	if (val < 0)
++		return val;
++
++	rtlgen_decode_physr(phydev, val);
++
++	return 0;
++}
++
++static int rtlgen_read_mmd(struct phy_device *phydev, int devnum, u16 regnum)
++{
++	int ret;
++
++	if (devnum == MDIO_MMD_VEND2) {
++		rtl821x_write_page(phydev, regnum >> 4);
++		ret = __phy_read(phydev, 0x10 + ((regnum & 0xf) >> 1));
++		rtl821x_write_page(phydev, 0);
++	} else if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE) {
++		rtl821x_write_page(phydev, 0xa5c);
++		ret = __phy_read(phydev, 0x12);
++		rtl821x_write_page(phydev, 0);
++	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {
++		rtl821x_write_page(phydev, 0xa5d);
++		ret = __phy_read(phydev, 0x10);
++		rtl821x_write_page(phydev, 0);
++	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE) {
++		rtl821x_write_page(phydev, 0xa5d);
++		ret = __phy_read(phydev, 0x11);
++		rtl821x_write_page(phydev, 0);
++	} else {
++		ret = -EOPNOTSUPP;
++	}
++
++	return ret;
++}
++
++static int rtlgen_write_mmd(struct phy_device *phydev, int devnum, u16 regnum,
++			    u16 val)
++{
++	int ret;
++
++	if (devnum == MDIO_MMD_VEND2) {
++		rtl821x_write_page(phydev, regnum >> 4);
++		ret = __phy_write(phydev, 0x10 + ((regnum & 0xf) >> 1), val);
++		rtl821x_write_page(phydev, 0);
++	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {
++		rtl821x_write_page(phydev, 0xa5d);
++		ret = __phy_write(phydev, 0x10, val);
++		rtl821x_write_page(phydev, 0);
++	} else {
++		ret = -EOPNOTSUPP;
++	}
++
++	return ret;
++}
++
++static int rtl822x_read_mmd(struct phy_device *phydev, int devnum, u16 regnum)
++{
++	int ret = rtlgen_read_mmd(phydev, devnum, regnum);
++
++	if (ret != -EOPNOTSUPP)
++		return ret;
++
++	if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE2) {
++		rtl821x_write_page(phydev, 0xa6e);
++		ret = __phy_read(phydev, 0x16);
++		rtl821x_write_page(phydev, 0);
++	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2) {
++		rtl821x_write_page(phydev, 0xa6d);
++		ret = __phy_read(phydev, 0x12);
++		rtl821x_write_page(phydev, 0);
++	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE2) {
++		rtl821x_write_page(phydev, 0xa6d);
++		ret = __phy_read(phydev, 0x10);
++		rtl821x_write_page(phydev, 0);
++	}
++
++	return ret;
++}
++
++static int rtl822x_write_mmd(struct phy_device *phydev, int devnum, u16 regnum,
++			     u16 val)
++{
++	int ret = rtlgen_write_mmd(phydev, devnum, regnum, val);
++
++	if (ret != -EOPNOTSUPP)
++		return ret;
++
++	if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2) {
++		rtl821x_write_page(phydev, 0xa6d);
++		ret = __phy_write(phydev, 0x12, val);
++		rtl821x_write_page(phydev, 0);
++	}
++
++	return ret;
++}
++
++static int rtl822xb_config_init(struct phy_device *phydev)
++{
++	bool has_2500, has_sgmii;
++	u16 mode;
++	int ret;
++
++	has_2500 = test_bit(PHY_INTERFACE_MODE_2500BASEX,
++			    phydev->host_interfaces) ||
++		   phydev->interface == PHY_INTERFACE_MODE_2500BASEX;
++
++	has_sgmii = test_bit(PHY_INTERFACE_MODE_SGMII,
++			     phydev->host_interfaces) ||
++		    phydev->interface == PHY_INTERFACE_MODE_SGMII;
++
++	/* fill in possible interfaces */
++	__assign_bit(PHY_INTERFACE_MODE_2500BASEX, phydev->possible_interfaces,
++		     has_2500);
++	__assign_bit(PHY_INTERFACE_MODE_SGMII, phydev->possible_interfaces,
++		     has_sgmii);
++
++	if (!has_2500 && !has_sgmii)
++		return 0;
++
++	/* determine SerDes option mode */
++	if (has_2500 && !has_sgmii) {
++		mode = RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX;
++		phydev->rate_matching = RATE_MATCH_PAUSE;
++	} else {
++		mode = RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX_SGMII;
++		phydev->rate_matching = RATE_MATCH_NONE;
++	}
++
++	/* the following sequence with magic numbers sets up the SerDes
++	 * option mode
++	 */
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x75f3, 0);
++	if (ret < 0)
++		return ret;
++
++	ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND1,
++				     RTL822X_VND1_SERDES_OPTION,
++				     RTL822X_VND1_SERDES_OPTION_MODE_MASK,
++				     mode);
++	if (ret < 0)
++		return ret;
++
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x6a04, 0x0503);
++	if (ret < 0)
++		return ret;
++
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x6f10, 0xd455);
++	if (ret < 0)
++		return ret;
++
++	return phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x6f11, 0x8020);
++}
++
++static int rtl822xb_get_rate_matching(struct phy_device *phydev,
++				      phy_interface_t iface)
++{
++	int val;
++
++	/* Only rate matching at 2500base-x */
++	if (iface != PHY_INTERFACE_MODE_2500BASEX)
++		return RATE_MATCH_NONE;
++
++	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, RTL822X_VND1_SERDES_OPTION);
++	if (val < 0)
++		return val;
++
++	if ((val & RTL822X_VND1_SERDES_OPTION_MODE_MASK) ==
++	    RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX)
++		return RATE_MATCH_PAUSE;
++
++	/* RTL822X_VND1_SERDES_OPTION_MODE_2500BASEX_SGMII */
++	return RATE_MATCH_NONE;
++}
++
++static int rtl822x_get_features(struct phy_device *phydev)
++{
++	int val;
++
++	val = phy_read_paged(phydev, 0xa61, 0x13);
++	if (val < 0)
++		return val;
++
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
++			 phydev->supported, val & MDIO_PMA_SPEED_2_5G);
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
++			 phydev->supported, val & MDIO_PMA_SPEED_5G);
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
++			 phydev->supported, val & MDIO_SPEED_10G);
++
++	return genphy_read_abilities(phydev);
++}
++
++static int rtl822x_config_aneg(struct phy_device *phydev)
++{
++	int ret = 0;
++
++	if (phydev->autoneg == AUTONEG_ENABLE) {
++		u16 adv = linkmode_adv_to_mii_10gbt_adv_t(phydev->advertising);
++
++		ret = phy_modify_paged_changed(phydev, 0xa5d, 0x12,
++					       MDIO_AN_10GBT_CTRL_ADV2_5G |
++					       MDIO_AN_10GBT_CTRL_ADV5G,
++					       adv);
++		if (ret < 0)
++			return ret;
++	}
++
++	return __genphy_config_aneg(phydev, ret);
++}
++
++static void rtl822xb_update_interface(struct phy_device *phydev)
++{
++	int val;
++
++	if (!phydev->link)
++		return;
++
++	/* Change interface according to serdes mode */
++	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, RTL822X_VND1_SERDES_CTRL3);
++	if (val < 0)
++		return;
++
++	switch (val & RTL822X_VND1_SERDES_CTRL3_MODE_MASK) {
++	case RTL822X_VND1_SERDES_CTRL3_MODE_2500BASEX:
++		phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
++		break;
++	case RTL822X_VND1_SERDES_CTRL3_MODE_SGMII:
++		phydev->interface = PHY_INTERFACE_MODE_SGMII;
++		break;
++	}
++}
++
++static int rtl822x_read_status(struct phy_device *phydev)
++{
++	int lpadv, ret;
++
++	mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
++
++	ret = rtlgen_read_status(phydev);
++	if (ret < 0)
++		return ret;
++
++	if (phydev->autoneg == AUTONEG_DISABLE ||
++	    !phydev->autoneg_complete)
++		return 0;
++
++	lpadv = phy_read_paged(phydev, 0xa5d, 0x13);
++	if (lpadv < 0)
++		return lpadv;
++
++	mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, lpadv);
++
++	return 0;
++}
++
++static int rtl822xb_read_status(struct phy_device *phydev)
++{
++	int ret;
++
++	ret = rtl822x_read_status(phydev);
++	if (ret < 0)
++		return ret;
++
++	rtl822xb_update_interface(phydev);
++
++	return 0;
++}
++
++static int rtl822x_c45_get_features(struct phy_device *phydev)
++{
++	linkmode_set_bit(ETHTOOL_LINK_MODE_TP_BIT,
++			 phydev->supported);
++
++	return genphy_c45_pma_read_abilities(phydev);
++}
++
++static int rtl822x_c45_config_aneg(struct phy_device *phydev)
++{
++	bool changed = false;
++	int ret, val;
++
++	if (phydev->autoneg == AUTONEG_DISABLE)
++		return genphy_c45_pma_setup_forced(phydev);
++
++	ret = genphy_c45_an_config_aneg(phydev);
++	if (ret < 0)
++		return ret;
++	if (ret > 0)
++		changed = true;
++
++	val = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);
++
++	/* Vendor register as C45 has no standardized support for 1000BaseT */
++	ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2, RTL822X_VND2_GBCR,
++				     ADVERTISE_1000FULL, val);
++	if (ret < 0)
++		return ret;
++	if (ret > 0)
++		changed = true;
++
++	return genphy_c45_check_and_restart_aneg(phydev, changed);
++}
++
++static int rtl822x_c45_read_status(struct phy_device *phydev)
++{
++	int ret, val;
++
++	/* Vendor register as C45 has no standardized support for 1000BaseT */
++	if (phydev->autoneg == AUTONEG_ENABLE && genphy_c45_aneg_done(phydev)) {
++		val = phy_read_mmd(phydev, MDIO_MMD_VEND2,
++				   RTL822X_VND2_GANLPAR);
++		if (val < 0)
++			return val;
++	} else {
++		val = 0;
++	}
++	mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, val);
++
++	ret = genphy_c45_read_status(phydev);
++	if (ret < 0)
++		return ret;
++
++	if (!phydev->link) {
++		phydev->master_slave_state = MASTER_SLAVE_STATE_UNKNOWN;
++		return 0;
++	}
++
++	/* Read actual speed from vendor register. */
++	val = phy_read_mmd(phydev, MDIO_MMD_VEND2, RTL_VND2_PHYSR);
++	if (val < 0)
++		return val;
++
++	rtlgen_decode_physr(phydev, val);
++
++	return 0;
++}
++
++static int rtl822xb_c45_read_status(struct phy_device *phydev)
++{
++	int ret;
++
++	ret = rtl822x_c45_read_status(phydev);
++	if (ret < 0)
++		return ret;
++
++	rtl822xb_update_interface(phydev);
++
++	return 0;
++}
++
++static bool rtlgen_supports_2_5gbps(struct phy_device *phydev)
++{
++	int val;
++
++	phy_write(phydev, RTL821x_PAGE_SELECT, 0xa61);
++	val = phy_read(phydev, 0x13);
++	phy_write(phydev, RTL821x_PAGE_SELECT, 0);
++
++	return val >= 0 && val & MDIO_PMA_SPEED_2_5G;
++}
++
++/* On internal PHY's MMD reads over C22 always return 0.
++ * Check a MMD register which is known to be non-zero.
++ */
++static bool rtlgen_supports_mmd(struct phy_device *phydev)
++{
++	int val;
++
++	phy_lock_mdio_bus(phydev);
++	__phy_write(phydev, MII_MMD_CTRL, MDIO_MMD_PCS);
++	__phy_write(phydev, MII_MMD_DATA, MDIO_PCS_EEE_ABLE);
++	__phy_write(phydev, MII_MMD_CTRL, MDIO_MMD_PCS | MII_MMD_CTRL_NOINCR);
++	val = __phy_read(phydev, MII_MMD_DATA);
++	phy_unlock_mdio_bus(phydev);
++
++	return val > 0;
++}
++
++static int rtlgen_match_phy_device(struct phy_device *phydev)
++{
++	return phydev->phy_id == RTL_GENERIC_PHYID &&
++	       !rtlgen_supports_2_5gbps(phydev);
++}
++
++static int rtl8226_match_phy_device(struct phy_device *phydev)
++{
++	return phydev->phy_id == RTL_GENERIC_PHYID &&
++	       rtlgen_supports_2_5gbps(phydev) &&
++	       rtlgen_supports_mmd(phydev);
++}
++
++static int rtlgen_is_c45_match(struct phy_device *phydev, unsigned int id,
++			       bool is_c45)
++{
++	if (phydev->is_c45)
++		return is_c45 && (id == phydev->c45_ids.device_ids[1]);
++	else
++		return !is_c45 && (id == phydev->phy_id);
++}
++
++static int rtl8221b_match_phy_device(struct phy_device *phydev)
++{
++	return phydev->phy_id == RTL_8221B && rtlgen_supports_mmd(phydev);
++}
++
++static int rtl8221b_vb_cg_c22_match_phy_device(struct phy_device *phydev)
++{
++	return rtlgen_is_c45_match(phydev, RTL_8221B_VB_CG, false);
++}
++
++static int rtl8221b_vb_cg_c45_match_phy_device(struct phy_device *phydev)
++{
++	return rtlgen_is_c45_match(phydev, RTL_8221B_VB_CG, true);
++}
++
++static int rtl8221b_vn_cg_c22_match_phy_device(struct phy_device *phydev)
++{
++	return rtlgen_is_c45_match(phydev, RTL_8221B_VN_CG, false);
++}
++
++static int rtl8221b_vn_cg_c45_match_phy_device(struct phy_device *phydev)
++{
++	return rtlgen_is_c45_match(phydev, RTL_8221B_VN_CG, true);
++}
++
++static int rtl_internal_nbaset_match_phy_device(struct phy_device *phydev)
++{
++	if (phydev->is_c45)
++		return false;
++
++	switch (phydev->phy_id) {
++	case RTL_GENERIC_PHYID:
++	case RTL_8221B:
++	case RTL_8251B:
++	case 0x001cc841:
++		break;
++	default:
++		return false;
++	}
++
++	return rtlgen_supports_2_5gbps(phydev) && !rtlgen_supports_mmd(phydev);
++}
++
++static int rtl8251b_c45_match_phy_device(struct phy_device *phydev)
++{
++	return rtlgen_is_c45_match(phydev, RTL_8251B, true);
++}
++
++static int rtlgen_resume(struct phy_device *phydev)
++{
++	int ret = genphy_resume(phydev);
++
++	/* Internal PHY's from RTL8168h up may not be instantly ready */
++	msleep(20);
++
++	return ret;
++}
++
++static int rtlgen_c45_resume(struct phy_device *phydev)
++{
++	int ret = genphy_c45_pma_resume(phydev);
++
++	msleep(20);
++
++	return ret;
++}
++
++static int rtl9000a_config_init(struct phy_device *phydev)
++{
++	phydev->autoneg = AUTONEG_DISABLE;
++	phydev->speed = SPEED_100;
++	phydev->duplex = DUPLEX_FULL;
++
++	return 0;
++}
++
++static int rtl9000a_config_aneg(struct phy_device *phydev)
++{
++	int ret;
++	u16 ctl = 0;
++
++	switch (phydev->master_slave_set) {
++	case MASTER_SLAVE_CFG_MASTER_FORCE:
++		ctl |= CTL1000_AS_MASTER;
++		break;
++	case MASTER_SLAVE_CFG_SLAVE_FORCE:
++		break;
++	case MASTER_SLAVE_CFG_UNKNOWN:
++	case MASTER_SLAVE_CFG_UNSUPPORTED:
++		return 0;
++	default:
++		phydev_warn(phydev, "Unsupported Master/Slave mode\n");
++		return -EOPNOTSUPP;
++	}
++
++	ret = phy_modify_changed(phydev, MII_CTRL1000, CTL1000_AS_MASTER, ctl);
++	if (ret == 1)
++		ret = genphy_soft_reset(phydev);
++
++	return ret;
++}
++
++static int rtl9000a_read_status(struct phy_device *phydev)
++{
++	int ret;
++
++	phydev->master_slave_get = MASTER_SLAVE_CFG_UNKNOWN;
++	phydev->master_slave_state = MASTER_SLAVE_STATE_UNKNOWN;
++
++	ret = genphy_update_link(phydev);
++	if (ret)
++		return ret;
++
++	ret = phy_read(phydev, MII_CTRL1000);
++	if (ret < 0)
++		return ret;
++	if (ret & CTL1000_AS_MASTER)
++		phydev->master_slave_get = MASTER_SLAVE_CFG_MASTER_FORCE;
++	else
++		phydev->master_slave_get = MASTER_SLAVE_CFG_SLAVE_FORCE;
++
++	ret = phy_read(phydev, MII_STAT1000);
++	if (ret < 0)
++		return ret;
++	if (ret & LPA_1000MSRES)
++		phydev->master_slave_state = MASTER_SLAVE_STATE_MASTER;
++	else
++		phydev->master_slave_state = MASTER_SLAVE_STATE_SLAVE;
++
++	return 0;
++}
++
++static int rtl9000a_ack_interrupt(struct phy_device *phydev)
++{
++	int err;
++
++	err = phy_read(phydev, RTL8211F_INSR);
++
++	return (err < 0) ? err : 0;
++}
++
++static int rtl9000a_config_intr(struct phy_device *phydev)
++{
++	u16 val;
++	int err;
++
++	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
++		err = rtl9000a_ack_interrupt(phydev);
++		if (err)
++			return err;
++
++		val = (u16)~RTL9000A_GINMR_LINK_STATUS;
++		err = phy_write_paged(phydev, 0xa42, RTL9000A_GINMR, val);
++	} else {
++		val = ~0;
++		err = phy_write_paged(phydev, 0xa42, RTL9000A_GINMR, val);
++		if (err)
++			return err;
++
++		err = rtl9000a_ack_interrupt(phydev);
++	}
++
++	return phy_write_paged(phydev, 0xa42, RTL9000A_GINMR, val);
++}
++
++static irqreturn_t rtl9000a_handle_interrupt(struct phy_device *phydev)
++{
++	int irq_status;
++
++	irq_status = phy_read(phydev, RTL8211F_INSR);
++	if (irq_status < 0) {
++		phy_error(phydev);
++		return IRQ_NONE;
++	}
++
++	if (!(irq_status & RTL8211F_INER_LINK_STATUS))
++		return IRQ_NONE;
++
++	phy_trigger_machine(phydev);
++
++	return IRQ_HANDLED;
++}
++
++static struct phy_driver realtek_drvs[] = {
++	{
++		PHY_ID_MATCH_EXACT(0x00008201),
++		.name           = "RTL8201CP Ethernet",
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc816),
++		.name		= "RTL8201F Fast Ethernet",
++		.config_intr	= &rtl8201_config_intr,
++		.handle_interrupt = rtl8201_handle_interrupt,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_MODEL(0x001cc880),
++		.name		= "RTL8208 Fast Ethernet",
++		.read_mmd	= genphy_read_mmd_unsupported,
++		.write_mmd	= genphy_write_mmd_unsupported,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc910),
++		.name		= "RTL8211 Gigabit Ethernet",
++		.config_aneg	= rtl8211_config_aneg,
++		.read_mmd	= &genphy_read_mmd_unsupported,
++		.write_mmd	= &genphy_write_mmd_unsupported,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc912),
++		.name		= "RTL8211B Gigabit Ethernet",
++		.config_intr	= &rtl8211b_config_intr,
++		.handle_interrupt = rtl821x_handle_interrupt,
++		.read_mmd	= &genphy_read_mmd_unsupported,
++		.write_mmd	= &genphy_write_mmd_unsupported,
++		.suspend	= rtl8211b_suspend,
++		.resume		= rtl8211b_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc913),
++		.name		= "RTL8211C Gigabit Ethernet",
++		.config_init	= rtl8211c_config_init,
++		.read_mmd	= &genphy_read_mmd_unsupported,
++		.write_mmd	= &genphy_write_mmd_unsupported,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc914),
++		.name		= "RTL8211DN Gigabit Ethernet",
++		.config_intr	= rtl8211e_config_intr,
++		.handle_interrupt = rtl821x_handle_interrupt,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc915),
++		.name		= "RTL8211E Gigabit Ethernet",
++		.config_init	= &rtl8211e_config_init,
++		.config_intr	= &rtl8211e_config_intr,
++		.handle_interrupt = rtl821x_handle_interrupt,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc916),
++		.name		= "RTL8211F Gigabit Ethernet",
++		.probe		= rtl821x_probe,
++		.config_init	= &rtl8211f_config_init,
++		.read_status	= rtlgen_read_status,
++		.config_intr	= &rtl8211f_config_intr,
++		.handle_interrupt = rtl8211f_handle_interrupt,
++		.suspend	= rtl821x_suspend,
++		.resume		= rtl821x_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++		.flags		= PHY_ALWAYS_CALL_SUSPEND,
++		.led_hw_is_supported = rtl8211f_led_hw_is_supported,
++		.led_hw_control_get = rtl8211f_led_hw_control_get,
++		.led_hw_control_set = rtl8211f_led_hw_control_set,
++	}, {
++		PHY_ID_MATCH_EXACT(RTL_8211FVD_PHYID),
++		.name		= "RTL8211F-VD Gigabit Ethernet",
++		.probe		= rtl821x_probe,
++		.config_init	= &rtl8211f_config_init,
++		.read_status	= rtlgen_read_status,
++		.config_intr	= &rtl8211f_config_intr,
++		.handle_interrupt = rtl8211f_handle_interrupt,
++		.suspend	= rtl821x_suspend,
++		.resume		= rtl821x_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++		.flags		= PHY_ALWAYS_CALL_SUSPEND,
++	}, {
++		.name		= "Generic FE-GE Realtek PHY",
++		.match_phy_device = rtlgen_match_phy_device,
++		.read_status	= rtlgen_read_status,
++		.suspend	= genphy_suspend,
++		.resume		= rtlgen_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++		.read_mmd	= rtlgen_read_mmd,
++		.write_mmd	= rtlgen_write_mmd,
++	}, {
++		.name		= "RTL8226 2.5Gbps PHY",
++		.match_phy_device = rtl8226_match_phy_device,
++		.get_features	= rtl822x_get_features,
++		.config_aneg	= rtl822x_config_aneg,
++		.read_status	= rtl822x_read_status,
++		.suspend	= genphy_suspend,
++		.resume		= rtlgen_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		.match_phy_device = rtl8221b_match_phy_device,
++		.name		= "RTL8226B_RTL8221B 2.5Gbps PHY",
++		.get_features	= rtl822x_get_features,
++		.config_aneg	= rtl822x_config_aneg,
++		.config_init    = rtl822xb_config_init,
++		.get_rate_matching = rtl822xb_get_rate_matching,
++		.read_status	= rtl822xb_read_status,
++		.suspend	= genphy_suspend,
++		.resume		= rtlgen_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc838),
++		.name           = "RTL8226-CG 2.5Gbps PHY",
++		.get_features   = rtl822x_get_features,
++		.config_aneg    = rtl822x_config_aneg,
++		.read_status    = rtl822x_read_status,
++		.suspend        = genphy_suspend,
++		.resume         = rtlgen_resume,
++		.read_page      = rtl821x_read_page,
++		.write_page     = rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc848),
++		.name           = "RTL8226B-CG_RTL8221B-CG 2.5Gbps PHY",
++		.get_features   = rtl822x_get_features,
++		.config_aneg    = rtl822x_config_aneg,
++		.config_init    = rtl822xb_config_init,
++		.get_rate_matching = rtl822xb_get_rate_matching,
++		.read_status    = rtl822xb_read_status,
++		.suspend        = genphy_suspend,
++		.resume         = rtlgen_resume,
++		.read_page      = rtl821x_read_page,
++		.write_page     = rtl821x_write_page,
++	}, {
++		.match_phy_device = rtl8221b_vb_cg_c22_match_phy_device,
++		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C22)",
++		.get_features   = rtl822x_get_features,
++		.config_aneg    = rtl822x_config_aneg,
++		.config_init    = rtl822xb_config_init,
++		.get_rate_matching = rtl822xb_get_rate_matching,
++		.read_status    = rtl822xb_read_status,
++		.suspend        = genphy_suspend,
++		.resume         = rtlgen_resume,
++		.read_page      = rtl821x_read_page,
++		.write_page     = rtl821x_write_page,
++	}, {
++		.match_phy_device = rtl8221b_vb_cg_c45_match_phy_device,
++		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C45)",
++		.config_init    = rtl822xb_config_init,
++		.get_rate_matching = rtl822xb_get_rate_matching,
++		.get_features   = rtl822x_c45_get_features,
++		.config_aneg    = rtl822x_c45_config_aneg,
++		.read_status    = rtl822xb_c45_read_status,
++		.suspend        = genphy_c45_pma_suspend,
++		.resume         = rtlgen_c45_resume,
++	}, {
++		.match_phy_device = rtl8221b_vn_cg_c22_match_phy_device,
++		.name           = "RTL8221B-VM-CG 2.5Gbps PHY (C22)",
++		.get_features   = rtl822x_get_features,
++		.config_aneg    = rtl822x_config_aneg,
++		.config_init    = rtl822xb_config_init,
++		.get_rate_matching = rtl822xb_get_rate_matching,
++		.read_status    = rtl822xb_read_status,
++		.suspend        = genphy_suspend,
++		.resume         = rtlgen_resume,
++		.read_page      = rtl821x_read_page,
++		.write_page     = rtl821x_write_page,
++	}, {
++		.match_phy_device = rtl8221b_vn_cg_c45_match_phy_device,
++		.name           = "RTL8221B-VN-CG 2.5Gbps PHY (C45)",
++		.config_init    = rtl822xb_config_init,
++		.get_rate_matching = rtl822xb_get_rate_matching,
++		.get_features   = rtl822x_c45_get_features,
++		.config_aneg    = rtl822x_c45_config_aneg,
++		.read_status    = rtl822xb_c45_read_status,
++		.suspend        = genphy_c45_pma_suspend,
++		.resume         = rtlgen_c45_resume,
++	}, {
++		.match_phy_device = rtl8251b_c45_match_phy_device,
++		.name           = "RTL8251B 5Gbps PHY",
++		.get_features   = rtl822x_get_features,
++		.config_aneg    = rtl822x_config_aneg,
++		.read_status    = rtl822x_read_status,
++		.suspend        = genphy_suspend,
++		.resume         = rtlgen_resume,
++		.read_page      = rtl821x_read_page,
++		.write_page     = rtl821x_write_page,
++	}, {
++		.match_phy_device = rtl_internal_nbaset_match_phy_device,
++		.name           = "Realtek Internal NBASE-T PHY",
++		.flags		= PHY_IS_INTERNAL,
++		.get_features   = rtl822x_get_features,
++		.config_aneg    = rtl822x_config_aneg,
++		.read_status    = rtl822x_read_status,
++		.suspend        = genphy_suspend,
++		.resume         = rtlgen_resume,
++		.read_page      = rtl821x_read_page,
++		.write_page     = rtl821x_write_page,
++		.read_mmd	= rtl822x_read_mmd,
++		.write_mmd	= rtl822x_write_mmd,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001ccad0),
++		.name		= "RTL8224 2.5Gbps PHY",
++		.get_features   = rtl822x_c45_get_features,
++		.config_aneg    = rtl822x_c45_config_aneg,
++		.read_status    = rtl822x_c45_read_status,
++		.suspend        = genphy_c45_pma_suspend,
++		.resume         = rtlgen_c45_resume,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc961),
++		.name		= "RTL8366RB Gigabit Ethernet",
++		.config_init	= &rtl8366rb_config_init,
++		/* These interrupts are handled by the irq controller
++		 * embedded inside the RTL8366RB, they get unmasked when the
++		 * irq is requested and ACKed by reading the status register,
++		 * which is done by the irqchip code.
++		 */
++		.config_intr	= genphy_no_config_intr,
++		.handle_interrupt = genphy_handle_interrupt_no_ack,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001ccb00),
++		.name		= "RTL9000AA_RTL9000AN Ethernet",
++		.features       = PHY_BASIC_T1_FEATURES,
++		.config_init	= rtl9000a_config_init,
++		.config_aneg	= rtl9000a_config_aneg,
++		.read_status	= rtl9000a_read_status,
++		.config_intr	= rtl9000a_config_intr,
++		.handle_interrupt = rtl9000a_handle_interrupt,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_page	= rtl821x_read_page,
++		.write_page	= rtl821x_write_page,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc942),
++		.name		= "RTL8365MB-VC Gigabit Ethernet",
++		/* Interrupt handling analogous to RTL8366RB */
++		.config_intr	= genphy_no_config_intr,
++		.handle_interrupt = genphy_handle_interrupt_no_ack,
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++	}, {
++		PHY_ID_MATCH_EXACT(0x001cc960),
++		.name		= "RTL8366S Gigabit Ethernet",
++		.suspend	= genphy_suspend,
++		.resume		= genphy_resume,
++		.read_mmd	= genphy_read_mmd_unsupported,
++		.write_mmd	= genphy_write_mmd_unsupported,
++	},
++};
++
++module_phy_driver(realtek_drvs);
++
++static const struct mdio_device_id __maybe_unused realtek_tbl[] = {
++	{ PHY_ID_MATCH_VENDOR(0x001cc800) },
++	{ }
++};
++
++MODULE_DEVICE_TABLE(mdio, realtek_tbl);
diff --git a/target/linux/generic/backport-6.12/781-11-v6.14-net-phy-realtek-add-hwmon-support-for-temp-sensor-on.patch b/target/linux/generic/backport-6.12/781-11-v6.14-net-phy-realtek-add-hwmon-support-for-temp-sensor-on.patch
new file mode 100644
index 0000000000..2dec701028
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-11-v6.14-net-phy-realtek-add-hwmon-support-for-temp-sensor-on.patch
@@ -0,0 +1,173 @@
+From 33700ca45b7d2e1655d4cad95e25671e8a94e2f0 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Sat, 11 Jan 2025 21:51:24 +0100
+Subject: [PATCH] net: phy: realtek: add hwmon support for temp sensor on
+ RTL822x
+
+This adds hwmon support for the temperature sensor on RTL822x.
+It's available on the standalone versions of the PHY's, and on
+the integrated PHY's in RTL8125B/RTL8125D/RTL8126.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/ad6bfe9f-6375-4a00-84b4-bfb38a21bd71@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/realtek/Kconfig         |  6 ++
+ drivers/net/phy/realtek/Makefile        |  1 +
+ drivers/net/phy/realtek/realtek.h       | 10 ++++
+ drivers/net/phy/realtek/realtek_hwmon.c | 79 +++++++++++++++++++++++++
+ drivers/net/phy/realtek/realtek_main.c  | 12 ++++
+ 5 files changed, 108 insertions(+)
+ create mode 100644 drivers/net/phy/realtek/realtek.h
+ create mode 100644 drivers/net/phy/realtek/realtek_hwmon.c
+
+--- a/drivers/net/phy/realtek/Kconfig
++++ b/drivers/net/phy/realtek/Kconfig
+@@ -3,3 +3,9 @@ config REALTEK_PHY
+ 	tristate "Realtek PHYs"
+ 	help
+ 	  Currently supports RTL821x/RTL822x and fast ethernet PHYs
++
++config REALTEK_PHY_HWMON
++	def_bool REALTEK_PHY && HWMON
++	depends on !(REALTEK_PHY=y && HWMON=m)
++	help
++	  Optional hwmon support for the temperature sensor
+--- a/drivers/net/phy/realtek/Makefile
++++ b/drivers/net/phy/realtek/Makefile
+@@ -1,3 +1,4 @@
+ # SPDX-License-Identifier: GPL-2.0
+ realtek-y			+= realtek_main.o
++realtek-$(CONFIG_REALTEK_PHY_HWMON) += realtek_hwmon.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+--- /dev/null
++++ b/drivers/net/phy/realtek/realtek.h
+@@ -0,0 +1,10 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++
++#ifndef REALTEK_H
++#define REALTEK_H
++
++#include <linux/phy.h>
++
++int rtl822x_hwmon_init(struct phy_device *phydev);
++
++#endif /* REALTEK_H */
+--- /dev/null
++++ b/drivers/net/phy/realtek/realtek_hwmon.c
+@@ -0,0 +1,79 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * HWMON support for Realtek PHY's
++ *
++ * Author: Heiner Kallweit <hkallweit1@gmail.com>
++ */
++
++#include <linux/hwmon.h>
++#include <linux/phy.h>
++
++#include "realtek.h"
++
++#define RTL822X_VND2_TSALRM				0xa662
++#define RTL822X_VND2_TSRR				0xbd84
++#define RTL822X_VND2_TSSR				0xb54c
++
++static int rtl822x_hwmon_get_temp(int raw)
++{
++	if (raw >= 512)
++		raw -= 1024;
++
++	return 1000 * raw / 2;
++}
++
++static int rtl822x_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
++			      u32 attr, int channel, long *val)
++{
++	struct phy_device *phydev = dev_get_drvdata(dev);
++	int raw;
++
++	switch (attr) {
++	case hwmon_temp_input:
++		raw = phy_read_mmd(phydev, MDIO_MMD_VEND2, RTL822X_VND2_TSRR) & 0x3ff;
++		*val = rtl822x_hwmon_get_temp(raw);
++		break;
++	case hwmon_temp_max:
++		/* Chip reduces speed to 1G if threshold is exceeded */
++		raw = phy_read_mmd(phydev, MDIO_MMD_VEND2, RTL822X_VND2_TSSR) >> 6;
++		*val = rtl822x_hwmon_get_temp(raw);
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static const struct hwmon_ops rtl822x_hwmon_ops = {
++	.visible = 0444,
++	.read = rtl822x_hwmon_read,
++};
++
++static const struct hwmon_channel_info * const rtl822x_hwmon_info[] = {
++	HWMON_CHANNEL_INFO(temp, HWMON_T_INPUT | HWMON_T_MAX),
++	NULL
++};
++
++static const struct hwmon_chip_info rtl822x_hwmon_chip_info = {
++	.ops = &rtl822x_hwmon_ops,
++	.info = rtl822x_hwmon_info,
++};
++
++int rtl822x_hwmon_init(struct phy_device *phydev)
++{
++	struct device *hwdev, *dev = &phydev->mdio.dev;
++	const char *name;
++
++	/* Ensure over-temp alarm is reset. */
++	phy_clear_bits_mmd(phydev, MDIO_MMD_VEND2, RTL822X_VND2_TSALRM, 3);
++
++	name = devm_hwmon_sanitize_name(dev, dev_name(dev));
++	if (IS_ERR(name))
++		return PTR_ERR(name);
++
++	hwdev = devm_hwmon_device_register_with_info(dev, name, phydev,
++						     &rtl822x_hwmon_chip_info,
++						     NULL);
++	return PTR_ERR_OR_ZERO(hwdev);
++}
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -14,6 +14,8 @@
+ #include <linux/delay.h>
+ #include <linux/clk.h>
+ 
++#include "realtek.h"
++
+ #define RTL821x_PHYSR				0x11
+ #define RTL821x_PHYSR_DUPLEX			BIT(13)
+ #define RTL821x_PHYSR_SPEED			GENMASK(15, 14)
+@@ -820,6 +822,15 @@ static int rtl822x_write_mmd(struct phy_
+ 	return ret;
+ }
+ 
++static int rtl822x_probe(struct phy_device *phydev)
++{
++	if (IS_ENABLED(CONFIG_REALTEK_PHY_HWMON) &&
++	    phydev->phy_id != RTL_GENERIC_PHYID)
++		return rtl822x_hwmon_init(phydev);
++
++	return 0;
++}
++
+ static int rtl822xb_config_init(struct phy_device *phydev)
+ {
+ 	bool has_2500, has_sgmii;
+@@ -1518,6 +1529,7 @@ static struct phy_driver realtek_drvs[]
+ 		.match_phy_device = rtl_internal_nbaset_match_phy_device,
+ 		.name           = "Realtek Internal NBASE-T PHY",
+ 		.flags		= PHY_IS_INTERNAL,
++		.probe		= rtl822x_probe,
+ 		.get_features   = rtl822x_get_features,
+ 		.config_aneg    = rtl822x_config_aneg,
+ 		.read_status    = rtl822x_read_status,
diff --git a/target/linux/generic/backport-6.12/781-12-v6.14-net-phy-realtek-HWMON-support-for-standalone-version.patch b/target/linux/generic/backport-6.12/781-12-v6.14-net-phy-realtek-HWMON-support-for-standalone-version.patch
new file mode 100644
index 0000000000..8b8c97c54f
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-12-v6.14-net-phy-realtek-HWMON-support-for-standalone-version.patch
@@ -0,0 +1,64 @@
+From 64ff63aeefb03139ae27454bd4208244579ae88e Mon Sep 17 00:00:00 2001
+From: Aleksander Jan Bajkowski <olek2@wp.pl>
+Date: Fri, 17 Jan 2025 23:24:21 +0100
+Subject: [PATCH] net: phy: realtek: HWMON support for standalone versions of
+ RTL8221B and RTL8251
+
+HWMON support has been added for the RTL8221/8251 PHYs integrated together
+with the MAC inside the RTL8125/8126 chips. This patch extends temperature
+reading support for standalone variants of the mentioned PHYs.
+
+I don't know whether the earlier revisions of the RTL8226 also have a
+built-in temperature sensor, so they have been skipped for now.
+
+Tested on RTL8221B-VB-CG.
+
+Signed-off-by: Aleksander Jan Bajkowski <olek2@wp.pl>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/realtek/realtek_main.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -1474,6 +1474,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vb_cg_c22_match_phy_device,
+ 		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C22)",
++		.probe		= rtl822x_probe,
+ 		.get_features   = rtl822x_get_features,
+ 		.config_aneg    = rtl822x_config_aneg,
+ 		.config_init    = rtl822xb_config_init,
+@@ -1486,6 +1487,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vb_cg_c45_match_phy_device,
+ 		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C45)",
++		.probe		= rtl822x_probe,
+ 		.config_init    = rtl822xb_config_init,
+ 		.get_rate_matching = rtl822xb_get_rate_matching,
+ 		.get_features   = rtl822x_c45_get_features,
+@@ -1496,6 +1498,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vn_cg_c22_match_phy_device,
+ 		.name           = "RTL8221B-VM-CG 2.5Gbps PHY (C22)",
++		.probe		= rtl822x_probe,
+ 		.get_features   = rtl822x_get_features,
+ 		.config_aneg    = rtl822x_config_aneg,
+ 		.config_init    = rtl822xb_config_init,
+@@ -1508,6 +1511,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vn_cg_c45_match_phy_device,
+ 		.name           = "RTL8221B-VN-CG 2.5Gbps PHY (C45)",
++		.probe		= rtl822x_probe,
+ 		.config_init    = rtl822xb_config_init,
+ 		.get_rate_matching = rtl822xb_get_rate_matching,
+ 		.get_features   = rtl822x_c45_get_features,
+@@ -1518,6 +1522,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8251b_c45_match_phy_device,
+ 		.name           = "RTL8251B 5Gbps PHY",
++		.probe		= rtl822x_probe,
+ 		.get_features   = rtl822x_get_features,
+ 		.config_aneg    = rtl822x_config_aneg,
+ 		.read_status    = rtl822x_read_status,
diff --git a/target/linux/generic/backport-6.12/781-13-v6.15-net-phy-realtek-make-HWMON-support-a-user-visible-Kc.patch b/target/linux/generic/backport-6.12/781-13-v6.15-net-phy-realtek-make-HWMON-support-a-user-visible-Kc.patch
new file mode 100644
index 0000000000..821d7ee879
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-13-v6.15-net-phy-realtek-make-HWMON-support-a-user-visible-Kc.patch
@@ -0,0 +1,35 @@
+From 51773846fab24a353bed4ebb660997ced4bc32d7 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Mon, 3 Feb 2025 21:33:39 +0100
+Subject: [PATCH] net: phy: realtek: make HWMON support a user-visible Kconfig
+ symbol
+
+Make config symbol REALTEK_PHY_HWMON user-visible, so that users can
+remove support if not needed.
+
+Suggested-by: Geert Uytterhoeven <geert@linux-m68k.org>
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Link: https://patch.msgid.link/3466ee92-166a-4b0f-9ae7-42b9e046f333@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/realtek/Kconfig | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/phy/realtek/Kconfig
++++ b/drivers/net/phy/realtek/Kconfig
+@@ -4,8 +4,12 @@ config REALTEK_PHY
+ 	help
+ 	  Currently supports RTL821x/RTL822x and fast ethernet PHYs
+ 
++if REALTEK_PHY
++
+ config REALTEK_PHY_HWMON
+-	def_bool REALTEK_PHY && HWMON
+-	depends on !(REALTEK_PHY=y && HWMON=m)
++	bool "HWMON support for Realtek PHYs"
++	depends on HWMON && !(REALTEK_PHY=y && HWMON=m)
+ 	help
+ 	  Optional hwmon support for the temperature sensor
++
++endif # REALTEK_PHY
diff --git a/target/linux/generic/backport-6.12/781-14-v6.15-net-phy-realtek-use-string-choices-helpers.patch b/target/linux/generic/backport-6.12/781-14-v6.15-net-phy-realtek-use-string-choices-helpers.patch
new file mode 100644
index 0000000000..d3e09bc7cd
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-14-v6.15-net-phy-realtek-use-string-choices-helpers.patch
@@ -0,0 +1,54 @@
+From 0bea93fdbaf8675b7e8124bdcaf51497dcc8bcfa Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Mon, 3 Feb 2025 21:41:36 +0100
+Subject: [PATCH] net: phy: realtek: use string choices helpers
+
+Use string choices helpers to simplify the code.
+
+Reported-by: kernel test robot <lkp@intel.com>
+Closes: https://lore.kernel.org/oe-kbuild-all/202501190707.qQS8PGHW-lkp@intel.com/
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Simon Horman <horms@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/realtek/realtek_main.c | 9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -13,6 +13,7 @@
+ #include <linux/module.h>
+ #include <linux/delay.h>
+ #include <linux/clk.h>
++#include <linux/string_choices.h>
+ 
+ #include "realtek.h"
+ 
+@@ -422,11 +423,11 @@ static int rtl8211f_config_init(struct p
+ 	} else if (ret) {
+ 		dev_dbg(dev,
+ 			"%s 2ns TX delay (and changing the value from pin-strapping RXD1 or the bootloader)\n",
+-			val_txdly ? "Enabling" : "Disabling");
++			str_enable_disable(val_txdly));
+ 	} else {
+ 		dev_dbg(dev,
+ 			"2ns TX delay was already %s (by pin-strapping RXD1 or bootloader configuration)\n",
+-			val_txdly ? "enabled" : "disabled");
++			str_enabled_disabled(val_txdly));
+ 	}
+ 
+ 	ret = phy_modify_paged_changed(phydev, 0xd08, 0x15, RTL8211F_RX_DELAY,
+@@ -437,11 +438,11 @@ static int rtl8211f_config_init(struct p
+ 	} else if (ret) {
+ 		dev_dbg(dev,
+ 			"%s 2ns RX delay (and changing the value from pin-strapping RXD0 or the bootloader)\n",
+-			val_rxdly ? "Enabling" : "Disabling");
++			str_enable_disable(val_rxdly));
+ 	} else {
+ 		dev_dbg(dev,
+ 			"2ns RX delay was already %s (by pin-strapping RXD0 or bootloader configuration)\n",
+-			val_rxdly ? "enabled" : "disabled");
++			str_enabled_disabled(val_rxdly));
+ 	}
+ 
+ 	if (priv->has_phycr2) {
diff --git a/target/linux/generic/backport-6.12/781-15-v6.15-net-phy-realtek-improve-mmd-register-access-for-inte.patch b/target/linux/generic/backport-6.12/781-15-v6.15-net-phy-realtek-improve-mmd-register-access-for-inte.patch
new file mode 100644
index 0000000000..3a3a20d58b
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-15-v6.15-net-phy-realtek-improve-mmd-register-access-for-inte.patch
@@ -0,0 +1,134 @@
+From da681ed73fb980286fc29de707b35d76bb33e123 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 13 Feb 2025 20:18:17 +0100
+Subject: [PATCH] net: phy: realtek: improve mmd register access for internal
+ PHY's
+
+r8169 provides the MDIO bus for the internal PHY's. It has been extended
+with c45 access functions for addressing MDIO_MMD_VEND2 registers.
+So we can switch from paged access to directly addressing the
+MDIO_MMD_VEND2 registers.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/a5f2333c-dda9-48ad-9801-77049766e632@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/realtek/realtek_main.c | 79 +++++++++++---------------
+ 1 file changed, 33 insertions(+), 46 deletions(-)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -735,29 +735,31 @@ static int rtlgen_read_status(struct phy
+ 	return 0;
+ }
+ 
++static int rtlgen_read_vend2(struct phy_device *phydev, int regnum)
++{
++	return __mdiobus_c45_read(phydev->mdio.bus, 0, MDIO_MMD_VEND2, regnum);
++}
++
++static int rtlgen_write_vend2(struct phy_device *phydev, int regnum, u16 val)
++{
++	return __mdiobus_c45_write(phydev->mdio.bus, 0, MDIO_MMD_VEND2, regnum,
++				   val);
++}
++
+ static int rtlgen_read_mmd(struct phy_device *phydev, int devnum, u16 regnum)
+ {
+ 	int ret;
+ 
+-	if (devnum == MDIO_MMD_VEND2) {
+-		rtl821x_write_page(phydev, regnum >> 4);
+-		ret = __phy_read(phydev, 0x10 + ((regnum & 0xf) >> 1));
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE) {
+-		rtl821x_write_page(phydev, 0xa5c);
+-		ret = __phy_read(phydev, 0x12);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {
+-		rtl821x_write_page(phydev, 0xa5d);
+-		ret = __phy_read(phydev, 0x10);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE) {
+-		rtl821x_write_page(phydev, 0xa5d);
+-		ret = __phy_read(phydev, 0x11);
+-		rtl821x_write_page(phydev, 0);
+-	} else {
++	if (devnum == MDIO_MMD_VEND2)
++		ret = rtlgen_read_vend2(phydev, regnum);
++	else if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE)
++		ret = rtlgen_read_vend2(phydev, 0xa5c4);
++	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV)
++		ret = rtlgen_read_vend2(phydev, 0xa5d0);
++	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE)
++		ret = rtlgen_read_vend2(phydev, 0xa5d2);
++	else
+ 		ret = -EOPNOTSUPP;
+-	}
+ 
+ 	return ret;
+ }
+@@ -767,17 +769,12 @@ static int rtlgen_write_mmd(struct phy_d
+ {
+ 	int ret;
+ 
+-	if (devnum == MDIO_MMD_VEND2) {
+-		rtl821x_write_page(phydev, regnum >> 4);
+-		ret = __phy_write(phydev, 0x10 + ((regnum & 0xf) >> 1), val);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {
+-		rtl821x_write_page(phydev, 0xa5d);
+-		ret = __phy_write(phydev, 0x10, val);
+-		rtl821x_write_page(phydev, 0);
+-	} else {
++	if (devnum == MDIO_MMD_VEND2)
++		ret = rtlgen_write_vend2(phydev, regnum, val);
++	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV)
++		ret = rtlgen_write_vend2(phydev, regnum, 0xa5d0);
++	else
+ 		ret = -EOPNOTSUPP;
+-	}
+ 
+ 	return ret;
+ }
+@@ -789,19 +786,12 @@ static int rtl822x_read_mmd(struct phy_d
+ 	if (ret != -EOPNOTSUPP)
+ 		return ret;
+ 
+-	if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE2) {
+-		rtl821x_write_page(phydev, 0xa6e);
+-		ret = __phy_read(phydev, 0x16);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2) {
+-		rtl821x_write_page(phydev, 0xa6d);
+-		ret = __phy_read(phydev, 0x12);
+-		rtl821x_write_page(phydev, 0);
+-	} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE2) {
+-		rtl821x_write_page(phydev, 0xa6d);
+-		ret = __phy_read(phydev, 0x10);
+-		rtl821x_write_page(phydev, 0);
+-	}
++	if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE2)
++		ret = rtlgen_read_vend2(phydev, 0xa6ec);
++	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2)
++		ret = rtlgen_read_vend2(phydev, 0xa6d4);
++	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE2)
++		ret = rtlgen_read_vend2(phydev, 0xa6d0);
+ 
+ 	return ret;
+ }
+@@ -814,11 +804,8 @@ static int rtl822x_write_mmd(struct phy_
+ 	if (ret != -EOPNOTSUPP)
+ 		return ret;
+ 
+-	if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2) {
+-		rtl821x_write_page(phydev, 0xa6d);
+-		ret = __phy_write(phydev, 0x12, val);
+-		rtl821x_write_page(phydev, 0);
+-	}
++	if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2)
++		ret = rtlgen_write_vend2(phydev, 0xa6d4, val);
+ 
+ 	return ret;
+ }
diff --git a/target/linux/generic/backport-6.12/781-16-v6.15-net-phy-realtek-switch-from-paged-to-MMD-ops-in-rtl8.patch b/target/linux/generic/backport-6.12/781-16-v6.15-net-phy-realtek-switch-from-paged-to-MMD-ops-in-rtl8.patch
new file mode 100644
index 0000000000..5e3c3ce70a
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-16-v6.15-net-phy-realtek-switch-from-paged-to-MMD-ops-in-rtl8.patch
@@ -0,0 +1,52 @@
+From 02d3b306ac2f0b174753d1c5b9e4e5fb8ec5057e Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 13 Feb 2025 20:19:14 +0100
+Subject: [PATCH] net: phy: realtek: switch from paged to MMD ops in rtl822x
+ functions
+
+The MDIO bus provided by r8169 for the internal PHY's now supports
+c45 ops for the MDIO_MMD_VEND2 device. So we can switch to standard
+MMD ops here.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/81416f95-0fac-4225-87b4-828e3738b8ed@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/realtek/realtek_main.c | 11 +++++------
+ 1 file changed, 5 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -901,7 +901,7 @@ static int rtl822x_get_features(struct p
+ {
+ 	int val;
+ 
+-	val = phy_read_paged(phydev, 0xa61, 0x13);
++	val = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xa616);
+ 	if (val < 0)
+ 		return val;
+ 
+@@ -922,10 +922,9 @@ static int rtl822x_config_aneg(struct ph
+ 	if (phydev->autoneg == AUTONEG_ENABLE) {
+ 		u16 adv = linkmode_adv_to_mii_10gbt_adv_t(phydev->advertising);
+ 
+-		ret = phy_modify_paged_changed(phydev, 0xa5d, 0x12,
+-					       MDIO_AN_10GBT_CTRL_ADV2_5G |
+-					       MDIO_AN_10GBT_CTRL_ADV5G,
+-					       adv);
++		ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2, 0xa5d4,
++					     MDIO_AN_10GBT_CTRL_ADV2_5G |
++					     MDIO_AN_10GBT_CTRL_ADV5G, adv);
+ 		if (ret < 0)
+ 			return ret;
+ 	}
+@@ -969,7 +968,7 @@ static int rtl822x_read_status(struct ph
+ 	    !phydev->autoneg_complete)
+ 		return 0;
+ 
+-	lpadv = phy_read_paged(phydev, 0xa5d, 0x13);
++	lpadv = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xa5d6);
+ 	if (lpadv < 0)
+ 		return lpadv;
+ 
diff --git a/target/linux/generic/backport-6.12/781-17-v6.15-net-phy-realtek-add-helper-RTL822X_VND2_C22_REG.patch b/target/linux/generic/backport-6.12/781-17-v6.15-net-phy-realtek-add-helper-RTL822X_VND2_C22_REG.patch
new file mode 100644
index 0000000000..5134d08b1c
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-17-v6.15-net-phy-realtek-add-helper-RTL822X_VND2_C22_REG.patch
@@ -0,0 +1,48 @@
+From 8af2136e77989a64fae0284bf76fd584e32edd3a Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Fri, 14 Feb 2025 21:31:14 +0100
+Subject: [PATCH] net: phy: realtek: add helper RTL822X_VND2_C22_REG
+
+C22 register space is mapped to 0xa400 in MMD VEND2 register space.
+Add a helper to access mapped C22 registers.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/6344277b-c5c7-449b-ac89-d5425306ca76@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/realtek/realtek_main.c | 9 ++++-----
+ 1 file changed, 4 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -79,9 +79,7 @@
+ /* RTL822X_VND2_XXXXX registers are only accessible when phydev->is_c45
+  * is set, they cannot be accessed by C45-over-C22.
+  */
+-#define RTL822X_VND2_GBCR				0xa412
+-
+-#define RTL822X_VND2_GANLPAR				0xa414
++#define RTL822X_VND2_C22_REG(reg)		(0xa400 + 2 * (reg))
+ 
+ #define RTL8366RB_POWER_SAVE			0x15
+ #define RTL8366RB_POWER_SAVE_ON			BIT(12)
+@@ -1015,7 +1013,8 @@ static int rtl822x_c45_config_aneg(struc
+ 	val = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);
+ 
+ 	/* Vendor register as C45 has no standardized support for 1000BaseT */
+-	ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2, RTL822X_VND2_GBCR,
++	ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2,
++				     RTL822X_VND2_C22_REG(MII_CTRL1000),
+ 				     ADVERTISE_1000FULL, val);
+ 	if (ret < 0)
+ 		return ret;
+@@ -1032,7 +1031,7 @@ static int rtl822x_c45_read_status(struc
+ 	/* Vendor register as C45 has no standardized support for 1000BaseT */
+ 	if (phydev->autoneg == AUTONEG_ENABLE && genphy_c45_aneg_done(phydev)) {
+ 		val = phy_read_mmd(phydev, MDIO_MMD_VEND2,
+-				   RTL822X_VND2_GANLPAR);
++				   RTL822X_VND2_C22_REG(MII_STAT1000));
+ 		if (val < 0)
+ 			return val;
+ 	} else {
diff --git a/target/linux/generic/backport-6.12/781-18-v6.15-net-phy-realtek-add-defines-for-shadowed-c45-standar.patch b/target/linux/generic/backport-6.12/781-18-v6.15-net-phy-realtek-add-defines-for-shadowed-c45-standar.patch
new file mode 100644
index 0000000000..ff7d5b1fb6
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-18-v6.15-net-phy-realtek-add-defines-for-shadowed-c45-standar.patch
@@ -0,0 +1,113 @@
+From fabcfd6d10999024a721ae1b965b57eb8a305ace Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Sat, 15 Feb 2025 14:29:15 +0100
+Subject: [PATCH] net: phy: realtek: add defines for shadowed c45 standard
+ registers
+
+Realtek shadows standard c45 registers in VEND2 device register space.
+Add defines for these VEND2 registers, based on the names of the
+standard c45 registers.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/c90bdf76-f8b8-4d06-9656-7a52d5658ee6@gmail.com
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/realtek/realtek_main.c | 33 +++++++++++++++++---------
+ 1 file changed, 22 insertions(+), 11 deletions(-)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -94,6 +94,16 @@
+ #define RTL_VND2_PHYSR_MASTER			BIT(11)
+ #define RTL_VND2_PHYSR_SPEED_MASK		(RTL_VND2_PHYSR_SPEEDL | RTL_VND2_PHYSR_SPEEDH)
+ 
++#define	RTL_MDIO_PCS_EEE_ABLE			0xa5c4
++#define	RTL_MDIO_AN_EEE_ADV			0xa5d0
++#define	RTL_MDIO_AN_EEE_LPABLE			0xa5d2
++#define	RTL_MDIO_AN_10GBT_CTRL			0xa5d4
++#define	RTL_MDIO_AN_10GBT_STAT			0xa5d6
++#define	RTL_MDIO_PMA_SPEED			0xa616
++#define	RTL_MDIO_AN_EEE_LPABLE2			0xa6d0
++#define	RTL_MDIO_AN_EEE_ADV2			0xa6d4
++#define	RTL_MDIO_PCS_EEE_ABLE2			0xa6ec
++
+ #define RTL_GENERIC_PHYID			0x001cc800
+ #define RTL_8211FVD_PHYID			0x001cc878
+ #define RTL_8221B				0x001cc840
+@@ -751,11 +761,11 @@ static int rtlgen_read_mmd(struct phy_de
+ 	if (devnum == MDIO_MMD_VEND2)
+ 		ret = rtlgen_read_vend2(phydev, regnum);
+ 	else if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE)
+-		ret = rtlgen_read_vend2(phydev, 0xa5c4);
++		ret = rtlgen_read_vend2(phydev, RTL_MDIO_PCS_EEE_ABLE);
+ 	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV)
+-		ret = rtlgen_read_vend2(phydev, 0xa5d0);
++		ret = rtlgen_read_vend2(phydev, RTL_MDIO_AN_EEE_ADV);
+ 	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE)
+-		ret = rtlgen_read_vend2(phydev, 0xa5d2);
++		ret = rtlgen_read_vend2(phydev, RTL_MDIO_AN_EEE_LPABLE);
+ 	else
+ 		ret = -EOPNOTSUPP;
+ 
+@@ -770,7 +780,7 @@ static int rtlgen_write_mmd(struct phy_d
+ 	if (devnum == MDIO_MMD_VEND2)
+ 		ret = rtlgen_write_vend2(phydev, regnum, val);
+ 	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV)
+-		ret = rtlgen_write_vend2(phydev, regnum, 0xa5d0);
++		ret = rtlgen_write_vend2(phydev, regnum, RTL_MDIO_AN_EEE_ADV);
+ 	else
+ 		ret = -EOPNOTSUPP;
+ 
+@@ -785,11 +795,11 @@ static int rtl822x_read_mmd(struct phy_d
+ 		return ret;
+ 
+ 	if (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE2)
+-		ret = rtlgen_read_vend2(phydev, 0xa6ec);
++		ret = rtlgen_read_vend2(phydev, RTL_MDIO_PCS_EEE_ABLE2);
+ 	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2)
+-		ret = rtlgen_read_vend2(phydev, 0xa6d4);
++		ret = rtlgen_read_vend2(phydev, RTL_MDIO_AN_EEE_ADV2);
+ 	else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE2)
+-		ret = rtlgen_read_vend2(phydev, 0xa6d0);
++		ret = rtlgen_read_vend2(phydev, RTL_MDIO_AN_EEE_LPABLE2);
+ 
+ 	return ret;
+ }
+@@ -803,7 +813,7 @@ static int rtl822x_write_mmd(struct phy_
+ 		return ret;
+ 
+ 	if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2)
+-		ret = rtlgen_write_vend2(phydev, 0xa6d4, val);
++		ret = rtlgen_write_vend2(phydev, RTL_MDIO_AN_EEE_ADV2, val);
+ 
+ 	return ret;
+ }
+@@ -899,7 +909,7 @@ static int rtl822x_get_features(struct p
+ {
+ 	int val;
+ 
+-	val = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xa616);
++	val = phy_read_mmd(phydev, MDIO_MMD_VEND2, RTL_MDIO_PMA_SPEED);
+ 	if (val < 0)
+ 		return val;
+ 
+@@ -920,7 +930,8 @@ static int rtl822x_config_aneg(struct ph
+ 	if (phydev->autoneg == AUTONEG_ENABLE) {
+ 		u16 adv = linkmode_adv_to_mii_10gbt_adv_t(phydev->advertising);
+ 
+-		ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2, 0xa5d4,
++		ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2,
++					     RTL_MDIO_AN_10GBT_CTRL,
+ 					     MDIO_AN_10GBT_CTRL_ADV2_5G |
+ 					     MDIO_AN_10GBT_CTRL_ADV5G, adv);
+ 		if (ret < 0)
+@@ -966,7 +977,7 @@ static int rtl822x_read_status(struct ph
+ 	    !phydev->autoneg_complete)
+ 		return 0;
+ 
+-	lpadv = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xa5d6);
++	lpadv = phy_read_mmd(phydev, MDIO_MMD_VEND2, RTL_MDIO_AN_10GBT_STAT);
+ 	if (lpadv < 0)
+ 		return lpadv;
+ 
diff --git a/target/linux/generic/backport-6.12/781-19-v6.15-net-phy-realtek-disable-PHY-mode-EEE.patch b/target/linux/generic/backport-6.12/781-19-v6.15-net-phy-realtek-disable-PHY-mode-EEE.patch
new file mode 100644
index 0000000000..4d755d4e22
--- /dev/null
+++ b/target/linux/generic/backport-6.12/781-19-v6.15-net-phy-realtek-disable-PHY-mode-EEE.patch
@@ -0,0 +1,54 @@
+From bfc17c1658353f22843c7c13e27c2d31950f1887 Mon Sep 17 00:00:00 2001
+From: "Russell King (Oracle)" <rmk+kernel@armlinux.org.uk>
+Date: Sun, 16 Mar 2025 12:39:54 +0000
+Subject: [PATCH] net: phy: realtek: disable PHY-mode EEE
+
+Realtek RTL8211F has a "PHY-mode" EEE support which interferes with an
+IEEE 802.3 compliant implementation. This mode defaults to enabled, and
+results in the MAC receive path not seeing the link transition to LPI
+state.
+
+Fix this by disabling PHY-mode EEE.
+
+Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/E1ttnHW-00785s-Uq@rmk-PC.armlinux.org.uk
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/phy/realtek/realtek_main.c | 11 +++++++++--
+ 1 file changed, 9 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -33,6 +33,9 @@
+ 
+ #define RTL8211F_PHYCR1				0x18
+ #define RTL8211F_PHYCR2				0x19
++#define RTL8211F_CLKOUT_EN			BIT(0)
++#define RTL8211F_PHYCR2_PHY_EEE_ENABLE		BIT(5)
++
+ #define RTL8211F_INSR				0x1d
+ 
+ #define RTL8211F_LEDCR				0x10
+@@ -55,8 +58,6 @@
+ #define RTL8211E_TX_DELAY			BIT(12)
+ #define RTL8211E_RX_DELAY			BIT(11)
+ 
+-#define RTL8211F_CLKOUT_EN			BIT(0)
+-
+ #define RTL8201F_ISR				0x1e
+ #define RTL8201F_ISR_ANERR			BIT(15)
+ #define RTL8201F_ISR_DUPLEX			BIT(13)
+@@ -453,6 +454,12 @@ static int rtl8211f_config_init(struct p
+ 			str_enabled_disabled(val_rxdly));
+ 	}
+ 
++	/* Disable PHY-mode EEE so LPI is passed to the MAC */
++	ret = phy_modify_paged(phydev, 0xa43, RTL8211F_PHYCR2,
++			       RTL8211F_PHYCR2_PHY_EEE_ENABLE, 0);
++	if (ret)
++		return ret;
++
+ 	if (priv->has_phycr2) {
+ 		ret = phy_modify_paged(phydev, 0xa43, RTL8211F_PHYCR2,
+ 				       RTL8211F_CLKOUT_EN, priv->phycr2);
diff --git a/target/linux/generic/backport-6.12/792-v6.16-igc-enable-HW-vlan-tag-insertion-stripping-by-defaul.patch b/target/linux/generic/backport-6.12/792-v6.16-igc-enable-HW-vlan-tag-insertion-stripping-by-defaul.patch
new file mode 100644
index 0000000000..e231bc8d49
--- /dev/null
+++ b/target/linux/generic/backport-6.12/792-v6.16-igc-enable-HW-vlan-tag-insertion-stripping-by-defaul.patch
@@ -0,0 +1,32 @@
+From 8cae5a0d91fea01d90ce7c1827e26934a22ca2fa Mon Sep 17 00:00:00 2001
+From: Rui Salvaterra <rsalvaterra@gmail.com>
+Date: Wed, 5 Mar 2025 11:53:56 +0000
+Subject: [PATCH] igc: enable HW vlan tag insertion/stripping by default
+
+This is enabled by default in other Intel drivers I've checked (e1000, e1000e,
+iavf, igb and ice). Fixes an out-of-the-box performance issue when running
+OpenWrt on typical mini-PCs with igc-supported Ethernet controllers and 802.1Q
+VLAN configurations, as ethtool isn't part of the default packages and sane
+defaults are expected.
+
+In my specific case, with an Intel N100-based machine with four I226-V Ethernet
+controllers, my upload performance increased from under 30 Mb/s to the expected
+~1 Gb/s.
+
+Signed-off-by: Rui Salvaterra <rsalvaterra@gmail.com>
+---
+ drivers/net/ethernet/intel/igc/igc_main.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/net/ethernet/intel/igc/igc_main.c
++++ b/drivers/net/ethernet/intel/igc/igc_main.c
+@@ -7066,6 +7066,9 @@ static int igc_probe(struct pci_dev *pde
+ 	netdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |
+ 			       NETDEV_XDP_ACT_XSK_ZEROCOPY;
+ 
++	/* enable HW vlan tag insertion/stripping by default */
++	netdev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;
++
+ 	/* MTU range: 68 - 9216 */
+ 	netdev->min_mtu = ETH_MIN_MTU;
+ 	netdev->max_mtu = MAX_STD_JUMBO_FRAME_SIZE;
diff --git a/target/linux/generic/backport-6.12/800-v6.13-hwmon-Add-static-visibility-member-to-struct-hwmon_o.patch b/target/linux/generic/backport-6.12/800-v6.13-hwmon-Add-static-visibility-member-to-struct-hwmon_o.patch
new file mode 100644
index 0000000000..0c9f920562
--- /dev/null
+++ b/target/linux/generic/backport-6.12/800-v6.13-hwmon-Add-static-visibility-member-to-struct-hwmon_o.patch
@@ -0,0 +1,88 @@
+From 79bc0af904db647979c735563299c9b0d820e432 Mon Sep 17 00:00:00 2001
+From: Heiner Kallweit <hkallweit1@gmail.com>
+Date: Thu, 10 Oct 2024 21:35:42 +0200
+Subject: [PATCH] hwmon: Add static visibility member to struct hwmon_ops
+
+Several drivers return the same static value in their is_visible
+callback, what results in code duplication. Therefore add an option
+for drivers to specify a static visibility directly.
+
+Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
+Message-ID: <89690b81-2c73-47ae-9ae9-45c77b45ca0c@gmail.com>
+groeck: Renamed hwmon_ops_is_visible -> hwmon_is_visible
+Signed-off-by: Guenter Roeck <linux@roeck-us.net>
+---
+ drivers/hwmon/hwmon.c | 19 +++++++++++++++----
+ include/linux/hwmon.h |  5 ++++-
+ 2 files changed, 19 insertions(+), 5 deletions(-)
+
+--- a/drivers/hwmon/hwmon.c
++++ b/drivers/hwmon/hwmon.c
+@@ -145,6 +145,17 @@ static const struct class hwmon_class =
+ 
+ static DEFINE_IDA(hwmon_ida);
+ 
++static umode_t hwmon_is_visible(const struct hwmon_ops *ops,
++				const void *drvdata,
++				enum hwmon_sensor_types type,
++				u32 attr, int channel)
++{
++	if (ops->visible)
++		return ops->visible;
++
++	return ops->is_visible(drvdata, type, attr, channel);
++}
++
+ /* Thermal zone handling */
+ 
+ /*
+@@ -267,8 +278,8 @@ static int hwmon_thermal_register_sensor
+ 			int err;
+ 
+ 			if (!(info[i]->config[j] & HWMON_T_INPUT) ||
+-			    !chip->ops->is_visible(drvdata, hwmon_temp,
+-						   hwmon_temp_input, j))
++			    !hwmon_is_visible(chip->ops, drvdata, hwmon_temp,
++					      hwmon_temp_input, j))
+ 				continue;
+ 
+ 			err = hwmon_thermal_add_sensor(dev, j);
+@@ -506,7 +517,7 @@ static struct attribute *hwmon_genattr(c
+ 	const char *name;
+ 	bool is_string = is_string_attr(type, attr);
+ 
+-	mode = ops->is_visible(drvdata, type, attr, index);
++	mode = hwmon_is_visible(ops, drvdata, type, attr, index);
+ 	if (!mode)
+ 		return ERR_PTR(-ENOENT);
+ 
+@@ -1033,7 +1044,7 @@ hwmon_device_register_with_info(struct d
+ 	if (!dev || !name || !chip)
+ 		return ERR_PTR(-EINVAL);
+ 
+-	if (!chip->ops || !chip->ops->is_visible || !chip->info)
++	if (!chip->ops || !(chip->ops->visible || chip->ops->is_visible) || !chip->info)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	return __hwmon_device_register(dev, name, drvdata, chip, extra_groups);
+--- a/include/linux/hwmon.h
++++ b/include/linux/hwmon.h
+@@ -368,7 +368,9 @@ enum hwmon_intrusion_attributes {
+ 
+ /**
+  * struct hwmon_ops - hwmon device operations
+- * @is_visible: Callback to return attribute visibility. Mandatory.
++ * @visible:	Static visibility. If non-zero, 'is_visible' is ignored.
++ * @is_visible: Callback to return attribute visibility. Mandatory unless
++ *		'visible' is non-zero.
+  *		Parameters are:
+  *		@const void *drvdata:
+  *			Pointer to driver-private data structure passed
+@@ -412,6 +414,7 @@ enum hwmon_intrusion_attributes {
+  *		The function returns 0 on success or a negative error number.
+  */
+ struct hwmon_ops {
++	umode_t visible;
+ 	umode_t (*is_visible)(const void *drvdata, enum hwmon_sensor_types type,
+ 			      u32 attr, int channel);
+ 	int (*read)(struct device *dev, enum hwmon_sensor_types type,
diff --git a/target/linux/generic/backport-6.12/839-v6.13-net-phy-aquantia-allow-forcing-order-of-MDI-pairs.patch b/target/linux/generic/backport-6.12/839-v6.13-net-phy-aquantia-allow-forcing-order-of-MDI-pairs.patch
new file mode 100644
index 0000000000..aabaa33e2c
--- /dev/null
+++ b/target/linux/generic/backport-6.12/839-v6.13-net-phy-aquantia-allow-forcing-order-of-MDI-pairs.patch
@@ -0,0 +1,107 @@
+From a2e1ba275eae96a8171deb19e9c7c2f5978fee7b Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Fri, 4 Oct 2024 17:18:16 +0100
+Subject: [PATCH] net: phy: aquantia: allow forcing order of MDI pairs
+
+Despite supporting Auto MDI-X, it looks like Aquantia only supports
+swapping pair (1,2) with pair (3,6) like it used to be for MDI-X on
+100MBit/s networks.
+
+When all 4 pairs are in use (for 1000MBit/s or faster) the link does not
+come up with pair order is not configured correctly, either using
+MDI_CFG pin or using the "PMA Receive Reserved Vendor Provisioning 1"
+register.
+
+Normally, the order of MDI pairs being either ABCD or DCBA is configured
+by pulling the MDI_CFG pin.
+
+However, some hardware designs require overriding the value configured
+by that bootstrap pin. The PHY allows doing that by setting a bit in
+"PMA Receive Reserved Vendor Provisioning 1" register which allows
+ignoring the state of the MDI_CFG pin and another bit configuring
+whether the order of MDI pairs should be normal (ABCD) or reverse
+(DCBA). Pair polarity is not affected and remains identical in both
+settings.
+
+Introduce property "marvell,mdi-cfg-order" which allows forcing either
+normal or reverse order of the MDI pairs from DT.
+
+If the property isn't present, the behavior is unchanged and MDI pair
+order configuration is untouched (ie. either the result of MDI_CFG pin
+pull-up/pull-down, or pair order override already configured by the
+bootloader before Linux is started).
+
+Forcing normal pair order is required on the Adtran SDG-8733A Wi-Fi 7
+residential gateway.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/9ed760ff87d5fc456f31e407ead548bbb754497d.1728058550.git.daniel@makrotopia.org
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/aquantia/aquantia_main.c | 33 ++++++++++++++++++++++++
+ 1 file changed, 33 insertions(+)
+
+--- a/drivers/net/phy/aquantia/aquantia_main.c
++++ b/drivers/net/phy/aquantia/aquantia_main.c
+@@ -11,6 +11,7 @@
+ #include <linux/module.h>
+ #include <linux/delay.h>
+ #include <linux/bitfield.h>
++#include <linux/of.h>
+ #include <linux/phy.h>
+ 
+ #include "aquantia.h"
+@@ -71,6 +72,11 @@
+ #define MDIO_AN_TX_VEND_INT_MASK2		0xd401
+ #define MDIO_AN_TX_VEND_INT_MASK2_LINK		BIT(0)
+ 
++#define PMAPMD_RSVD_VEND_PROV			0xe400
++#define PMAPMD_RSVD_VEND_PROV_MDI_CONF		GENMASK(1, 0)
++#define PMAPMD_RSVD_VEND_PROV_MDI_REVERSE	BIT(0)
++#define PMAPMD_RSVD_VEND_PROV_MDI_FORCE		BIT(1)
++
+ #define MDIO_AN_RX_LP_STAT1			0xe820
+ #define MDIO_AN_RX_LP_STAT1_1000BASET_FULL	BIT(15)
+ #define MDIO_AN_RX_LP_STAT1_1000BASET_HALF	BIT(14)
+@@ -485,6 +491,29 @@ static void aqr107_chip_info(struct phy_
+ 		   fw_major, fw_minor, build_id, prov_id);
+ }
+ 
++static int aqr107_config_mdi(struct phy_device *phydev)
++{
++	struct device_node *np = phydev->mdio.dev.of_node;
++	u32 mdi_conf;
++	int ret;
++
++	ret = of_property_read_u32(np, "marvell,mdi-cfg-order", &mdi_conf);
++
++	/* Do nothing in case property "marvell,mdi-cfg-order" is not present */
++	if (ret == -ENOENT)
++		return 0;
++
++	if (ret)
++		return ret;
++
++	if (mdi_conf & ~PMAPMD_RSVD_VEND_PROV_MDI_REVERSE)
++		return -EINVAL;
++
++	return phy_modify_mmd(phydev, MDIO_MMD_PMAPMD, PMAPMD_RSVD_VEND_PROV,
++			      PMAPMD_RSVD_VEND_PROV_MDI_CONF,
++			      mdi_conf | PMAPMD_RSVD_VEND_PROV_MDI_FORCE);
++}
++
+ static int aqr107_config_init(struct phy_device *phydev)
+ {
+ 	struct aqr107_priv *priv = phydev->priv;
+@@ -514,6 +543,10 @@ static int aqr107_config_init(struct phy
+ 	if (ret)
+ 		return ret;
+ 
++	ret = aqr107_config_mdi(phydev);
++	if (ret)
++		return ret;
++
+ 	/* Restore LED polarity state after reset */
+ 	for_each_set_bit(led_active_low, &priv->leds_active_low, AQR_MAX_LEDS) {
+ 		ret = aqr_phy_led_active_low_set(phydev, led_active_low, true);
diff --git a/target/linux/generic/backport-6.12/840-v6.13-net-phy-aquantia-fix-return-value-check-in-aqr107_co.patch b/target/linux/generic/backport-6.12/840-v6.13-net-phy-aquantia-fix-return-value-check-in-aqr107_co.patch
new file mode 100644
index 0000000000..565edbd388
--- /dev/null
+++ b/target/linux/generic/backport-6.12/840-v6.13-net-phy-aquantia-fix-return-value-check-in-aqr107_co.patch
@@ -0,0 +1,31 @@
+From ce21b8fb255ebf0b49913fb4c62741d7eb05c6f6 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Fri, 11 Oct 2024 22:28:43 +0100
+Subject: [PATCH] net: phy: aquantia: fix return value check in
+ aqr107_config_mdi()
+
+of_property_read_u32() returns -EINVAL in case the property cannot be
+found rather than -ENOENT. Fix the check to not abort probing in case
+of the property being missing, and also in case CONFIG_OF is not set
+which will result in -ENOSYS.
+
+Fixes: a2e1ba275eae ("net: phy: aquantia: allow forcing order of MDI pairs")
+Reported-by: Jon Hunter <jonathanh@nvidia.com>
+Closes: https://lore.kernel.org/all/114b4c03-5d16-42ed-945d-cf78eabea12b@nvidia.com/
+Suggested-by: Hans-Frieder Vogt <hfdevel@gmx.net>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/phy/aquantia/aquantia_main.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/phy/aquantia/aquantia_main.c
++++ b/drivers/net/phy/aquantia/aquantia_main.c
+@@ -500,7 +500,7 @@ static int aqr107_config_mdi(struct phy_
+ 	ret = of_property_read_u32(np, "marvell,mdi-cfg-order", &mdi_conf);
+ 
+ 	/* Do nothing in case property "marvell,mdi-cfg-order" is not present */
+-	if (ret == -ENOENT)
++	if (ret == -EINVAL || ret == -ENOSYS)
+ 		return 0;
+ 
+ 	if (ret)
diff --git a/target/linux/generic/backport-6.12/841-v6.13-net-phy-support-active-high-property-for-PHY-LEDs.patch b/target/linux/generic/backport-6.12/841-v6.13-net-phy-support-active-high-property-for-PHY-LEDs.patch
new file mode 100644
index 0000000000..ad1d554531
--- /dev/null
+++ b/target/linux/generic/backport-6.12/841-v6.13-net-phy-support-active-high-property-for-PHY-LEDs.patch
@@ -0,0 +1,53 @@
+From a274465cc3bef2dfd9c9ea5100848dda0a8641e1 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 10 Oct 2024 13:54:19 +0100
+Subject: [PATCH 1/4] net: phy: support 'active-high' property for PHY LEDs
+
+In addition to 'active-low' and 'inactive-high-impedance' also
+support 'active-high' property for PHY LED pin configuration.
+As only either 'active-high' or 'active-low' can be set at the
+same time, WARN and return an error in case both are set.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/91598487773d768f254d5faf06cf65b13e972f0e.1728558223.git.daniel@makrotopia.org
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/phy/phy_device.c | 6 ++++++
+ include/linux/phy.h          | 5 +++--
+ 2 files changed, 9 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -3385,11 +3385,17 @@ static int of_phy_led(struct phy_device
+ 	if (index > U8_MAX)
+ 		return -EINVAL;
+ 
++	if (of_property_read_bool(led, "active-high"))
++		set_bit(PHY_LED_ACTIVE_HIGH, &modes);
+ 	if (of_property_read_bool(led, "active-low"))
+ 		set_bit(PHY_LED_ACTIVE_LOW, &modes);
+ 	if (of_property_read_bool(led, "inactive-high-impedance"))
+ 		set_bit(PHY_LED_INACTIVE_HIGH_IMPEDANCE, &modes);
+ 
++	if (WARN_ON(modes & BIT(PHY_LED_ACTIVE_LOW) &&
++		    modes & BIT(PHY_LED_ACTIVE_HIGH)))
++		return -EINVAL;
++
+ 	if (modes) {
+ 		/* Return error if asked to set polarity modes but not supported */
+ 		if (!phydev->drv->led_polarity_set)
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -877,8 +877,9 @@ struct phy_plca_status {
+ 
+ /* Modes for PHY LED configuration */
+ enum phy_led_modes {
+-	PHY_LED_ACTIVE_LOW = 0,
+-	PHY_LED_INACTIVE_HIGH_IMPEDANCE = 1,
++	PHY_LED_ACTIVE_HIGH = 0,
++	PHY_LED_ACTIVE_LOW = 1,
++	PHY_LED_INACTIVE_HIGH_IMPEDANCE = 2,
+ 
+ 	/* keep it last */
+ 	__PHY_LED_MODES_NUM,
diff --git a/target/linux/generic/backport-6.12/842-v6.13-net-phy-aquantia-correctly-describe-LED-polarity-ove.patch b/target/linux/generic/backport-6.12/842-v6.13-net-phy-aquantia-correctly-describe-LED-polarity-ove.patch
new file mode 100644
index 0000000000..155f796f8c
--- /dev/null
+++ b/target/linux/generic/backport-6.12/842-v6.13-net-phy-aquantia-correctly-describe-LED-polarity-ove.patch
@@ -0,0 +1,108 @@
+From 9d55e68b19f222e6334ef4021c5527998f5ab537 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 10 Oct 2024 13:55:00 +0100
+Subject: [PATCH 2/4] net: phy: aquantia: correctly describe LED polarity
+ override
+
+Use newly defined 'active-high' property to set the
+VEND1_GLOBAL_LED_DRIVE_VDD bit and let 'active-low' clear that bit. This
+reflects the technical reality which was inverted in the previous
+description in which the 'active-low' property was used to actually set
+the VEND1_GLOBAL_LED_DRIVE_VDD bit, which means that VDD (ie. supply
+voltage) of the LED is driven rather than GND.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/86a413b4387c42dcb54f587cc2433a06f16aae83.1728558223.git.daniel@makrotopia.org
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/phy/aquantia/aquantia.h      |  1 +
+ drivers/net/phy/aquantia/aquantia_leds.c | 19 ++++++++++++++-----
+ drivers/net/phy/aquantia/aquantia_main.c | 12 +++++++++---
+ 3 files changed, 24 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/phy/aquantia/aquantia.h
++++ b/drivers/net/phy/aquantia/aquantia.h
+@@ -177,6 +177,7 @@ static const struct aqr107_hw_stat aqr10
+ struct aqr107_priv {
+ 	u64 sgmii_stats[AQR107_SGMII_STAT_SZ];
+ 	unsigned long leds_active_low;
++	unsigned long leds_active_high;
+ };
+ 
+ #if IS_REACHABLE(CONFIG_HWMON)
+--- a/drivers/net/phy/aquantia/aquantia_leds.c
++++ b/drivers/net/phy/aquantia/aquantia_leds.c
+@@ -121,13 +121,13 @@ int aqr_phy_led_active_low_set(struct ph
+ {
+ 	return phy_modify_mmd(phydev, MDIO_MMD_VEND1, AQR_LED_DRIVE(index),
+ 			      VEND1_GLOBAL_LED_DRIVE_VDD,
+-			      enable ? VEND1_GLOBAL_LED_DRIVE_VDD : 0);
++			      enable ? 0 : VEND1_GLOBAL_LED_DRIVE_VDD);
+ }
+ 
+ int aqr_phy_led_polarity_set(struct phy_device *phydev, int index, unsigned long modes)
+ {
++	bool force_active_low = false, force_active_high = false;
+ 	struct aqr107_priv *priv = phydev->priv;
+-	bool active_low = false;
+ 	u32 mode;
+ 
+ 	if (index >= AQR_MAX_LEDS)
+@@ -136,7 +136,10 @@ int aqr_phy_led_polarity_set(struct phy_
+ 	for_each_set_bit(mode, &modes, __PHY_LED_MODES_NUM) {
+ 		switch (mode) {
+ 		case PHY_LED_ACTIVE_LOW:
+-			active_low = true;
++			force_active_low = true;
++			break;
++		case PHY_LED_ACTIVE_HIGH:
++			force_active_high = true;
+ 			break;
+ 		default:
+ 			return -EINVAL;
+@@ -144,8 +147,14 @@ int aqr_phy_led_polarity_set(struct phy_
+ 	}
+ 
+ 	/* Save LED driver vdd state to restore on SW reset */
+-	if (active_low)
++	if (force_active_low)
+ 		priv->leds_active_low |= BIT(index);
+ 
+-	return aqr_phy_led_active_low_set(phydev, index, active_low);
++	if (force_active_high)
++		priv->leds_active_high |= BIT(index);
++
++	if (force_active_high || force_active_low)
++		return aqr_phy_led_active_low_set(phydev, index, force_active_low);
++
++	unreachable();
+ }
+--- a/drivers/net/phy/aquantia/aquantia_main.c
++++ b/drivers/net/phy/aquantia/aquantia_main.c
+@@ -517,7 +517,7 @@ static int aqr107_config_mdi(struct phy_
+ static int aqr107_config_init(struct phy_device *phydev)
+ {
+ 	struct aqr107_priv *priv = phydev->priv;
+-	u32 led_active_low;
++	u32 led_idx;
+ 	int ret;
+ 
+ 	/* Check that the PHY interface type is compatible */
+@@ -548,8 +548,14 @@ static int aqr107_config_init(struct phy
+ 		return ret;
+ 
+ 	/* Restore LED polarity state after reset */
+-	for_each_set_bit(led_active_low, &priv->leds_active_low, AQR_MAX_LEDS) {
+-		ret = aqr_phy_led_active_low_set(phydev, led_active_low, true);
++	for_each_set_bit(led_idx, &priv->leds_active_low, AQR_MAX_LEDS) {
++		ret = aqr_phy_led_active_low_set(phydev, led_idx, true);
++		if (ret)
++			return ret;
++	}
++
++	for_each_set_bit(led_idx, &priv->leds_active_high, AQR_MAX_LEDS) {
++		ret = aqr_phy_led_active_low_set(phydev, led_idx, false);
+ 		if (ret)
+ 			return ret;
+ 	}
diff --git a/target/linux/generic/backport-6.12/843-v6.13-net-phy-mxl-gpy-add-basic-LED-support.patch b/target/linux/generic/backport-6.12/843-v6.13-net-phy-mxl-gpy-add-basic-LED-support.patch
new file mode 100644
index 0000000000..c785f8a98a
--- /dev/null
+++ b/target/linux/generic/backport-6.12/843-v6.13-net-phy-mxl-gpy-add-basic-LED-support.patch
@@ -0,0 +1,332 @@
+From 78997e9a5e4d8a4df561e083a92c91ae23010e07 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Tue, 1 Oct 2024 01:17:18 +0100
+Subject: [PATCH] net: phy: mxl-gpy: add basic LED support
+
+Add basic support for LEDs connected to MaxLinear GPY2xx and GPY115 PHYs.
+The PHYs allow up to 4 LEDs to be connected.
+Implement controlling LEDs in software as well as netdev trigger offloading
+and LED polarity setup.
+
+The hardware claims to support 16 PWM brightness levels but there is no
+documentation on how to use that feature, hence this is not supported.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/b6ec9050339f8244ff898898a1cecc33b13a48fc.1727741563.git.daniel@makrotopia.org
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mxl-gpy.c | 218 ++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 218 insertions(+)
+
+--- a/drivers/net/phy/mxl-gpy.c
++++ b/drivers/net/phy/mxl-gpy.c
+@@ -38,6 +38,7 @@
+ #define PHY_MIISTAT		0x18	/* MII state */
+ #define PHY_IMASK		0x19	/* interrupt mask */
+ #define PHY_ISTAT		0x1A	/* interrupt status */
++#define PHY_LED			0x1B	/* LEDs */
+ #define PHY_FWV			0x1E	/* firmware version */
+ 
+ #define PHY_MIISTAT_SPD_MASK	GENMASK(2, 0)
+@@ -61,6 +62,11 @@
+ 				 PHY_IMASK_ADSC | \
+ 				 PHY_IMASK_ANC)
+ 
++#define GPY_MAX_LEDS		4
++#define PHY_LED_POLARITY(idx)	BIT(12 + (idx))
++#define PHY_LED_HWCONTROL(idx)	BIT(8 + (idx))
++#define PHY_LED_ON(idx)		BIT(idx)
++
+ #define PHY_FWV_REL_MASK	BIT(15)
+ #define PHY_FWV_MAJOR_MASK	GENMASK(11, 8)
+ #define PHY_FWV_MINOR_MASK	GENMASK(7, 0)
+@@ -72,6 +78,23 @@
+ #define PHY_MDI_MDI_X_CD	0x1
+ #define PHY_MDI_MDI_X_CROSS	0x0
+ 
++/* LED */
++#define VSPEC1_LED(idx)		(1 + (idx))
++#define VSPEC1_LED_BLINKS	GENMASK(15, 12)
++#define VSPEC1_LED_PULSE	GENMASK(11, 8)
++#define VSPEC1_LED_CON		GENMASK(7, 4)
++#define VSPEC1_LED_BLINKF	GENMASK(3, 0)
++
++#define VSPEC1_LED_LINK10	BIT(0)
++#define VSPEC1_LED_LINK100	BIT(1)
++#define VSPEC1_LED_LINK1000	BIT(2)
++#define VSPEC1_LED_LINK2500	BIT(3)
++
++#define VSPEC1_LED_TXACT	BIT(0)
++#define VSPEC1_LED_RXACT	BIT(1)
++#define VSPEC1_LED_COL		BIT(2)
++#define VSPEC1_LED_NO_CON	BIT(3)
++
+ /* SGMII */
+ #define VSPEC1_SGMII_CTRL	0x08
+ #define VSPEC1_SGMII_CTRL_ANEN	BIT(12)		/* Aneg enable */
+@@ -835,6 +858,156 @@ static int gpy115_loopback(struct phy_de
+ 	return genphy_soft_reset(phydev);
+ }
+ 
++static int gpy_led_brightness_set(struct phy_device *phydev,
++				  u8 index, enum led_brightness value)
++{
++	int ret;
++
++	if (index >= GPY_MAX_LEDS)
++		return -EINVAL;
++
++	/* clear HWCONTROL and set manual LED state */
++	ret = phy_modify(phydev, PHY_LED,
++			 ((value == LED_OFF) ? PHY_LED_HWCONTROL(index) : 0) |
++			 PHY_LED_ON(index),
++			 (value == LED_OFF) ? 0 : PHY_LED_ON(index));
++	if (ret)
++		return ret;
++
++	/* ToDo: set PWM brightness */
++
++	/* clear HW LED setup */
++	if (value == LED_OFF)
++		return phy_write_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_LED(index), 0);
++	else
++		return 0;
++}
++
++static const unsigned long supported_triggers = (BIT(TRIGGER_NETDEV_LINK) |
++						 BIT(TRIGGER_NETDEV_LINK_100) |
++						 BIT(TRIGGER_NETDEV_LINK_1000) |
++						 BIT(TRIGGER_NETDEV_LINK_2500) |
++						 BIT(TRIGGER_NETDEV_RX) |
++						 BIT(TRIGGER_NETDEV_TX));
++
++static int gpy_led_hw_is_supported(struct phy_device *phydev, u8 index,
++				   unsigned long rules)
++{
++	if (index >= GPY_MAX_LEDS)
++		return -EINVAL;
++
++	/* All combinations of the supported triggers are allowed */
++	if (rules & ~supported_triggers)
++		return -EOPNOTSUPP;
++
++	return 0;
++}
++
++static int gpy_led_hw_control_get(struct phy_device *phydev, u8 index,
++				  unsigned long *rules)
++{
++	int val;
++
++	if (index >= GPY_MAX_LEDS)
++		return -EINVAL;
++
++	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_LED(index));
++	if (val < 0)
++		return val;
++
++	if (FIELD_GET(VSPEC1_LED_CON, val) & VSPEC1_LED_LINK10)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_10);
++
++	if (FIELD_GET(VSPEC1_LED_CON, val) & VSPEC1_LED_LINK100)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_100);
++
++	if (FIELD_GET(VSPEC1_LED_CON, val) & VSPEC1_LED_LINK1000)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_1000);
++
++	if (FIELD_GET(VSPEC1_LED_CON, val) & VSPEC1_LED_LINK2500)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_2500);
++
++	if (FIELD_GET(VSPEC1_LED_CON, val) == (VSPEC1_LED_LINK10 |
++					       VSPEC1_LED_LINK100 |
++					       VSPEC1_LED_LINK1000 |
++					       VSPEC1_LED_LINK2500))
++		*rules |= BIT(TRIGGER_NETDEV_LINK);
++
++	if (FIELD_GET(VSPEC1_LED_PULSE, val) & VSPEC1_LED_TXACT)
++		*rules |= BIT(TRIGGER_NETDEV_TX);
++
++	if (FIELD_GET(VSPEC1_LED_PULSE, val) & VSPEC1_LED_RXACT)
++		*rules |= BIT(TRIGGER_NETDEV_RX);
++
++	return 0;
++}
++
++static int gpy_led_hw_control_set(struct phy_device *phydev, u8 index,
++				  unsigned long rules)
++{
++	u16 val = 0;
++	int ret;
++
++	if (index >= GPY_MAX_LEDS)
++		return -EINVAL;
++
++	if (rules & BIT(TRIGGER_NETDEV_LINK) ||
++	    rules & BIT(TRIGGER_NETDEV_LINK_10))
++		val |= FIELD_PREP(VSPEC1_LED_CON, VSPEC1_LED_LINK10);
++
++	if (rules & BIT(TRIGGER_NETDEV_LINK) ||
++	    rules & BIT(TRIGGER_NETDEV_LINK_100))
++		val |= FIELD_PREP(VSPEC1_LED_CON, VSPEC1_LED_LINK100);
++
++	if (rules & BIT(TRIGGER_NETDEV_LINK) ||
++	    rules & BIT(TRIGGER_NETDEV_LINK_1000))
++		val |= FIELD_PREP(VSPEC1_LED_CON, VSPEC1_LED_LINK1000);
++
++	if (rules & BIT(TRIGGER_NETDEV_LINK) ||
++	    rules & BIT(TRIGGER_NETDEV_LINK_2500))
++		val |= FIELD_PREP(VSPEC1_LED_CON, VSPEC1_LED_LINK2500);
++
++	if (rules & BIT(TRIGGER_NETDEV_TX))
++		val |= FIELD_PREP(VSPEC1_LED_PULSE, VSPEC1_LED_TXACT);
++
++	if (rules & BIT(TRIGGER_NETDEV_RX))
++		val |= FIELD_PREP(VSPEC1_LED_PULSE, VSPEC1_LED_RXACT);
++
++	/* allow RX/TX pulse without link indication */
++	if ((rules & BIT(TRIGGER_NETDEV_TX) || rules & BIT(TRIGGER_NETDEV_RX)) &&
++	    !(val & VSPEC1_LED_CON))
++		val |= FIELD_PREP(VSPEC1_LED_PULSE, VSPEC1_LED_NO_CON) | VSPEC1_LED_CON;
++
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_LED(index), val);
++	if (ret)
++		return ret;
++
++	return phy_set_bits(phydev, PHY_LED, PHY_LED_HWCONTROL(index));
++}
++
++static int gpy_led_polarity_set(struct phy_device *phydev, int index,
++				unsigned long modes)
++{
++	bool active_low = false;
++	u32 mode;
++
++	if (index >= GPY_MAX_LEDS)
++		return -EINVAL;
++
++	for_each_set_bit(mode, &modes, __PHY_LED_MODES_NUM) {
++		switch (mode) {
++		case PHY_LED_ACTIVE_LOW:
++			active_low = true;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	return phy_modify(phydev, PHY_LED, PHY_LED_POLARITY(index),
++			  active_low ? 0 : PHY_LED_POLARITY(index));
++}
++
+ static struct phy_driver gpy_drivers[] = {
+ 	{
+ 		PHY_ID_MATCH_MODEL(PHY_ID_GPY2xx),
+@@ -852,6 +1025,11 @@ static struct phy_driver gpy_drivers[] =
+ 		.set_wol	= gpy_set_wol,
+ 		.get_wol	= gpy_get_wol,
+ 		.set_loopback	= gpy_loopback,
++		.led_brightness_set = gpy_led_brightness_set,
++		.led_hw_is_supported = gpy_led_hw_is_supported,
++		.led_hw_control_get = gpy_led_hw_control_get,
++		.led_hw_control_set = gpy_led_hw_control_set,
++		.led_polarity_set = gpy_led_polarity_set,
+ 	},
+ 	{
+ 		.phy_id		= PHY_ID_GPY115B,
+@@ -870,6 +1048,11 @@ static struct phy_driver gpy_drivers[] =
+ 		.set_wol	= gpy_set_wol,
+ 		.get_wol	= gpy_get_wol,
+ 		.set_loopback	= gpy115_loopback,
++		.led_brightness_set = gpy_led_brightness_set,
++		.led_hw_is_supported = gpy_led_hw_is_supported,
++		.led_hw_control_get = gpy_led_hw_control_get,
++		.led_hw_control_set = gpy_led_hw_control_set,
++		.led_polarity_set = gpy_led_polarity_set,
+ 	},
+ 	{
+ 		PHY_ID_MATCH_MODEL(PHY_ID_GPY115C),
+@@ -887,6 +1070,11 @@ static struct phy_driver gpy_drivers[] =
+ 		.set_wol	= gpy_set_wol,
+ 		.get_wol	= gpy_get_wol,
+ 		.set_loopback	= gpy115_loopback,
++		.led_brightness_set = gpy_led_brightness_set,
++		.led_hw_is_supported = gpy_led_hw_is_supported,
++		.led_hw_control_get = gpy_led_hw_control_get,
++		.led_hw_control_set = gpy_led_hw_control_set,
++		.led_polarity_set = gpy_led_polarity_set,
+ 	},
+ 	{
+ 		.phy_id		= PHY_ID_GPY211B,
+@@ -905,6 +1093,11 @@ static struct phy_driver gpy_drivers[] =
+ 		.set_wol	= gpy_set_wol,
+ 		.get_wol	= gpy_get_wol,
+ 		.set_loopback	= gpy_loopback,
++		.led_brightness_set = gpy_led_brightness_set,
++		.led_hw_is_supported = gpy_led_hw_is_supported,
++		.led_hw_control_get = gpy_led_hw_control_get,
++		.led_hw_control_set = gpy_led_hw_control_set,
++		.led_polarity_set = gpy_led_polarity_set,
+ 	},
+ 	{
+ 		PHY_ID_MATCH_MODEL(PHY_ID_GPY211C),
+@@ -922,6 +1115,11 @@ static struct phy_driver gpy_drivers[] =
+ 		.set_wol	= gpy_set_wol,
+ 		.get_wol	= gpy_get_wol,
+ 		.set_loopback	= gpy_loopback,
++		.led_brightness_set = gpy_led_brightness_set,
++		.led_hw_is_supported = gpy_led_hw_is_supported,
++		.led_hw_control_get = gpy_led_hw_control_get,
++		.led_hw_control_set = gpy_led_hw_control_set,
++		.led_polarity_set = gpy_led_polarity_set,
+ 	},
+ 	{
+ 		.phy_id		= PHY_ID_GPY212B,
+@@ -940,6 +1138,11 @@ static struct phy_driver gpy_drivers[] =
+ 		.set_wol	= gpy_set_wol,
+ 		.get_wol	= gpy_get_wol,
+ 		.set_loopback	= gpy_loopback,
++		.led_brightness_set = gpy_led_brightness_set,
++		.led_hw_is_supported = gpy_led_hw_is_supported,
++		.led_hw_control_get = gpy_led_hw_control_get,
++		.led_hw_control_set = gpy_led_hw_control_set,
++		.led_polarity_set = gpy_led_polarity_set,
+ 	},
+ 	{
+ 		PHY_ID_MATCH_MODEL(PHY_ID_GPY212C),
+@@ -957,6 +1160,11 @@ static struct phy_driver gpy_drivers[] =
+ 		.set_wol	= gpy_set_wol,
+ 		.get_wol	= gpy_get_wol,
+ 		.set_loopback	= gpy_loopback,
++		.led_brightness_set = gpy_led_brightness_set,
++		.led_hw_is_supported = gpy_led_hw_is_supported,
++		.led_hw_control_get = gpy_led_hw_control_get,
++		.led_hw_control_set = gpy_led_hw_control_set,
++		.led_polarity_set = gpy_led_polarity_set,
+ 	},
+ 	{
+ 		.phy_id		= PHY_ID_GPY215B,
+@@ -975,6 +1183,11 @@ static struct phy_driver gpy_drivers[] =
+ 		.set_wol	= gpy_set_wol,
+ 		.get_wol	= gpy_get_wol,
+ 		.set_loopback	= gpy_loopback,
++		.led_brightness_set = gpy_led_brightness_set,
++		.led_hw_is_supported = gpy_led_hw_is_supported,
++		.led_hw_control_get = gpy_led_hw_control_get,
++		.led_hw_control_set = gpy_led_hw_control_set,
++		.led_polarity_set = gpy_led_polarity_set,
+ 	},
+ 	{
+ 		PHY_ID_MATCH_MODEL(PHY_ID_GPY215C),
+@@ -992,6 +1205,11 @@ static struct phy_driver gpy_drivers[] =
+ 		.set_wol	= gpy_set_wol,
+ 		.get_wol	= gpy_get_wol,
+ 		.set_loopback	= gpy_loopback,
++		.led_brightness_set = gpy_led_brightness_set,
++		.led_hw_is_supported = gpy_led_hw_is_supported,
++		.led_hw_control_get = gpy_led_hw_control_get,
++		.led_hw_control_set = gpy_led_hw_control_set,
++		.led_polarity_set = gpy_led_polarity_set,
+ 	},
+ 	{
+ 		PHY_ID_MATCH_MODEL(PHY_ID_GPY241B),
diff --git a/target/linux/generic/backport-6.12/844-v6.13-net-phy-mxl-gpy-add-missing-support-for-TRIGGER_NETD.patch b/target/linux/generic/backport-6.12/844-v6.13-net-phy-mxl-gpy-add-missing-support-for-TRIGGER_NETD.patch
new file mode 100644
index 0000000000..39bef9b982
--- /dev/null
+++ b/target/linux/generic/backport-6.12/844-v6.13-net-phy-mxl-gpy-add-missing-support-for-TRIGGER_NETD.patch
@@ -0,0 +1,28 @@
+From f95b4725e796b12e5f347a0d161e1d3843142aa8 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Fri, 4 Oct 2024 16:56:35 +0100
+Subject: [PATCH] net: phy: mxl-gpy: add missing support for
+ TRIGGER_NETDEV_LINK_10
+
+The PHY also support 10MBit/s links as well as the corresponding link
+indication trigger to be offloaded. Add TRIGGER_NETDEV_LINK_10 to the
+supported triggers.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/cc5da0a989af8b0d49d823656d88053c4de2ab98.1728057367.git.daniel@makrotopia.org
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ drivers/net/phy/mxl-gpy.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/phy/mxl-gpy.c
++++ b/drivers/net/phy/mxl-gpy.c
+@@ -884,6 +884,7 @@ static int gpy_led_brightness_set(struct
+ }
+ 
+ static const unsigned long supported_triggers = (BIT(TRIGGER_NETDEV_LINK) |
++						 BIT(TRIGGER_NETDEV_LINK_10) |
+ 						 BIT(TRIGGER_NETDEV_LINK_100) |
+ 						 BIT(TRIGGER_NETDEV_LINK_1000) |
+ 						 BIT(TRIGGER_NETDEV_LINK_2500) |
diff --git a/target/linux/generic/backport-6.12/845-v6.13-net-phy-mxl-gpy-correctly-describe-LED-polarity.patch b/target/linux/generic/backport-6.12/845-v6.13-net-phy-mxl-gpy-correctly-describe-LED-polarity.patch
new file mode 100644
index 0000000000..5fd3dcc77b
--- /dev/null
+++ b/target/linux/generic/backport-6.12/845-v6.13-net-phy-mxl-gpy-correctly-describe-LED-polarity.patch
@@ -0,0 +1,58 @@
+From eb89c79c1b8f17fc1611540768678e60df89ac42 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 10 Oct 2024 13:55:17 +0100
+Subject: [PATCH 3/4] net: phy: mxl-gpy: correctly describe LED polarity
+
+According the datasheet covering the LED (0x1b) register:
+0B Active High LEDx pin driven high when activated
+1B Active Low LEDx pin driven low when activated
+
+Make use of the now available 'active-high' property and correctly
+reflect the polarity setting which was previously inverted.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/180ccafa837f09908b852a8a874a3808c5ecd2d0.1728558223.git.daniel@makrotopia.org
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/phy/mxl-gpy.c | 16 ++++++++++++----
+ 1 file changed, 12 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/phy/mxl-gpy.c
++++ b/drivers/net/phy/mxl-gpy.c
+@@ -989,7 +989,7 @@ static int gpy_led_hw_control_set(struct
+ static int gpy_led_polarity_set(struct phy_device *phydev, int index,
+ 				unsigned long modes)
+ {
+-	bool active_low = false;
++	bool force_active_low = false, force_active_high = false;
+ 	u32 mode;
+ 
+ 	if (index >= GPY_MAX_LEDS)
+@@ -998,15 +998,23 @@ static int gpy_led_polarity_set(struct p
+ 	for_each_set_bit(mode, &modes, __PHY_LED_MODES_NUM) {
+ 		switch (mode) {
+ 		case PHY_LED_ACTIVE_LOW:
+-			active_low = true;
++			force_active_low = true;
++			break;
++		case PHY_LED_ACTIVE_HIGH:
++			force_active_high = true;
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+-	return phy_modify(phydev, PHY_LED, PHY_LED_POLARITY(index),
+-			  active_low ? 0 : PHY_LED_POLARITY(index));
++	if (force_active_low)
++		return phy_set_bits(phydev, PHY_LED, PHY_LED_POLARITY(index));
++
++	if (force_active_high)
++		return phy_clear_bits(phydev, PHY_LED, PHY_LED_POLARITY(index));
++
++	unreachable();
+ }
+ 
+ static struct phy_driver gpy_drivers[] = {
diff --git a/target/linux/generic/backport-6.12/846-v6.13-net-phy-intel-xway-add-support-for-PHY-LEDs.patch b/target/linux/generic/backport-6.12/846-v6.13-net-phy-intel-xway-add-support-for-PHY-LEDs.patch
new file mode 100644
index 0000000000..c57b5777ad
--- /dev/null
+++ b/target/linux/generic/backport-6.12/846-v6.13-net-phy-intel-xway-add-support-for-PHY-LEDs.patch
@@ -0,0 +1,379 @@
+From 1758af47b98c17da464cb45f476875150955dd48 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 10 Oct 2024 13:55:29 +0100
+Subject: [PATCH 4/4] net: phy: intel-xway: add support for PHY LEDs
+
+The intel-xway PHY driver predates the PHY LED framework and currently
+initializes all LED pins to equal default values.
+
+Add PHY LED functions to the drivers and don't set default values if
+LEDs are defined in device tree.
+
+According the datasheets 3 LEDs are supported on all Intel XWAY PHYs.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://patch.msgid.link/81f4717ab9acf38f3239727a4540ae96fd01109b.1728558223.git.daniel@makrotopia.org
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/phy/intel-xway.c | 253 +++++++++++++++++++++++++++++++++--
+ 1 file changed, 244 insertions(+), 9 deletions(-)
+
+--- a/drivers/net/phy/intel-xway.c
++++ b/drivers/net/phy/intel-xway.c
+@@ -151,6 +151,13 @@
+ #define XWAY_MMD_LED3H			0x01E8
+ #define XWAY_MMD_LED3L			0x01E9
+ 
++#define XWAY_GPHY_MAX_LEDS		3
++#define XWAY_GPHY_LED_INV(idx)		BIT(12 + (idx))
++#define XWAY_GPHY_LED_EN(idx)		BIT(8 + (idx))
++#define XWAY_GPHY_LED_DA(idx)		BIT(idx)
++#define XWAY_MMD_LEDxH(idx)		(XWAY_MMD_LED0H + 2 * (idx))
++#define XWAY_MMD_LEDxL(idx)		(XWAY_MMD_LED0L + 2 * (idx))
++
+ #define PHY_ID_PHY11G_1_3		0x030260D1
+ #define PHY_ID_PHY22F_1_3		0x030260E1
+ #define PHY_ID_PHY11G_1_4		0xD565A400
+@@ -229,20 +236,12 @@ static int xway_gphy_rgmii_init(struct p
+ 			  XWAY_MDIO_MIICTRL_TXSKEW_MASK, val);
+ }
+ 
+-static int xway_gphy_config_init(struct phy_device *phydev)
++static int xway_gphy_init_leds(struct phy_device *phydev)
+ {
+ 	int err;
+ 	u32 ledxh;
+ 	u32 ledxl;
+ 
+-	/* Mask all interrupts */
+-	err = phy_write(phydev, XWAY_MDIO_IMASK, 0);
+-	if (err)
+-		return err;
+-
+-	/* Clear all pending interrupts */
+-	phy_read(phydev, XWAY_MDIO_ISTAT);
+-
+ 	/* Ensure that integrated led function is enabled for all leds */
+ 	err = phy_write(phydev, XWAY_MDIO_LED,
+ 			XWAY_MDIO_LED_LED0_EN |
+@@ -276,6 +275,26 @@ static int xway_gphy_config_init(struct
+ 	phy_write_mmd(phydev, MDIO_MMD_VEND2, XWAY_MMD_LED2H, ledxh);
+ 	phy_write_mmd(phydev, MDIO_MMD_VEND2, XWAY_MMD_LED2L, ledxl);
+ 
++	return 0;
++}
++
++static int xway_gphy_config_init(struct phy_device *phydev)
++{
++	struct device_node *np = phydev->mdio.dev.of_node;
++	int err;
++
++	/* Mask all interrupts */
++	err = phy_write(phydev, XWAY_MDIO_IMASK, 0);
++	if (err)
++		return err;
++
++	/* Use default LED configuration if 'leds' node isn't defined */
++	if (!of_get_child_by_name(np, "leds"))
++		xway_gphy_init_leds(phydev);
++
++	/* Clear all pending interrupts */
++	phy_read(phydev, XWAY_MDIO_ISTAT);
++
+ 	err = xway_gphy_rgmii_init(phydev);
+ 	if (err)
+ 		return err;
+@@ -347,6 +366,172 @@ static irqreturn_t xway_gphy_handle_inte
+ 	return IRQ_HANDLED;
+ }
+ 
++static int xway_gphy_led_brightness_set(struct phy_device *phydev,
++					u8 index, enum led_brightness value)
++{
++	int ret;
++
++	if (index >= XWAY_GPHY_MAX_LEDS)
++		return -EINVAL;
++
++	/* clear EN and set manual LED state */
++	ret = phy_modify(phydev, XWAY_MDIO_LED,
++			 ((value == LED_OFF) ? XWAY_GPHY_LED_EN(index) : 0) |
++			 XWAY_GPHY_LED_DA(index),
++			 (value == LED_OFF) ? 0 : XWAY_GPHY_LED_DA(index));
++	if (ret)
++		return ret;
++
++	/* clear HW LED setup */
++	if (value == LED_OFF) {
++		ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, XWAY_MMD_LEDxH(index), 0);
++		if (ret)
++			return ret;
++
++		return phy_write_mmd(phydev, MDIO_MMD_VEND2, XWAY_MMD_LEDxL(index), 0);
++	} else {
++		return 0;
++	}
++}
++
++static const unsigned long supported_triggers = (BIT(TRIGGER_NETDEV_LINK) |
++						 BIT(TRIGGER_NETDEV_LINK_10) |
++						 BIT(TRIGGER_NETDEV_LINK_100) |
++						 BIT(TRIGGER_NETDEV_LINK_1000) |
++						 BIT(TRIGGER_NETDEV_RX) |
++						 BIT(TRIGGER_NETDEV_TX));
++
++static int xway_gphy_led_hw_is_supported(struct phy_device *phydev, u8 index,
++					 unsigned long rules)
++{
++	if (index >= XWAY_GPHY_MAX_LEDS)
++		return -EINVAL;
++
++	/* activity triggers are not possible without combination with a link
++	 * trigger.
++	 */
++	if (rules & (BIT(TRIGGER_NETDEV_RX) | BIT(TRIGGER_NETDEV_TX)) &&
++	    !(rules & (BIT(TRIGGER_NETDEV_LINK) |
++		       BIT(TRIGGER_NETDEV_LINK_10) |
++		       BIT(TRIGGER_NETDEV_LINK_100) |
++		       BIT(TRIGGER_NETDEV_LINK_1000))))
++		return -EOPNOTSUPP;
++
++	/* All other combinations of the supported triggers are allowed */
++	if (rules & ~supported_triggers)
++		return -EOPNOTSUPP;
++
++	return 0;
++}
++
++static int xway_gphy_led_hw_control_get(struct phy_device *phydev, u8 index,
++					unsigned long *rules)
++{
++	int lval, hval;
++
++	if (index >= XWAY_GPHY_MAX_LEDS)
++		return -EINVAL;
++
++	hval = phy_read_mmd(phydev, MDIO_MMD_VEND2, XWAY_MMD_LEDxH(index));
++	if (hval < 0)
++		return hval;
++
++	lval = phy_read_mmd(phydev, MDIO_MMD_VEND2, XWAY_MMD_LEDxL(index));
++	if (lval < 0)
++		return lval;
++
++	if (hval & XWAY_MMD_LEDxH_CON_LINK10)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_10);
++
++	if (hval & XWAY_MMD_LEDxH_CON_LINK100)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_100);
++
++	if (hval & XWAY_MMD_LEDxH_CON_LINK1000)
++		*rules |= BIT(TRIGGER_NETDEV_LINK_1000);
++
++	if ((hval & XWAY_MMD_LEDxH_CON_LINK10) &&
++	    (hval & XWAY_MMD_LEDxH_CON_LINK100) &&
++	    (hval & XWAY_MMD_LEDxH_CON_LINK1000))
++		*rules |= BIT(TRIGGER_NETDEV_LINK);
++
++	if (lval & XWAY_MMD_LEDxL_PULSE_TXACT)
++		*rules |= BIT(TRIGGER_NETDEV_TX);
++
++	if (lval & XWAY_MMD_LEDxL_PULSE_RXACT)
++		*rules |= BIT(TRIGGER_NETDEV_RX);
++
++	return 0;
++}
++
++static int xway_gphy_led_hw_control_set(struct phy_device *phydev, u8 index,
++					unsigned long rules)
++{
++	u16 hval = 0, lval = 0;
++	int ret;
++
++	if (index >= XWAY_GPHY_MAX_LEDS)
++		return -EINVAL;
++
++	if (rules & BIT(TRIGGER_NETDEV_LINK) ||
++	    rules & BIT(TRIGGER_NETDEV_LINK_10))
++		hval |= XWAY_MMD_LEDxH_CON_LINK10;
++
++	if (rules & BIT(TRIGGER_NETDEV_LINK) ||
++	    rules & BIT(TRIGGER_NETDEV_LINK_100))
++		hval |= XWAY_MMD_LEDxH_CON_LINK100;
++
++	if (rules & BIT(TRIGGER_NETDEV_LINK) ||
++	    rules & BIT(TRIGGER_NETDEV_LINK_1000))
++		hval |= XWAY_MMD_LEDxH_CON_LINK1000;
++
++	if (rules & BIT(TRIGGER_NETDEV_TX))
++		lval |= XWAY_MMD_LEDxL_PULSE_TXACT;
++
++	if (rules & BIT(TRIGGER_NETDEV_RX))
++		lval |= XWAY_MMD_LEDxL_PULSE_RXACT;
++
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, XWAY_MMD_LEDxH(index), hval);
++	if (ret)
++		return ret;
++
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, XWAY_MMD_LEDxL(index), lval);
++	if (ret)
++		return ret;
++
++	return phy_set_bits(phydev, XWAY_MDIO_LED, XWAY_GPHY_LED_EN(index));
++}
++
++static int xway_gphy_led_polarity_set(struct phy_device *phydev, int index,
++				      unsigned long modes)
++{
++	bool force_active_low = false, force_active_high = false;
++	u32 mode;
++
++	if (index >= XWAY_GPHY_MAX_LEDS)
++		return -EINVAL;
++
++	for_each_set_bit(mode, &modes, __PHY_LED_MODES_NUM) {
++		switch (mode) {
++		case PHY_LED_ACTIVE_LOW:
++			force_active_low = true;
++			break;
++		case PHY_LED_ACTIVE_HIGH:
++			force_active_high = true;
++			break;
++		default:
++			return -EINVAL;
++		}
++	}
++
++	if (force_active_low)
++		return phy_set_bits(phydev, XWAY_MDIO_LED, XWAY_GPHY_LED_INV(index));
++
++	if (force_active_high)
++		return phy_clear_bits(phydev, XWAY_MDIO_LED, XWAY_GPHY_LED_INV(index));
++
++	unreachable();
++}
++
+ static struct phy_driver xway_gphy[] = {
+ 	{
+ 		.phy_id		= PHY_ID_PHY11G_1_3,
+@@ -359,6 +544,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	}, {
+ 		.phy_id		= PHY_ID_PHY22F_1_3,
+ 		.phy_id_mask	= 0xffffffff,
+@@ -370,6 +560,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	}, {
+ 		.phy_id		= PHY_ID_PHY11G_1_4,
+ 		.phy_id_mask	= 0xffffffff,
+@@ -381,6 +576,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	}, {
+ 		.phy_id		= PHY_ID_PHY22F_1_4,
+ 		.phy_id_mask	= 0xffffffff,
+@@ -392,6 +592,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	}, {
+ 		.phy_id		= PHY_ID_PHY11G_1_5,
+ 		.phy_id_mask	= 0xffffffff,
+@@ -402,6 +607,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	}, {
+ 		.phy_id		= PHY_ID_PHY22F_1_5,
+ 		.phy_id_mask	= 0xffffffff,
+@@ -412,6 +622,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	}, {
+ 		.phy_id		= PHY_ID_PHY11G_VR9_1_1,
+ 		.phy_id_mask	= 0xffffffff,
+@@ -422,6 +637,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	}, {
+ 		.phy_id		= PHY_ID_PHY22F_VR9_1_1,
+ 		.phy_id_mask	= 0xffffffff,
+@@ -432,6 +652,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	}, {
+ 		.phy_id		= PHY_ID_PHY11G_VR9_1_2,
+ 		.phy_id_mask	= 0xffffffff,
+@@ -442,6 +667,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	}, {
+ 		.phy_id		= PHY_ID_PHY22F_VR9_1_2,
+ 		.phy_id_mask	= 0xffffffff,
+@@ -452,6 +682,11 @@ static struct phy_driver xway_gphy[] = {
+ 		.config_intr	= xway_gphy_config_intr,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
++		.led_brightness_set = xway_gphy_led_brightness_set,
++		.led_hw_is_supported = xway_gphy_led_hw_is_supported,
++		.led_hw_control_get = xway_gphy_led_hw_control_get,
++		.led_hw_control_set = xway_gphy_led_hw_control_set,
++		.led_polarity_set = xway_gphy_led_polarity_set,
+ 	},
+ };
+ module_phy_driver(xway_gphy);
diff --git a/target/linux/generic/backport-6.12/880-v6.14-gpio-regmap-Use-generic-request-free-ops.patch b/target/linux/generic/backport-6.12/880-v6.14-gpio-regmap-Use-generic-request-free-ops.patch
new file mode 100644
index 0000000000..f9299f9733
--- /dev/null
+++ b/target/linux/generic/backport-6.12/880-v6.14-gpio-regmap-Use-generic-request-free-ops.patch
@@ -0,0 +1,30 @@
+From b0fa00fe38f673c986633c11087274deeb7ce7b0 Mon Sep 17 00:00:00 2001
+From: Sander Vanheule <sander@svanheule.net>
+Date: Tue, 7 Jan 2025 21:16:20 +0100
+Subject: [PATCH] gpio: regmap: Use generic request/free ops
+
+Set the gpiochip request and free ops to the generic implementations.
+This way a user can provide a gpio-ranges property defined for a pinmux,
+easing muxing of gpio functions. Provided that the pin controller
+implementents the pinmux op .gpio_request_enable(), pins will
+automatically be muxed to their GPIO function when requested.
+
+Signed-off-by: Sander Vanheule <sander@svanheule.net>
+Acked-by: Michael Walle <mwalle@kernel.org>
+Link: https://lore.kernel.org/r/20250107201621.12467-1-sander@svanheule.net
+Signed-off-by: Bartosz Golaszewski <bartosz.golaszewski@linaro.org>
+---
+ drivers/gpio/gpio-regmap.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/gpio/gpio-regmap.c
++++ b/drivers/gpio/gpio-regmap.c
+@@ -262,6 +262,8 @@ struct gpio_regmap *gpio_regmap_register
+ 	chip->label = config->label ?: dev_name(config->parent);
+ 	chip->can_sleep = regmap_might_sleep(config->regmap);
+ 
++	chip->request = gpiochip_generic_request;
++	chip->free = gpiochip_generic_free;
+ 	chip->get = gpio_regmap_get;
+ 	if (gpio->reg_set_base && gpio->reg_clr_base)
+ 		chip->set = gpio_regmap_set_with_clear;
diff --git a/target/linux/generic/backport-6.12/901-v6.13-net-dsa-mv88e6xxx-Support-LED-control.patch b/target/linux/generic/backport-6.12/901-v6.13-net-dsa-mv88e6xxx-Support-LED-control.patch
new file mode 100644
index 0000000000..19268cf578
--- /dev/null
+++ b/target/linux/generic/backport-6.12/901-v6.13-net-dsa-mv88e6xxx-Support-LED-control.patch
@@ -0,0 +1,1250 @@
+From 7b590490e3aa6bfa38bf6e2069a529017fd3c1d2 Mon Sep 17 00:00:00 2001
+From: Linus Walleij <linus.walleij@linaro.org>
+Date: Fri, 13 Oct 2023 00:08:35 +0200
+Subject: [PATCH] net: dsa: mv88e6xxx: Support LED control
+
+This adds control over the hardware LEDs in the Marvell
+MV88E6xxx DSA switch and enables it for MV88E6352.
+
+This fixes an imminent problem on the Inteno XG6846 which
+has a WAN LED that simply do not work with hardware
+defaults: driver amendment is necessary.
+
+The patch is modeled after Christian Marangis LED support
+code for the QCA8k DSA switch, I got help with the register
+definitions from Tim Harvey.
+
+After this patch it is possible to activate hardware link
+indication like this (or with a similar script):
+
+  cd /sys/class/leds/Marvell\ 88E6352:05:00:green:wan/
+  echo netdev > trigger
+  echo 1 > link
+
+This makes the green link indicator come up on any link
+speed. It is also possible to be more elaborate, like this:
+
+  cd /sys/class/leds/Marvell\ 88E6352:05:00:green:wan/
+  echo netdev > trigger
+  echo 1 > link_1000
+  cd /sys/class/leds/Marvell\ 88E6352:05:01:amber:wan/
+  echo netdev > trigger
+  echo 1 > link_100
+
+Making the green LED come on for a gigabit link and the
+amber LED come on for a 100 mbit link.
+
+Each port has 2 LED slots (the hardware may use just one or
+none) and the hardware triggers are specified in four bits per
+LED, and some of the hardware triggers are only available on the
+SFP (fiber) uplink. The restrictions are described in the
+port.h header file where the registers are described. For
+example, selector 1 set for LED 1 on port 5 or 6 will indicate
+Fiber 1000 (gigabit) and activity with a blinking LED, but
+ONLY for an SFP connection. If port 5/6 is used with something
+not SFP, this selector is a noop: something else need to be
+selected.
+
+After the previous series rewriting the MV88E6xxx DT
+bindings to use YAML a "leds" subnode is already valid
+for each port, in my scratch device tree it looks like
+this:
+
+   leds {
+     #address-cells = <1>;
+     #size-cells = <0>;
+
+     led@0 {
+       reg = <0>;
+       color = <LED_COLOR_ID_GREEN>;
+       function = LED_FUNCTION_LAN;
+       default-state = "off";
+       linux,default-trigger = "netdev";
+     };
+     led@1 {
+       reg = <1>;
+       color = <LED_COLOR_ID_AMBER>;
+       function = LED_FUNCTION_LAN;
+       default-state = "off";
+     };
+   };
+
+This DT config is not yet configuring everything: when the netdev
+default trigger is assigned the hw acceleration callbacks are
+not called, and there is no way to set the netdev sub-trigger
+type (such as link_1000) from the device tree, such as if you want
+a gigabit link indicator. This has to be done from userspace at
+this point.
+
+We add LED operations to all switches in the 6352 family:
+6172, 6176, 6240 and 6352.
+
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/net/dsa/mv88e6xxx/Kconfig  |  10 +
+ drivers/net/dsa/mv88e6xxx/Makefile |   1 +
+ drivers/net/dsa/mv88e6xxx/chip.c   |  38 +-
+ drivers/net/dsa/mv88e6xxx/chip.h   |  11 +
+ drivers/net/dsa/mv88e6xxx/leds.c   | 839 +++++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/port.c   |   1 +
+ drivers/net/dsa/mv88e6xxx/port.h   | 133 +++++
+ 7 files changed, 1031 insertions(+), 2 deletions(-)
+ create mode 100644 drivers/net/dsa/mv88e6xxx/leds.c
+
+--- a/drivers/net/dsa/mv88e6xxx/Kconfig
++++ b/drivers/net/dsa/mv88e6xxx/Kconfig
+@@ -17,3 +17,13 @@ config NET_DSA_MV88E6XXX_PTP
+ 	help
+ 	  Say Y to enable PTP hardware timestamping on Marvell 88E6xxx switch
+ 	  chips that support it.
++
++config NET_DSA_MV88E6XXX_LEDS
++	bool "LED support for Marvell 88E6xxx"
++	default y
++	depends on NET_DSA_MV88E6XXX
++	depends on LEDS_CLASS=y || LEDS_CLASS=NET_DSA_MV88E6XXX
++	depends on LEDS_TRIGGERS
++	help
++	  This enabled support for controlling the LEDs attached to the
++	  Marvell 88E6xxx switch chips.
+--- a/drivers/net/dsa/mv88e6xxx/Makefile
++++ b/drivers/net/dsa/mv88e6xxx/Makefile
+@@ -9,6 +9,7 @@ mv88e6xxx-objs += global2.o
+ mv88e6xxx-objs += global2_avb.o
+ mv88e6xxx-objs += global2_scratch.o
+ mv88e6xxx-$(CONFIG_NET_DSA_MV88E6XXX_PTP) += hwtstamp.o
++mv88e6xxx-$(CONFIG_NET_DSA_MV88E6XXX_LEDS) += leds.o
+ mv88e6xxx-objs += pcs-6185.o
+ mv88e6xxx-objs += pcs-6352.o
+ mv88e6xxx-objs += pcs-639x.o
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -27,6 +27,7 @@
+ #include <linux/of_irq.h>
+ #include <linux/of_mdio.h>
+ #include <linux/platform_data/mv88e6xxx.h>
++#include <linux/property.h>
+ #include <linux/netdevice.h>
+ #include <linux/gpio/consumer.h>
+ #include <linux/phylink.h>
+@@ -3412,14 +3413,43 @@ static int mv88e6xxx_setup_upstream_port
+ static int mv88e6xxx_setup_port(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	struct device_node *phy_handle = NULL;
++	struct fwnode_handle *ports_fwnode;
++	struct fwnode_handle *port_fwnode;
+ 	struct dsa_switch *ds = chip->ds;
++	struct mv88e6xxx_port *p;
+ 	struct dsa_port *dp;
+ 	int tx_amp;
+ 	int err;
+ 	u16 reg;
++	u32 val;
+ 
+-	chip->ports[port].chip = chip;
+-	chip->ports[port].port = port;
++	p = &chip->ports[port];
++	p->chip = chip;
++	p->port = port;
++
++	/* Look up corresponding fwnode if any */
++	ports_fwnode = device_get_named_child_node(chip->dev, "ethernet-ports");
++	if (!ports_fwnode)
++		ports_fwnode = device_get_named_child_node(chip->dev, "ports");
++	if (ports_fwnode) {
++		fwnode_for_each_child_node(ports_fwnode, port_fwnode) {
++			if (fwnode_property_read_u32(port_fwnode, "reg", &val))
++				continue;
++			if (val == port) {
++				p->fwnode = port_fwnode;
++				p->fiber = fwnode_property_present(port_fwnode, "sfp");
++				break;
++			}
++		}
++	} else {
++		dev_dbg(chip->dev, "no ethernet ports node defined for the device\n");
++	}
++
++	if (chip->info->ops->port_setup_leds) {
++		err = chip->info->ops->port_setup_leds(chip, port);
++		if (err && err != -EOPNOTSUPP)
++			return err;
++	}
+ 
+ 	err = mv88e6xxx_port_setup_mac(chip, port, LINK_UNFORCED,
+ 				       SPEED_UNFORCED, DUPLEX_UNFORCED,
+@@ -4653,6 +4683,7 @@ static const struct mv88e6xxx_ops mv88e6
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_get_cmode = mv88e6352_port_get_cmode,
++	.port_setup_leds = mv88e6xxx_port_setup_leds,
+ 	.port_setup_message_port = mv88e6xxx_setup_message_port,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6095_g1_stats_set_histogram,
+@@ -4755,6 +4786,7 @@ static const struct mv88e6xxx_ops mv88e6
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_get_cmode = mv88e6352_port_get_cmode,
++	.port_setup_leds = mv88e6xxx_port_setup_leds,
+ 	.port_setup_message_port = mv88e6xxx_setup_message_port,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6095_g1_stats_set_histogram,
+@@ -5030,6 +5062,7 @@ static const struct mv88e6xxx_ops mv88e6
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_get_cmode = mv88e6352_port_get_cmode,
++	.port_setup_leds = mv88e6xxx_port_setup_leds,
+ 	.port_setup_message_port = mv88e6xxx_setup_message_port,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6095_g1_stats_set_histogram,
+@@ -5460,6 +5493,7 @@ static const struct mv88e6xxx_ops mv88e6
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_get_cmode = mv88e6352_port_get_cmode,
++	.port_setup_leds = mv88e6xxx_port_setup_leds,
+ 	.port_setup_message_port = mv88e6xxx_setup_message_port,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6095_g1_stats_set_histogram,
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -13,7 +13,9 @@
+ #include <linux/irq.h>
+ #include <linux/gpio/consumer.h>
+ #include <linux/kthread.h>
++#include <linux/leds.h>
+ #include <linux/phy.h>
++#include <linux/property.h>
+ #include <linux/ptp_clock_kernel.h>
+ #include <linux/timecounter.h>
+ #include <net/dsa.h>
+@@ -276,6 +278,7 @@ struct mv88e6xxx_vlan {
+ struct mv88e6xxx_port {
+ 	struct mv88e6xxx_chip *chip;
+ 	int port;
++	struct fwnode_handle *fwnode;
+ 	struct mv88e6xxx_vlan bridge_pvid;
+ 	u64 serdes_stats[2];
+ 	u64 atu_member_violation;
+@@ -290,6 +293,11 @@ struct mv88e6xxx_port {
+ 	struct devlink_region *region;
+ 	void *pcs_private;
+ 
++	/* LED related information */
++	bool fiber;
++	struct led_classdev led0;
++	struct led_classdev led1;
++
+ 	/* MacAuth Bypass control flag */
+ 	bool mab;
+ };
+@@ -574,6 +582,9 @@ struct mv88e6xxx_ops {
+ 			      phy_interface_t mode);
+ 	int (*port_get_cmode)(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
+ 
++	/* LED control */
++	int (*port_setup_leds)(struct mv88e6xxx_chip *chip, int port);
++
+ 	/* Some devices have a per port register indicating what is
+ 	 * the upstream port this port should forward to.
+ 	 */
+--- /dev/null
++++ b/drivers/net/dsa/mv88e6xxx/leds.c
+@@ -0,0 +1,839 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++#include <linux/bitfield.h>
++#include <linux/leds.h>
++#include <linux/property.h>
++
++#include "chip.h"
++#include "global2.h"
++#include "port.h"
++
++/* Offset 0x16: LED control */
++
++static int mv88e6xxx_port_led_write(struct mv88e6xxx_chip *chip, int port, u16 reg)
++{
++	reg |= MV88E6XXX_PORT_LED_CONTROL_UPDATE;
++
++	return mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_LED_CONTROL, reg);
++}
++
++static int mv88e6xxx_port_led_read(struct mv88e6xxx_chip *chip, int port,
++				   u16 ptr, u16 *val)
++{
++	int err;
++
++	err = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_LED_CONTROL, ptr);
++	if (err)
++		return err;
++
++	err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_LED_CONTROL, val);
++	*val &= 0x3ff;
++
++	return err;
++}
++
++static int mv88e6xxx_led_brightness_set(struct mv88e6xxx_port *p, int led,
++					int brightness)
++{
++	u16 reg;
++	int err;
++
++	err = mv88e6xxx_port_led_read(p->chip, p->port,
++				      MV88E6XXX_PORT_LED_CONTROL_POINTER_LED01_CTRL,
++				      &reg);
++	if (err)
++		return err;
++
++	if (led == 1)
++		reg &= ~MV88E6XXX_PORT_LED_CONTROL_LED1_SEL_MASK;
++	else
++		reg &= ~MV88E6XXX_PORT_LED_CONTROL_LED0_SEL_MASK;
++
++	if (brightness) {
++		/* Selector 0x0f == Force LED ON */
++		if (led == 1)
++			reg |= MV88E6XXX_PORT_LED_CONTROL_LED1_SELF;
++		else
++			reg |= MV88E6XXX_PORT_LED_CONTROL_LED0_SELF;
++	} else {
++		/* Selector 0x0e == Force LED OFF */
++		if (led == 1)
++			reg |= MV88E6XXX_PORT_LED_CONTROL_LED1_SELE;
++		else
++			reg |= MV88E6XXX_PORT_LED_CONTROL_LED0_SELE;
++	}
++
++	reg |= MV88E6XXX_PORT_LED_CONTROL_POINTER_LED01_CTRL;
++
++	return mv88e6xxx_port_led_write(p->chip, p->port, reg);
++}
++
++static int mv88e6xxx_led0_brightness_set_blocking(struct led_classdev *ldev,
++						  enum led_brightness brightness)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led0);
++	int err;
++
++	mv88e6xxx_reg_lock(p->chip);
++	err = mv88e6xxx_led_brightness_set(p, 0, brightness);
++	mv88e6xxx_reg_unlock(p->chip);
++
++	return err;
++}
++
++static int mv88e6xxx_led1_brightness_set_blocking(struct led_classdev *ldev,
++						  enum led_brightness brightness)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led1);
++	int err;
++
++	mv88e6xxx_reg_lock(p->chip);
++	err = mv88e6xxx_led_brightness_set(p, 1, brightness);
++	mv88e6xxx_reg_unlock(p->chip);
++
++	return err;
++}
++
++struct mv88e6xxx_led_hwconfig {
++	int led;
++	u8 portmask;
++	unsigned long rules;
++	bool fiber;
++	bool blink_activity;
++	u16 selector;
++};
++
++/* The following is a lookup table to check what rules we can support on a
++ * certain LED given restrictions such as that some rules only work with fiber
++ * (SFP) connections and some blink on activity by default.
++ */
++#define MV88E6XXX_PORTS_0_3 (BIT(0) | BIT(1) | BIT(2) | BIT(3))
++#define MV88E6XXX_PORTS_4_5 (BIT(4) | BIT(5))
++#define MV88E6XXX_PORT_4 BIT(4)
++#define MV88E6XXX_PORT_5 BIT(5)
++
++/* Entries are listed in selector order.
++ *
++ * These configurations vary across different switch families, list
++ * different tables per-family here.
++ */
++static const struct mv88e6xxx_led_hwconfig mv88e6352_led_hwconfigs[] = {
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORT_4,
++		.rules = BIT(TRIGGER_NETDEV_LINK),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL0,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORT_5,
++		.rules = BIT(TRIGGER_NETDEV_LINK_1000),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL0,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_100) | BIT(TRIGGER_NETDEV_LINK_1000),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL1,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_10) | BIT(TRIGGER_NETDEV_LINK_100),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL1,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_4_5,
++		.rules = BIT(TRIGGER_NETDEV_LINK_100),
++		.blink_activity = true,
++		.fiber = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL1,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_4_5,
++		.rules = BIT(TRIGGER_NETDEV_LINK_1000),
++		.blink_activity = true,
++		.fiber = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL1,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_1000),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL2,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_10) | BIT(TRIGGER_NETDEV_LINK_100),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL2,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_4_5,
++		.rules = BIT(TRIGGER_NETDEV_LINK_1000),
++		.blink_activity = true,
++		.fiber = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL2,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_4_5,
++		.rules = BIT(TRIGGER_NETDEV_LINK_100),
++		.blink_activity = true,
++		.fiber = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL2,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL3,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_1000),
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL3,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_4_5,
++		.rules = BIT(TRIGGER_NETDEV_LINK),
++		.fiber = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL3,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORT_4,
++		.rules = BIT(TRIGGER_NETDEV_LINK),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL4,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORT_5,
++		.rules = BIT(TRIGGER_NETDEV_LINK),
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL5,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_FULL_DUPLEX),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL6,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_10) | BIT(TRIGGER_NETDEV_LINK_1000),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL6,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORT_4,
++		.rules = BIT(TRIGGER_NETDEV_FULL_DUPLEX),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL6,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORT_5,
++		.rules = BIT(TRIGGER_NETDEV_FULL_DUPLEX),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL6,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_10) | BIT(TRIGGER_NETDEV_LINK_1000),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL7,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_10) | BIT(TRIGGER_NETDEV_LINK_1000),
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL7,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK),
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL8,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL8,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORT_5,
++		.rules = BIT(TRIGGER_NETDEV_LINK),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL8,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_10),
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SEL9,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_100),
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SEL9,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_10),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SELA,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_100),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SELA,
++	},
++	{
++		.led = 0,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_100) | BIT(TRIGGER_NETDEV_LINK_1000),
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED0_SELB,
++	},
++	{
++		.led = 1,
++		.portmask = MV88E6XXX_PORTS_0_3,
++		.rules = BIT(TRIGGER_NETDEV_LINK_100) | BIT(TRIGGER_NETDEV_LINK_1000),
++		.blink_activity = true,
++		.selector = MV88E6XXX_PORT_LED_CONTROL_LED1_SELB,
++	},
++};
++
++/* mv88e6xxx_led_match_selector() - look up the appropriate LED mode selector
++ * @p: port state container
++ * @led: LED number, 0 or 1
++ * @blink_activity: blink the LED (usually blink on indicated activity)
++ * @fiber: the link is connected to fiber such as SFP
++ * @rules: LED status flags from the LED classdev core
++ * @selector: fill in the selector in this parameter with an OR operation
++ */
++static int mv88e6xxx_led_match_selector(struct mv88e6xxx_port *p, int led, bool blink_activity,
++					bool fiber, unsigned long rules, u16 *selector)
++{
++	const struct mv88e6xxx_led_hwconfig *conf;
++	int i;
++
++	/* No rules means we turn the LED off */
++	if (!rules) {
++		if (led == 1)
++			*selector |= MV88E6XXX_PORT_LED_CONTROL_LED1_SELE;
++		else
++			*selector |= MV88E6XXX_PORT_LED_CONTROL_LED0_SELE;
++		return 0;
++	}
++
++	/* TODO: these rules are for MV88E6352, when adding other families,
++	 * think about making sure you select the table that match the
++	 * specific switch family.
++	 */
++	for (i = 0; i < ARRAY_SIZE(mv88e6352_led_hwconfigs); i++) {
++		conf = &mv88e6352_led_hwconfigs[i];
++
++		if (conf->led != led)
++			continue;
++
++		if (!(conf->portmask & BIT(p->port)))
++			continue;
++
++		if (conf->blink_activity != blink_activity)
++			continue;
++
++		if (conf->fiber != fiber)
++			continue;
++
++		if (conf->rules == rules) {
++			dev_dbg(p->chip->dev, "port%d LED %d set selector %04x for rules %08lx\n",
++				p->port, led, conf->selector, rules);
++			*selector |= conf->selector;
++			return 0;
++		}
++	}
++
++	return -EOPNOTSUPP;
++}
++
++/* mv88e6xxx_led_match_selector() - find Linux netdev rules from a selector value
++ * @p: port state container
++ * @selector: the selector value from the LED actity register
++ * @led: LED number, 0 or 1
++ * @rules: Linux netdev activity rules found from selector
++ */
++static int
++mv88e6xxx_led_match_rule(struct mv88e6xxx_port *p, u16 selector, int led, unsigned long *rules)
++{
++	const struct mv88e6xxx_led_hwconfig *conf;
++	int i;
++
++	/* Find the selector in the table, we just look for the right selector
++	 * and ignore if the activity has special properties such as blinking
++	 * or is fiber-only.
++	 */
++	for (i = 0; i < ARRAY_SIZE(mv88e6352_led_hwconfigs); i++) {
++		conf = &mv88e6352_led_hwconfigs[i];
++
++		if (conf->led != led)
++			continue;
++
++		if (!(conf->portmask & BIT(p->port)))
++			continue;
++
++		if (conf->selector == selector) {
++			dev_dbg(p->chip->dev, "port%d LED %d has selector %04x, rules %08lx\n",
++				p->port, led, selector, conf->rules);
++			*rules = conf->rules;
++			return 0;
++		}
++	}
++
++	return -EINVAL;
++}
++
++/* mv88e6xxx_led_get_selector() - get the appropriate LED mode selector
++ * @p: port state container
++ * @led: LED number, 0 or 1
++ * @fiber: the link is connected to fiber such as SFP
++ * @rules: LED status flags from the LED classdev core
++ * @selector: fill in the selector in this parameter with an OR operation
++ */
++static int mv88e6xxx_led_get_selector(struct mv88e6xxx_port *p, int led,
++				      bool fiber, unsigned long rules, u16 *selector)
++{
++	int err;
++
++	/* What happens here is that we first try to locate a trigger with solid
++	 * indicator (such as LED is on for a 1000 link) else we try a second
++	 * sweep to find something suitable with a trigger that will blink on
++	 * activity.
++	 */
++	err = mv88e6xxx_led_match_selector(p, led, false, fiber, rules, selector);
++	if (err)
++		return mv88e6xxx_led_match_selector(p, led, true, fiber, rules, selector);
++
++	return 0;
++}
++
++/* Sets up the hardware blinking period */
++static int mv88e6xxx_led_set_blinking_period(struct mv88e6xxx_port *p, int led,
++					     unsigned long delay_on, unsigned long delay_off)
++{
++	unsigned long period;
++	u16 reg;
++
++	period = delay_on + delay_off;
++
++	reg = 0;
++
++	switch (period) {
++	case 21:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_21MS;
++		break;
++	case 42:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_42MS;
++		break;
++	case 84:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_84MS;
++		break;
++	case 168:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_168MS;
++		break;
++	case 336:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_336MS;
++		break;
++	case 672:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_672MS;
++		break;
++	default:
++		/* Fall back to software blinking */
++		return -EINVAL;
++	}
++
++	/* This is essentially PWM duty cycle: how long time of the period
++	 * will the LED be on. Zero isn't great in most cases.
++	 */
++	switch (delay_on) {
++	case 0:
++		/* This is usually pretty useless and will make the LED look OFF */
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_NONE;
++		break;
++	case 21:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_21MS;
++		break;
++	case 42:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_42MS;
++		break;
++	case 84:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_84MS;
++		break;
++	case 168:
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_168MS;
++		break;
++	default:
++		/* Just use something non-zero */
++		reg |= MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_21MS;
++		break;
++	}
++
++	/* Set up blink rate */
++	reg |= MV88E6XXX_PORT_LED_CONTROL_POINTER_STRETCH_BLINK;
++
++	return mv88e6xxx_port_led_write(p->chip, p->port, reg);
++}
++
++static int mv88e6xxx_led_blink_set(struct mv88e6xxx_port *p, int led,
++				   unsigned long *delay_on, unsigned long *delay_off)
++{
++	u16 reg;
++	int err;
++
++	/* Choose a sensible default 336 ms (~3 Hz) */
++	if ((*delay_on == 0) && (*delay_off == 0)) {
++		*delay_on = 168;
++		*delay_off = 168;
++	}
++
++	/* No off delay is just on */
++	if (*delay_off == 0)
++		return mv88e6xxx_led_brightness_set(p, led, 1);
++
++	err = mv88e6xxx_led_set_blinking_period(p, led, *delay_on, *delay_off);
++	if (err)
++		return err;
++
++	err = mv88e6xxx_port_led_read(p->chip, p->port,
++				      MV88E6XXX_PORT_LED_CONTROL_POINTER_LED01_CTRL,
++				      &reg);
++	if (err)
++		return err;
++
++	if (led == 1)
++		reg &= ~MV88E6XXX_PORT_LED_CONTROL_LED1_SEL_MASK;
++	else
++		reg &= ~MV88E6XXX_PORT_LED_CONTROL_LED0_SEL_MASK;
++
++	/* This will select the forced blinking status */
++	if (led == 1)
++		reg |= MV88E6XXX_PORT_LED_CONTROL_LED1_SELD;
++	else
++		reg |= MV88E6XXX_PORT_LED_CONTROL_LED0_SELD;
++
++	reg |= MV88E6XXX_PORT_LED_CONTROL_POINTER_LED01_CTRL;
++
++	return mv88e6xxx_port_led_write(p->chip, p->port, reg);
++}
++
++static int mv88e6xxx_led0_blink_set(struct led_classdev *ldev,
++				    unsigned long *delay_on,
++				    unsigned long *delay_off)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led0);
++	int err;
++
++	mv88e6xxx_reg_lock(p->chip);
++	err = mv88e6xxx_led_blink_set(p, 0, delay_on, delay_off);
++	mv88e6xxx_reg_unlock(p->chip);
++
++	return err;
++}
++
++static int mv88e6xxx_led1_blink_set(struct led_classdev *ldev,
++				    unsigned long *delay_on,
++				    unsigned long *delay_off)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led1);
++	int err;
++
++	mv88e6xxx_reg_lock(p->chip);
++	err = mv88e6xxx_led_blink_set(p, 1, delay_on, delay_off);
++	mv88e6xxx_reg_unlock(p->chip);
++
++	return err;
++}
++
++static int
++mv88e6xxx_led0_hw_control_is_supported(struct led_classdev *ldev, unsigned long rules)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led0);
++	u16 selector = 0;
++
++	return mv88e6xxx_led_get_selector(p, 0, p->fiber, rules, &selector);
++}
++
++static int
++mv88e6xxx_led1_hw_control_is_supported(struct led_classdev *ldev, unsigned long rules)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led1);
++	u16 selector = 0;
++
++	return mv88e6xxx_led_get_selector(p, 1, p->fiber, rules, &selector);
++}
++
++static int mv88e6xxx_led_hw_control_set(struct mv88e6xxx_port *p,
++					int led, unsigned long rules)
++{
++	u16 reg;
++	int err;
++
++	err = mv88e6xxx_port_led_read(p->chip, p->port,
++				      MV88E6XXX_PORT_LED_CONTROL_POINTER_LED01_CTRL,
++				      &reg);
++	if (err)
++		return err;
++
++	if (led == 1)
++		reg &= ~MV88E6XXX_PORT_LED_CONTROL_LED1_SEL_MASK;
++	else
++		reg &= ~MV88E6XXX_PORT_LED_CONTROL_LED0_SEL_MASK;
++
++	err = mv88e6xxx_led_get_selector(p, led, p->fiber, rules, &reg);
++	if (err)
++		return err;
++
++	reg |= MV88E6XXX_PORT_LED_CONTROL_POINTER_LED01_CTRL;
++
++	if (led == 0)
++		dev_dbg(p->chip->dev, "LED 0 hw control on port %d trigger selector 0x%02x\n",
++			p->port,
++			(unsigned int)(reg & MV88E6XXX_PORT_LED_CONTROL_LED0_SEL_MASK));
++	else
++		dev_dbg(p->chip->dev, "LED 1 hw control on port %d trigger selector 0x%02x\n",
++			p->port,
++			(unsigned int)(reg & MV88E6XXX_PORT_LED_CONTROL_LED1_SEL_MASK) >> 4);
++
++	return mv88e6xxx_port_led_write(p->chip, p->port, reg);
++}
++
++static int
++mv88e6xxx_led_hw_control_get(struct mv88e6xxx_port *p, int led, unsigned long *rules)
++{
++	u16 val;
++	int err;
++
++	mv88e6xxx_reg_lock(p->chip);
++	err = mv88e6xxx_port_led_read(p->chip, p->port,
++				      MV88E6XXX_PORT_LED_CONTROL_POINTER_LED01_CTRL, &val);
++	mv88e6xxx_reg_unlock(p->chip);
++	if (err)
++		return err;
++
++	/* Mask out the selector bits for this port */
++	if (led == 1) {
++		val &= MV88E6XXX_PORT_LED_CONTROL_LED1_SEL_MASK;
++		/* It's forced blinking/OFF/ON */
++		if (val == MV88E6XXX_PORT_LED_CONTROL_LED1_SELD ||
++		    val == MV88E6XXX_PORT_LED_CONTROL_LED1_SELE ||
++		    val == MV88E6XXX_PORT_LED_CONTROL_LED1_SELF) {
++			*rules = 0;
++			return 0;
++		}
++	} else {
++		val &= MV88E6XXX_PORT_LED_CONTROL_LED0_SEL_MASK;
++		/* It's forced blinking/OFF/ON */
++		if (val == MV88E6XXX_PORT_LED_CONTROL_LED0_SELD ||
++		    val == MV88E6XXX_PORT_LED_CONTROL_LED0_SELE ||
++		    val == MV88E6XXX_PORT_LED_CONTROL_LED0_SELF) {
++			*rules = 0;
++			return 0;
++		}
++	}
++
++	err = mv88e6xxx_led_match_rule(p, val, led, rules);
++	if (!err)
++		return 0;
++
++	dev_dbg(p->chip->dev, "couldn't find matching selector for %04x\n", val);
++	*rules = 0;
++	return 0;
++}
++
++static int
++mv88e6xxx_led0_hw_control_set(struct led_classdev *ldev, unsigned long rules)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led0);
++	int err;
++
++	mv88e6xxx_reg_lock(p->chip);
++	err = mv88e6xxx_led_hw_control_set(p, 0, rules);
++	mv88e6xxx_reg_unlock(p->chip);
++
++	return err;
++}
++
++static int
++mv88e6xxx_led1_hw_control_set(struct led_classdev *ldev, unsigned long rules)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led1);
++	int err;
++
++	mv88e6xxx_reg_lock(p->chip);
++	err = mv88e6xxx_led_hw_control_set(p, 1, rules);
++	mv88e6xxx_reg_unlock(p->chip);
++
++	return err;
++}
++
++static int
++mv88e6xxx_led0_hw_control_get(struct led_classdev *ldev, unsigned long *rules)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led0);
++
++	return mv88e6xxx_led_hw_control_get(p, 0, rules);
++}
++
++static int
++mv88e6xxx_led1_hw_control_get(struct led_classdev *ldev, unsigned long *rules)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led1);
++
++	return mv88e6xxx_led_hw_control_get(p, 1, rules);
++}
++
++static struct device *mv88e6xxx_led_hw_control_get_device(struct mv88e6xxx_port *p)
++{
++	struct dsa_port *dp;
++
++	dp = dsa_to_port(p->chip->ds, p->port);
++	if (!dp)
++		return NULL;
++	if (dp->user)
++		return &dp->user->dev;
++	return NULL;
++}
++
++static struct device *
++mv88e6xxx_led0_hw_control_get_device(struct led_classdev *ldev)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led0);
++
++	return mv88e6xxx_led_hw_control_get_device(p);
++}
++
++static struct device *
++mv88e6xxx_led1_hw_control_get_device(struct led_classdev *ldev)
++{
++	struct mv88e6xxx_port *p = container_of(ldev, struct mv88e6xxx_port, led1);
++
++	return mv88e6xxx_led_hw_control_get_device(p);
++}
++
++int mv88e6xxx_port_setup_leds(struct mv88e6xxx_chip *chip, int port)
++{
++	struct fwnode_handle *led = NULL, *leds = NULL;
++	struct led_init_data init_data = { };
++	enum led_default_state state;
++	struct mv88e6xxx_port *p;
++	struct led_classdev *l;
++	struct device *dev;
++	u32 led_num;
++	int ret;
++
++	/* LEDs are on ports 1,2,3,4, 5 and 6 (index 0..5), no more */
++	if (port > 5)
++		return -EOPNOTSUPP;
++
++	p = &chip->ports[port];
++	if (!p->fwnode)
++		return 0;
++
++	dev = chip->dev;
++
++	leds = fwnode_get_named_child_node(p->fwnode, "leds");
++	if (!leds) {
++		dev_dbg(dev, "No Leds node specified in device tree for port %d!\n",
++			port);
++		return 0;
++	}
++
++	fwnode_for_each_child_node(leds, led) {
++		/* Reg represent the led number of the port, max 2
++		 * LEDs can be connected to each port, in some designs
++		 * only one LED is connected.
++		 */
++		if (fwnode_property_read_u32(led, "reg", &led_num))
++			continue;
++		if (led_num > 1) {
++			dev_err(dev, "invalid LED specified port %d\n", port);
++			return -EINVAL;
++		}
++
++		if (led_num == 0)
++			l = &p->led0;
++		else
++			l = &p->led1;
++
++		state = led_init_default_state_get(led);
++		switch (state) {
++		case LEDS_DEFSTATE_ON:
++			l->brightness = 1;
++			mv88e6xxx_led_brightness_set(p, led_num, 1);
++			break;
++		case LEDS_DEFSTATE_KEEP:
++			break;
++		default:
++			l->brightness = 0;
++			mv88e6xxx_led_brightness_set(p, led_num, 0);
++		}
++
++		l->max_brightness = 1;
++		if (led_num == 0) {
++			l->brightness_set_blocking = mv88e6xxx_led0_brightness_set_blocking;
++			l->blink_set = mv88e6xxx_led0_blink_set;
++			l->hw_control_is_supported = mv88e6xxx_led0_hw_control_is_supported;
++			l->hw_control_set = mv88e6xxx_led0_hw_control_set;
++			l->hw_control_get = mv88e6xxx_led0_hw_control_get;
++			l->hw_control_get_device = mv88e6xxx_led0_hw_control_get_device;
++		} else {
++			l->brightness_set_blocking = mv88e6xxx_led1_brightness_set_blocking;
++			l->blink_set = mv88e6xxx_led1_blink_set;
++			l->hw_control_is_supported = mv88e6xxx_led1_hw_control_is_supported;
++			l->hw_control_set = mv88e6xxx_led1_hw_control_set;
++			l->hw_control_get = mv88e6xxx_led1_hw_control_get;
++			l->hw_control_get_device = mv88e6xxx_led1_hw_control_get_device;
++		}
++		l->hw_control_trigger = "netdev";
++
++		init_data.default_label = ":port";
++		init_data.fwnode = led;
++		init_data.devname_mandatory = true;
++		init_data.devicename = kasprintf(GFP_KERNEL, "%s:0%d:0%d", chip->info->name,
++						 port, led_num);
++		if (!init_data.devicename)
++			return -ENOMEM;
++
++		ret = devm_led_classdev_register_ext(dev, l, &init_data);
++		kfree(init_data.devicename);
++
++		if (ret) {
++			dev_err(dev, "Failed to init LED %d for port %d", led_num, port);
++			return ret;
++		}
++	}
++
++	return 0;
++}
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -12,6 +12,7 @@
+ #include <linux/if_bridge.h>
+ #include <linux/phy.h>
+ #include <linux/phylink.h>
++#include <linux/property.h>
+ 
+ #include "chip.h"
+ #include "global2.h"
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -309,6 +309,130 @@
+ /* Offset 0x13: OutFiltered Counter */
+ #define MV88E6XXX_PORT_OUT_FILTERED	0x13
+ 
++/* Offset 0x16: LED Control */
++#define MV88E6XXX_PORT_LED_CONTROL				0x16
++#define MV88E6XXX_PORT_LED_CONTROL_UPDATE			BIT(15)
++#define MV88E6XXX_PORT_LED_CONTROL_POINTER_MASK			GENMASK(14, 12)
++#define MV88E6XXX_PORT_LED_CONTROL_POINTER_LED01_CTRL		(0x00 << 12) /* Control for LED 0 and 1 */
++#define MV88E6XXX_PORT_LED_CONTROL_POINTER_STRETCH_BLINK	(0x06 << 12) /* Stetch and Blink Rate */
++#define MV88E6XXX_PORT_LED_CONTROL_POINTER_CNTL_SPECIAL		(0x07 << 12) /* Control for the Port's Special LED */
++#define MV88E6XXX_PORT_LED_CONTROL_DATA_MASK			GENMASK(10, 0)
++/* Selection masks valid for either port 1,2,3,4 or 5 */
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL_MASK		GENMASK(3, 0)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL_MASK		GENMASK(7, 4)
++/* Selection control for LED 0 and 1, ports 5 and 6 only has LED 0
++ * Bits  Function
++ * 0..3  LED 0 control selector on ports 1-5
++ * 4..7  LED 1 control selector on ports 1-4 on port 5 this controls LED 0 of port 6
++ *
++ * Sel Port LED Function for the 6352 family:
++ * 0   1-4  0   Link/Act/Speed by Blink Rate (off=no link, on=link, blink=activity, blink speed=link speed)
++ *     1-4  1   Port 2's Special LED
++ *     5-6  0   Port 5 Link/Act (off=no link, on=link, blink=activity)
++ *     5-6  1   Port 6 Link/Act (off=no link, on=link 1000, blink=activity)
++ * 1   1-4  0   100/1000 Link/Act (off=no link, on=100 or 1000 link, blink=activity)
++ *     1-4  1   10/100 Link Act (off=no link, on=10 or 100 link, blink=activity)
++ *     5-6  0   Fiber 100 Link/Act (off=no link, on=link 100, blink=activity)
++ *     5-6  1   Fiber 1000 Link/Act (off=no link, on=link 1000, blink=activity)
++ * 2   1-4  0   1000 Link/Act (off=no link, on=link 1000, blink=activity)
++ *     1-4  1   10/100 Link/Act (off=no link, on=10 or 100 link, blink=activity)
++ *     5-6  0   Fiber 1000 Link/Act (off=no link, on=link 1000, blink=activity)
++ *     5-6  1   Fiber 100 Link/Act (off=no link, on=link 100, blink=activity)
++ * 3   1-4  0   Link/Act (off=no link, on=link, blink=activity)
++ *     1-4  1   1000 Link (off=no link, on=1000 link)
++ *     5-6  0   Port 0's Special LED
++ *     5-6  1   Fiber Link (off=no link, on=link)
++ * 4   1-4  0   Port 0's Special LED
++ *     1-4  1   Port 1's Special LED
++ *     5-6  0   Port 1's Special LED
++ *     5-6  1   Port 5 Link/Act (off=no link, on=link, blink=activity)
++ * 5   1-4  0   Reserved
++ *     1-4  1   Reserved
++ *     5-6  0   Port 2's Special LED
++ *     5-6  1   Port 6 Link (off=no link, on=link)
++ * 6   1-4  0   Duplex/Collision (off=half-duplex,on=full-duplex,blink=collision)
++ *     1-4  1   10/1000 Link/Act (off=no link, on=10 or 1000 link, blink=activity)
++ *     5-6  0   Port 5 Duplex/Collision (off=half-duplex, on=full-duplex, blink=col)
++ *     5-6  1   Port 6 Duplex/Collision (off=half-duplex, on=full-duplex, blink=col)
++ * 7   1-4  0   10/1000 Link/Act (off=no link, on=10 or 1000 link, blink=activity)
++ *     1-4  1   10/1000 Link (off=no link, on=10 or 1000 link)
++ *     5-6  0   Port 5 Link/Act/Speed by Blink rate (off=no link, on=link, blink=activity, blink speed=link speed)
++ *     5-6  1   Port 6 Link/Act/Speed by Blink rate (off=no link, on=link, blink=activity,  blink speed=link speed)
++ * 8   1-4  0   Link (off=no link, on=link)
++ *     1-4  1   Activity (off=no link, blink on=activity)
++ *     5-6  0   Port 6 Link/Act (off=no link, on=link, blink=activity)
++ *     5-6  1   Port 0's Special LED
++ * 9   1-4  0   10 Link (off=no link, on=10 link)
++ *     1-4  1   100 Link (off=no link, on=100 link)
++ *     5-6  0   Reserved
++ *     5-6  1   Port 1's Special LED
++ * a   1-4  0   10 Link/Act (off=no link, on=10 link, blink=activity)
++ *     1-4  1   100 Link/Act (off=no link, on=100 link, blink=activity)
++ *     5-6  0   Reserved
++ *     5-6  1   Port 2's Special LED
++ * b   1-4  0   100/1000 Link (off=no link, on=100 or 1000 link)
++ *     1-4  1   10/100 Link (off=no link, on=100 link, blink=activity)
++ *     5-6  0   Reserved
++ *     5-6  1   Reserved
++ * c     *  *   PTP Act (blink on=PTP activity)
++ * d     *  *   Force Blink
++ * e     *  *   Force Off
++ * f     *  *   Force On
++ */
++/* Select LED0 output */
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL0			0x0
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL1			0x1
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL2			0x2
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL3			0x3
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL4			0x4
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL5			0x5
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL6			0x6
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL7			0x7
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL8			0x8
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SEL9			0x9
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SELA			0xa
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SELB			0xb
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SELC			0xc
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SELD			0xd
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SELE			0xe
++#define MV88E6XXX_PORT_LED_CONTROL_LED0_SELF			0xf
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL0			(0x0 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL1			(0x1 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL2			(0x2 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL3			(0x3 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL4			(0x4 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL5			(0x5 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL6			(0x6 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL7			(0x7 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL8			(0x8 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SEL9			(0x9 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SELA			(0xa << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SELB			(0xb << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SELC			(0xc << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SELD			(0xd << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SELE			(0xe << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_LED1_SELF			(0xf << 4)
++/* Stretch and Blink Rate Control (Index 0x06 of LED Control) */
++/* Pulse Stretch Selection for all LED's on this port */
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_NONE	(0 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_21MS	(1 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_42MS	(2 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_84MS	(3 << 4)
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_PULSE_STRETCH_168MS	(4 << 4)
++/* Blink Rate Selection for all LEDs on this port */
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_21MS		0
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_42MS		1
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_84MS		2
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_168MS	3
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_336MS	4
++#define MV88E6XXX_PORT_LED_CONTROL_0x06_BLINK_RATE_672MS	5
++ /* Control for Special LED (Index 0x7 of LED Control on Port0) */
++#define MV88E6XXX_PORT_LED_CONTROL_0x07_P0_LAN_LINKACT_SHIFT	0 /* bits 6:0 LAN Link Activity LED */
++/* Control for Special LED (Index 0x7 of LED Control on Port 1) */
++#define MV88E6XXX_PORT_LED_CONTROL_0x07_P1_WAN_LINKACT_SHIFT	0 /* bits 6:0 WAN Link Activity LED */
++/* Control for Special LED (Index 0x7 of LED Control on Port 2) */
++#define MV88E6XXX_PORT_LED_CONTROL_0x07_P2_PTP_ACT		0 /* bits 6:0 PTP Activity */
++
+ /* Offset 0x18: IEEE Priority Mapping Table */
+ #define MV88E6390_PORT_IEEE_PRIO_MAP_TABLE			0x18
+ #define MV88E6390_PORT_IEEE_PRIO_MAP_TABLE_UPDATE		0x8000
+@@ -457,6 +581,15 @@ int mv88e6393x_port_set_cmode(struct mv8
+ 			      phy_interface_t mode);
+ int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
+ int mv88e6352_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
++#ifdef CONFIG_NET_DSA_MV88E6XXX_LEDS
++int mv88e6xxx_port_setup_leds(struct mv88e6xxx_chip *chip, int port);
++#else
++static inline int mv88e6xxx_port_setup_leds(struct mv88e6xxx_chip *chip,
++					    int port)
++{
++	return 0;
++}
++#endif
+ int mv88e6xxx_port_drop_untagged(struct mv88e6xxx_chip *chip, int port,
+ 				 bool drop_untagged);
+ int mv88e6xxx_port_set_map_da(struct mv88e6xxx_chip *chip, int port, bool map);
diff --git a/target/linux/generic/backport-6.12/902-v6.13-fortify-Hide-run-time-copy-size-from-value-range-tracking.patch b/target/linux/generic/backport-6.12/902-v6.13-fortify-Hide-run-time-copy-size-from-value-range-tracking.patch
new file mode 100644
index 0000000000..8dca649866
--- /dev/null
+++ b/target/linux/generic/backport-6.12/902-v6.13-fortify-Hide-run-time-copy-size-from-value-range-tracking.patch
@@ -0,0 +1,155 @@
+From 239d87327dcd361b0098038995f8908f3296864f Mon Sep 17 00:00:00 2001
+From: Kees Cook <kees@kernel.org>
+Date: Thu, 12 Dec 2024 17:28:06 -0800
+Subject: fortify: Hide run-time copy size from value range tracking
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+GCC performs value range tracking for variables as a way to provide better
+diagnostics. One place this is regularly seen is with warnings associated
+with bounds-checking, e.g. -Wstringop-overflow, -Wstringop-overread,
+-Warray-bounds, etc. In order to keep the signal-to-noise ratio high,
+warnings aren't emitted when a value range spans the entire value range
+representable by a given variable. For example:
+
+	unsigned int len;
+	char dst[8];
+	...
+	memcpy(dst, src, len);
+
+If len's value is unknown, it has the full "unsigned int" range of [0,
+UINT_MAX], and GCC's compile-time bounds checks against memcpy() will
+be ignored. However, when a code path has been able to narrow the range:
+
+	if (len > 16)
+		return;
+	memcpy(dst, src, len);
+
+Then the range will be updated for the execution path. Above, len is
+now [0, 16] when reading memcpy(), so depending on other optimizations,
+we might see a -Wstringop-overflow warning like:
+
+	error: '__builtin_memcpy' writing between 9 and 16 bytes into region of size 8 [-Werror=stringop-overflow]
+
+When building with CONFIG_FORTIFY_SOURCE, the fortified run-time bounds
+checking can appear to narrow value ranges of lengths for memcpy(),
+depending on how the compiler constructs the execution paths during
+optimization passes, due to the checks against the field sizes. For
+example:
+
+	if (p_size_field != SIZE_MAX &&
+	    p_size != p_size_field && p_size_field < size)
+
+As intentionally designed, these checks only affect the kernel warnings
+emitted at run-time and do not block the potentially overflowing memcpy(),
+so GCC thinks it needs to produce a warning about the resulting value
+range that might be reaching the memcpy().
+
+We have seen this manifest a few times now, with the most recent being
+with cpumasks:
+
+In function ‘bitmap_copy’,
+    inlined from ‘cpumask_copy’ at ./include/linux/cpumask.h:839:2,
+    inlined from ‘__padata_set_cpumasks’ at kernel/padata.c:730:2:
+./include/linux/fortify-string.h:114:33: error: ‘__builtin_memcpy’ reading between 257 and 536870904 bytes from a region of size 256 [-Werror=stringop-overread]
+  114 | #define __underlying_memcpy     __builtin_memcpy
+      |                                 ^
+./include/linux/fortify-string.h:633:9: note: in expansion of macro ‘__underlying_memcpy’
+  633 |         __underlying_##op(p, q, __fortify_size);                        \
+      |         ^~~~~~~~~~~~~
+./include/linux/fortify-string.h:678:26: note: in expansion of macro ‘__fortify_memcpy_chk’
+  678 | #define memcpy(p, q, s)  __fortify_memcpy_chk(p, q, s,                  \
+      |                          ^~~~~~~~~~~~~~~~~~~~
+./include/linux/bitmap.h:259:17: note: in expansion of macro ‘memcpy’
+  259 |                 memcpy(dst, src, len);
+      |                 ^~~~~~
+kernel/padata.c: In function ‘__padata_set_cpumasks’:
+kernel/padata.c:713:48: note: source object ‘pcpumask’ of size [0, 256]
+  713 |                                  cpumask_var_t pcpumask,
+      |                                  ~~~~~~~~~~~~~~^~~~~~~~
+
+This warning is _not_ emitted when CONFIG_FORTIFY_SOURCE is disabled,
+and with the recent -fdiagnostics-details we can confirm the origin of
+the warning is due to FORTIFY's bounds checking:
+
+../include/linux/bitmap.h:259:17: note: in expansion of macro 'memcpy'
+  259 |                 memcpy(dst, src, len);
+      |                 ^~~~~~
+  '__padata_set_cpumasks': events 1-2
+../include/linux/fortify-string.h:613:36:
+  612 |         if (p_size_field != SIZE_MAX &&
+      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  613 |             p_size != p_size_field && p_size_field < size)
+      |             ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
+      |                                    |
+      |                                    (1) when the condition is evaluated to false
+      |                                    (2) when the condition is evaluated to true
+  '__padata_set_cpumasks': event 3
+  114 | #define __underlying_memcpy     __builtin_memcpy
+      |                                 ^
+      |                                 |
+      |                                 (3) out of array bounds here
+
+Note that the cpumask warning started appearing since bitmap functions
+were recently marked __always_inline in commit ed8cd2b3bd9f ("bitmap:
+Switch from inline to __always_inline"), which allowed GCC to gain
+visibility into the variables as they passed through the FORTIFY
+implementation.
+
+In order to silence these false positives but keep otherwise deterministic
+compile-time warnings intact, hide the length variable from GCC with
+OPTIMIZE_HIDE_VAR() before calling the builtin memcpy.
+
+Additionally add a comment about why all the macro args have copies with
+const storage.
+
+Reported-by: "Thomas Weißschuh" <linux@weissschuh.net>
+Closes: https://lore.kernel.org/all/db7190c8-d17f-4a0d-bc2f-5903c79f36c2@t-8ch.de/
+Reported-by: Nilay Shroff <nilay@linux.ibm.com>
+Closes: https://lore.kernel.org/all/20241112124127.1666300-1-nilay@linux.ibm.com/
+Tested-by: Nilay Shroff <nilay@linux.ibm.com>
+Acked-by: Yury Norov <yury.norov@gmail.com>
+Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+Signed-off-by: Kees Cook <kees@kernel.org>
+---
+ include/linux/fortify-string.h | 14 +++++++++++++-
+ 1 file changed, 13 insertions(+), 1 deletion(-)
+
+--- a/include/linux/fortify-string.h
++++ b/include/linux/fortify-string.h
+@@ -616,6 +616,12 @@ __FORTIFY_INLINE bool fortify_memcpy_chk
+ 	return false;
+ }
+ 
++/*
++ * To work around what seems to be an optimizer bug, the macro arguments
++ * need to have const copies or the values end up changed by the time they
++ * reach fortify_warn_once(). See commit 6f7630b1b5bc ("fortify: Capture
++ * __bos() results in const temp vars") for more details.
++ */
+ #define __fortify_memcpy_chk(p, q, size, p_size, q_size,		\
+ 			     p_size_field, q_size_field, op) ({		\
+ 	const size_t __fortify_size = (size_t)(size);			\
+@@ -623,6 +629,8 @@ __FORTIFY_INLINE bool fortify_memcpy_chk
+ 	const size_t __q_size = (q_size);				\
+ 	const size_t __p_size_field = (p_size_field);			\
+ 	const size_t __q_size_field = (q_size_field);			\
++	/* Keep a mutable version of the size for the final copy. */	\
++	size_t __copy_size = __fortify_size;				\
+ 	fortify_warn_once(fortify_memcpy_chk(__fortify_size, __p_size,	\
+ 				     __q_size, __p_size_field,		\
+ 				     __q_size_field, FORTIFY_FUNC_ ##op), \
+@@ -630,7 +638,11 @@ __FORTIFY_INLINE bool fortify_memcpy_chk
+ 		  __fortify_size,					\
+ 		  "field \"" #p "\" at " FILE_LINE,			\
+ 		  __p_size_field);					\
+-	__underlying_##op(p, q, __fortify_size);			\
++	/* Hide only the run-time size from value range tracking to */	\
++	/* silence compile-time false positive bounds warnings. */	\
++	if (!__builtin_constant_p(__copy_size))				\
++		OPTIMIZER_HIDE_VAR(__copy_size);			\
++	__underlying_##op(p, q, __copy_size);				\
+ })
+ 
+ /*
diff --git a/target/linux/generic/config-6.12 b/target/linux/generic/config-6.12
new file mode 100644
index 0000000000..7a3b597e55
--- /dev/null
+++ b/target/linux/generic/config-6.12
@@ -0,0 +1,7680 @@
+# CONFIG_104_QUAD_8 is not set
+CONFIG_32BIT=y
+# CONFIG_6LOWPAN is not set
+# CONFIG_6LOWPAN_DEBUGFS is not set
+# CONFIG_6PACK is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_9P_FS is not set
+# CONFIG_AB8500_CORE is not set
+# CONFIG_ABP060MG is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_ACENIC is not set
+# CONFIG_ACERHDF is not set
+# CONFIG_ACER_WIRELESS is not set
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_ACPI_ALS is not set
+# CONFIG_ACPI_APEI is not set
+# CONFIG_ACPI_APEI_PCIEAER is not set
+# CONFIG_ACPI_BUTTON is not set
+# CONFIG_ACPI_CONFIGFS is not set
+# CONFIG_ACPI_EXTLOG is not set
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_NFIT is not set
+# CONFIG_ACPI_REDUCED_HARDWARE_ONLY is not set
+# CONFIG_ACPI_TABLE_UPGRADE is not set
+# CONFIG_ACPI_VIDEO is not set
+# CONFIG_AD2S1200 is not set
+# CONFIG_AD2S1210 is not set
+# CONFIG_AD2S90 is not set
+# CONFIG_AD3552R is not set
+# CONFIG_AD4000 is not set
+# CONFIG_AD4130 is not set
+# CONFIG_AD4695 is not set
+# CONFIG_AD5064 is not set
+# CONFIG_AD5110 is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_AD5272 is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5592R is not set
+# CONFIG_AD5593R is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_AD5686 is not set
+# CONFIG_AD5686_SPI is not set
+# CONFIG_AD5696_I2C is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5758 is not set
+# CONFIG_AD5761 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5766 is not set
+# CONFIG_AD5770R is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD5933 is not set
+# CONFIG_AD7091R5 is not set
+# CONFIG_AD7091R8 is not set
+# CONFIG_AD7124 is not set
+# CONFIG_AD7150 is not set
+# CONFIG_AD7173 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_AD7266 is not set
+# CONFIG_AD7280 is not set
+# CONFIG_AD7291 is not set
+# CONFIG_AD7292 is not set
+# CONFIG_AD7293 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7303 is not set
+# CONFIG_AD7380 is not set
+# CONFIG_AD74115 is not set
+# CONFIG_AD74413R is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7606 is not set
+# CONFIG_AD7606_IFACE_PARALLEL is not set
+# CONFIG_AD7606_IFACE_SPI is not set
+# CONFIG_AD7746 is not set
+# CONFIG_AD7766 is not set
+# CONFIG_AD7768_1 is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7816 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_AD7923 is not set
+# CONFIG_AD7944 is not set
+# CONFIG_AD7949 is not set
+# CONFIG_AD799X is not set
+# CONFIG_AD8366 is not set
+# CONFIG_AD8801 is not set
+# CONFIG_AD9467 is not set
+# CONFIG_AD9523 is not set
+# CONFIG_AD9739A is not set
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# CONFIG_ADA4250 is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_ADF4350 is not set
+# CONFIG_ADF4371 is not set
+# CONFIG_ADF4377 is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADIN1100_PHY is not set
+# CONFIG_ADIN1110 is not set
+# CONFIG_ADIN_PHY is not set
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16136 is not set
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADIS16240 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADIS16400 is not set
+# CONFIG_ADIS16460 is not set
+# CONFIG_ADIS16475 is not set
+# CONFIG_ADIS16480 is not set
+# CONFIG_ADI_AXI_ADC is not set
+# CONFIG_ADI_AXI_DAC is not set
+# CONFIG_ADJD_S311 is not set
+# CONFIG_ADM6996_PHY is not set
+# CONFIG_ADM8211 is not set
+# CONFIG_ADMFM2000 is not set
+# CONFIG_ADMV1013 is not set
+# CONFIG_ADMV1014 is not set
+# CONFIG_ADMV4420 is not set
+# CONFIG_ADMV8818 is not set
+# CONFIG_ADRF6780 is not set
+# CONFIG_ADT7316 is not set
+# CONFIG_ADUX1020 is not set
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_ADXL313_I2C is not set
+# CONFIG_ADXL313_SPI is not set
+# CONFIG_ADXL345_I2C is not set
+# CONFIG_ADXL345_SPI is not set
+# CONFIG_ADXL355_I2C is not set
+# CONFIG_ADXL355_SPI is not set
+# CONFIG_ADXL367_I2C is not set
+# CONFIG_ADXL367_SPI is not set
+# CONFIG_ADXL372_I2C is not set
+# CONFIG_ADXL372_SPI is not set
+# CONFIG_ADXL380_I2C is not set
+# CONFIG_ADXL380_SPI is not set
+# CONFIG_ADXRS290 is not set
+# CONFIG_ADXRS450 is not set
+CONFIG_AEABI=y
+# CONFIG_AF8133J is not set
+# CONFIG_AFE4403 is not set
+# CONFIG_AFE4404 is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_AFS_DEBUG_CURSOR is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_AF_KCM is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_RXRPC_INJECT_LOSS is not set
+# CONFIG_AF_RXRPC_INJECT_RX_DELAY is not set
+# CONFIG_AF_RXRPC_IPV6 is not set
+CONFIG_AF_UNIX_OOB=y
+# CONFIG_AGP is not set
+# CONFIG_AHCI_BRCM is not set
+# CONFIG_AHCI_CEVA is not set
+# CONFIG_AHCI_DWC is not set
+# CONFIG_AHCI_IMX is not set
+# CONFIG_AHCI_MVEBU is not set
+# CONFIG_AHCI_QORIQ is not set
+# CONFIG_AHCI_XGENE is not set
+CONFIG_AIO=y
+# CONFIG_AIR_EN8811H_PHY is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_AK09911 is not set
+# CONFIG_AK8974 is not set
+# CONFIG_AK8975 is not set
+# CONFIG_AL3010 is not set
+# CONFIG_AL3320A is not set
+# CONFIG_ALIM7101_WDT is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_ALTERA_MBOX is not set
+# CONFIG_ALTERA_MSGDMA is not set
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_ALX is not set
+# CONFIG_AL_FIC is not set
+# CONFIG_AM2315 is not set
+# CONFIG_AM335X_PHY_USB is not set
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_AMD_MEM_ENCRYPT is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_AMD_QDMA is not set
+# CONFIG_AMD_XGBE is not set
+# CONFIG_AMD_XGBE_HAVE_ECC is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_AMILO_RFKILL is not set
+# CONFIG_AMPERE_ERRATUM_AC03_CPU_38 is not set
+# CONFIG_AMT is not set
+# CONFIG_ANDROID_BINDER_IPC is not set
+# CONFIG_ANON_VMA_NAME is not set
+# CONFIG_AOSONG_AGS02MA is not set
+# CONFIG_APDS9300 is not set
+# CONFIG_APDS9306 is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_APDS9960 is not set
+# CONFIG_APM_EMULATION is not set
+# CONFIG_APPLE_GMUX is not set
+# CONFIG_APPLE_MFI_FASTCHARGE is not set
+# CONFIG_APPLE_PROPERTIES is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_AQTION is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AR5523 is not set
+# CONFIG_AR8216_PHY is not set
+# CONFIG_AR8216_PHY_LEDS is not set
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_AIROHA is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_APPLE is not set
+# CONFIG_ARCH_ARTPEC is not set
+# CONFIG_ARCH_ASPEED is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_AXXIA is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_BCMBCA is not set
+# CONFIG_ARCH_BCM_21664 is not set
+# CONFIG_ARCH_BCM_23550 is not set
+# CONFIG_ARCH_BCM_281XX is not set
+# CONFIG_ARCH_BCM_5301X is not set
+# CONFIG_ARCH_BCM_53573 is not set
+# CONFIG_ARCH_BCM_CYGNUS is not set
+# CONFIG_ARCH_BCM_HR2 is not set
+# CONFIG_ARCH_BCM_IPROC is not set
+# CONFIG_ARCH_BCM_NSP is not set
+# CONFIG_ARCH_BERLIN is not set
+CONFIG_ARCH_BINFMT_ELF_STATE=y
+# CONFIG_ARCH_BITMAIN is not set
+# CONFIG_ARCH_BRCMSTB is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_DAVINCI is not set
+CONFIG_ARCH_DEFAULT_CRASH_DUMP=y
+# CONFIG_ARCH_DIGICOLOR is not set
+# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_EXYNOS is not set
+CONFIG_ARCH_FLATMEM_ENABLE=y
+# CONFIG_ARCH_FOOTBRIDGE is not set
+CONFIG_ARCH_FORCE_MAX_ORDER=11
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_HI3xxx is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_HPE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_INTEL_SOCFPGA is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_K3 is not set
+# CONFIG_ARCH_KEEMBAY is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_LAYERSCAPE is not set
+# CONFIG_ARCH_LG1K is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MA35 is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MILBEAUT is not set
+CONFIG_ARCH_MMAP_RND_BITS=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=8
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MSTARV7 is not set
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_MULTI_V6 is not set
+# CONFIG_ARCH_MULTI_V7 is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_NPCM is not set
+# CONFIG_ARCH_NSPIRE is not set
+# CONFIG_ARCH_NXP is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_ARCH_OMAP2 is not set
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PENSANDO is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_RDA is not set
+# CONFIG_ARCH_REALTEK is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_S32 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_SEATTLE is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_SPARX5 is not set
+# CONFIG_ARCH_SPRD is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_STM32 is not set
+# CONFIG_ARCH_SUNPLUS is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_SYNQUACER is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_THUNDER is not set
+# CONFIG_ARCH_THUNDER2 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_VISCONTI is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_WANTS_THP_SWAP is not set
+# CONFIG_ARCH_WM8505 is not set
+# CONFIG_ARCH_WM8750 is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_XGENE is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_ARCNET is not set
+# CONFIG_ARC_IRQ_NO_AUTOSAVE is not set
+# CONFIG_ARM64_16K_PAGES is not set
+# CONFIG_ARM64_64K_PAGES is not set
+# CONFIG_ARM64_AMU_EXTN is not set
+# CONFIG_ARM64_BTI is not set
+CONFIG_ARM64_CNP=y
+# CONFIG_ARM64_E0PD is not set
+# CONFIG_ARM64_EPAN is not set
+# CONFIG_ARM64_ERRATUM_1024718 is not set
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1286807 is not set
+# CONFIG_ARM64_ERRATUM_1319367 is not set
+# CONFIG_ARM64_ERRATUM_1418040 is not set
+# CONFIG_ARM64_ERRATUM_1463225 is not set
+# CONFIG_ARM64_ERRATUM_1508412 is not set
+# CONFIG_ARM64_ERRATUM_1530923 is not set
+# CONFIG_ARM64_ERRATUM_1542419 is not set
+# CONFIG_ARM64_ERRATUM_1742098 is not set
+# CONFIG_ARM64_ERRATUM_2051678 is not set
+# CONFIG_ARM64_ERRATUM_2054223 is not set
+# CONFIG_ARM64_ERRATUM_2067961 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_2441007 is not set
+# CONFIG_ARM64_ERRATUM_2441009 is not set
+# CONFIG_ARM64_ERRATUM_2645198 is not set
+# CONFIG_ARM64_ERRATUM_2658417 is not set
+# CONFIG_ARM64_ERRATUM_2966298 is not set
+# CONFIG_ARM64_ERRATUM_3117295 is not set
+# CONFIG_ARM64_ERRATUM_3194386 is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_834220 is not set
+# CONFIG_ARM64_ERRATUM_843419 is not set
+# CONFIG_ARM64_ERRATUM_845719 is not set
+# CONFIG_ARM64_ERRATUM_858921 is not set
+# CONFIG_ARM64_HW_AFDBM is not set
+# CONFIG_ARM64_LSE_ATOMICS is not set
+# CONFIG_ARM64_MTE is not set
+CONFIG_ARM64_PAN=y
+# CONFIG_ARM64_PMEM is not set
+# CONFIG_ARM64_POE is not set
+# CONFIG_ARM64_PSEUDO_NMI is not set
+# CONFIG_ARM64_PTR_AUTH is not set
+# CONFIG_ARM64_RAS_EXTN is not set
+# CONFIG_ARM64_RELOC_TEST is not set
+# CONFIG_ARM64_SME is not set
+# CONFIG_ARM64_SVE is not set
+CONFIG_ARM64_SW_TTBR0_PAN=y
+# CONFIG_ARM64_TLB_RANGE is not set
+# CONFIG_ARM64_USE_LSE_ATOMICS is not set
+# CONFIG_ARM64_VA_BITS_48 is not set
+# CONFIG_ARM_APPENDED_DTB is not set
+# CONFIG_ARM_ARCH_TIMER is not set
+# CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND is not set
+# CONFIG_ARM_CCI is not set
+# CONFIG_ARM_CCI400_PMU is not set
+# CONFIG_ARM_CCI5xx_PMU is not set
+# CONFIG_ARM_CCI_PMU is not set
+# CONFIG_ARM_CCN is not set
+# CONFIG_ARM_CMN is not set
+# CONFIG_ARM_CORESIGHT_PMU_ARCH_SYSTEM_PMU is not set
+# CONFIG_ARM_CPUIDLE is not set
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+# CONFIG_ARM_DSU_PMU is not set
+# CONFIG_ARM_ERRATA_326103 is not set
+# CONFIG_ARM_ERRATA_364296 is not set
+# CONFIG_ARM_ERRATA_411920 is not set
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764319 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_ERRATA_814220 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+# CONFIG_ARM_ERRATA_857271 is not set
+# CONFIG_ARM_ERRATA_857272 is not set
+# CONFIG_ARM_FFA_TRANSPORT is not set
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
+# CONFIG_ARM_KPROBES_TEST is not set
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARM_MEDIATEK_CPUFREQ_HW is not set
+# CONFIG_ARM_MHU is not set
+CONFIG_ARM_MODULE_PLTS=y
+# CONFIG_ARM_NI is not set
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+# CONFIG_ARM_PSCI is not set
+# CONFIG_ARM_PSCI_CHECKER is not set
+# CONFIG_ARM_PSCI_CPUIDLE is not set
+# CONFIG_ARM_PTDUMP_DEBUGFS is not set
+# CONFIG_ARM_SBSA_WATCHDOG is not set
+# CONFIG_ARM_SCMI_PROTOCOL is not set
+# CONFIG_ARM_SCPI_PROTOCOL is not set
+# CONFIG_ARM_SDE_INTERFACE is not set
+# CONFIG_ARM_SMCCC_SOC_ID is not set
+# CONFIG_ARM_SMC_WATCHDOG is not set
+# CONFIG_ARM_SMMU_V3_PMU is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
+# CONFIG_ARM_SPE_PMU is not set
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_ARM_VIRT_EXT is not set
+# CONFIG_AS3935 is not set
+# CONFIG_AS73211 is not set
+# CONFIG_ASM9260_TIMER is not set
+# CONFIG_ASN1 is not set
+# CONFIG_ASUS_LAPTOP is not set
+# CONFIG_ASUS_WIRELESS is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+# CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AT91_SAMA5D2_ADC is not set
+# CONFIG_ATA is not set
+# CONFIG_ATAGS is not set
+CONFIG_ATAGS_PROC=y
+# CONFIG_ATALK is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_ATA_ACPI is not set
+CONFIG_ATA_BMDMA=y
+# CONFIG_ATA_FORCE is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_ATA_LEDS is not set
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_ATA_PIIX is not set
+CONFIG_ATA_SFF=y
+# CONFIG_ATA_VERBOSE_ERROR is not set
+# CONFIG_ATH10K is not set
+# CONFIG_ATH25 is not set
+# CONFIG_ATH5K is not set
+# CONFIG_ATH6KL is not set
+# CONFIG_ATH79 is not set
+# CONFIG_ATH9K is not set
+# CONFIG_ATH9K_HTC is not set
+# CONFIG_ATH_DEBUG is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL2 is not set
+# CONFIG_ATLAS_EZO_SENSOR is not set
+# CONFIG_ATLAS_PH_SENSOR is not set
+# CONFIG_ATM is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ATM_BR2684 is not set
+CONFIG_ATM_BR2684_IPFILTER=y
+# CONFIG_ATM_CLIP is not set
+CONFIG_ATM_CLIP_NO_ICMP=y
+# CONFIG_ATM_DRIVERS is not set
+# CONFIG_ATM_DUMMY is not set
+# CONFIG_ATM_ENI is not set
+# CONFIG_ATM_FORE200E is not set
+# CONFIG_ATM_HE is not set
+# CONFIG_ATM_IA is not set
+# CONFIG_ATM_IDT77252 is not set
+# CONFIG_ATM_LANAI is not set
+# CONFIG_ATM_LANE is not set
+# CONFIG_ATM_MPOA is not set
+# CONFIG_ATM_NICSTAR is not set
+# CONFIG_ATM_SOLOS is not set
+# CONFIG_ATM_TCP is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ATP is not set
+# CONFIG_AUDIT is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTO_ZRELADDR is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_AW96103 is not set
+# CONFIG_AX25 is not set
+# CONFIG_AX25_DAMA_SLAVE is not set
+# CONFIG_AX88796 is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_AXP20X_ADC is not set
+# CONFIG_AXP20X_POWER is not set
+# CONFIG_AXP288_ADC is not set
+# CONFIG_AXP288_FUEL_GAUGE is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_B44 is not set
+# CONFIG_B53 is not set
+# CONFIG_B53_MDIO_DRIVER is not set
+# CONFIG_B53_MMAP_DRIVER is not set
+# CONFIG_B53_SERDES is not set
+# CONFIG_B53_SPI_DRIVER is not set
+# CONFIG_B53_SRAB_DRIVER is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_APPLE is not set
+# CONFIG_BACKLIGHT_ARCXCNN is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_CLASS_DEVICE is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_KTD253 is not set
+# CONFIG_BACKLIGHT_KTD2801 is not set
+# CONFIG_BACKLIGHT_KTZ8866 is not set
+# CONFIG_BACKLIGHT_LED is not set
+# CONFIG_BACKLIGHT_LM3509 is not set
+# CONFIG_BACKLIGHT_LM3630A is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_MP3309C is not set
+# CONFIG_BACKLIGHT_PANDORA is not set
+# CONFIG_BACKLIGHT_PWM is not set
+# CONFIG_BACKLIGHT_QCOM_WLED is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_BACKTRACE_VERBOSE is not set
+# CONFIG_BAREUDP is not set
+# CONFIG_BASE_SMALL is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_BQ27XXX_HDQ is not set
+# CONFIG_BATTERY_CW2015 is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_BATTERY_LEGO_EV3 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_BATTERY_MAX1720X is not set
+# CONFIG_BATTERY_MAX1721X is not set
+# CONFIG_BATTERY_PM8916_BMS_VM is not set
+# CONFIG_BATTERY_RT5033 is not set
+# CONFIG_BATTERY_SAMSUNG_SDI is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_UG3105 is not set
+# CONFIG_BAYCOM_EPP is not set
+# CONFIG_BAYCOM_PAR is not set
+# CONFIG_BAYCOM_SER_FDX is not set
+# CONFIG_BAYCOM_SER_HDX is not set
+# CONFIG_BCACHE is not set
+# CONFIG_BCACHEFS_FS is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_BCM54140_PHY is not set
+# CONFIG_BCM63XX is not set
+# CONFIG_BCM63XX_PHY is not set
+# CONFIG_BCM7038_L1_IRQ is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_BCM7120_L2_IRQ is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM84881_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BCMA is not set
+# CONFIG_BCMA_DRIVER_GPIO is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMGENET is not set
+# CONFIG_BCM_IPROC_ADC is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_BCM_SBA_RAID is not set
+# CONFIG_BCM_VK is not set
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BE2NET is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_BGMAC is not set
+# CONFIG_BH1745 is not set
+# CONFIG_BH1750 is not set
+# CONFIG_BH1780 is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_BIG_LITTLE is not set
+CONFIG_BINARY_PRINTF=y
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_FDPIC is not set
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_BITREVERSE=y
+# CONFIG_BLK_CGROUP_IOCOST is not set
+# CONFIG_BLK_CGROUP_IOLATENCY is not set
+# CONFIG_BLK_CGROUP_IOPRIO is not set
+# CONFIG_BLK_DEBUG_FS is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_DM is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_DEV_PMEM is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_SD is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_BLK_DEV_THROTTLING is not set
+# CONFIG_BLK_DEV_UBLK is not set
+CONFIG_BLK_DEV_WRITE_MOUNTED=y
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_INLINE_ENCRYPTION is not set
+# CONFIG_BLK_SED_OPAL is not set
+# CONFIG_BLK_WBT is not set
+CONFIG_BLOCK=y
+# CONFIG_BLOCK_LEGACY_AUTOLOAD is not set
+# CONFIG_BLOCK_NOTIFIERS is not set
+# CONFIG_BMA180 is not set
+# CONFIG_BMA220 is not set
+# CONFIG_BMA400 is not set
+# CONFIG_BMC150_ACCEL is not set
+# CONFIG_BMC150_MAGN is not set
+# CONFIG_BMC150_MAGN_I2C is not set
+# CONFIG_BMC150_MAGN_SPI is not set
+# CONFIG_BME680 is not set
+# CONFIG_BMG160 is not set
+# CONFIG_BMI088_ACCEL is not set
+# CONFIG_BMI160_I2C is not set
+# CONFIG_BMI160_SPI is not set
+# CONFIG_BMI323_I2C is not set
+# CONFIG_BMI323_SPI is not set
+# CONFIG_BMIPS_GENERIC is not set
+# CONFIG_BMP280 is not set
+# CONFIG_BNA is not set
+# CONFIG_BNX2 is not set
+# CONFIG_BNX2X is not set
+# CONFIG_BNX2X_SRIOV is not set
+# CONFIG_BNXT is not set
+# CONFIG_BONDING is not set
+# CONFIG_BOOKE_WDT is not set
+CONFIG_BOOKE_WDT_DEFAULT_TIMEOUT=3
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+# CONFIG_BOOTTIME_TRACING is not set
+# CONFIG_BOOT_CONFIG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_BOOT_RAW=y
+# CONFIG_BOSCH_BNO055_I2C is not set
+# CONFIG_BOSCH_BNO055_SERIAL is not set
+# CONFIG_BOUNCE is not set
+CONFIG_BPF=y
+CONFIG_BPF_JIT=y
+# CONFIG_BPF_JIT_ALWAYS_ON is not set
+CONFIG_BPF_JIT_DEFAULT_ON=y
+# CONFIG_BPF_LSM is not set
+# CONFIG_BPF_PRELOAD is not set
+# CONFIG_BPF_STREAM_PARSER is not set
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_UNPRIV_DEFAULT_OFF=y
+# CONFIG_BPQETHER is not set
+CONFIG_BQL=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_BRCMFMAC is not set
+# CONFIG_BRCMSMAC is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_BRCMSTB_L2_IRQ is not set
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_CFM is not set
+# CONFIG_BRIDGE_EBT_802_3 is not set
+# CONFIG_BRIDGE_EBT_AMONG is not set
+# CONFIG_BRIDGE_EBT_ARP is not set
+# CONFIG_BRIDGE_EBT_ARPREPLY is not set
+# CONFIG_BRIDGE_EBT_BROUTE is not set
+# CONFIG_BRIDGE_EBT_DNAT is not set
+# CONFIG_BRIDGE_EBT_IP is not set
+# CONFIG_BRIDGE_EBT_IP6 is not set
+# CONFIG_BRIDGE_EBT_LIMIT is not set
+# CONFIG_BRIDGE_EBT_LOG is not set
+# CONFIG_BRIDGE_EBT_MARK is not set
+# CONFIG_BRIDGE_EBT_MARK_T is not set
+# CONFIG_BRIDGE_EBT_NFLOG is not set
+# CONFIG_BRIDGE_EBT_PKTTYPE is not set
+# CONFIG_BRIDGE_EBT_REDIRECT is not set
+# CONFIG_BRIDGE_EBT_SNAT is not set
+# CONFIG_BRIDGE_EBT_STP is not set
+# CONFIG_BRIDGE_EBT_T_FILTER is not set
+# CONFIG_BRIDGE_EBT_T_NAT is not set
+# CONFIG_BRIDGE_EBT_VLAN is not set
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_BRIDGE_MRP is not set
+# CONFIG_BRIDGE_NETFILTER is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+CONFIG_BRIDGE_VLAN_FILTERING=y
+# CONFIG_BROADCOM_PHY is not set
+CONFIG_BROKEN_ON_SMP=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_BT is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_REF_VERIFY is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BT_AOSPEXT is not set
+# CONFIG_BT_ATH3K is not set
+# CONFIG_BT_BNEP is not set
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+# CONFIG_BT_BREDR is not set
+# CONFIG_BT_CMTP is not set
+# CONFIG_BT_FEATURE_DEBUG is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBCM4377 is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIBLUECARD is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBT3C is not set
+# CONFIG_BT_HCIBTSDIO is not set
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTUSB_AUTOSUSPEND is not set
+# CONFIG_BT_HCIBTUSB_MTK is not set
+CONFIG_BT_HCIBTUSB_POLL_SYNC=y
+# CONFIG_BT_HCIBTUSB_RTL is not set
+# CONFIG_BT_HCIDTL1 is not set
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIUART_3WIRE is not set
+# CONFIG_BT_HCIUART_AG6XX is not set
+# CONFIG_BT_HCIUART_AML is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIUART_MRVL is not set
+# CONFIG_BT_HCIUART_QCA is not set
+# CONFIG_BT_HCIUART_RTL is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_HIDP is not set
+# CONFIG_BT_INTEL_PCIE is not set
+# CONFIG_BT_LE is not set
+# CONFIG_BT_LEDS is not set
+CONFIG_BT_LE_L2CAP_ECRED=y
+# CONFIG_BT_MRVL is not set
+# CONFIG_BT_MSFTEXT is not set
+# CONFIG_BT_MTKSDIO is not set
+# CONFIG_BT_MTKUART is not set
+# CONFIG_BT_NXPUART is not set
+# CONFIG_BT_RFCOMM is not set
+CONFIG_BT_RFCOMM_TTY=y
+# CONFIG_BT_SELFTEST is not set
+# CONFIG_BT_VIRTIO is not set
+CONFIG_BUG=y
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+CONFIG_BUILDTIME_TABLE_SORT=y
+CONFIG_BUILD_SALT=""
+# CONFIG_C2PORT is not set
+# CONFIG_CACHESTAT_SYSCALL is not set
+CONFIG_CACHE_L2X0_PMU=y
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CAN is not set
+# CONFIG_CAN_BCM is not set
+# CONFIG_CAN_CAN327 is not set
+# CONFIG_CAN_CTUCANFD_PCI is not set
+# CONFIG_CAN_CTUCANFD_PLATFORM is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# CONFIG_CAN_DEV is not set
+# CONFIG_CAN_ESD_402_PCI is not set
+# CONFIG_CAN_ESD_USB is not set
+# CONFIG_CAN_ETAS_ES58X is not set
+# CONFIG_CAN_F81604 is not set
+# CONFIG_CAN_GS_USB is not set
+# CONFIG_CAN_GW is not set
+# CONFIG_CAN_HI311X is not set
+# CONFIG_CAN_IFI_CANFD is not set
+# CONFIG_CAN_ISOTP is not set
+# CONFIG_CAN_J1939 is not set
+# CONFIG_CAN_KVASER_PCIEFD is not set
+# CONFIG_CAN_MCBA_USB is not set
+# CONFIG_CAN_MCP251XFD is not set
+# CONFIG_CAN_M_CAN is not set
+# CONFIG_CAN_NETLINK is not set
+# CONFIG_CAN_PEAK_PCIEFD is not set
+# CONFIG_CAN_RAW is not set
+# CONFIG_CAN_RCAR is not set
+# CONFIG_CAN_RCAR_CANFD is not set
+# CONFIG_CAN_ROCKCHIP_CANFD is not set
+# CONFIG_CAN_SLCAN is not set
+# CONFIG_CAN_SUN4I is not set
+# CONFIG_CAN_UCAN is not set
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_VXCAN is not set
+# CONFIG_CAPI_TRACE is not set
+CONFIG_CARDBUS=y
+# CONFIG_CARL9170 is not set
+# CONFIG_CASSINI is not set
+# CONFIG_CAVIUM_CPT is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23144 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_ERRATUM_30115 is not set
+# CONFIG_CAVIUM_OCTEON_SOC is not set
+# CONFIG_CAVIUM_PTP is not set
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+# CONFIG_CB710_CORE is not set
+# CONFIG_CC10001_ADC is not set
+# CONFIG_CCS811 is not set
+CONFIG_CC_CAN_LINK=y
+CONFIG_CC_NO_STRINGOP_OVERFLOW=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_CDX_BUS is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_CFG80211 is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_HEADERS=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CGROUP_FAVOR_DYNMODS is not set
+# CONFIG_CGROUP_MISC is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_CHARGER_BD99954 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ2515X is not set
+# CONFIG_CHARGER_BQ256XX is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_BQ25980 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_CHARGER_LTC4162L is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_MAX77976 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_PM8916_LBC is not set
+# CONFIG_CHARGER_QCOM_SMB2 is not set
+# CONFIG_CHARGER_QCOM_SMBB is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_CHARGER_RT9467 is not set
+# CONFIG_CHARGER_RT9471 is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_CHARGER_TWL4030 is not set
+# CONFIG_CHARGER_UCS1002 is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CIFS is not set
+CONFIG_CIFS_ALLOW_INSECURE_LEGACY=y
+# CONFIG_CIFS_COMPRESSION is not set
+# CONFIG_CIFS_DEBUG is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_FSCACHE is not set
+# CONFIG_CIFS_NFSD_EXPORT is not set
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_STATS2 is not set
+# CONFIG_CIFS_SWN_UPCALL is not set
+CONFIG_CIFS_XATTR=y
+# CONFIG_CIO_DAC is not set
+# CONFIG_CLKSRC_PISTACHIO is not set
+# CONFIG_CLKSRC_VERSATILE is not set
+# CONFIG_CLK_GFM_LPASS_SM8250 is not set
+# CONFIG_CLK_HSDK is not set
+# CONFIG_CLK_ICST is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_CLK_SP810 is not set
+CONFIG_CLS_U32_MARK=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CM32181 is not set
+# CONFIG_CM3232 is not set
+# CONFIG_CM3323 is not set
+# CONFIG_CM3605 is not set
+# CONFIG_CM36651 is not set
+# CONFIG_CMA is not set
+CONFIG_CMDLINE=""
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
+# CONFIG_CMDLINE_PARTITION is not set
+# CONFIG_CNIC is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_CODE_PATCHING_SELFTEST is not set
+# CONFIG_COMEDI is not set
+# CONFIG_COMMON_CLK_AXI_CLKGEN is not set
+# CONFIG_COMMON_CLK_BOSTON is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+# CONFIG_COMMON_CLK_IPROC is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_MEDIATEK_FHCTL is not set
+# CONFIG_COMMON_CLK_MT6765 is not set
+# CONFIG_COMMON_CLK_MT8167 is not set
+# CONFIG_COMMON_CLK_MT8167_AUDSYS is not set
+# CONFIG_COMMON_CLK_MT8167_IMGSYS is not set
+# CONFIG_COMMON_CLK_MT8167_MFGCFG is not set
+# CONFIG_COMMON_CLK_MT8167_MMSYS is not set
+# CONFIG_COMMON_CLK_MT8167_VDECSYS is not set
+# CONFIG_COMMON_CLK_MT8188 is not set
+# CONFIG_COMMON_CLK_MT8192 is not set
+# CONFIG_COMMON_CLK_NXP is not set
+# CONFIG_COMMON_CLK_PIC32 is not set
+# CONFIG_COMMON_CLK_PISTACHIO is not set
+# CONFIG_COMMON_CLK_PWM is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_QCOM is not set
+# CONFIG_COMMON_CLK_RS9_PCIE is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI521XX is not set
+# CONFIG_COMMON_CLK_SI5341 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_VC3 is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+# CONFIG_COMMON_CLK_VC7 is not set
+# CONFIG_COMMON_CLK_XGENE is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+CONFIG_COMPACTION=y
+# CONFIG_COMPAL_LAPTOP is not set
+# CONFIG_COMPAT is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_COMPILE_TEST is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_CONSTRUCTORS=y
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_CORDIC is not set
+# CONFIG_COREDUMP is not set
+# CONFIG_CORESIGHT is not set
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_COUNTER is not set
+# CONFIG_CPA_DEBUG is not set
+# CONFIG_CPUFREQ_DT is not set
+# CONFIG_CPUFREQ_DT_PLATDEV is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_SCHEDUTIL is not set
+# CONFIG_CPU_FREQ_THERMAL is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_ICACHE_MISMATCH_WORKAROUND is not set
+# CONFIG_CPU_IDLE is not set
+# CONFIG_CPU_IDLE_GOV_LADDER is not set
+# CONFIG_CPU_IDLE_GOV_MENU is not set
+# CONFIG_CPU_IDLE_GOV_TEO is not set
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+# CONFIG_CPU_ISOLATION is not set
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+# CONFIG_CPU_NO_EFFICIENT_FFS is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+# CONFIG_CPU_THERMAL is not set
+# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS_BLOCKDEV=y
+# CONFIG_CRAMFS_MTD is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_SELFTEST is not set
+# CONFIG_CRC32_SLICEBY4 is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC4 is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC64_ROCKSOFT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_CRC8 is not set
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC_ITU_T is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+# CONFIG_CROS_HPS_I2C is not set
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_842 is not set
+CONFIG_CRYPTO_ACOMP2=y
+# CONFIG_CRYPTO_ADIANTUM is not set
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_AEGIS128_AESNI_SSE2 is not set
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_ARM is not set
+# CONFIG_CRYPTO_AES_ARM64 is not set
+# CONFIG_CRYPTO_AES_ARM64_BS is not set
+# CONFIG_CRYPTO_AES_ARM64_CE is not set
+# CONFIG_CRYPTO_AES_ARM64_CE_BLK is not set
+# CONFIG_CRYPTO_AES_ARM64_CE_CCM is not set
+# CONFIG_CRYPTO_AES_ARM64_NEON_BLK is not set
+# CONFIG_CRYPTO_AES_ARM_BS is not set
+# CONFIG_CRYPTO_AES_ARM_CE is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_AES_RISCV64 is not set
+# CONFIG_CRYPTO_AES_TI is not set
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_ARIA is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_BLAKE2B is not set
+# CONFIG_CRYPTO_BLAKE2B_NEON is not set
+# CONFIG_CRYPTO_BLAKE2S_ARM is not set
+# CONFIG_CRYPTO_BLAKE2S_X86 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CBC is not set
+CONFIG_CRYPTO_CCM=y
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_CHACHA20_NEON is not set
+# CONFIG_CRYPTO_CHACHA20_X86_64 is not set
+# CONFIG_CRYPTO_CHACHA_MIPS is not set
+# CONFIG_CRYPTO_CHACHA_RISCV64 is not set
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32_ARM_CE is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_CRCT10DIF_ARM64_CE is not set
+# CONFIG_CRYPTO_CRCT10DIF_ARM_CE is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_CURVE25519 is not set
+# CONFIG_CRYPTO_CURVE25519_NEON is not set
+# CONFIG_CRYPTO_CURVE25519_X86 is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_DEV_AMLOGIC_GXL is not set
+# CONFIG_CRYPTO_DEV_ATMEL_AES is not set
+# CONFIG_CRYPTO_DEV_ATMEL_AUTHENC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA204A is not set
+# CONFIG_CRYPTO_DEV_ATMEL_TDES is not set
+# CONFIG_CRYPTO_DEV_CAVIUM_ZIP is not set
+# CONFIG_CRYPTO_DEV_CCP is not set
+# CONFIG_CRYPTO_DEV_CCP_DEBUGFS is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API_DESC is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM_DEBUG is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM_INTC is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HISI_SEC is not set
+# CONFIG_CRYPTO_DEV_HISI_ZIP is not set
+# CONFIG_CRYPTO_DEV_IMGTEC_HASH is not set
+# CONFIG_CRYPTO_DEV_MARVELL_CESA is not set
+# CONFIG_CRYPTO_DEV_MXS_DCP is not set
+# CONFIG_CRYPTO_DEV_NITROX_CNN55XX is not set
+# CONFIG_CRYPTO_DEV_OCTEONTX_CPT is not set
+# CONFIG_CRYPTO_DEV_QAT_420XX is not set
+# CONFIG_CRYPTO_DEV_QAT_4XXX is not set
+# CONFIG_CRYPTO_DEV_QAT_C3XXX is not set
+# CONFIG_CRYPTO_DEV_QAT_C3XXXVF is not set
+# CONFIG_CRYPTO_DEV_QAT_C62X is not set
+# CONFIG_CRYPTO_DEV_QAT_C62XVF is not set
+# CONFIG_CRYPTO_DEV_QAT_DH895xCC is not set
+# CONFIG_CRYPTO_DEV_QAT_DH895xCCVF is not set
+# CONFIG_CRYPTO_DEV_QCE is not set
+# CONFIG_CRYPTO_DEV_S5P is not set
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_CRYPTO_DEV_SAHARA is not set
+# CONFIG_CRYPTO_DEV_SP_PSP is not set
+# CONFIG_CRYPTO_DEV_TALITOS is not set
+# CONFIG_CRYPTO_DEV_VIRTIO is not set
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_ECDH is not set
+# CONFIG_CRYPTO_ECDSA is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+# CONFIG_CRYPTO_ECRDSA is not set
+# CONFIG_CRYPTO_ESSIV is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_GHASH=y
+# CONFIG_CRYPTO_GHASH_ARM64_CE is not set
+# CONFIG_CRYPTO_GHASH_ARM_CE is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+# CONFIG_CRYPTO_GHASH_RISCV64 is not set
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+# CONFIG_CRYPTO_HCTR2 is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_JITTERENTROPY_TESTINTERFACE is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+CONFIG_CRYPTO_KPP=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_LIB_ARC4=y
+# CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC is not set
+# CONFIG_CRYPTO_LIB_CHACHA is not set
+# CONFIG_CRYPTO_LIB_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_LIB_CURVE25519 is not set
+# CONFIG_CRYPTO_LIB_POLY1305 is not set
+CONFIG_CRYPTO_LIB_POLY1305_RSIZE=9
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_NHPOLY1305_NEON is not set
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_PCRYPT=y
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_POLY1305_ARM is not set
+# CONFIG_CRYPTO_POLY1305_MIPS is not set
+# CONFIG_CRYPTO_POLY1305_NEON is not set
+# CONFIG_CRYPTO_POLY1305_X86_64 is not set
+# CONFIG_CRYPTO_POLYVAL_ARM64_CE is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RNG is not set
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_ARM is not set
+# CONFIG_CRYPTO_SHA1_ARM64_CE is not set
+# CONFIG_CRYPTO_SHA1_ARM_CE is not set
+# CONFIG_CRYPTO_SHA1_ARM_NEON is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA256_ARM is not set
+# CONFIG_CRYPTO_SHA256_ARM64 is not set
+# CONFIG_CRYPTO_SHA256_RISCV64 is not set
+# CONFIG_CRYPTO_SHA2_ARM64_CE is not set
+# CONFIG_CRYPTO_SHA2_ARM_CE is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SHA3_ARM64 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA512_ARM is not set
+# CONFIG_CRYPTO_SHA512_ARM64 is not set
+# CONFIG_CRYPTO_SHA512_ARM64_CE is not set
+# CONFIG_CRYPTO_SHA512_RISCV64 is not set
+# CONFIG_CRYPTO_SIMD is not set
+CONFIG_CRYPTO_SKCIPHER=y
+CONFIG_CRYPTO_SKCIPHER2=y
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_SM3_ARM64_CE is not set
+# CONFIG_CRYPTO_SM3_GENERIC is not set
+# CONFIG_CRYPTO_SM3_NEON is not set
+# CONFIG_CRYPTO_SM3_RISCV64 is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_SM4_ARM64_CE is not set
+# CONFIG_CRYPTO_SM4_ARM64_CE_BLK is not set
+# CONFIG_CRYPTO_SM4_ARM64_CE_CCM is not set
+# CONFIG_CRYPTO_SM4_ARM64_CE_GCM is not set
+# CONFIG_CRYPTO_SM4_ARM64_NEON_BLK is not set
+# CONFIG_CRYPTO_SM4_GENERIC is not set
+# CONFIG_CRYPTO_SM4_RISCV64 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+# CONFIG_CRYPTO_TWOFISH_COMMON is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_USER_API_ENABLE_OBSOLETE is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_RNG_CAVP is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_VMAC is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_XXHASH is not set
+# CONFIG_CRYPTO_ZSTD is not set
+# CONFIG_CS5535_MFGPT is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_CS89x0_PLATFORM is not set
+# CONFIG_CSD_LOCK_WAIT_DEBUG is not set
+# CONFIG_CUSE is not set
+# CONFIG_CW1200 is not set
+# CONFIG_CXD2880_SPI_DRV is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_BUS is not set
+# CONFIG_CYPRESS_FIRMWARE is not set
+# CONFIG_CZNIC_PLATFORMS is not set
+# CONFIG_DA280 is not set
+# CONFIG_DA311 is not set
+# CONFIG_DAMON is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DAX is not set
+# CONFIG_DCB is not set
+# CONFIG_DDR is not set
+# CONFIG_DEBUG_ALIGN_RODATA is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_CGROUP_REF is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_EFI is not set
+# CONFIG_DEBUG_FORCE_FUNCTION_ALIGN_64B is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_FS_ALLOW_ALL=y
+# CONFIG_DEBUG_FS_ALLOW_NONE is not set
+# CONFIG_DEBUG_FS_DISALLOW_MOUNT is not set
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_INFO_BTF is not set
+CONFIG_DEBUG_INFO_COMPRESSED_NONE=y
+# CONFIG_DEBUG_INFO_COMPRESSED_ZLIB is not set
+# CONFIG_DEBUG_INFO_COMPRESSED_ZSTD is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_DEBUG_INFO_DWARF5 is not set
+CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
+# CONFIG_DEBUG_INFO_NONE is not set
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_IRQFLAGS is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_KMAP_LOCAL is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_KOBJECT_RELEASE is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+# CONFIG_DEBUG_LOCKDEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_MAPLE_TREE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_MISC is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_NET is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_PAGE_REF is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_RSEQ is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_DEBUG_UART_8250_PALMCHIP is not set
+# CONFIG_DEBUG_UART_8250_WORD is not set
+# CONFIG_DEBUG_UART_FLOW_CONTROL is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VM_MAPLE_TREE is not set
+# CONFIG_DEBUG_VM_PGFLAGS is not set
+# CONFIG_DEBUG_VM_PGTABLE is not set
+# CONFIG_DEBUG_VM_RB is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_WX is not set
+# CONFIG_DEBUG_ZBOOT is not set
+# CONFIG_DEFAULT_CODEL is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_FQ is not set
+CONFIG_DEFAULT_FQ_CODEL=y
+# CONFIG_DEFAULT_FQ_PIE is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+CONFIG_DEFAULT_INIT=""
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_DEFAULT_NET_SCH="fq_codel"
+# CONFIG_DEFAULT_PFIFO_FAST is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SFQ is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_DEFERRED_STRUCT_PAGE_INIT is not set
+# CONFIG_DELL_LAPTOP is not set
+# CONFIG_DELL_RBTN is not set
+# CONFIG_DELL_SMBIOS is not set
+# CONFIG_DELL_SMO8800 is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_DEVMEM is not set
+CONFIG_DEVPORT=y
+# CONFIG_DEVTMPFS is not set
+# CONFIG_DEVTMPFS_MOUNT is not set
+# CONFIG_DEVTMPFS_SAFE is not set
+# CONFIG_DEV_DAX is not set
+# CONFIG_DHT11 is not set
+CONFIG_DIMLIB=y
+# CONFIG_DL2K is not set
+# CONFIG_DLHL60D is not set
+# CONFIG_DLM is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DM9051 is not set
+# CONFIG_DMABUF_DEBUG is not set
+# CONFIG_DMABUF_HEAPS is not set
+# CONFIG_DMABUF_MOVE_NOTIFY is not set
+# CONFIG_DMABUF_SELFTESTS is not set
+# CONFIG_DMABUF_SYSFS_STATS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_DMADEVICES_DEBUG is not set
+# CONFIG_DMAPOOL_TEST is not set
+# CONFIG_DMARD06 is not set
+# CONFIG_DMARD09 is not set
+# CONFIG_DMARD10 is not set
+# CONFIG_DMATEST is not set
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_DMA_COHERENT_POOL=y
+CONFIG_DMA_DECLARE_COHERENT=y
+# CONFIG_DMA_ENGINE is not set
+# CONFIG_DMA_FENCE_TRACE is not set
+# CONFIG_DMA_JZ4780 is not set
+# CONFIG_DMA_MAP_BENCHMARK is not set
+CONFIG_DMA_NONCOHERENT_MMAP=y
+# CONFIG_DMA_RESTRICTED_POOL is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_DM_AUDIT is not set
+# CONFIG_DM_CACHE is not set
+# CONFIG_DM_CLONE is not set
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_DUST is not set
+# CONFIG_DM_EBS is not set
+# CONFIG_DM_ERA is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_INTEGRITY is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_LOG_WRITES is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_SWITCH is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_UNSTRIPED is not set
+# CONFIG_DM_VDO is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_DM_WRITECACHE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_ZONED is not set
+# CONFIG_DNET is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_DP83640_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_DP83869_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83TD510_PHY is not set
+# CONFIG_DP83TG720_PHY is not set
+# CONFIG_DPM_WATCHDOG is not set
+# CONFIG_DPOT_DAC is not set
+# CONFIG_DPS310 is not set
+CONFIG_DQL=y
+# CONFIG_DRAGONRISE_FF is not set
+# CONFIG_DRM is not set
+# CONFIG_DRM_ACCEL is not set
+# CONFIG_DRM_AMDGPU is not set
+# CONFIG_DRM_AMDGPU_CIK is not set
+# CONFIG_DRM_AMDGPU_SI is not set
+# CONFIG_DRM_AMDGPU_USERPTR is not set
+# CONFIG_DRM_AMDGPU_WERROR is not set
+# CONFIG_DRM_AMD_ACP is not set
+# CONFIG_DRM_AMD_DC_SI is not set
+# CONFIG_DRM_AMD_SECURE_DISPLAY is not set
+# CONFIG_DRM_ANALOGIX_ANX6345 is not set
+# CONFIG_DRM_ANALOGIX_ANX7625 is not set
+# CONFIG_DRM_ANALOGIX_ANX78XX is not set
+# CONFIG_DRM_ARCPGU is not set
+# CONFIG_DRM_ARMADA is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_ATMEL_HLCDC is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_DRM_CDNS_DSI is not set
+# CONFIG_DRM_CDNS_MHDP8546 is not set
+# CONFIG_DRM_CHIPONE_ICN6211 is not set
+# CONFIG_DRM_CHRONTEL_CH7033 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS is not set
+# CONFIG_DRM_DEBUG_MM is not set
+# CONFIG_DRM_DEBUG_MODESET_LOCK is not set
+# CONFIG_DRM_DISPLAY_CONNECTOR is not set
+# CONFIG_DRM_DISPLAY_DP_AUX_CEC is not set
+# CONFIG_DRM_DISPLAY_DP_AUX_CHARDEV is not set
+# CONFIG_DRM_DW_HDMI_CEC is not set
+# CONFIG_DRM_ETNAVIV is not set
+# CONFIG_DRM_EXYNOS is not set
+# CONFIG_DRM_FBDEV_EMULATION is not set
+# CONFIG_DRM_FBDEV_LEAK_PHYS_SMEM is not set
+# CONFIG_DRM_FSL_DCU is not set
+# CONFIG_DRM_GM12U320 is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_GUD is not set
+# CONFIG_DRM_HDLCD is not set
+# CONFIG_DRM_HISI_HIBMC is not set
+# CONFIG_DRM_HISI_KIRIN is not set
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_NXP_TDA9950 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I915 is not set
+# CONFIG_DRM_IMX_LCDIF is not set
+# CONFIG_DRM_ITE_IT6505 is not set
+# CONFIG_DRM_ITE_IT66121 is not set
+# CONFIG_DRM_KOMEDA is not set
+# CONFIG_DRM_LIB_RANDOM is not set
+# CONFIG_DRM_LIMA is not set
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+# CONFIG_DRM_LOGICVC is not set
+# CONFIG_DRM_LONTIUM_LT8912B is not set
+# CONFIG_DRM_LONTIUM_LT9211 is not set
+# CONFIG_DRM_LONTIUM_LT9611 is not set
+# CONFIG_DRM_LONTIUM_LT9611UXC is not set
+# CONFIG_DRM_LOONGSON is not set
+# CONFIG_DRM_LVDS_CODEC is not set
+# CONFIG_DRM_MALI_DISPLAY is not set
+# CONFIG_DRM_MCDE is not set
+# CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_MXSFB is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_NWL_MIPI_DSI is not set
+# CONFIG_DRM_NXP_PTN3460 is not set
+# CONFIG_DRM_OFDRM is not set
+# CONFIG_DRM_OMAP is not set
+# CONFIG_DRM_PANEL_ABT_Y030XX067A is not set
+# CONFIG_DRM_PANEL_ARM_VERSATILE is not set
+# CONFIG_DRM_PANEL_ASUS_Z00T_TM5P5_NT35596 is not set
+# CONFIG_DRM_PANEL_AUO_A030JTN01 is not set
+# CONFIG_DRM_PANEL_BOE_BF060Y8M_AJ0 is not set
+# CONFIG_DRM_PANEL_BOE_HIMAX8279D is not set
+# CONFIG_DRM_PANEL_BOE_TH101MB31UIG002_28A is not set
+# CONFIG_DRM_PANEL_BOE_TV101WUM_LL2 is not set
+# CONFIG_DRM_PANEL_BOE_TV101WUM_NL6 is not set
+# CONFIG_DRM_PANEL_DSI_CM is not set
+# CONFIG_DRM_PANEL_EBBG_FT8719 is not set
+# CONFIG_DRM_PANEL_EDP is not set
+# CONFIG_DRM_PANEL_ELIDA_KD35T133 is not set
+# CONFIG_DRM_PANEL_FEIXIN_K101_IM2BA02 is not set
+# CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D is not set
+# CONFIG_DRM_PANEL_HIMAX_HX83102 is not set
+# CONFIG_DRM_PANEL_HIMAX_HX83112A is not set
+# CONFIG_DRM_PANEL_HIMAX_HX8394 is not set
+# CONFIG_DRM_PANEL_ILITEK_IL9322 is not set
+# CONFIG_DRM_PANEL_ILITEK_ILI9341 is not set
+# CONFIG_DRM_PANEL_ILITEK_ILI9881C is not set
+# CONFIG_DRM_PANEL_INNOLUX_EJ030NA is not set
+# CONFIG_DRM_PANEL_INNOLUX_P079ZCA is not set
+# CONFIG_DRM_PANEL_JADARD_JD9365DA_H3 is not set
+# CONFIG_DRM_PANEL_JDI_LPM102A188A is not set
+# CONFIG_DRM_PANEL_JDI_LT070ME05000 is not set
+# CONFIG_DRM_PANEL_JDI_R63452 is not set
+# CONFIG_DRM_PANEL_KHADAS_TS050 is not set
+# CONFIG_DRM_PANEL_KINGDISPLAY_KD097D04 is not set
+# CONFIG_DRM_PANEL_LEADTEK_LTK050H3146W is not set
+# CONFIG_DRM_PANEL_LEADTEK_LTK500HD1829 is not set
+# CONFIG_DRM_PANEL_LG_LB035Q02 is not set
+# CONFIG_DRM_PANEL_LG_LG4573 is not set
+# CONFIG_DRM_PANEL_LG_SW43408 is not set
+# CONFIG_DRM_PANEL_LINCOLNTECH_LCD197 is not set
+# CONFIG_DRM_PANEL_LVDS is not set
+# CONFIG_DRM_PANEL_MAGNACHIP_D53E6EA8966 is not set
+# CONFIG_DRM_PANEL_MANTIX_MLAF057WE51 is not set
+# CONFIG_DRM_PANEL_MIPI_DBI is not set
+# CONFIG_DRM_PANEL_NEC_NL8048HL11 is not set
+# CONFIG_DRM_PANEL_NEWVISION_NV3051D is not set
+# CONFIG_DRM_PANEL_NEWVISION_NV3052C is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT35510 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT35560 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT35950 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT36523 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT36672A is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT36672E is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT39016 is not set
+# CONFIG_DRM_PANEL_OLIMEX_LCD_OLINUXINO is not set
+# CONFIG_DRM_PANEL_ORISETECH_OTA5601A is not set
+# CONFIG_DRM_PANEL_ORISETECH_OTM8009A is not set
+# CONFIG_DRM_PANEL_OSD_OSD101T2587_53TS is not set
+# CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00 is not set
+# CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN is not set
+# CONFIG_DRM_PANEL_RAYDIUM_RM67191 is not set
+# CONFIG_DRM_PANEL_RAYDIUM_RM68200 is not set
+# CONFIG_DRM_PANEL_RAYDIUM_RM692E5 is not set
+# CONFIG_DRM_PANEL_RAYDIUM_RM69380 is not set
+# CONFIG_DRM_PANEL_RONBO_RB070D30 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_ATNA33XC20 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_DB7430 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_LD9040 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6D16D0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6D27A1 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6D7AA0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E3FA7 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E3HA2 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E63J0X03 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E63M0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E88A0_AMS452EF01 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_SOFEF00 is not set
+# CONFIG_DRM_PANEL_SEIKO_43WVF1G is not set
+# CONFIG_DRM_PANEL_SHARP_LQ101R1SX01 is not set
+# CONFIG_DRM_PANEL_SHARP_LS037V7DW01 is not set
+# CONFIG_DRM_PANEL_SHARP_LS043T1LE01 is not set
+# CONFIG_DRM_PANEL_SHARP_LS060T1SX01 is not set
+# CONFIG_DRM_PANEL_SIMPLE is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7701 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7703 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7789V is not set
+# CONFIG_DRM_PANEL_SONY_ACX565AKM is not set
+# CONFIG_DRM_PANEL_SONY_TD4353_JDI is not set
+# CONFIG_DRM_PANEL_SONY_TULIP_TRULY_NT35521 is not set
+# CONFIG_DRM_PANEL_STARTEK_KD070FHFID015 is not set
+# CONFIG_DRM_PANEL_SYNAPTICS_R63353 is not set
+# CONFIG_DRM_PANEL_TDO_TL070WSH30 is not set
+# CONFIG_DRM_PANEL_TPO_TD028TTEC1 is not set
+# CONFIG_DRM_PANEL_TPO_TD043MTEA1 is not set
+# CONFIG_DRM_PANEL_TPO_TPG110 is not set
+# CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA is not set
+# CONFIG_DRM_PANEL_VISIONOX_R66451 is not set
+# CONFIG_DRM_PANEL_VISIONOX_RM69299 is not set
+# CONFIG_DRM_PANEL_VISIONOX_VTDR6130 is not set
+# CONFIG_DRM_PANEL_WIDECHIPS_WS2401 is not set
+# CONFIG_DRM_PANEL_XINPENG_XPP055C272 is not set
+# CONFIG_DRM_PANFROST is not set
+# CONFIG_DRM_PANIC is not set
+# CONFIG_DRM_PANTHOR is not set
+# CONFIG_DRM_PARADE_PS8622 is not set
+# CONFIG_DRM_PARADE_PS8640 is not set
+# CONFIG_DRM_PL111 is not set
+# CONFIG_DRM_POWERVR is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_RADEON_USERPTR is not set
+# CONFIG_DRM_RCAR_DW_HDMI is not set
+# CONFIG_DRM_RCAR_LVDS is not set
+# CONFIG_DRM_RCAR_USE_LVDS is not set
+# CONFIG_DRM_RCAR_USE_MIPI_DSI is not set
+# CONFIG_DRM_ROCKCHIP is not set
+# CONFIG_DRM_SAMSUNG_DSIM is not set
+# CONFIG_DRM_SII902X is not set
+# CONFIG_DRM_SII9234 is not set
+# CONFIG_DRM_SIL_SII8620 is not set
+# CONFIG_DRM_SIMPLEDRM is not set
+# CONFIG_DRM_SIMPLE_BRIDGE is not set
+# CONFIG_DRM_SSD130X is not set
+# CONFIG_DRM_STI is not set
+# CONFIG_DRM_STM is not set
+# CONFIG_DRM_SUN4I is not set
+# CONFIG_DRM_THINE_THC63LVD1024 is not set
+# CONFIG_DRM_TIDSS is not set
+# CONFIG_DRM_TILCDC is not set
+# CONFIG_DRM_TI_DLPC3433 is not set
+# CONFIG_DRM_TI_SN65DSI83 is not set
+# CONFIG_DRM_TI_SN65DSI86 is not set
+# CONFIG_DRM_TI_TFP410 is not set
+# CONFIG_DRM_TI_TPD12S015 is not set
+# CONFIG_DRM_TOSHIBA_TC358762 is not set
+# CONFIG_DRM_TOSHIBA_TC358764 is not set
+# CONFIG_DRM_TOSHIBA_TC358767 is not set
+# CONFIG_DRM_TOSHIBA_TC358768 is not set
+# CONFIG_DRM_TOSHIBA_TC358775 is not set
+# CONFIG_DRM_TVE200 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_V3D is not set
+# CONFIG_DRM_VBOXVIDEO is not set
+# CONFIG_DRM_VC4_HDMI_CEC is not set
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VIRTIO_GPU is not set
+# CONFIG_DRM_VKMS is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_XE is not set
+# CONFIG_DRM_XEN is not set
+# CONFIG_DRM_XEN_FRONTEND is not set
+# CONFIG_DS1682 is not set
+# CONFIG_DS1803 is not set
+# CONFIG_DS4424 is not set
+# CONFIG_DST_CACHE is not set
+# CONFIG_DTLK is not set
+# CONFIG_DUMMY is not set
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_DVB_A8293 is not set
+# CONFIG_DVB_AF9013 is not set
+# CONFIG_DVB_AF9033 is not set
+# CONFIG_DVB_AS102 is not set
+# CONFIG_DVB_ASCOT2E is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_AU8522_DTV is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_B2C2_FLEXCOP_PCI is not set
+# CONFIG_DVB_B2C2_FLEXCOP_USB is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_CX24117 is not set
+# CONFIG_DVB_CX24120 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_DVB_CXD2820R is not set
+# CONFIG_DVB_CXD2841ER is not set
+# CONFIG_DVB_CXD2880 is not set
+# CONFIG_DVB_DDBRIDGE is not set
+# CONFIG_DVB_DEMUX_SECTION_LOSS_LOG is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_DRX39XYJ is not set
+# CONFIG_DVB_DRXD is not set
+# CONFIG_DVB_DRXK is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_DUMMY_FE is not set
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_FIREDTV is not set
+# CONFIG_DVB_HELENE is not set
+# CONFIG_DVB_HORUS3A is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_IX2505V is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_LG2160 is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_LGDT3306A is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_LNBH25 is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_LNBP22 is not set
+# CONFIG_DVB_M88DS3103 is not set
+# CONFIG_DVB_M88RS2000 is not set
+CONFIG_DVB_MAX_ADAPTERS=16
+# CONFIG_DVB_MB86A16 is not set
+# CONFIG_DVB_MB86A20S is not set
+# CONFIG_DVB_MMAP is not set
+# CONFIG_DVB_MN88443X is not set
+# CONFIG_DVB_MN88472 is not set
+# CONFIG_DVB_MN88473 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_MXL5XX is not set
+# CONFIG_DVB_MXL692 is not set
+# CONFIG_DVB_NET is not set
+# CONFIG_DVB_NETUP_UNIDVB is not set
+# CONFIG_DVB_NGENE is not set
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_PLATFORM_DRIVERS is not set
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_PLUTO2 is not set
+# CONFIG_DVB_PT1 is not set
+# CONFIG_DVB_PT3 is not set
+# CONFIG_DVB_RTL2830 is not set
+# CONFIG_DVB_RTL2832 is not set
+# CONFIG_DVB_RTL2832_SDR is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_S5H1411 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_SI2165 is not set
+# CONFIG_DVB_SI2168 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_SP2 is not set
+# CONFIG_DVB_SP8870 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STV0297 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV0367 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV0910 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_STV6110x is not set
+# CONFIG_DVB_STV6111 is not set
+# CONFIG_DVB_TC90522 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_TDA10071 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA18271C2DD is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TEST_DRIVERS is not set
+# CONFIG_DVB_TS2020 is not set
+# CONFIG_DVB_TTUSB_BUDGET is not set
+# CONFIG_DVB_TTUSB_DEC is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_ULE_DEBUG is not set
+# CONFIG_DVB_USB is not set
+# CONFIG_DVB_USB_V2 is not set
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_ZD1301_DEMOD is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DWC_PCIE_PMU is not set
+# CONFIG_DWC_XLGMAC is not set
+# CONFIG_DWMAC_DWC_QOS_ETH is not set
+# CONFIG_DWMAC_INTEL_PLAT is not set
+# CONFIG_DWMAC_IPQ806X is not set
+# CONFIG_DWMAC_LOONGSON is not set
+# CONFIG_DWMAC_LPC18XX is not set
+# CONFIG_DWMAC_MESON is not set
+# CONFIG_DWMAC_ROCKCHIP is not set
+# CONFIG_DWMAC_SOCFPGA is not set
+# CONFIG_DWMAC_STI is not set
+# CONFIG_DW_AXI_DMAC is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+# CONFIG_DW_EDMA is not set
+# CONFIG_DW_EDMA_PCIE is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_DW_XDATA_PCIE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DYNAMIC_DEBUG_CORE is not set
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_E1000E_HWTS is not set
+# CONFIG_EARLY_PRINTK_8250 is not set
+# CONFIG_EARLY_PRINTK_USB_XDBC is not set
+# CONFIG_EBC_C384_WDT is not set
+# CONFIG_ECHO is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_EC_LENOVO_YOGA_C630 is not set
+# CONFIG_EDAC is not set
+# CONFIG_EEEPC_LAPTOP is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_DIGSY_MTC_CFG is not set
+# CONFIG_EEPROM_EE1004 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EFI is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_EFI_VARS_PSTORE is not set
+# CONFIG_EFS_FS is not set
+CONFIG_ELFCORE=y
+# CONFIG_ELF_CORE is not set
+# CONFIG_EMAC_ROCKCHIP is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_ENA_ETHERNET is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_ENCX24J600 is not set
+# CONFIG_ENERGY_MODEL is not set
+# CONFIG_ENIC is not set
+# CONFIG_ENS160 is not set
+# CONFIG_ENS210 is not set
+# CONFIG_ENVELOPE_DETECTOR is not set
+# CONFIG_EPAPR_PARAVIRT is not set
+# CONFIG_EPIC100 is not set
+CONFIG_EPOLL=y
+# CONFIG_EQUALIZER is not set
+# CONFIG_EROFS_FS is not set
+# CONFIG_ET131X is not set
+CONFIG_ETHERNET=y
+# CONFIG_ETHOC is not set
+CONFIG_ETHTOOL_NETLINK=y
+CONFIG_EVENTFD=y
+# CONFIG_EVM is not set
+CONFIG_EXECMEM=y
+# CONFIG_EXFAT_FS is not set
+CONFIG_EXPERT=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_DEBUG is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+CONFIG_EXT4_USE_FOR_EXT2=y
+# CONFIG_EXTCON is not set
+# CONFIG_EXTCON_ADC_JACK is not set
+# CONFIG_EXTCON_AXP288 is not set
+# CONFIG_EXTCON_FSA9480 is not set
+# CONFIG_EXTCON_GPIO is not set
+# CONFIG_EXTCON_INTEL_INT3496 is not set
+# CONFIG_EXTCON_LC824206XA is not set
+# CONFIG_EXTCON_MAX3355 is not set
+# CONFIG_EXTCON_PTN5150 is not set
+# CONFIG_EXTCON_QCOM_SPMI_MISC is not set
+# CONFIG_EXTCON_RT8973A is not set
+# CONFIG_EXTCON_SM5502 is not set
+# CONFIG_EXTCON_USBC_TUSB320 is not set
+# CONFIG_EXTCON_USB_GPIO is not set
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_EXTRA_TARGETS=""
+# CONFIG_EXYNOS_ADC is not set
+# CONFIG_EYEQ is not set
+# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_F2FS_CHECK_FS is not set
+# CONFIG_F2FS_FAULT_INJECTION is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_F2FS_FS_COMPRESSION is not set
+# CONFIG_F2FS_FS_POSIX_ACL is not set
+# CONFIG_F2FS_FS_SECURITY is not set
+CONFIG_F2FS_FS_XATTR=y
+# CONFIG_F2FS_IOSTAT is not set
+CONFIG_F2FS_STAT_FS=y
+# CONFIG_F2FS_UNFAIR_RWSEM is not set
+# CONFIG_FAILOVER is not set
+# CONFIG_FAIR_GROUP_SCHED is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_FANOTIFY_ACCESS_PERMISSIONS is not set
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_FB is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_ATMEL is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_BIG_ENDIAN is not set
+# CONFIG_FB_BOTH_ENDIAN is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_DEVICE is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_FSL_DIU is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_IMX is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_LITTLE_ENDIAN is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_NEOMAGIC is not set
+CONFIG_FB_NOTIFY=y
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_OF is not set
+# CONFIG_FB_OMAP2 is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_PS3 is not set
+# CONFIG_FB_PXA is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_FB_SM750 is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_TFT is not set
+# CONFIG_FB_TFT_AGM1264K_FL is not set
+# CONFIG_FB_TFT_BD663474 is not set
+# CONFIG_FB_TFT_HX8340BN is not set
+# CONFIG_FB_TFT_HX8347D is not set
+# CONFIG_FB_TFT_HX8353D is not set
+# CONFIG_FB_TFT_HX8357D is not set
+# CONFIG_FB_TFT_ILI9163 is not set
+# CONFIG_FB_TFT_ILI9320 is not set
+# CONFIG_FB_TFT_ILI9325 is not set
+# CONFIG_FB_TFT_ILI9340 is not set
+# CONFIG_FB_TFT_ILI9341 is not set
+# CONFIG_FB_TFT_ILI9481 is not set
+# CONFIG_FB_TFT_ILI9486 is not set
+# CONFIG_FB_TFT_PCD8544 is not set
+# CONFIG_FB_TFT_RA8875 is not set
+# CONFIG_FB_TFT_S6D02A1 is not set
+# CONFIG_FB_TFT_S6D1121 is not set
+# CONFIG_FB_TFT_SEPS525 is not set
+# CONFIG_FB_TFT_SH1106 is not set
+# CONFIG_FB_TFT_SSD1289 is not set
+# CONFIG_FB_TFT_SSD1305 is not set
+# CONFIG_FB_TFT_SSD1306 is not set
+# CONFIG_FB_TFT_SSD1331 is not set
+# CONFIG_FB_TFT_SSD1351 is not set
+# CONFIG_FB_TFT_ST7735R is not set
+# CONFIG_FB_TFT_ST7789V is not set
+# CONFIG_FB_TFT_TINYLCD is not set
+# CONFIG_FB_TFT_TLS8204 is not set
+# CONFIG_FB_TFT_UC1611 is not set
+# CONFIG_FB_TFT_UC1701 is not set
+# CONFIG_FB_TFT_UPD161704 is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_FDDI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_FHANDLE is not set
+CONFIG_FIB_RULES=y
+# CONFIG_FIELDBUS_DEV is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FIXED_PHY is not set
+CONFIG_FLATMEM=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_FM10K is not set
+# CONFIG_FONTS is not set
+# CONFIG_FONT_6x8 is not set
+# CONFIG_FONT_TER16x32 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_FORCE_NR_CPUS is not set
+CONFIG_FORTIFY_SOURCE=y
+# CONFIG_FPGA is not set
+# CONFIG_FPROBE is not set
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION is not set
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_FREEZER is not set
+# CONFIG_FSCACHE is not set
+# CONFIG_FSI is not set
+# CONFIG_FSL_DPAA2_SWITCH is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_FSL_ENETC is not set
+# CONFIG_FSL_ENETC_IERB is not set
+# CONFIG_FSL_ENETC_MDIO is not set
+# CONFIG_FSL_ENETC_VF is not set
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_FSL_MC_BUS is not set
+# CONFIG_FSL_PQ_MDIO is not set
+# CONFIG_FSL_QDMA is not set
+# CONFIG_FSL_RCPM is not set
+# CONFIG_FSL_XGMAC_MDIO is not set
+CONFIG_FSNOTIFY=y
+# CONFIG_FS_DAX is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FS_STACK=y
+# CONFIG_FS_VERITY is not set
+# CONFIG_FTGMAC100 is not set
+# CONFIG_FTL is not set
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTRACE is not set
+# CONFIG_FTRACE_RECORD_RECURSION is not set
+# CONFIG_FTRACE_SORT_STARTUP_TEST is not set
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_FTRACE_VALIDATE_RCU_IS_WATCHING is not set
+# CONFIG_FTR_FIXUP_SELFTEST is not set
+# CONFIG_FTWDT010_WATCHDOG is not set
+# CONFIG_FUEL_GAUGE_MM8013 is not set
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
+# CONFIG_FUJITSU_ES is not set
+# CONFIG_FUJITSU_LAPTOP is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_FUNCTION_ERROR_INJECTION is not set
+# CONFIG_FUNCTION_GRAPH_RETVAL is not set
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_FUN_ETH is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_FUSE_PASSTHROUGH is not set
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+# CONFIG_FUSION_SPI is not set
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+# CONFIG_FW_CFG_SYSFS is not set
+# CONFIG_FW_DEVLINK_SYNC_STATE_TIMEOUT is not set
+CONFIG_FW_LOADER=y
+# CONFIG_FW_LOADER_COMPRESS is not set
+# CONFIG_FW_LOADER_DEBUG is not set
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+# CONFIG_FW_UPLOAD is not set
+# CONFIG_FXAS21002C is not set
+# CONFIG_FXLS8962AF_I2C is not set
+# CONFIG_FXLS8962AF_SPI is not set
+# CONFIG_FXOS8700_I2C is not set
+# CONFIG_FXOS8700_SPI is not set
+CONFIG_GACT_PROB=y
+# CONFIG_GADGET_UAC1 is not set
+# CONFIG_GAMEPORT is not set
+CONFIG_GCC_NO_STRINGOP_OVERFLOW=y
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_GCOV is not set
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_GDB_SCRIPTS is not set
+# CONFIG_GEMINI_ETHERNET is not set
+# CONFIG_GENERIC_ADC_BATTERY is not set
+# CONFIG_GENERIC_ADC_THERMAL is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_HWEIGHT=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+CONFIG_GENERIC_IRQ_IPI=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_GENERIC_PHY is not set
+CONFIG_GENERIC_PTDUMP=y
+CONFIG_GENERIC_VDSO_TIME_NS=y
+# CONFIG_GENEVE is not set
+# CONFIG_GENWQE is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_GLOB_SELFTEST is not set
+# CONFIG_GNSS is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_GOOGLE_CBMEM is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+# CONFIG_GOOGLE_FRAMEBUFFER_COREBOOT is not set
+# CONFIG_GOOGLE_MEMCONSOLE_X86_LEGACY is not set
+# CONFIG_GOOGLE_SMI is not set
+# CONFIG_GP2AP002 is not set
+# CONFIG_GP2AP020A00F is not set
+# CONFIG_GPD_POCKET_FAN is not set
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+# CONFIG_GPIO_104_DIO_48E is not set
+# CONFIG_GPIO_104_IDIO_16 is not set
+# CONFIG_GPIO_104_IDI_48 is not set
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_AGGREGATOR is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_AMD8111 is not set
+# CONFIG_GPIO_AMDPT is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# CONFIG_GPIO_BCM_KONA is not set
+# CONFIG_GPIO_BRCMSTB is not set
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_CASCADE is not set
+# CONFIG_GPIO_CDEV is not set
+# CONFIG_GPIO_CDEV_V1 is not set
+# CONFIG_GPIO_CS5535 is not set
+# CONFIG_GPIO_DS4520 is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_EXAR is not set
+# CONFIG_GPIO_F7188X is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_FXL6408 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GPIO_MM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_HISI is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_ICH is not set
+# CONFIG_GPIO_IT87 is not set
+# CONFIG_GPIO_LATCH is not set
+# CONFIG_GPIO_LOGICVC is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCA953X_IRQ is not set
+# CONFIG_GPIO_PCA9570 is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_PCH is not set
+# CONFIG_GPIO_PCIE_IDIO_24 is not set
+# CONFIG_GPIO_PCI_IDIO_16 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_PL061 is not set
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_RDC321X is not set
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SCH is not set
+# CONFIG_GPIO_SCH311X is not set
+# CONFIG_GPIO_SIFIVE is not set
+# CONFIG_GPIO_SIM is not set
+# CONFIG_GPIO_SLOPPY_LOGIC_ANALYZER is not set
+# CONFIG_GPIO_SYSCON is not set
+CONFIG_GPIO_SYSFS=y
+# CONFIG_GPIO_TPIC2810 is not set
+# CONFIG_GPIO_TS4900 is not set
+# CONFIG_GPIO_TS5500 is not set
+# CONFIG_GPIO_VIRTIO is not set
+# CONFIG_GPIO_VIRTUSER is not set
+# CONFIG_GPIO_VX855 is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_GPIO_WINBOND is not set
+# CONFIG_GPIO_WS16C48 is not set
+# CONFIG_GPIO_XGENE is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_XRA1403 is not set
+# CONFIG_GPIO_ZEVIO is not set
+# CONFIG_GP_PCI1XXXX is not set
+# CONFIG_GREENASIA_FF is not set
+# CONFIG_GREYBUS is not set
+# CONFIG_GTP is not set
+# CONFIG_GUP_TEST is not set
+# CONFIG_GVE is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_HAPPYMEAL is not set
+CONFIG_HARDENED_USERCOPY=y
+CONFIG_HARDEN_BRANCH_HISTORY=y
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+# CONFIG_HCALL_STATS is not set
+# CONFIG_HDC100X is not set
+# CONFIG_HDC2010 is not set
+# CONFIG_HDC3020 is not set
+# CONFIG_HDLC is not set
+# CONFIG_HDLC_CISCO is not set
+# CONFIG_HDLC_FR is not set
+# CONFIG_HDLC_PPP is not set
+# CONFIG_HDLC_RAW is not set
+# CONFIG_HDLC_RAW_ETH is not set
+# CONFIG_HDMI_LPE_AUDIO is not set
+# CONFIG_HDQ_MASTER_OMAP is not set
+# CONFIG_HEADERS_INSTALL is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HI6421V600_IRQ is not set
+# CONFIG_HI8435 is not set
+# CONFIG_HIBERNATION is not set
+# CONFIG_HID is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACCUTOUCH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_ACRUX_FF is not set
+# CONFIG_HID_ALPS is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_ASUS is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_BIGBEN_FF is not set
+# CONFIG_HID_BPF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CORSAIR is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_CP2112 is not set
+# CONFIG_HID_CREATIVE_SB0540 is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_ELAN is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EVISION is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_FT260 is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GENERIC is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_GLORIOUS is not set
+# CONFIG_HID_GOODIX_SPI is not set
+# CONFIG_HID_GOOGLE_HAMMER is not set
+# CONFIG_HID_GOOGLE_STADIA_FF is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_GT683R is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LED is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LETSKETCH is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_LOGITECH_DJ is not set
+# CONFIG_HID_LOGITECH_HIDPP is not set
+# CONFIG_HID_MACALLY is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MALTRON is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_MCP2200 is not set
+# CONFIG_HID_MCP2221 is not set
+# CONFIG_HID_MEGAWORLD_FF is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NINTENDO is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_NVIDIA_SHIELD is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PID is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PLAYSTATION is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_PXRC is not set
+# CONFIG_HID_RAZER is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_RETRODE is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SEMITEK is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_SIGMAMICRO is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPRE is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_U2FZERO is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_VIEWSONIC is not set
+# CONFIG_HID_VIVALDI is not set
+# CONFIG_HID_VRC2 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_WINWING is not set
+# CONFIG_HID_XIAOMI is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_HIGH_RES_TIMERS=y
+# CONFIG_HINIC is not set
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HIPPI is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_HISILICON_ERRATUM_161600802 is not set
+# CONFIG_HISILICON_ERRATUM_162100801 is not set
+# CONFIG_HISI_DMA is not set
+# CONFIG_HISI_FEMAC is not set
+# CONFIG_HISI_HIKEY_USB is not set
+# CONFIG_HISI_PCIE_PMU is not set
+# CONFIG_HISI_PTT is not set
+# CONFIG_HIST_TRIGGERS_DEBUG is not set
+# CONFIG_HIX5HD2_GMAC is not set
+# CONFIG_HMC425 is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_HNS is not set
+# CONFIG_HNS3 is not set
+# CONFIG_HNS3_PMU is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_HP03 is not set
+# CONFIG_HP206C is not set
+CONFIG_HPET_MMAP_DEFAULT=y
+# CONFIG_HPFS_FS is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_HSA_AMD is not set
+# CONFIG_HSC030PA is not set
+# CONFIG_HSI is not set
+# CONFIG_HSR is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTE is not set
+# CONFIG_HTS221 is not set
+# CONFIG_HTU21 is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_HUGETLB_PAGE_OPTIMIZE_VMEMMAP_DEFAULT_ON is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_HVC_UDBG is not set
+# CONFIG_HWLAT_TRACER is not set
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWSPINLOCK is not set
+# CONFIG_HWSPINLOCK_OMAP is not set
+CONFIG_HW_PERF_EVENTS=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HW_RANDOM_AMD is not set
+# CONFIG_HW_RANDOM_ARM_SMCCC_TRNG is not set
+# CONFIG_HW_RANDOM_ATMEL is not set
+# CONFIG_HW_RANDOM_BA431 is not set
+# CONFIG_HW_RANDOM_BCM2835 is not set
+# CONFIG_HW_RANDOM_CAVIUM is not set
+# CONFIG_HW_RANDOM_CCTRNG is not set
+# CONFIG_HW_RANDOM_CN10K is not set
+# CONFIG_HW_RANDOM_EXYNOS is not set
+# CONFIG_HW_RANDOM_GEODE is not set
+# CONFIG_HW_RANDOM_INTEL is not set
+# CONFIG_HW_RANDOM_IPROC_RNG200 is not set
+# CONFIG_HW_RANDOM_MTK is not set
+# CONFIG_HW_RANDOM_OMAP is not set
+# CONFIG_HW_RANDOM_OMAP3_ROM is not set
+# CONFIG_HW_RANDOM_PPC4XX is not set
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_TPM=y
+# CONFIG_HW_RANDOM_VIA is not set
+# CONFIG_HW_RANDOM_VIRTIO is not set
+# CONFIG_HW_RANDOM_XIPHERA is not set
+# CONFIG_HX711 is not set
+# CONFIG_HX9023S is not set
+# CONFIG_HYPERV is not set
+CONFIG_HZ=100
+CONFIG_HZ_100=y
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_24 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_48 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_PERIODIC is not set
+# CONFIG_I2C is not set
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_AU1550 is not set
+# CONFIG_I2C_BCM2835 is not set
+# CONFIG_I2C_BCM_IPROC is not set
+# CONFIG_I2C_BRCMSTB is not set
+# CONFIG_I2C_CADENCE is not set
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_CP2615 is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEMUX_PINCTRL is not set
+# CONFIG_I2C_DESIGNWARE_CORE is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_SLAVE is not set
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_EG20T is not set
+# CONFIG_I2C_ELEKTOR is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_GPIO_FAULT_INJECTOR is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_HID is not set
+# CONFIG_I2C_HID_OF is not set
+# CONFIG_I2C_HID_OF_ELAN is not set
+# CONFIG_I2C_HID_OF_GOODIX is not set
+# CONFIG_I2C_HISI is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_IBM_IIC is not set
+# CONFIG_I2C_IMG is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_ISMT is not set
+# CONFIG_I2C_JZ4780 is not set
+# CONFIG_I2C_MLXCPLD is not set
+# CONFIG_I2C_MPC is not set
+# CONFIG_I2C_MT65XX is not set
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_GPMUX is not set
+# CONFIG_I2C_MUX_LTC4306 is not set
+# CONFIG_I2C_MUX_MLXCPLD is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_MV64XXX is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_NVIDIA_GPU is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_OCTEON is not set
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PCA_ISA is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PCI1XXXX is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_PXA_SLAVE is not set
+# CONFIG_I2C_RCAR is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_S3C2410 is not set
+# CONFIG_I2C_SCMI is not set
+# CONFIG_I2C_SH_MOBILE is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_SLAVE_EEPROM is not set
+# CONFIG_I2C_SMBUS is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_THUNDERX is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_VERSATILE is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VIRTIO is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I3C is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+# CONFIG_IAQCORE is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_IBM_EMAC_DEBUG is not set
+# CONFIG_IBM_EMAC_EMAC4 is not set
+# CONFIG_IBM_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_IBM_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_EMAC_RGMII is not set
+# CONFIG_IBM_EMAC_TAH is not set
+# CONFIG_IBM_EMAC_ZMII is not set
+# CONFIG_ICE is not set
+# CONFIG_ICP10100 is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_IDEAPAD_LAPTOP is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_IDPF is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_IEEE802154_ADF7242 is not set
+# CONFIG_IEEE802154_ATUSB is not set
+# CONFIG_IEEE802154_CA8210 is not set
+# CONFIG_IEEE802154_HWSIM is not set
+# CONFIG_IEEE802154_MCR20A is not set
+# CONFIG_IFB is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IGC is not set
+# CONFIG_IIO is not set
+# CONFIG_IIO_BUFFER is not set
+# CONFIG_IIO_BUFFER_CB is not set
+# CONFIG_IIO_BUFFER_DMA is not set
+# CONFIG_IIO_BUFFER_DMAENGINE is not set
+# CONFIG_IIO_BUFFER_HW_CONSUMER is not set
+# CONFIG_IIO_CONFIGFS is not set
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+# CONFIG_IIO_CROS_EC_ACCEL_LEGACY is not set
+# CONFIG_IIO_INTERRUPT_TRIGGER is not set
+# CONFIG_IIO_KX022A_I2C is not set
+# CONFIG_IIO_KX022A_SPI is not set
+# CONFIG_IIO_MUX is not set
+# CONFIG_IIO_RESCALE is not set
+# CONFIG_IIO_SIMPLE_DUMMY is not set
+# CONFIG_IIO_SSP_SENSORHUB is not set
+# CONFIG_IIO_ST_ACCEL_3AXIS is not set
+# CONFIG_IIO_ST_GYRO_3AXIS is not set
+# CONFIG_IIO_ST_LSM6DSX is not set
+# CONFIG_IIO_ST_LSM9DS0 is not set
+# CONFIG_IIO_ST_MAGN_3AXIS is not set
+# CONFIG_IIO_ST_PRESS is not set
+# CONFIG_IIO_SW_DEVICE is not set
+# CONFIG_IIO_SW_TRIGGER is not set
+# CONFIG_IIO_SYSFS_TRIGGER is not set
+# CONFIG_IIO_TRIGGER is not set
+# CONFIG_IIO_TRIGGERED_EVENT is not set
+# CONFIG_IKCONFIG is not set
+# CONFIG_IKCONFIG_PROC is not set
+# CONFIG_IKHEADERS is not set
+# CONFIG_IMA is not set
+# CONFIG_IMGPDC_WDT is not set
+# CONFIG_IMG_MDC_DMA is not set
+# CONFIG_IMX7D_ADC is not set
+# CONFIG_IMX8QXP_ADC is not set
+# CONFIG_IMX93_ADC is not set
+# CONFIG_IMX_IPUV3_CORE is not set
+# CONFIG_IMX_SCMI_MISC_DRV is not set
+# CONFIG_IMX_THERMAL is not set
+# CONFIG_INA2XX_ADC is not set
+# CONFIG_INDIRECT_PIO is not set
+CONFIG_INET=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_ESPINTCP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_ESPINTCP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TABLE_PERTURB_ORDER=16
+# CONFIG_INET_TCP_DIAG is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_INFTL is not set
+# CONFIG_INGENIC_ADC is not set
+# CONFIG_INGENIC_CGU_JZ4725B is not set
+# CONFIG_INGENIC_CGU_JZ4740 is not set
+# CONFIG_INGENIC_CGU_JZ4755 is not set
+# CONFIG_INGENIC_CGU_JZ4760 is not set
+# CONFIG_INGENIC_CGU_JZ4770 is not set
+# CONFIG_INGENIC_CGU_JZ4780 is not set
+# CONFIG_INGENIC_CGU_X1000 is not set
+# CONFIG_INGENIC_CGU_X1830 is not set
+# CONFIG_INGENIC_OST is not set
+# CONFIG_INGENIC_SYSOST is not set
+# CONFIG_INGENIC_TCU_CLK is not set
+# CONFIG_INGENIC_TCU_IRQ is not set
+# CONFIG_INGENIC_TIMER is not set
+# CONFIG_INITRAMFS_PRESERVE_MTIME is not set
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# CONFIG_INIT_STACK_ALL_PATTERN is not set
+# CONFIG_INIT_STACK_ALL_ZERO is not set
+CONFIG_INIT_STACK_NONE=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_APANEL is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
+# CONFIG_INPUT_AXP20X_PEK is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DA7280_HAPTICS is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_GPIO_VIBRA is not set
+# CONFIG_INPUT_IBM_PANEL is not set
+# CONFIG_INPUT_IDEAPAD_SLIDEBAR is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_IQS269A is not set
+# CONFIG_INPUT_IQS626A is not set
+# CONFIG_INPUT_IQS7222 is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_LEDS is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+# CONFIG_INPUT_MAX8997_HAPTIC is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_PALMAS_PWRBUTTON is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_PM8941_PWRKEY is not set
+# CONFIG_INPUT_PM8XXX_VIBRATOR is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_PWM_VIBRA is not set
+# CONFIG_INPUT_REGULATOR_HAPTIC is not set
+# CONFIG_INPUT_SOC_BUTTON_ARRAY is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_TPS65218_PWRBUTTON is not set
+# CONFIG_INPUT_TWL4030_PWRBUTTON is not set
+# CONFIG_INPUT_TWL4030_VIBRA is not set
+# CONFIG_INPUT_TWL6040_VIBRA is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_WISTRON_BTNS is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INT340X_THERMAL is not set
+# CONFIG_INTEGRITY is not set
+# CONFIG_INTEGRITY_AUDIT is not set
+# CONFIG_INTEGRITY_SIGNATURE is not set
+# CONFIG_INTEL_ATOMISP2_LED is not set
+# CONFIG_INTEL_ATOMISP2_PM is not set
+# CONFIG_INTEL_HID_EVENT is not set
+# CONFIG_INTEL_IDLE is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_INTEL_INT0002_VGPIO is not set
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_INTEL_ISH_HID is not set
+# CONFIG_INTEL_MEI is not set
+# CONFIG_INTEL_MEI_GSC_PROXY is not set
+# CONFIG_INTEL_MEI_HDCP is not set
+# CONFIG_INTEL_MEI_ME is not set
+# CONFIG_INTEL_MEI_PXP is not set
+# CONFIG_INTEL_MEI_TXE is not set
+# CONFIG_INTEL_OAKTRAIL is not set
+# CONFIG_INTEL_PMC_CORE is not set
+# CONFIG_INTEL_PUNIT_IPC is not set
+# CONFIG_INTEL_RST is not set
+# CONFIG_INTEL_SMARTCONNECT is not set
+# CONFIG_INTEL_SOC_PMIC is not set
+# CONFIG_INTEL_SOC_PMIC_CHTDC_TI is not set
+# CONFIG_INTEL_SOC_PMIC_CHTWC is not set
+# CONFIG_INTEL_TH is not set
+# CONFIG_INTEL_VBTN is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_INV_ICM42600_I2C is not set
+# CONFIG_INV_ICM42600_SPI is not set
+# CONFIG_INV_MPU6050_I2C is not set
+# CONFIG_INV_MPU6050_IIO is not set
+# CONFIG_INV_MPU6050_SPI is not set
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_IONIC is not set
+# CONFIG_IOSCHED_BFQ is not set
+# CONFIG_IOSM is not set
+CONFIG_IO_STRICT_DEVMEM=y
+# CONFIG_IO_URING is not set
+CONFIG_IO_WQ=y
+# CONFIG_IP17XX_PHY is not set
+# CONFIG_IP5XXX_POWER is not set
+# CONFIG_IP6_NF_FILTER is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP6_NF_MANGLE is not set
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_MATCH_SRH is not set
+# CONFIG_IP6_NF_NAT is not set
+# CONFIG_IP6_NF_RAW is not set
+# CONFIG_IP6_NF_SECURITY is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+# CONFIG_IP6_NF_TARGET_MASQUERADE is not set
+# CONFIG_IP6_NF_TARGET_REJECT is not set
+# CONFIG_IP6_NF_TARGET_SYNPROXY is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_IPMB_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPU_BRIDGE is not set
+# CONFIG_IPV6 is not set
+# CONFIG_IPV6_FOU is not set
+# CONFIG_IPV6_FOU_TUNNEL is not set
+# CONFIG_IPV6_ILA is not set
+# CONFIG_IPV6_IOAM6_LWTUNNEL is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_ROUTE_INFO is not set
+# CONFIG_IPV6_RPL_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_SIT_6RD is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_VTI is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_IPVTAP is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2100_DEBUG is not set
+CONFIG_IPW2100_MONITOR=y
+# CONFIG_IPW2200 is not set
+# CONFIG_IPW2200_DEBUG is not set
+CONFIG_IPW2200_MONITOR=y
+# CONFIG_IPW2200_PROMISCUOUS is not set
+# CONFIG_IPW2200_QOS is not set
+# CONFIG_IPW2200_RADIOTAP is not set
+# CONFIG_IPWIRELESS is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_FIB_TRIE_STATS is not set
+# CONFIG_IP_MROUTE is not set
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_NF_ARPFILTER is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_ARP_MANGLE is not set
+# CONFIG_IP_NF_FILTER is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_SECURITY is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_MASQUERADE is not set
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_IP_PNP is not set
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_SCTP is not set
+# CONFIG_IP_SET is not set
+# CONFIG_IP_SET_HASH_IPMAC is not set
+# CONFIG_IP_VS is not set
+# CONFIG_IP_VS_MH is not set
+CONFIG_IP_VS_MH_TAB_INDEX=10
+# CONFIG_IP_VS_TWOS is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_IRQ_ALL_CPUS is not set
+# CONFIG_IRQ_POLL is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_IRSD200 is not set
+# CONFIG_IR_GPIO_CIR is not set
+# CONFIG_IR_HIX5HD2 is not set
+# CONFIG_IR_IGORPLUGUSB is not set
+# CONFIG_IR_IGUANA is not set
+# CONFIG_IR_IMG is not set
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_IMON_RAW is not set
+# CONFIG_IR_JVC_DECODER is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_NEC_DECODER is not set
+# CONFIG_IR_RC5_DECODER is not set
+# CONFIG_IR_RC6_DECODER is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_SERIAL is not set
+# CONFIG_IR_SONY_DECODER is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_IR_TOY is not set
+# CONFIG_IR_TTUSBIR is not set
+# CONFIG_ISA_BUS is not set
+# CONFIG_ISA_BUS_API is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_ISCSI_TCP is not set
+CONFIG_ISDN=y
+# CONFIG_ISDN_CAPI is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_ISL29125 is not set
+# CONFIG_ISL29501 is not set
+# CONFIG_ISL76682 is not set
+# CONFIG_ISO9660_FS is not set
+# CONFIG_ISS4xx is not set
+# CONFIG_ITG3200 is not set
+# CONFIG_IWL3945 is not set
+# CONFIG_IWLWIFI is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+# CONFIG_JAILHOUSE_GUEST is not set
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_POSIX_ACL is not set
+# CONFIG_JFFS2_FS_SECURITY is not set
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_LZMA=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_ZLIB is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_POSIX_ACL is not set
+# CONFIG_JFS_SECURITY is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_JME is not set
+CONFIG_JOLIET=y
+# CONFIG_JSA1212 is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_JZ4740_WDT is not set
+# CONFIG_KALLSYMS is not set
+# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_SELFTEST is not set
+# CONFIG_KALLSYMS_UNCOMPRESSED is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_KASAN is not set
+# CONFIG_KASAN_MODULE_TEST is not set
+CONFIG_KASAN_STACK=y
+# CONFIG_KCMP is not set
+# CONFIG_KCOV is not set
+CONFIG_KCOV_IRQ_AREA_SIZE=0x40000
+# CONFIG_KCSAN is not set
+# CONFIG_KEBA_CP500 is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZ4 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_ZSTD is not set
+CONFIG_KERNFS=y
+# CONFIG_KEXEC is not set
+# CONFIG_KEXEC_FILE is not set
+# CONFIG_KEXEC_SIG is not set
+# CONFIG_KEYBOARD_ADC is not set
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+# CONFIG_KEYBOARD_APPLESPI is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_BCM is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_CYPRESS_SF is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_MT6779 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_PINEPHONE is not set
+# CONFIG_KEYBOARD_PXA27x is not set
+# CONFIG_KEYBOARD_QT1050 is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_SH_KEYSC is not set
+# CONFIG_KEYBOARD_SNVS_PWRKEY is not set
+# CONFIG_KEYBOARD_STMPE is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_TEGRA is not set
+# CONFIG_KEYBOARD_TM2_TOUCHKEY is not set
+# CONFIG_KEYBOARD_TWL4030 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYS is not set
+# CONFIG_KEYS_REQUEST_CACHE is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_KFENCE is not set
+# CONFIG_KGDB is not set
+# CONFIG_KMX61 is not set
+# CONFIG_KPROBES is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_KPROBE_EVENTS_ON_NOTRACE is not set
+# CONFIG_KPROBE_EVENT_GEN_TEST is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSM is not set
+# CONFIG_KSZ884X_PCI is not set
+# CONFIG_KUNIT is not set
+CONFIG_KUSER_HELPERS=y
+# CONFIG_KVM_AMD is not set
+# CONFIG_KVM_AMD_SEV is not set
+# CONFIG_KVM_GUEST is not set
+# CONFIG_KVM_INTEL is not set
+# CONFIG_KVM_WERROR is not set
+# CONFIG_KVM_XEN is not set
+# CONFIG_KXCJK1013 is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_L2TP is not set
+# CONFIG_L2TP_ETH is not set
+# CONFIG_L2TP_IP is not set
+# CONFIG_L2TP_V3 is not set
+# CONFIG_LAN743X is not set
+# CONFIG_LAN865X is not set
+# CONFIG_LAN966X_OIC is not set
+# CONFIG_LAN966X_SWITCH is not set
+# CONFIG_LANTIQ is not set
+# CONFIG_LAPB is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_CLASS_DEVICE is not set
+# CONFIG_LCD_HX8357 is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_OTM3225A is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+CONFIG_LDISC_AUTOLOAD=y
+# CONFIG_LDM_PARTITION is not set
+CONFIG_LD_DEAD_CODE_DATA_ELIMINATION=y
+# CONFIG_LD_HEAD_STUB_CATCH is not set
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_APU is not set
+# CONFIG_LEDS_AW200XX is not set
+# CONFIG_LEDS_AW2013 is not set
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_BD2606MVV is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_BLINKM is not set
+CONFIG_LEDS_BRIGHTNESS_HW_CHANGED=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+CONFIG_LEDS_CLASS_MULTICOLOR=y
+# CONFIG_LEDS_CR0014114 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_EL15203000 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_GROUP_MULTICOLOR is not set
+# CONFIG_LEDS_INTEL_SS4200 is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+# CONFIG_LEDS_KTD202X is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3532 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LM3692X is not set
+# CONFIG_LEDS_LM3697 is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP50XX is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP5569 is not set
+# CONFIG_LEDS_LP55XX_COMMON is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_MLXCPLD is not set
+# CONFIG_LEDS_MLXREG is not set
+# CONFIG_LEDS_NCP5623 is not set
+# CONFIG_LEDS_NIC78BX is not set
+# CONFIG_LEDS_NS2 is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_PCA995X is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_PWM_MULTICOLOR is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_SPI_BYTE is not set
+# CONFIG_LEDS_ST1202 is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TI_LMU_COMMON is not set
+# CONFIG_LEDS_TLC591XX is not set
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_ACTIVITY is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+# CONFIG_LEDS_TRIGGER_DISK is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_INPUT_EVENTS is not set
+# CONFIG_LEDS_TRIGGER_MTD is not set
+CONFIG_LEDS_TRIGGER_NETDEV=y
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+# CONFIG_LEDS_TRIGGER_PANIC is not set
+# CONFIG_LEDS_TRIGGER_PATTERN is not set
+CONFIG_LEDS_TRIGGER_TIMER=y
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_TTY is not set
+# CONFIG_LEDS_TURRIS_OMNIA is not set
+# CONFIG_LEDS_USER is not set
+# CONFIG_LED_TRIGGER_PHY is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LEGACY_TIOCSTI is not set
+# CONFIG_LIB80211 is not set
+# CONFIG_LIB80211_CRYPT_CCMP is not set
+# CONFIG_LIB80211_CRYPT_TKIP is not set
+# CONFIG_LIB80211_CRYPT_WEP is not set
+# CONFIG_LIB80211_DEBUG is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_LIBERTAS_USB is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_LIBIPW_DEBUG is not set
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_LIDAR_LITE_V2 is not set
+CONFIG_LINEAR_RANGES=y
+# CONFIG_LIQUIDIO is not set
+# CONFIG_LIQUIDIO_VF is not set
+# CONFIG_LIRC is not set
+CONFIG_LIST_HARDENED=y
+# CONFIG_LITEX_LITEETH is not set
+# CONFIG_LITEX_SOC_CONTROLLER is not set
+# CONFIG_LIVEPATCH is not set
+# CONFIG_LKDTM is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_LMK04832 is not set
+# CONFIG_LMP91000 is not set
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_LOCKD is not set
+CONFIG_LOCKDEP_BITS=15
+CONFIG_LOCKDEP_CHAINS_BITS=16
+CONFIG_LOCKDEP_CIRCULAR_QUEUE_BITS=12
+CONFIG_LOCKDEP_STACK_TRACE_BITS=19
+CONFIG_LOCKDEP_STACK_TRACE_HASH_BITS=14
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_LOCKD_V4=y
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_LOCK_EVENT_COUNTS is not set
+CONFIG_LOCK_MM_AND_FIND_VMA=y
+# CONFIG_LOCK_STAT is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+# CONFIG_LOGO is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+# CONFIG_LOONGSON_MC146818 is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_LP_CONSOLE is not set
+CONFIG_LRU_GEN=y
+CONFIG_LRU_GEN_ENABLED=y
+# CONFIG_LRU_GEN_STATS is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+CONFIG_LSM_MMAP_MIN_ADDR=65536
+# CONFIG_LTC1660 is not set
+# CONFIG_LTC2309 is not set
+# CONFIG_LTC2471 is not set
+# CONFIG_LTC2485 is not set
+# CONFIG_LTC2496 is not set
+# CONFIG_LTC2497 is not set
+# CONFIG_LTC2632 is not set
+# CONFIG_LTC2664 is not set
+# CONFIG_LTC2688 is not set
+# CONFIG_LTC2983 is not set
+# CONFIG_LTE_GDM724X is not set
+CONFIG_LTO_NONE=y
+# CONFIG_LTR390 is not set
+# CONFIG_LTR501 is not set
+# CONFIG_LTRF216A is not set
+# CONFIG_LV0104CS is not set
+# CONFIG_LWQ_TEST is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_LZ4HC_COMPRESS is not set
+# CONFIG_LZ4_COMPRESS is not set
+# CONFIG_LZ4_DECOMPRESS is not set
+CONFIG_LZMA_COMPRESS=y
+CONFIG_LZMA_DECOMPRESS=y
+# CONFIG_LZO_COMPRESS is not set
+# CONFIG_LZO_DECOMPRESS is not set
+# CONFIG_M62332 is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_MACB is not set
+# CONFIG_MACH_ASM9260 is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_INGENIC is not set
+# CONFIG_MACH_INGENIC_SOC is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_MACH_JZ4740 is not set
+# CONFIG_MACH_LOONGSON2EF is not set
+# CONFIG_MACH_LOONGSON32 is not set
+# CONFIG_MACH_LOONGSON64 is not set
+# CONFIG_MACH_NINTENDO64 is not set
+# CONFIG_MACH_PIC32 is not set
+# CONFIG_MACH_REALTEK_RTL is not set
+# CONFIG_MACH_TX49XX is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+# CONFIG_MACSEC is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_MACVTAP is not set
+# CONFIG_MAC_EMUMOUSEBTN is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MAG3110 is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+# CONFIG_MAGIC_SYSRQ_SERIAL is not set
+CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE=""
+# CONFIG_MAILBOX is not set
+# CONFIG_MANAGER_SBS is not set
+# CONFIG_MANGLE_BOOTARGS is not set
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MARVELL_88Q2XXX_PHY is not set
+# CONFIG_MARVELL_88X2222_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MAX1027 is not set
+# CONFIG_MAX11100 is not set
+# CONFIG_MAX1118 is not set
+# CONFIG_MAX11205 is not set
+# CONFIG_MAX11410 is not set
+# CONFIG_MAX1241 is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_MAX30100 is not set
+# CONFIG_MAX30102 is not set
+# CONFIG_MAX30208 is not set
+# CONFIG_MAX31827 is not set
+# CONFIG_MAX31856 is not set
+# CONFIG_MAX31865 is not set
+# CONFIG_MAX34408 is not set
+# CONFIG_MAX44000 is not set
+# CONFIG_MAX44009 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MAX5432 is not set
+# CONFIG_MAX5481 is not set
+# CONFIG_MAX5487 is not set
+# CONFIG_MAX5522 is not set
+# CONFIG_MAX5821 is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_MAX9611 is not set
+# CONFIG_MAXIM_THERMOCOUPLE is not set
+# CONFIG_MAXLINEAR_GPHY is not set
+CONFIG_MAX_SKB_FRAGS=17
+# CONFIG_MB1232 is not set
+# CONFIG_MC3230 is not set
+# CONFIG_MCB is not set
+# CONFIG_MCP320X is not set
+# CONFIG_MCP3422 is not set
+# CONFIG_MCP3564 is not set
+# CONFIG_MCP3911 is not set
+# CONFIG_MCP4018 is not set
+# CONFIG_MCP41010 is not set
+# CONFIG_MCP4131 is not set
+# CONFIG_MCP4531 is not set
+# CONFIG_MCP4725 is not set
+# CONFIG_MCP4728 is not set
+# CONFIG_MCP4821 is not set
+# CONFIG_MCP4922 is not set
+# CONFIG_MCP9600 is not set
+# CONFIG_MCPM is not set
+# CONFIG_MCTP is not set
+# CONFIG_MD is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+# CONFIG_MDIO_DEVICE is not set
+# CONFIG_MDIO_DEVRES is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_IPQ4019 is not set
+# CONFIG_MDIO_IPQ8064 is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+# CONFIG_MDIO_MVUSB is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MDIO_THUNDER is not set
+# CONFIG_MDM_GCC_9607 is not set
+# CONFIG_MD_BITMAP_FILE is not set
+# CONFIG_MEDIATEK_GE_PHY is not set
+# CONFIG_MEDIATEK_MT6577_AUXADC is not set
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_ATTACH is not set
+# CONFIG_MEDIA_CAMERA_SUPPORT is not set
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+# CONFIG_MEDIA_CONTROLLER is not set
+# CONFIG_MEDIA_CONTROLLER_DVB is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_PCI_SUPPORT is not set
+# CONFIG_MEDIA_PLATFORM_DRIVERS is not set
+# CONFIG_MEDIA_PLATFORM_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+# CONFIG_MEDIA_SUPPORT is not set
+# CONFIG_MEDIA_SUPPORT_FILTER is not set
+# CONFIG_MEDIA_TEST_SUPPORT is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_USB_SUPPORT is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_MEMBARRIER=y
+CONFIG_MEMFD_CREATE=y
+# CONFIG_MEMORY is not set
+# CONFIG_MEMORY_FAILURE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_MEM_ALLOC_PROFILING is not set
+# CONFIG_MEN_A21_WDT is not set
+# CONFIG_MESON_SM is not set
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_88PM886_PMIC is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_AC100 is not set
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_ADP5585 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_MFD_ATC260X_I2C is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_AXP20X is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_CS40L50_I2C is not set
+# CONFIG_MFD_CS40L50_SPI is not set
+# CONFIG_MFD_CS42L43_I2C is not set
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_EXYNOS_LPASS is not set
+# CONFIG_MFD_GATEWORKS_GSC is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_MFD_INTEL_M10_BMC_SPI is not set
+# CONFIG_MFD_INTEL_QUARK_I2C_GPIO is not set
+# CONFIG_MFD_IQS62X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX5970 is not set
+# CONFIG_MFD_MAX77541 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77650 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77714 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_MFD_MP2629 is not set
+# CONFIG_MFD_MT6360 is not set
+# CONFIG_MFD_MT6370 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_NTXEC is not set
+# CONFIG_MFD_OCELOT is not set
+# CONFIG_MFD_OMAP_USB_HOST is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_QCOM_PM8008 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_RK8XX_I2C is not set
+# CONFIG_MFD_RK8XX_SPI is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_ROHM_BD71828 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_MFD_ROHM_BD957XMUF is not set
+# CONFIG_MFD_ROHM_BD96801 is not set
+# CONFIG_MFD_RSMU_I2C is not set
+# CONFIG_MFD_RSMU_SPI is not set
+# CONFIG_MFD_RT4831 is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RT5120 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SL28CPLD is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMPRO is not set
+# CONFIG_MFD_STMFX is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_STPMIC1 is not set
+# CONFIG_MFD_SY7636A is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS65219 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS6594_I2C is not set
+# CONFIG_MFD_TPS6594_SPI is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MHI_BUS is not set
+# CONFIG_MHI_BUS_DEBUG is not set
+# CONFIG_MHI_BUS_EP is not set
+# CONFIG_MHI_BUS_PCI_GENERIC is not set
+# CONFIG_MHI_NET is not set
+# CONFIG_MHI_WWAN_CTRL is not set
+# CONFIG_MHI_WWAN_MBIM is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_PIT64B is not set
+# CONFIG_MICROCHIP_T1S_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_MIGRATION is not set
+CONFIG_MII=y
+# CONFIG_MIKROTIK is not set
+# CONFIG_MIKROTIK_RB532 is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_MINIX_FS_NATIVE_ENDIAN is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_MIPS32_N32 is not set
+# CONFIG_MIPS32_O32 is not set
+# CONFIG_MIPS_ALCHEMY is not set
+# CONFIG_MIPS_CDMM is not set
+# CONFIG_MIPS_CMDLINE_DTB_EXTEND is not set
+# CONFIG_MIPS_CMDLINE_FROM_DTB is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MIPS_CPS is not set
+# CONFIG_MIPS_ELF_APPENDED_DTB is not set
+# CONFIG_MIPS_FP_SUPPORT is not set
+# CONFIG_MIPS_GENERIC is not set
+# CONFIG_MIPS_GENERIC_KERNEL is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_O32_FP64_SUPPORT is not set
+# CONFIG_MIPS_PLATFORM_DEVICES is not set
+# CONFIG_MIPS_RAW_APPENDED_DTB is not set
+# CONFIG_MIPS_VA_BITS_48 is not set
+# CONFIG_MIPS_VPE_LOADER is not set
+# CONFIG_MISC_ALCOR_PCI is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_MISC_RTSX_PCI is not set
+# CONFIG_MISC_RTSX_USB is not set
+# CONFIG_MISDN is not set
+# CONFIG_MISDN_AVMFRITZ is not set
+# CONFIG_MISDN_HFCPCI is not set
+# CONFIG_MISDN_HFCUSB is not set
+# CONFIG_MISDN_INFINEON is not set
+# CONFIG_MISDN_NETJET is not set
+# CONFIG_MISDN_SPEEDFAX is not set
+# CONFIG_MISDN_W6692 is not set
+CONFIG_MITIGATE_SPECTRE_BRANCH_HISTORY=y
+# CONFIG_MKISS is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX5_CORE is not set
+# CONFIG_MLX5_DPLL is not set
+# CONFIG_MLX5_MACSEC is not set
+# CONFIG_MLX5_SF is not set
+# CONFIG_MLX5_VFIO_PCI is not set
+# CONFIG_MLX90614 is not set
+# CONFIG_MLX90632 is not set
+# CONFIG_MLX90635 is not set
+# CONFIG_MLXFW is not set
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MLX_PLATFORM is not set
+# CONFIG_MMA7455_I2C is not set
+# CONFIG_MMA7455_SPI is not set
+# CONFIG_MMA7660 is not set
+# CONFIG_MMA8452 is not set
+# CONFIG_MMA9551 is not set
+# CONFIG_MMA9553 is not set
+# CONFIG_MMC is not set
+# CONFIG_MMC35240 is not set
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_AU1X is not set
+# CONFIG_MMC_BLOCK is not set
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_MMC_CAVIUM_THUNDERX is not set
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_CQHCI is not set
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_HSQ is not set
+# CONFIG_MMC_JZ4740 is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_MVSDIO is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_ACPI is not set
+# CONFIG_MMC_SDHCI_AM654 is not set
+# CONFIG_MMC_SDHCI_BCM_KONA is not set
+# CONFIG_MMC_SDHCI_BRCMSTB is not set
+# CONFIG_MMC_SDHCI_CADENCE is not set
+# CONFIG_MMC_SDHCI_F_SDH30 is not set
+# CONFIG_MMC_SDHCI_IPROC is not set
+# CONFIG_MMC_SDHCI_MILBEAUT is not set
+# CONFIG_MMC_SDHCI_MSM is not set
+# CONFIG_MMC_SDHCI_OF_ARASAN is not set
+# CONFIG_MMC_SDHCI_OF_ASPEED is not set
+# CONFIG_MMC_SDHCI_OF_AT91 is not set
+# CONFIG_MMC_SDHCI_OF_DWCMSHC is not set
+# CONFIG_MMC_SDHCI_OF_ESDHC is not set
+# CONFIG_MMC_SDHCI_OF_HLWD is not set
+# CONFIG_MMC_SDHCI_OMAP is not set
+# CONFIG_MMC_SDHCI_PCI is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_S3C is not set
+# CONFIG_MMC_SDHCI_XENON is not set
+# CONFIG_MMC_SDRICOH_CS is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_STM32_SDMMC is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_TIFM_SD is not set
+# CONFIG_MMC_TOSHIBA_PCI is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMIOTRACE is not set
+CONFIG_MMU=y
+CONFIG_MMU_GATHER_RCU_TABLE_FREE=y
+CONFIG_MMU_GATHER_TABLE_FREE=y
+CONFIG_MODPROBE_PATH="/sbin/modprobe"
+CONFIG_MODULES=y
+# CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_MODULE_COMPRESS_GZIP is not set
+# CONFIG_MODULE_COMPRESS_XZ is not set
+# CONFIG_MODULE_COMPRESS_ZSTD is not set
+# CONFIG_MODULE_DEBUG is not set
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_MODULE_STRIPPED=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_UNLOAD_TAINT_TRACKING is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MOST is not set
+# CONFIG_MOTORCOMM_PHY is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_INPORT is not set
+# CONFIG_MOUSE_LOGIBM is not set
+# CONFIG_MOUSE_PC110PAD is not set
+# CONFIG_MOUSE_PS2_FOCALTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_MOXTET is not set
+# CONFIG_MPL115 is not set
+# CONFIG_MPL115_I2C is not set
+# CONFIG_MPL115_SPI is not set
+# CONFIG_MPL3115 is not set
+# CONFIG_MPLS is not set
+# CONFIG_MPLS_IPTUNNEL is not set
+# CONFIG_MPLS_ROUTING is not set
+# CONFIG_MPRLS0025PA is not set
+# CONFIG_MPTCP is not set
+# CONFIG_MPU3050_I2C is not set
+# CONFIG_MQ_IOSCHED_DEADLINE is not set
+# CONFIG_MQ_IOSCHED_KYBER is not set
+# CONFIG_MS5611 is not set
+# CONFIG_MS5637 is not set
+# CONFIG_MSA311 is not set
+# CONFIG_MSCC_OCELOT_SWITCH is not set
+# CONFIG_MSDOS_FS is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_MSE102X is not set
+# CONFIG_MSI_BITMAP_SELFTEST is not set
+# CONFIG_MSI_LAPTOP is not set
+# CONFIG_MSM_GCC_8953 is not set
+# CONFIG_MSM_MMCC_8994 is not set
+# CONFIG_MST_IRQ is not set
+CONFIG_MTD=y
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_MTD_BLOCK2MTD is not set
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_CMDLINE_PARTS is not set
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_HYPERBUS is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MCHP23K256 is not set
+# CONFIG_MTD_MCHP48L640 is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_MYLOADER_PARTS is not set
+# CONFIG_MTD_NAND_AMS_DELTA is not set
+# CONFIG_MTD_NAND_ARASAN is not set
+# CONFIG_MTD_NAND_ATMEL is not set
+# CONFIG_MTD_NAND_AU1550 is not set
+# CONFIG_MTD_NAND_BRCMNAND is not set
+# CONFIG_MTD_NAND_BRCMNAND_BCM63XX is not set
+# CONFIG_MTD_NAND_BRCMNAND_BCMBCA is not set
+# CONFIG_MTD_NAND_BRCMNAND_BRCMSTB is not set
+# CONFIG_MTD_NAND_BRCMNAND_IPROC is not set
+# CONFIG_MTD_NAND_CADENCE is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_CS553X is not set
+# CONFIG_MTD_NAND_DAVINCI is not set
+# CONFIG_MTD_NAND_DENALI is not set
+# CONFIG_MTD_NAND_DENALI_DT is not set
+# CONFIG_MTD_NAND_DENALI_PCI is not set
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_ECC is not set
+# CONFIG_MTD_NAND_ECC_MXIC is not set
+# CONFIG_MTD_NAND_ECC_SW_BCH is not set
+# CONFIG_MTD_NAND_ECC_SW_HAMMING is not set
+# CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC is not set
+# CONFIG_MTD_NAND_FSL_ELBC is not set
+# CONFIG_MTD_NAND_FSL_IFC is not set
+# CONFIG_MTD_NAND_FSL_UPM is not set
+# CONFIG_MTD_NAND_FSMC is not set
+# CONFIG_MTD_NAND_GPIO is not set
+# CONFIG_MTD_NAND_GPMI_NAND is not set
+# CONFIG_MTD_NAND_HISI504 is not set
+# CONFIG_MTD_NAND_INTEL_LGM is not set
+# CONFIG_MTD_NAND_MPC5121_NFC is not set
+# CONFIG_MTD_NAND_MTK is not set
+# CONFIG_MTD_NAND_MTK_BMT is not set
+# CONFIG_MTD_NAND_MXC is not set
+# CONFIG_MTD_NAND_MXIC is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_NDFC is not set
+# CONFIG_MTD_NAND_OMAP2 is not set
+# CONFIG_MTD_NAND_OMAP_BCH_BUILD is not set
+# CONFIG_MTD_NAND_ORION is not set
+# CONFIG_MTD_NAND_PASEMI is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_NAND_RICOH is not set
+# CONFIG_MTD_NAND_S3C2410 is not set
+# CONFIG_MTD_NAND_SHARPSL is not set
+# CONFIG_MTD_NAND_SH_FLCTL is not set
+# CONFIG_MTD_NAND_SOCRATES is not set
+# CONFIG_MTD_NAND_TXX9NDFMC is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_PARSER_TRX is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+# CONFIG_MTD_PCI is not set
+# CONFIG_MTD_PCMCIA is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+# CONFIG_MTD_PHYSMAP_GEMINI is not set
+# CONFIG_MTD_PHYSMAP_GPIO_ADDR is not set
+# CONFIG_MTD_PHYSMAP_IXP4XX is not set
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_PHYSMAP_VERSATILE is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_RAW_NAND is not set
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_ROM is not set
+CONFIG_MTD_ROOTFS_ROOT_DEV=y
+# CONFIG_MTD_ROUTERBOOT_PARTS is not set
+# CONFIG_MTD_SERCOMM_PARTS is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_SPI_NAND is not set
+# CONFIG_MTD_SPI_NOR is not set
+# CONFIG_MTD_SPI_NOR_SWP_DISABLE is not set
+CONFIG_MTD_SPI_NOR_SWP_DISABLE_ON_VOLATILE=y
+# CONFIG_MTD_SPI_NOR_SWP_KEEP is not set
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+# CONFIG_MTD_SPI_NOR_USE_VARIABLE_ERASE is not set
+CONFIG_MTD_SPLIT=y
+# CONFIG_MTD_SPLIT_BCM63XX_FW is not set
+# CONFIG_MTD_SPLIT_BCM_WFI_FW is not set
+# CONFIG_MTD_SPLIT_BRNIMAGE_FW is not set
+# CONFIG_MTD_SPLIT_ELF_FW is not set
+# CONFIG_MTD_SPLIT_EVA_FW is not set
+# CONFIG_MTD_SPLIT_FIRMWARE is not set
+CONFIG_MTD_SPLIT_FIRMWARE_NAME="firmware"
+# CONFIG_MTD_SPLIT_FIT_FW is not set
+# CONFIG_MTD_SPLIT_H3C_VFS is not set
+# CONFIG_MTD_SPLIT_JIMAGE_FW is not set
+# CONFIG_MTD_SPLIT_LZMA_FW is not set
+# CONFIG_MTD_SPLIT_MINOR_FW is not set
+# CONFIG_MTD_SPLIT_SEAMA_FW is not set
+# CONFIG_MTD_SPLIT_SEIL_FW is not set
+CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
+CONFIG_MTD_SPLIT_SUPPORT=y
+# CONFIG_MTD_SPLIT_TPLINK_FW is not set
+# CONFIG_MTD_SPLIT_TRX_FW is not set
+# CONFIG_MTD_SPLIT_UIMAGE_FW is not set
+# CONFIG_MTD_SPLIT_WRGG_FW is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_NVMEM is not set
+# CONFIG_MTD_VIRT_CONCAT is not set
+# CONFIG_MTK_DEVAPC is not set
+# CONFIG_MTK_MMSYS is not set
+# CONFIG_MTK_T7XX is not set
+# CONFIG_MTK_THERMAL is not set
+# CONFIG_MULTIPLEXER is not set
+CONFIG_MULTIUSER=y
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_MUX_ADG792A is not set
+# CONFIG_MUX_ADGS1408 is not set
+# CONFIG_MUX_GPIO is not set
+# CONFIG_MUX_MMIO is not set
+# CONFIG_MV643XX_ETH is not set
+# CONFIG_MVMDIO is not set
+# CONFIG_MVNETA_BM is not set
+# CONFIG_MV_XOR_V2 is not set
+# CONFIG_MWAVE is not set
+# CONFIG_MWL8K is not set
+# CONFIG_MXC4005 is not set
+# CONFIG_MXC6255 is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NAU7802 is not set
+# CONFIG_NBPFAXI_DMA is not set
+# CONFIG_NCN26000_PHY is not set
+# CONFIG_NE2000 is not set
+# CONFIG_NE2K_PCI is not set
+CONFIG_NEED_TASKS_RCU=y
+CONFIG_NET=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETCONSOLE_EXTENDED_LOG is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+# CONFIG_NETFILTER_EGRESS is not set
+# CONFIG_NETFILTER_INGRESS is not set
+# CONFIG_NETFILTER_NETLINK is not set
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_GLUE_CT is not set
+# CONFIG_NETFILTER_NETLINK_HOOK is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NETFILTER_NETLINK_OSF is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_NETFILTER_XTABLES_COMPAT is not set
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_SECMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFS_DEBUG is not set
+# CONFIG_NETFS_STATS is not set
+# CONFIG_NETKIT is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETROM is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NET_9P is not set
+# CONFIG_NET_9P_USBG is not set
+# CONFIG_NET_ACT_BPF is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_CT is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_GATE is not set
+# CONFIG_NET_ACT_IFE is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_MPLS is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_SAMPLE is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_SKBMOD is not set
+# CONFIG_NET_ACT_TUNNEL_KEY is not set
+# CONFIG_NET_ACT_VLAN is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_ACT is not set
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_FLOWER is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_MATCHALL is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_U32 is not set
+CONFIG_NET_CORE=y
+# CONFIG_NET_DEVLINK is not set
+# CONFIG_NET_DEV_REFCNT_TRACKER is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_NET_DSA_AR9331 is not set
+# CONFIG_NET_DSA_BCM_SF2 is not set
+# CONFIG_NET_DSA_LANTIQ_GSWIP is not set
+# CONFIG_NET_DSA_LOOP is not set
+# CONFIG_NET_DSA_MICROCHIP_KSZ_COMMON is not set
+# CONFIG_NET_DSA_MSCC_FELIX is not set
+# CONFIG_NET_DSA_MSCC_OCELOT_EXT is not set
+# CONFIG_NET_DSA_MSCC_SEVILLE is not set
+# CONFIG_NET_DSA_MT7530 is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_LEDS is not set
+# CONFIG_NET_DSA_MV88E6XXX_PTP is not set
+# CONFIG_NET_DSA_QCA8K is not set
+# CONFIG_NET_DSA_QCA8K_LEDS_SUPPORT is not set
+# CONFIG_NET_DSA_REALTEK is not set
+# CONFIG_NET_DSA_REALTEK_SMI is not set
+# CONFIG_NET_DSA_SJA1105 is not set
+# CONFIG_NET_DSA_SMSC_LAN9303_I2C is not set
+# CONFIG_NET_DSA_SMSC_LAN9303_MDIO is not set
+# CONFIG_NET_DSA_TAG_AR9331 is not set
+# CONFIG_NET_DSA_TAG_BRCM is not set
+# CONFIG_NET_DSA_TAG_BRCM_LEGACY is not set
+# CONFIG_NET_DSA_TAG_BRCM_PREPEND is not set
+# CONFIG_NET_DSA_TAG_DSA is not set
+# CONFIG_NET_DSA_TAG_EDSA is not set
+# CONFIG_NET_DSA_TAG_GSWIP is not set
+# CONFIG_NET_DSA_TAG_HELLCREEK is not set
+# CONFIG_NET_DSA_TAG_KSZ is not set
+# CONFIG_NET_DSA_TAG_LAN9303 is not set
+# CONFIG_NET_DSA_TAG_MTK is not set
+# CONFIG_NET_DSA_TAG_NONE is not set
+# CONFIG_NET_DSA_TAG_OCELOT is not set
+# CONFIG_NET_DSA_TAG_OCELOT_8021Q is not set
+# CONFIG_NET_DSA_TAG_QCA is not set
+# CONFIG_NET_DSA_TAG_RTL4_A is not set
+# CONFIG_NET_DSA_TAG_RTL8_4 is not set
+# CONFIG_NET_DSA_TAG_RZN1_A5PSW is not set
+# CONFIG_NET_DSA_TAG_SJA1105 is not set
+# CONFIG_NET_DSA_TAG_TRAILER is not set
+# CONFIG_NET_DSA_TAG_VSC73XX_8021Q is not set
+# CONFIG_NET_DSA_TAG_XRS700X is not set
+# CONFIG_NET_DSA_VITESSE_VSC73XX is not set
+# CONFIG_NET_DSA_VITESSE_VSC73XX_PLATFORM is not set
+# CONFIG_NET_DSA_VITESSE_VSC73XX_SPI is not set
+# CONFIG_NET_DSA_XRS700X_I2C is not set
+# CONFIG_NET_DSA_XRS700X_MDIO is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_EMATCH_CANID is not set
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_IPT is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_TEXT is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_NET_IPGRE_BROADCAST=y
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_IP_TUNNEL is not set
+# CONFIG_NET_KEY is not set
+# CONFIG_NET_KEY_MIGRATE is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_MEDIATEK_STAR_EMAC is not set
+# CONFIG_NET_MPLS_GSO is not set
+# CONFIG_NET_NCSI is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_NET_NS_REFCNT_TRACKER is not set
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_NET_PTP_CLASSIFY is not set
+CONFIG_NET_RX_BUSY_POLL=y
+# CONFIG_NET_SB1000 is not set
+CONFIG_NET_SCHED=y
+# CONFIG_NET_SCH_CAKE is not set
+# CONFIG_NET_SCH_CBS is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_CODEL is not set
+CONFIG_NET_SCH_DEFAULT=y
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_ETF is not set
+# CONFIG_NET_SCH_ETS is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_NET_SCH_FQ is not set
+CONFIG_NET_SCH_FQ_CODEL=y
+# CONFIG_NET_SCH_FQ_PIE is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_PLUG is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_SKBPRIO is not set
+# CONFIG_NET_SCH_TAPRIO is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SELFTESTS is not set
+CONFIG_NET_SOCK_MSG=y
+CONFIG_NET_SWITCHDEV=y
+# CONFIG_NET_TC_SKB_EXT is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_NET_UDP_TUNNEL is not set
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_NET_VENDOR_8390=y
+CONFIG_NET_VENDOR_ADAPTEC=y
+CONFIG_NET_VENDOR_ADI=y
+CONFIG_NET_VENDOR_AGERE=y
+CONFIG_NET_VENDOR_ALACRITECH=y
+CONFIG_NET_VENDOR_ALTEON=y
+CONFIG_NET_VENDOR_AMAZON=y
+CONFIG_NET_VENDOR_AMD=y
+CONFIG_NET_VENDOR_AQUANTIA=y
+CONFIG_NET_VENDOR_ARC=y
+# CONFIG_NET_VENDOR_ASIX is not set
+CONFIG_NET_VENDOR_ATHEROS=y
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_NET_VENDOR_BROCADE=y
+CONFIG_NET_VENDOR_CADENCE=y
+CONFIG_NET_VENDOR_CAVIUM=y
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_NET_VENDOR_CIRRUS=y
+CONFIG_NET_VENDOR_CISCO=y
+CONFIG_NET_VENDOR_CORTINA=y
+CONFIG_NET_VENDOR_DAVICOM=y
+CONFIG_NET_VENDOR_DEC=y
+CONFIG_NET_VENDOR_DLINK=y
+CONFIG_NET_VENDOR_EMULEX=y
+# CONFIG_NET_VENDOR_ENGLEDER is not set
+CONFIG_NET_VENDOR_EZCHIP=y
+CONFIG_NET_VENDOR_FARADAY=y
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_NET_VENDOR_FUJITSU=y
+# CONFIG_NET_VENDOR_FUNGIBLE is not set
+CONFIG_NET_VENDOR_GOOGLE=y
+CONFIG_NET_VENDOR_HISILICON=y
+CONFIG_NET_VENDOR_HUAWEI=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_IBM=y
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_NET_VENDOR_LITEX is not set
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_NET_VENDOR_META=y
+CONFIG_NET_VENDOR_MICREL=y
+CONFIG_NET_VENDOR_MICROCHIP=y
+CONFIG_NET_VENDOR_MICROSEMI=y
+# CONFIG_NET_VENDOR_MICROSOFT is not set
+CONFIG_NET_VENDOR_MYRI=y
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_NETERION=y
+CONFIG_NET_VENDOR_NETRONOME=y
+CONFIG_NET_VENDOR_NI=y
+CONFIG_NET_VENDOR_NVIDIA=y
+CONFIG_NET_VENDOR_OKI=y
+CONFIG_NET_VENDOR_PACKET_ENGINES=y
+CONFIG_NET_VENDOR_PENSANDO=y
+CONFIG_NET_VENDOR_QLOGIC=y
+CONFIG_NET_VENDOR_QUALCOMM=y
+CONFIG_NET_VENDOR_RDC=y
+CONFIG_NET_VENDOR_REALTEK=y
+CONFIG_NET_VENDOR_RENESAS=y
+CONFIG_NET_VENDOR_ROCKER=y
+CONFIG_NET_VENDOR_SAMSUNG=y
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SILAN=y
+CONFIG_NET_VENDOR_SIS=y
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_NET_VENDOR_SOCIONEXT=y
+CONFIG_NET_VENDOR_SOLARFLARE=y
+CONFIG_NET_VENDOR_STMICRO=y
+CONFIG_NET_VENDOR_SUN=y
+CONFIG_NET_VENDOR_SYNOPSYS=y
+CONFIG_NET_VENDOR_TEHUTI=y
+CONFIG_NET_VENDOR_TI=y
+CONFIG_NET_VENDOR_TOSHIBA=y
+# CONFIG_NET_VENDOR_VERTEXCOM is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_NET_VENDOR_WANGXUN is not set
+CONFIG_NET_VENDOR_WIZNET=y
+CONFIG_NET_VENDOR_XILINX=y
+CONFIG_NET_VENDOR_XIRCOM=y
+# CONFIG_NET_VRF is not set
+# CONFIG_NET_XGENE is not set
+CONFIG_NEW_LEDS=y
+# CONFIG_NFC is not set
+# CONFIG_NFP is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_LEGACY_CLIENT_TRACKING is not set
+# CONFIG_NFSD_V2 is not set
+# CONFIG_NFSD_V2_ACL is not set
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+# CONFIG_NFS_ACL_SUPPORT is not set
+CONFIG_NFS_COMMON=y
+# CONFIG_NFS_DISABLE_UDP_SUPPORT is not set
+# CONFIG_NFS_FS is not set
+# CONFIG_NFS_FSCACHE is not set
+# CONFIG_NFS_LOCALIO is not set
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V2 is not set
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFTL is not set
+# CONFIG_NFT_BRIDGE_META is not set
+# CONFIG_NFT_BRIDGE_REJECT is not set
+# CONFIG_NFT_CONNLIMIT is not set
+# CONFIG_NFT_DUP_IPV4 is not set
+# CONFIG_NFT_DUP_IPV6 is not set
+# CONFIG_NFT_FIB_IPV4 is not set
+# CONFIG_NFT_FIB_IPV6 is not set
+# CONFIG_NFT_FIB_NETDEV is not set
+# CONFIG_NFT_FLOW_OFFLOAD is not set
+# CONFIG_NFT_OSF is not set
+# CONFIG_NFT_REJECT_NETDEV is not set
+# CONFIG_NFT_SOCKET is not set
+# CONFIG_NFT_SYNPROXY is not set
+# CONFIG_NFT_TPROXY is not set
+# CONFIG_NFT_TUNNEL is not set
+# CONFIG_NFT_XFRM is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_BRIDGE is not set
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_LABELS is not set
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SECMARK is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CONNTRACK_ZONES is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_HELPER is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_GRE is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_FLOW_TABLE is not set
+# CONFIG_NF_FLOW_TABLE_PROCFS is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_LOG_SYSLOG is not set
+# CONFIG_NF_NAT is not set
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_H323 is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_SNMP_BASIC is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_SOCKET_IPV4 is not set
+# CONFIG_NF_SOCKET_IPV6 is not set
+# CONFIG_NF_TABLES is not set
+CONFIG_NF_TABLES_ARP=y
+CONFIG_NF_TABLES_BRIDGE=y
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NF_TABLES_IPV6=y
+CONFIG_NF_TABLES_NETDEV=y
+# CONFIG_NF_TPROXY_IPV4 is not set
+# CONFIG_NF_TPROXY_IPV6 is not set
+# CONFIG_NGBE is not set
+# CONFIG_NI903X_WDT is not set
+# CONFIG_NIC7018_WDT is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_NIU is not set
+# CONFIG_NI_XGE_MANAGEMENT_ENET is not set
+CONFIG_NLATTR=y
+# CONFIG_NLMON is not set
+# CONFIG_NLS is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UCS2_UTILS is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_NOA1305 is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NS83820 is not set
+# CONFIG_NTB is not set
+# CONFIG_NTFS3_64BIT_CLUSTER is not set
+# CONFIG_NTFS3_FS is not set
+# CONFIG_NTFS3_FS_POSIX_ACL is not set
+# CONFIG_NTFS3_LZX_XPRESS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTP_PPS is not set
+# CONFIG_NULL_TTY is not set
+# CONFIG_NUMA is not set
+# CONFIG_NVGRACE_GPU_VFIO_PCI is not set
+# CONFIG_NVIDIA_CARMEL_CNP_ERRATUM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_NVMEM_BCM_OCOTP is not set
+# CONFIG_NVMEM_BLOCK is not set
+# CONFIG_NVMEM_IMX_OCOTP is not set
+# CONFIG_NVMEM_LAYOUT_ASCII_ENV is not set
+# CONFIG_NVMEM_LAYOUT_MIKROTIK is not set
+# CONFIG_NVMEM_LAYOUT_ONIE_TLV is not set
+# CONFIG_NVMEM_LAYOUT_SL28_VPD is not set
+# CONFIG_NVMEM_LAYOUT_U_BOOT_ENV is not set
+# CONFIG_NVMEM_REBOOT_MODE is not set
+# CONFIG_NVMEM_RMEM is not set
+# CONFIG_NVMEM_SYSFS is not set
+# CONFIG_NVMEM_U_BOOT_ENV is not set
+# CONFIG_NVME_AUTH is not set
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_HOST_AUTH is not set
+# CONFIG_NVME_TARGET is not set
+# CONFIG_NVME_TCP is not set
+# CONFIG_NVME_VERBOSE_ERRORS is not set
+# CONFIG_NVRAM is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_NXP_C45_TJA11XX_PHY is not set
+# CONFIG_NXP_CBTX_PHY is not set
+# CONFIG_NXP_TJA11XX_PHY is not set
+# CONFIG_N_GSM is not set
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_OA_TC6 is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_OCTEONTX2_AF is not set
+# CONFIG_OCTEONTX2_PF is not set
+# CONFIG_OCTEON_EP is not set
+# CONFIG_OCTEON_EP_VF is not set
+# CONFIG_OF_OVERLAY is not set
+CONFIG_OF_PARTITION=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_UNITTEST is not set
+# CONFIG_OID_REGISTRY is not set
+# CONFIG_OMAP2_DSS_DEBUG is not set
+# CONFIG_OMAP2_DSS_DEBUGFS is not set
+# CONFIG_OMAP2_DSS_SDI is not set
+# CONFIG_OMAP_OCP2SCP is not set
+# CONFIG_OMAP_USB2 is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_OPEN_DICE is not set
+# CONFIG_OPT3001 is not set
+# CONFIG_OPT4001 is not set
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ORION_WATCHDOG is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_OSNOISE_TRACER is not set
+CONFIG_OVERLAY_FS=y
+# CONFIG_OVERLAY_FS_DEBUG is not set
+# CONFIG_OVERLAY_FS_INDEX is not set
+# CONFIG_OVERLAY_FS_METACOPY is not set
+CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW=y
+# CONFIG_OVERLAY_FS_REDIRECT_DIR is not set
+CONFIG_OVERLAY_FS_XINO_AUTO=y
+# CONFIG_P54_COMMON is not set
+# CONFIG_PA12203001 is not set
+# CONFIG_PAC1921 is not set
+# CONFIG_PAC1934 is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+# CONFIG_PACKING is not set
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_PAGE_POOL is not set
+# CONFIG_PAGE_POOL_STATS is not set
+# CONFIG_PAGE_REPORTING is not set
+CONFIG_PAGE_SHIFT=12
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_32KB is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_TABLE_CHECK is not set
+# CONFIG_PALMAS_GPADC is not set
+# CONFIG_PANASONIC_LAPTOP is not set
+# CONFIG_PANEL is not set
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_ON_OOPS_VALUE=1
+CONFIG_PANIC_TIMEOUT=1
+# CONFIG_PANTHERLORD_FF is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PARPORT_1284 is not set
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_PC is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_PATA_ACPI is not set
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARASAN_CF is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5535 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IMX is not set
+# CONFIG_PATA_ISAPNP is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OCTEON_CF is not set
+# CONFIG_PATA_OF_PLATFORM is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PARPORT is not set
+# CONFIG_PATA_PCMCIA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_QDI is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_WINBOND_VLB is not set
+# CONFIG_PC104 is not set
+# CONFIG_PC300TOO is not set
+# CONFIG_PCCARD is not set
+# CONFIG_PCH_DMA is not set
+# CONFIG_PCH_GBE is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_PCI is not set
+# CONFIG_PCI200SYN is not set
+# CONFIG_PCIEAER is not set
+# CONFIG_PCIEAER_INJECT is not set
+# CONFIG_PCIEASPM is not set
+# CONFIG_PCIEPORTBUS is not set
+# CONFIG_PCIE_AL is not set
+# CONFIG_PCIE_ALTERA is not set
+# CONFIG_PCIE_ARMADA_8K is not set
+CONFIG_PCIE_BUS_DEFAULT=y
+# CONFIG_PCIE_BUS_PEER2PEER is not set
+# CONFIG_PCIE_BUS_PERFORMANCE is not set
+# CONFIG_PCIE_BUS_SAFE is not set
+# CONFIG_PCIE_BUS_TUNE_OFF is not set
+# CONFIG_PCIE_CADENCE_HOST is not set
+# CONFIG_PCIE_CADENCE_PLAT_HOST is not set
+# CONFIG_PCIE_DPC is not set
+# CONFIG_PCIE_DW_PLAT is not set
+# CONFIG_PCIE_DW_PLAT_HOST is not set
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIE_IPROC is not set
+# CONFIG_PCIE_KIRIN is not set
+# CONFIG_PCIE_LAYERSCAPE_GEN4 is not set
+# CONFIG_PCIE_MEDIATEK_GEN3 is not set
+# CONFIG_PCIE_MICROCHIP_HOST is not set
+# CONFIG_PCIE_PTM is not set
+# CONFIG_PCIE_XILINX is not set
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_DISABLE_COMMON_QUIRKS is not set
+# CONFIG_PCI_DYNAMIC_OF_NODES is not set
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCI_ENDPOINT_TEST is not set
+# CONFIG_PCI_FTPCI100 is not set
+# CONFIG_PCI_HISI is not set
+# CONFIG_PCI_HOST_GENERIC is not set
+# CONFIG_PCI_HOST_THUNDER_ECAM is not set
+# CONFIG_PCI_HOST_THUNDER_PEM is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_J721E_HOST is not set
+# CONFIG_PCI_LAYERSCAPE is not set
+# CONFIG_PCI_MESON is not set
+# CONFIG_PCI_MSI is not set
+# CONFIG_PCI_NPEM is not set
+# CONFIG_PCI_PASID is not set
+# CONFIG_PCI_PF_STUB is not set
+# CONFIG_PCI_PRI is not set
+CONFIG_PCI_QUIRKS=y
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_SW_SWITCHTEC is not set
+CONFIG_PCI_SYSCALL=y
+# CONFIG_PCI_V3_SEMI is not set
+# CONFIG_PCI_XGENE is not set
+# CONFIG_PCMCIA is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+# CONFIG_PCMCIA_LOAD_CIS is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_PCNET is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_PCNET32 is not set
+CONFIG_PCPU_DEV_REFCNT=y
+CONFIG_PCP_BATCH_SCALE_MAX=5
+# CONFIG_PCSPKR_PLATFORM is not set
+# CONFIG_PCS_MTK_USXGMII is not set
+# CONFIG_PCS_XPCS is not set
+# CONFIG_PD6729 is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_PDS_CORE is not set
+# CONFIG_PECI is not set
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_EVENTS_AMD_POWER is not set
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_PER_VMA_LOCK_STATS is not set
+# CONFIG_PFCP is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_PHONET is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PHYLIB_LEDS is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_PHY_BRCM_USB is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_CADENCE_DPHY_RX is not set
+# CONFIG_PHY_CADENCE_SALVO is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_CADENCE_TORRENT is not set
+# CONFIG_PHY_CAN_TRANSCEIVER is not set
+# CONFIG_PHY_CPCAP_USB is not set
+# CONFIG_PHY_EXYNOS_DP_VIDEO is not set
+# CONFIG_PHY_EXYNOS_MIPI_VIDEO is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_INGENIC_USB is not set
+# CONFIG_PHY_INTEL_KEEMBAY_EMMC is not set
+# CONFIG_PHY_LAN966X_SERDES is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_MTK_HDMI is not set
+# CONFIG_PHY_MTK_MIPI_DSI is not set
+# CONFIG_PHY_MTK_XFI_TPHY is not set
+# CONFIG_PHY_MVEBU_CP110_UTMI is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# CONFIG_PHY_PISTACHIO_USB is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_QCOM_USB_HS is not set
+# CONFIG_PHY_QCOM_USB_HSIC is not set
+# CONFIG_PHY_SAMSUNG_USB2 is not set
+# CONFIG_PHY_TUSB1210 is not set
+# CONFIG_PHY_XGENE is not set
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_PID_NS is not set
+CONFIG_PINCONF=y
+# CONFIG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_AW9523 is not set
+# CONFIG_PINCTRL_AXP209 is not set
+# CONFIG_PINCTRL_CEDARFORK is not set
+# CONFIG_PINCTRL_CY8C95X0 is not set
+# CONFIG_PINCTRL_EXYNOS is not set
+# CONFIG_PINCTRL_ICELAKE is not set
+# CONFIG_PINCTRL_INGENIC is not set
+# CONFIG_PINCTRL_LPASS_LPI is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_MDM9607 is not set
+# CONFIG_PINCTRL_MICROCHIP_SGPIO is not set
+# CONFIG_PINCTRL_MSM8953 is not set
+# CONFIG_PINCTRL_MSM8X74 is not set
+# CONFIG_PINCTRL_MT6779 is not set
+# CONFIG_PINCTRL_MT8167 is not set
+# CONFIG_PINCTRL_MT8192 is not set
+# CONFIG_PINCTRL_MT8195 is not set
+# CONFIG_PINCTRL_MT8365 is not set
+# CONFIG_PINCTRL_MTK_V2 is not set
+# CONFIG_PINCTRL_OCELOT is not set
+# CONFIG_PINCTRL_PISTACHIO is not set
+# CONFIG_PINCTRL_SC7280 is not set
+# CONFIG_PINCTRL_SC8180X is not set
+# CONFIG_PINCTRL_SDX55 is not set
+CONFIG_PINCTRL_SINGLE=y
+# CONFIG_PINCTRL_SM6115 is not set
+# CONFIG_PINCTRL_SM6125 is not set
+# CONFIG_PINCTRL_SM8350 is not set
+# CONFIG_PINCTRL_STMFX is not set
+# CONFIG_PINCTRL_SX150X is not set
+# CONFIG_PING is not set
+CONFIG_PINMUX=y
+# CONFIG_PKCS7_MESSAGE_PARSER is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+# CONFIG_PL310_ERRATA_753970 is not set
+# CONFIG_PL310_ERRATA_769419 is not set
+# CONFIG_PL320_MBOX is not set
+# CONFIG_PL330_DMA is not set
+# CONFIG_PLATFORM_MHU is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_PLIP is not set
+# CONFIG_PLX_DMA is not set
+# CONFIG_PM is not set
+# CONFIG_PMBUS is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMS7003 is not set
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_PM_USERSPACE_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_POSIX_TIMERS=y
+# CONFIG_POWERCAP is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_RESET_BRCMKONA is not set
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+# CONFIG_POWER_RESET_LINKSTATION is not set
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_PIIX4_POWEROFF is not set
+# CONFIG_POWER_RESET_QNAP is not set
+# CONFIG_POWER_RESET_REGULATOR is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_SYSCON is not set
+# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
+# CONFIG_POWER_RESET_VERSATILE is not set
+# CONFIG_POWER_RESET_XGENE is not set
+# CONFIG_POWER_SEQUENCING is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_POWER_SUPPLY_HWMON is not set
+# CONFIG_PPC4xx_GPIO is not set
+# CONFIG_PPC_16K_PAGES is not set
+# CONFIG_PPC_256K_PAGES is not set
+CONFIG_PPC_4K_PAGES=y
+# CONFIG_PPC_64K_PAGES is not set
+# CONFIG_PPC_DISABLE_WERROR is not set
+# CONFIG_PPC_EMULATED_STATS is not set
+# CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
+# CONFIG_PPC_QUEUED_SPINLOCKS is not set
+# CONFIG_PPP is not set
+# CONFIG_PPPOATM is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOE_HASH_BITS_1 is not set
+# CONFIG_PPPOE_HASH_BITS_2 is not set
+CONFIG_PPPOE_HASH_BITS_4=y
+# CONFIG_PPPOE_HASH_BITS_8 is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_DEFLATE is not set
+CONFIG_PPP_FILTER=y
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPS is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_PARPORT is not set
+# CONFIG_PPS_DEBUG is not set
+# CONFIG_PPTP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_PREEMPTIRQ_DELAY_TEST is not set
+# CONFIG_PREEMPT_DYNAMIC is not set
+CONFIG_PREEMPT_NONE=y
+CONFIG_PREEMPT_NONE_BUILD=y
+# CONFIG_PREEMPT_RT is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PRESTERA is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_PRIME_NUMBERS is not set
+CONFIG_PRINTK=y
+# CONFIG_PRINTK_CALLER is not set
+# CONFIG_PRINTK_INDEX is not set
+# CONFIG_PRINTK_TIME is not set
+CONFIG_PRINT_STACK_DEPTH=64
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_MEM_ALWAYS_FORCE=y
+# CONFIG_PROC_MEM_FORCE_PTRACE is not set
+# CONFIG_PROC_MEM_NO_FORCE is not set
+# CONFIG_PROC_PAGE_MONITOR is not set
+# CONFIG_PROC_STRIPPED is not set
+CONFIG_PROC_SYSCTL=y
+# CONFIG_PROC_VMCORE_DEVICE_DUMP is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILING is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_PROVE_RAW_LOCK_NESTING is not set
+# CONFIG_PROVE_RCU is not set
+# CONFIG_PROVE_RCU_LIST is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_PSB6970_PHY is not set
+# CONFIG_PSE_CONTROLLER is not set
+# CONFIG_PSI is not set
+# CONFIG_PSI_DEFAULT_DISABLED is not set
+# CONFIG_PSTORE is not set
+# CONFIG_PSTORE_BLK is not set
+# CONFIG_PSTORE_COMPRESS is not set
+# CONFIG_PSTORE_CONSOLE is not set
+CONFIG_PSTORE_DEFAULT_KMSG_BYTES=10240
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_PTDUMP_DEBUGFS is not set
+# CONFIG_PTP_1588_CLOCK is not set
+# CONFIG_PTP_1588_CLOCK_FC3W is not set
+# CONFIG_PTP_1588_CLOCK_IDT82P33 is not set
+# CONFIG_PTP_1588_CLOCK_IDTCM is not set
+# CONFIG_PTP_1588_CLOCK_IXP46X is not set
+# CONFIG_PTP_1588_CLOCK_KVM is not set
+# CONFIG_PTP_1588_CLOCK_MOCK is not set
+# CONFIG_PTP_1588_CLOCK_OCP is not set
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+# CONFIG_PTP_1588_CLOCK_VMW is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_PWM is not set
+# CONFIG_PWM_ATMEL_TCB is not set
+# CONFIG_PWM_CLK is not set
+# CONFIG_PWM_DEBUG is not set
+# CONFIG_PWM_DWC is not set
+# CONFIG_PWM_FSL_FTM is not set
+# CONFIG_PWM_GPIO is not set
+# CONFIG_PWM_IMG is not set
+# CONFIG_PWM_JZ4740 is not set
+# CONFIG_PWM_MEDIATEK is not set
+# CONFIG_PWM_PCA9685 is not set
+# CONFIG_PWM_RASPBERRYPI_POE is not set
+# CONFIG_PWM_XILINX is not set
+CONFIG_PWRSEQ_EMMC=y
+# CONFIG_PWRSEQ_SD8787 is not set
+CONFIG_PWRSEQ_SIMPLE=y
+# CONFIG_QCA7000 is not set
+# CONFIG_QCA7000_SPI is not set
+# CONFIG_QCA7000_UART is not set
+# CONFIG_QCA807X_PHY is not set
+# CONFIG_QCA808X_PHY is not set
+# CONFIG_QCA83XX_PHY is not set
+# CONFIG_QCOM_A7PLL is not set
+# CONFIG_QCOM_BAM_DMUX is not set
+# CONFIG_QCOM_EMAC is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
+# CONFIG_QCOM_GPI_DMA is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_LMH is not set
+# CONFIG_QCOM_PBS is not set
+# CONFIG_QCOM_PD_MAPPER is not set
+# CONFIG_QCOM_PMIC_PDCHARGER_ULOG is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+# CONFIG_QCOM_SPMI_ADC5 is not set
+# CONFIG_QCOM_SPMI_ADC_TM5 is not set
+# CONFIG_QCOM_SPMI_IADC is not set
+# CONFIG_QCOM_SPMI_TEMP_ALARM is not set
+# CONFIG_QCOM_SPMI_VADC is not set
+# CONFIG_QCOM_SSC_BLOCK_BUS is not set
+# CONFIG_QED is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_QORIQ_CPUFREQ is not set
+# CONFIG_QORIQ_THERMAL is not set
+# CONFIG_QRTR is not set
+# CONFIG_QRTR_MHI is not set
+# CONFIG_QRTR_TUN is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_QUICC_ENGINE is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+# CONFIG_R6040 is not set
+# CONFIG_R8169 is not set
+# CONFIG_R8169_LEDS is not set
+# CONFIG_R8712U is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_GEMTEK is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_SF16FMR2 is not set
+# CONFIG_RADIO_TERRATEC is not set
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
+# CONFIG_RAID6_PQ_BENCHMARK is not set
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_RALINK is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_RANDOMIZE_KSTACK_OFFSET=y
+# CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT is not set
+# CONFIG_RANDOM_KMALLOC_CACHES is not set
+# CONFIG_RANDSTRUCT_NONE is not set
+# CONFIG_RAPIDIO is not set
+# CONFIG_RAS is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_RCU_CPU_STALL_CPUTIME is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_RCU_EXPERT is not set
+CONFIG_RCU_EXP_CPU_STALL_TIMEOUT=0
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_RCU_REF_SCALE_TEST is not set
+# CONFIG_RCU_SCALE_TEST is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_RCU_STRICT_GRACE_PERIOD is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RC_ATI_REMOTE is not set
+# CONFIG_RC_CORE is not set
+# CONFIG_RC_DECODERS is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_RC_MAP is not set
+# CONFIG_RC_XBOX_DVD is not set
+# CONFIG_RDS is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_ZSTD is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_READ_ONLY_THP_FOR_FS is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_REDWOOD is not set
+# CONFIG_REED_SOLOMON is not set
+# CONFIG_REED_SOLOMON_DEC8 is not set
+# CONFIG_REED_SOLOMON_ENC8 is not set
+# CONFIG_REED_SOLOMON_TEST is not set
+# CONFIG_REGMAP is not set
+# CONFIG_REGMAP_I2C is not set
+# CONFIG_REGMAP_MMIO is not set
+# CONFIG_REGMAP_SPI is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_REGULATOR_88PG86X is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ANATOP is not set
+# CONFIG_REGULATOR_AW37503 is not set
+# CONFIG_REGULATOR_DA9121 is not set
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_DA9211 is not set
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_FAN53880 is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_ISL9305 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_LTC3589 is not set
+# CONFIG_REGULATOR_LTC3676 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX20086 is not set
+# CONFIG_REGULATOR_MAX20411 is not set
+# CONFIG_REGULATOR_MAX77503 is not set
+# CONFIG_REGULATOR_MAX77620 is not set
+# CONFIG_REGULATOR_MAX77826 is not set
+# CONFIG_REGULATOR_MAX77857 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8893 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_MCP16502 is not set
+# CONFIG_REGULATOR_MP5416 is not set
+# CONFIG_REGULATOR_MP8859 is not set
+# CONFIG_REGULATOR_MP886X is not set
+# CONFIG_REGULATOR_MPQ7920 is not set
+# CONFIG_REGULATOR_MT6311 is not set
+# CONFIG_REGULATOR_MT6315 is not set
+# CONFIG_REGULATOR_MT6359 is not set
+# CONFIG_REGULATOR_NETLINK_EVENTS is not set
+# CONFIG_REGULATOR_PCA9450 is not set
+# CONFIG_REGULATOR_PF8X00 is not set
+# CONFIG_REGULATOR_PFUZE100 is not set
+# CONFIG_REGULATOR_PV88060 is not set
+# CONFIG_REGULATOR_PV88080 is not set
+# CONFIG_REGULATOR_PV88090 is not set
+# CONFIG_REGULATOR_PWM is not set
+# CONFIG_REGULATOR_QCOM_REFGEN is not set
+# CONFIG_REGULATOR_RAA215300 is not set
+# CONFIG_REGULATOR_RASPBERRYPI_TOUCHSCREEN_ATTINY is not set
+# CONFIG_REGULATOR_RT4801 is not set
+# CONFIG_REGULATOR_RT4803 is not set
+# CONFIG_REGULATOR_RT5190A is not set
+# CONFIG_REGULATOR_RT5739 is not set
+# CONFIG_REGULATOR_RT5759 is not set
+# CONFIG_REGULATOR_RT6160 is not set
+# CONFIG_REGULATOR_RT6190 is not set
+# CONFIG_REGULATOR_RT6245 is not set
+# CONFIG_REGULATOR_RTMV20 is not set
+# CONFIG_REGULATOR_RTQ2134 is not set
+# CONFIG_REGULATOR_RTQ2208 is not set
+# CONFIG_REGULATOR_RTQ6752 is not set
+# CONFIG_REGULATOR_SLG51000 is not set
+# CONFIG_REGULATOR_SY8106A is not set
+# CONFIG_REGULATOR_SY8824X is not set
+# CONFIG_REGULATOR_SY8827N is not set
+# CONFIG_REGULATOR_TI_ABB is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS6286X is not set
+# CONFIG_REGULATOR_TPS6287X is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS65132 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_VCTRL is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_FS_POSIX_ACL is not set
+# CONFIG_REISERFS_FS_SECURITY is not set
+CONFIG_REISERFS_FS_XATTR=y
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_RELAY is not set
+# CONFIG_RELOCATABLE is not set
+CONFIG_RELR=y
+# CONFIG_REMOTEPROC is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_RESET_ATH79 is not set
+# CONFIG_RESET_BERLIN is not set
+# CONFIG_RESET_BRCMSTB is not set
+# CONFIG_RESET_BRCMSTB_RESCAL is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_RESET_GPIO is not set
+# CONFIG_RESET_IMX7 is not set
+# CONFIG_RESET_INTEL_GW is not set
+# CONFIG_RESET_LANTIQ is not set
+# CONFIG_RESET_LPC18XX is not set
+# CONFIG_RESET_MESON is not set
+# CONFIG_RESET_PISTACHIO is not set
+# CONFIG_RESET_SIMPLE is not set
+# CONFIG_RESET_SOCFPGA is not set
+# CONFIG_RESET_SUNXI is not set
+# CONFIG_RESET_TEGRA_BPMP is not set
+# CONFIG_RESET_TI_SYSCON is not set
+# CONFIG_RESET_TI_TPS380X is not set
+# CONFIG_RESET_ZYNQ is not set
+# CONFIG_RFD77402 is not set
+# CONFIG_RFD_FTL is not set
+CONFIG_RFKILL=y
+# CONFIG_RFKILL_FULL is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_LEDS is not set
+# CONFIG_RICHTEK_RTQ6056 is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_RING_BUFFER_VALIDATE_TIME_DELTAS is not set
+# CONFIG_RISCV_PMU is not set
+# CONFIG_RISCV_PMU_LEGACY is not set
+# CONFIG_RISCV_PMU_SBI is not set
+# CONFIG_RMI4_CORE is not set
+# CONFIG_RMNET is not set
+# CONFIG_ROCKCHIP_ERRATUM_3588001 is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_ROCKER is not set
+# CONFIG_ROHM_BM1390 is not set
+# CONFIG_ROHM_BU27008 is not set
+# CONFIG_ROHM_BU27034 is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_ROSE is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_AES_SHA1 is not set
+# CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_AES_SHA2 is not set
+# CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_CAMELLIA is not set
+# CONFIG_RPMB is not set
+# CONFIG_RPMSG_QCOM_GLINK_RPM is not set
+# CONFIG_RPMSG_VIRTIO is not set
+# CONFIG_RPMSG_WWAN_CTRL is not set
+# CONFIG_RPR0521 is not set
+# CONFIG_RSEQ is not set
+# CONFIG_RT2X00 is not set
+# CONFIG_RTASE is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_RTC_DEBUG is not set
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABEOZ9 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_ARMADA38X is not set
+# CONFIG_RTC_DRV_AU1XXX is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_CADENCE is not set
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1307_CENTURY is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_EFI is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_EP93XX is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_GENERIC is not set
+# CONFIG_RTC_DRV_GOLDFISH is not set
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_JZ4740 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_MAX31335 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_MAX77686 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+# CONFIG_RTC_DRV_MOXART is not set
+# CONFIG_RTC_DRV_MPC5121 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_MT2712 is not set
+# CONFIG_RTC_DRV_NCT3018Y is not set
+# CONFIG_RTC_DRV_OMAP is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_PS3 is not set
+# CONFIG_RTC_DRV_R7301 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_RV3028 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RV3032 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_RX8111 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_SD2405AL is not set
+# CONFIG_RTC_DRV_SD3078 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_SUN6I is not set
+# CONFIG_RTC_DRV_TEGRA is not set
+# CONFIG_RTC_DRV_TEST is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_XGENE is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_NVMEM is not set
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTL8180 is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_RTL8192E is not set
+# CONFIG_RTL8261N_PHY is not set
+# CONFIG_RTL8306_PHY is not set
+# CONFIG_RTL8366RB_PHY is not set
+# CONFIG_RTL8366S_PHY is not set
+# CONFIG_RTL8366_SMI is not set
+# CONFIG_RTL8366_SMI_DEBUG_FS is not set
+# CONFIG_RTL8367B_PHY is not set
+# CONFIG_RTL8367_PHY is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_RTL_CARDS is not set
+# CONFIG_RTS5208 is not set
+CONFIG_RT_MUTEXES=y
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_RUST is not set
+# CONFIG_RV is not set
+CONFIG_RXKAD=y
+# CONFIG_RXPERF is not set
+# CONFIG_S2IO is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_SAMSUNG_LAPTOP is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_DWC is not set
+# CONFIG_SATA_DWC_OLD_DMA is not set
+# CONFIG_SATA_FSL is not set
+# CONFIG_SATA_HIGHBANK is not set
+# CONFIG_SATA_HOST is not set
+# CONFIG_SATA_INIC162X is not set
+CONFIG_SATA_MOBILE_LPM_POLICY=0
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PMP is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_RCAR is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+CONFIG_SBITMAP=y
+# CONFIG_SC92031 is not set
+# CONFIG_SCA3000 is not set
+# CONFIG_SCA3300 is not set
+# CONFIG_SCACHE_DEBUGFS is not set
+# CONFIG_SCC is not set
+# CONFIG_SCD30_CORE is not set
+# CONFIG_SCD4X is not set
+# CONFIG_SCF_TORTURE_TEST is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SCHED_CLASS_EXT is not set
+# CONFIG_SCHED_CLUSTER is not set
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_HRTICK=y
+# CONFIG_SCHED_MC is not set
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_SCHED_SMT is not set
+CONFIG_SCHED_STACK_END_CHECK=y
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CHELSIO_FCOE is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_FDOMAIN_PCI is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_HISI_SAS is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_LOGGING is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_LPFC is not set
+CONFIG_SCSI_MOD=y
+# CONFIG_SCSI_MPI3MR is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVSAS_DEBUG is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_MYRB is not set
+# CONFIG_SCSI_MYRS is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_PMCRAID is not set
+CONFIG_SCSI_PROC_FS=y
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+# CONFIG_SCSI_SMARTPQI is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SC_CAMCC_7180 is not set
+# CONFIG_SC_DISPCC_7280 is not set
+# CONFIG_SC_GCC_7280 is not set
+# CONFIG_SC_GCC_8180X is not set
+# CONFIG_SC_GPUCC_7280 is not set
+# CONFIG_SC_GPUCC_8280XP is not set
+# CONFIG_SC_VIDEOCC_7280 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_SDM_GPUCC_660 is not set
+# CONFIG_SDM_MMCC_660 is not set
+# CONFIG_SDP500 is not set
+# CONFIG_SDR_MAX2175 is not set
+# CONFIG_SDR_PLATFORM_DRIVERS is not set
+# CONFIG_SDX_GCC_55 is not set
+# CONFIG_SD_ADC_MODULATOR is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_SECCOMP_CACHE_DEBUG is not set
+# CONFIG_SECRETMEM is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_APPARMOR is not set
+CONFIG_SECURITY_DMESG_RESTRICT=y
+# CONFIG_SECURITY_LANDLOCK is not set
+# CONFIG_SECURITY_LOADPIN is not set
+# CONFIG_SECURITY_LOCKDOWN_LSM is not set
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_SAFESETID is not set
+# CONFIG_SECURITY_SELINUX_AVC_STATS is not set
+# CONFIG_SECURITY_SELINUX_BOOTPARAM is not set
+# CONFIG_SECURITY_SELINUX_DEBUG is not set
+# CONFIG_SECURITY_SELINUX_DEVELOP is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_YAMA is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_SENSEAIR_SUNRISE_CO2 is not set
+# CONFIG_SENSIRION_SGP30 is not set
+# CONFIG_SENSIRION_SGP40 is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_ACBEL_FSG032 is not set
+# CONFIG_SENSORS_ACPI_POWER is not set
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM1177 is not set
+# CONFIG_SENSORS_ADM1266 is not set
+# CONFIG_SENSORS_ADM1275 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADP1050 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_AHT10 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_AQUACOMPUTER_D5NEXT is not set
+# CONFIG_SENSORS_AS370 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ASPEED is not set
+# CONFIG_SENSORS_ASUS_ROG_RYUJIN is not set
+# CONFIG_SENSORS_ATK0110 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_AXI_FAN_CONTROL is not set
+# CONFIG_SENSORS_BEL_PFE is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_BPA_RS600 is not set
+# CONFIG_SENSORS_CHIPCAP2 is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_CORSAIR_CPRO is not set
+# CONFIG_SENSORS_CORSAIR_PSU is not set
+# CONFIG_SENSORS_DELL_SMM is not set
+# CONFIG_SENSORS_DELTA_AHE50DC_FAN is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_DPS920AB is not set
+# CONFIG_SENSORS_DRIVETEMP is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC2305 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_FSP_3Y is not set
+# CONFIG_SENSORS_FTSTEUTATES is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_GIGABYTE_WATERFORCE is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_GSC is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_HMC5843 is not set
+# CONFIG_SENSORS_HMC5843_I2C is not set
+# CONFIG_SENSORS_HMC5843_SPI is not set
+# CONFIG_SENSORS_HS3001 is not set
+# CONFIG_SENSORS_I5500 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_IBM_CFFPS is not set
+# CONFIG_SENSORS_IIO_HWMON is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA238 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_INA3221 is not set
+# CONFIG_SENSORS_INSPUR_IPSPS is not set
+# CONFIG_SENSORS_IR35221 is not set
+# CONFIG_SENSORS_IR36021 is not set
+# CONFIG_SENSORS_IR38064 is not set
+# CONFIG_SENSORS_IRPS5401 is not set
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_ISL29028 is not set
+# CONFIG_SENSORS_ISL68137 is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LM25066 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_LT7182S is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC2947_I2C is not set
+# CONFIG_SENSORS_LTC2947_SPI is not set
+# CONFIG_SENSORS_LTC2978 is not set
+# CONFIG_SENSORS_LTC2990 is not set
+# CONFIG_SENSORS_LTC2991 is not set
+# CONFIG_SENSORS_LTC2992 is not set
+# CONFIG_SENSORS_LTC3815 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LTC4282 is not set
+# CONFIG_SENSORS_LTC4286 is not set
+# CONFIG_SENSORS_LTQ_CPUTEMP is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX127 is not set
+# CONFIG_SENSORS_MAX15301 is not set
+# CONFIG_SENSORS_MAX16064 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX16601 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX20730 is not set
+# CONFIG_SENSORS_MAX20751 is not set
+# CONFIG_SENSORS_MAX31722 is not set
+# CONFIG_SENSORS_MAX31730 is not set
+# CONFIG_SENSORS_MAX31760 is not set
+# CONFIG_SENSORS_MAX31785 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_MAX34440 is not set
+# CONFIG_SENSORS_MAX6620 is not set
+# CONFIG_SENSORS_MAX6621 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX8688 is not set
+# CONFIG_SENSORS_MC34VR500 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_MP2856 is not set
+# CONFIG_SENSORS_MP2888 is not set
+# CONFIG_SENSORS_MP2891 is not set
+# CONFIG_SENSORS_MP2975 is not set
+# CONFIG_SENSORS_MP2993 is not set
+# CONFIG_SENSORS_MP5023 is not set
+# CONFIG_SENSORS_MP5920 is not set
+# CONFIG_SENSORS_MP5990 is not set
+# CONFIG_SENSORS_MP9941 is not set
+# CONFIG_SENSORS_MPQ7932 is not set
+# CONFIG_SENSORS_MPQ8785 is not set
+# CONFIG_SENSORS_MR75203 is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT6775_I2C is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_NPCM7XX is not set
+# CONFIG_SENSORS_NSA320 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NZXT_KRAKEN2 is not set
+# CONFIG_SENSORS_NZXT_KRAKEN3 is not set
+# CONFIG_SENSORS_NZXT_SMART2 is not set
+# CONFIG_SENSORS_OCC_P8_I2C is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_PIM4328 is not set
+# CONFIG_SENSORS_PLI1209BC is not set
+# CONFIG_SENSORS_PM6764TR is not set
+# CONFIG_SENSORS_PMBUS is not set
+# CONFIG_SENSORS_POWERZ is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_PT5161L is not set
+# CONFIG_SENSORS_PWM_FAN is not set
+# CONFIG_SENSORS_PXE1610 is not set
+# CONFIG_SENSORS_Q54SJ108A2 is not set
+# CONFIG_SENSORS_RM3100_I2C is not set
+# CONFIG_SENSORS_RM3100_SPI is not set
+# CONFIG_SENSORS_SBRMI is not set
+# CONFIG_SENSORS_SBTSI is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHT3x is not set
+# CONFIG_SENSORS_SHT4x is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SPD5118 is not set
+# CONFIG_SENSORS_STPDDC60 is not set
+# CONFIG_SENSORS_STTS751 is not set
+# CONFIG_SENSORS_TC654 is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_TDA38640 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP108 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_TMP464 is not set
+# CONFIG_SENSORS_TMP513 is not set
+# CONFIG_SENSORS_TPS23861 is not set
+# CONFIG_SENSORS_TPS40422 is not set
+# CONFIG_SENSORS_TPS53679 is not set
+# CONFIG_SENSORS_TPS546D24 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_SENSORS_UCD9000 is not set
+# CONFIG_SENSORS_UCD9200 is not set
+# CONFIG_SENSORS_VEXPRESS is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83773G is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_XDP710 is not set
+# CONFIG_SENSORS_XDPE122 is not set
+# CONFIG_SENSORS_XDPE152 is not set
+# CONFIG_SENSORS_XGENE is not set
+# CONFIG_SENSORS_ZL6100 is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_16550A_VARIANTS=y
+# CONFIG_SERIAL_8250_ACCENT is not set
+# CONFIG_SERIAL_8250_ASPEED_VUART is not set
+# CONFIG_SERIAL_8250_BOCA is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_CS is not set
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_DMA=y
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_EM is not set
+# CONFIG_SERIAL_8250_EXAR is not set
+# CONFIG_SERIAL_8250_EXAR_ST16C554 is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_FOURPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+# CONFIG_SERIAL_8250_INGENIC is not set
+# CONFIG_SERIAL_8250_LPSS is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_MID is not set
+CONFIG_SERIAL_8250_NR_UARTS=2
+# CONFIG_SERIAL_8250_PCI is not set
+# CONFIG_SERIAL_8250_PCI1XXXX is not set
+# CONFIG_SERIAL_8250_PERICOM is not set
+# CONFIG_SERIAL_8250_RSA is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_DEV_BUS is not set
+CONFIG_SERIAL_EARLYCON=y
+# CONFIG_SERIAL_EARLYCON_SEMIHOST is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_GRLIB_GAISLER_APBUART is not set
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_SERIAL_OF_PLATFORM is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SH_SCI is not set
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SPRD is not set
+# CONFIG_SERIAL_STM32 is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_UARTLITE is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_AMBAKMI is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_SUN4I_PS2 is not set
+# CONFIG_SFC is not set
+# CONFIG_SFC_FALCON is not set
+# CONFIG_SFC_SIENA is not set
+# CONFIG_SFP is not set
+# CONFIG_SF_PDMA is not set
+# CONFIG_SGETMASK_SYSCALL is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP28 is not set
+# CONFIG_SGI_IP30 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SGI_MFD_IOC3 is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_SG_POOL is not set
+# CONFIG_SG_SPLIT is not set
+# CONFIG_SHADOW_CALL_STACK is not set
+CONFIG_SHMEM=y
+# CONFIG_SHRINKER_DEBUG is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+# CONFIG_SH_ETH is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_SI1133 is not set
+# CONFIG_SI1145 is not set
+# CONFIG_SI7005 is not set
+# CONFIG_SI7020 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_SWARM is not set
+CONFIG_SIGNALFD=y
+# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
+# CONFIG_SIOX is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_SKY2_DEBUG is not set
+CONFIG_SLAB_BUCKETS=y
+CONFIG_SLAB_FREELIST_HARDENED=y
+CONFIG_SLAB_FREELIST_RANDOM=y
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLHC is not set
+# CONFIG_SLICOSS is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_SLIP is not set
+CONFIG_SLUB=y
+CONFIG_SLUB_CPU_PARTIAL=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_SLUB_TINY is not set
+# CONFIG_SMARTJOYPLUS_FF is not set
+# CONFIG_SMB_SERVER is not set
+# CONFIG_SMC9194 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_SMP is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_SMSC9420 is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_SMS_SDIO_DRV is not set
+# CONFIG_SMS_USB_DRV is not set
+# CONFIG_SM_CAMCC_8250 is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_SM_GCC_6115 is not set
+# CONFIG_SM_GCC_6125 is not set
+# CONFIG_SM_GCC_6350 is not set
+# CONFIG_SM_GCC_6375 is not set
+# CONFIG_SM_GCC_8350 is not set
+# CONFIG_SND is not set
+# CONFIG_SND_AC97_POWER_SAVE is not set
+# CONFIG_SND_AD1816A is not set
+# CONFIG_SND_AD1848 is not set
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ADLIB is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_ALS100 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_AMD_ACP_CONFIG is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_ASIHPI is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_ATMEL_AC97C is not set
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AUDIO_GRAPH_CARD is not set
+# CONFIG_SND_AUDIO_GRAPH_CARD2 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT2320 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_BCM2835 is not set
+# CONFIG_SND_BCM63XX_I2S_WHISTLER is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMI8330 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_CS4231 is not set
+# CONFIG_SND_CS4236 is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5530 is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTL_FAST_LOOKUP is not set
+# CONFIG_SND_CTL_INPUT_VALIDATION is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1688 is not set
+# CONFIG_SND_ES18XX is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FIREWIRE is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_GUSCLASSIC is not set
+# CONFIG_SND_GUSEXTREME is not set
+# CONFIG_SND_GUSMAX is not set
+# CONFIG_SND_HDA_CODEC_CS8409 is not set
+# CONFIG_SND_HDA_INTEL is not set
+# CONFIG_SND_HDA_INTEL_HDMI_SILENT_STREAM is not set
+CONFIG_SND_HDA_POWER_SAVE_DEFAULT=0
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_HWDEP is not set
+# CONFIG_SND_I2S_HI6210_I2S is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_INTERWAVE is not set
+# CONFIG_SND_INTERWAVE_STB is not set
+# CONFIG_SND_ISA is not set
+# CONFIG_SND_JZ4740_SOC_I2S is not set
+# CONFIG_SND_KIRKWOOD_SOC is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+CONFIG_SND_MAX_CARDS=16
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_MIPS is not set
+# CONFIG_SND_MIRO is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MPC52xx_SOC_EFIKA is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_MTS64 is not set
+# CONFIG_SND_MXS_SOC is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_OPL3SA2 is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_OPTI92X_AD1848 is not set
+# CONFIG_SND_OPTI92X_CS4231 is not set
+# CONFIG_SND_OPTI93X is not set
+CONFIG_SND_OSSEMUL=y
+# CONFIG_SND_OXYGEN is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_PCM is not set
+# CONFIG_SND_PCMCIA is not set
+# CONFIG_SND_PCMTEST is not set
+# CONFIG_SND_PCM_OSS is not set
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_PCM_TIMER is not set
+# CONFIG_SND_PCM_XRUN_DEBUG is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_PDAUDIOCF is not set
+# CONFIG_SND_PORTMAN2X4 is not set
+# CONFIG_SND_POWERPC_SOC is not set
+# CONFIG_SND_PPC is not set
+CONFIG_SND_PROC_FS=y
+# CONFIG_SND_RAWMIDI is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SB16 is not set
+# CONFIG_SND_SB8 is not set
+# CONFIG_SND_SBAWE is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_SE6X is not set
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_SEQ_UMP is not set
+# CONFIG_SND_SERIAL_GENERIC is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SND_SIS7019 is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SND_SOC_AC97_CODEC is not set
+# CONFIG_SND_SOC_AD193X_I2C is not set
+# CONFIG_SND_SOC_AD193X_SPI is not set
+# CONFIG_SND_SOC_ADAU1372_I2C is not set
+# CONFIG_SND_SOC_ADAU1372_SPI is not set
+# CONFIG_SND_SOC_ADAU1701 is not set
+# CONFIG_SND_SOC_ADAU1761_I2C is not set
+# CONFIG_SND_SOC_ADAU1761_SPI is not set
+# CONFIG_SND_SOC_ADAU7002 is not set
+# CONFIG_SND_SOC_ADAU7118_HW is not set
+# CONFIG_SND_SOC_ADAU7118_I2C is not set
+# CONFIG_SND_SOC_ADI is not set
+# CONFIG_SND_SOC_AK4104 is not set
+# CONFIG_SND_SOC_AK4118 is not set
+# CONFIG_SND_SOC_AK4375 is not set
+# CONFIG_SND_SOC_AK4458 is not set
+# CONFIG_SND_SOC_AK4554 is not set
+# CONFIG_SND_SOC_AK4613 is not set
+# CONFIG_SND_SOC_AK4619 is not set
+# CONFIG_SND_SOC_AK4642 is not set
+# CONFIG_SND_SOC_AK5386 is not set
+# CONFIG_SND_SOC_AK5558 is not set
+# CONFIG_SND_SOC_ALC5623 is not set
+# CONFIG_SND_SOC_AMD_ACP is not set
+# CONFIG_SND_SOC_AMD_ACP3x is not set
+# CONFIG_SND_SOC_AMD_ACP5x is not set
+# CONFIG_SND_SOC_AMD_RENOIR is not set
+# CONFIG_SND_SOC_AU1XAUDIO is not set
+# CONFIG_SND_SOC_AU1XPSC is not set
+# CONFIG_SND_SOC_AUDIO_IIO_AUX is not set
+# CONFIG_SND_SOC_AW8738 is not set
+# CONFIG_SND_SOC_AW87390 is not set
+# CONFIG_SND_SOC_AW88261 is not set
+# CONFIG_SND_SOC_AW88395 is not set
+# CONFIG_SND_SOC_AW88399 is not set
+# CONFIG_SND_SOC_BD28623 is not set
+# CONFIG_SND_SOC_BT_SCO is not set
+# CONFIG_SND_SOC_CHV3_CODEC is not set
+# CONFIG_SND_SOC_CHV3_I2S is not set
+# CONFIG_SND_SOC_CS35L32 is not set
+# CONFIG_SND_SOC_CS35L33 is not set
+# CONFIG_SND_SOC_CS35L34 is not set
+# CONFIG_SND_SOC_CS35L35 is not set
+# CONFIG_SND_SOC_CS35L36 is not set
+# CONFIG_SND_SOC_CS35L41_I2C is not set
+# CONFIG_SND_SOC_CS35L41_SPI is not set
+# CONFIG_SND_SOC_CS35L45_I2C is not set
+# CONFIG_SND_SOC_CS35L45_SPI is not set
+# CONFIG_SND_SOC_CS35L56_I2C is not set
+# CONFIG_SND_SOC_CS35L56_SPI is not set
+# CONFIG_SND_SOC_CS4234 is not set
+# CONFIG_SND_SOC_CS4265 is not set
+# CONFIG_SND_SOC_CS4270 is not set
+# CONFIG_SND_SOC_CS4271 is not set
+# CONFIG_SND_SOC_CS4271_I2C is not set
+# CONFIG_SND_SOC_CS4271_SPI is not set
+# CONFIG_SND_SOC_CS42L42 is not set
+# CONFIG_SND_SOC_CS42L51_I2C is not set
+# CONFIG_SND_SOC_CS42L52 is not set
+# CONFIG_SND_SOC_CS42L56 is not set
+# CONFIG_SND_SOC_CS42L73 is not set
+# CONFIG_SND_SOC_CS42L83 is not set
+# CONFIG_SND_SOC_CS42XX8_I2C is not set
+# CONFIG_SND_SOC_CS43130 is not set
+# CONFIG_SND_SOC_CS4341 is not set
+# CONFIG_SND_SOC_CS4349 is not set
+# CONFIG_SND_SOC_CS530X_I2C is not set
+# CONFIG_SND_SOC_CS53L30 is not set
+# CONFIG_SND_SOC_CX2072X is not set
+# CONFIG_SND_SOC_DA7213 is not set
+# CONFIG_SND_SOC_DMIC is not set
+# CONFIG_SND_SOC_ES7134 is not set
+# CONFIG_SND_SOC_ES7241 is not set
+# CONFIG_SND_SOC_ES8311 is not set
+# CONFIG_SND_SOC_ES8316 is not set
+# CONFIG_SND_SOC_ES8326 is not set
+# CONFIG_SND_SOC_ES8328 is not set
+# CONFIG_SND_SOC_ES8328_I2C is not set
+# CONFIG_SND_SOC_ES8328_SPI is not set
+# CONFIG_SND_SOC_EUKREA_TLV320 is not set
+# CONFIG_SND_SOC_FSL_ASOC_CARD is not set
+# CONFIG_SND_SOC_FSL_ASRC is not set
+# CONFIG_SND_SOC_FSL_AUD2HTX is not set
+# CONFIG_SND_SOC_FSL_AUDMIX is not set
+# CONFIG_SND_SOC_FSL_ESAI is not set
+# CONFIG_SND_SOC_FSL_MICFIL is not set
+# CONFIG_SND_SOC_FSL_RPMSG is not set
+# CONFIG_SND_SOC_FSL_SAI is not set
+# CONFIG_SND_SOC_FSL_SPDIF is not set
+# CONFIG_SND_SOC_FSL_SSI is not set
+# CONFIG_SND_SOC_FSL_XCVR is not set
+# CONFIG_SND_SOC_GTM601 is not set
+# CONFIG_SND_SOC_HDA is not set
+# CONFIG_SND_SOC_ICS43432 is not set
+# CONFIG_SND_SOC_IDT821034 is not set
+# CONFIG_SND_SOC_IMG is not set
+# CONFIG_SND_SOC_IMX_AUDMIX is not set
+# CONFIG_SND_SOC_IMX_AUDMUX is not set
+# CONFIG_SND_SOC_IMX_CARD is not set
+# CONFIG_SND_SOC_IMX_ES8328 is not set
+# CONFIG_SND_SOC_IMX_HDMI is not set
+# CONFIG_SND_SOC_IMX_RPMSG is not set
+# CONFIG_SND_SOC_INNO_RK3036 is not set
+# CONFIG_SND_SOC_INTEL_BDW_RT5677_MACH is not set
+# CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH is not set
+# CONFIG_SND_SOC_INTEL_BYTCR_RT5651_MACH is not set
+# CONFIG_SND_SOC_INTEL_BYT_CHT_DA7213_MACH is not set
+# CONFIG_SND_SOC_INTEL_BYT_CHT_ES8316_MACH is not set
+# CONFIG_SND_SOC_INTEL_BYT_CHT_NOCODEC_MACH is not set
+# CONFIG_SND_SOC_INTEL_CATPT is not set
+# CONFIG_SND_SOC_INTEL_CHT_BSW_MAX98090_TI_MACH is not set
+# CONFIG_SND_SOC_INTEL_CHT_BSW_NAU8824_MACH is not set
+# CONFIG_SND_SOC_INTEL_CHT_BSW_RT5645_MACH is not set
+# CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH is not set
+# CONFIG_SND_SOC_INTEL_HASWELL is not set
+# CONFIG_SND_SOC_INTEL_KEEMBAY is not set
+# CONFIG_SND_SOC_INTEL_SST is not set
+CONFIG_SND_SOC_INTEL_SST_TOPLEVEL=y
+# CONFIG_SND_SOC_INTEL_USER_FRIENDLY_LONG_NAMES is not set
+# CONFIG_SND_SOC_JZ4725B_CODEC is not set
+# CONFIG_SND_SOC_JZ4740_CODEC is not set
+# CONFIG_SND_SOC_JZ4770_CODEC is not set
+# CONFIG_SND_SOC_LOONGSON_CARD is not set
+# CONFIG_SND_SOC_LOONGSON_I2S_PCI is not set
+# CONFIG_SND_SOC_LPASS_RX_MACRO is not set
+# CONFIG_SND_SOC_LPASS_TX_MACRO is not set
+# CONFIG_SND_SOC_LPASS_VA_MACRO is not set
+# CONFIG_SND_SOC_LPASS_WSA_MACRO is not set
+# CONFIG_SND_SOC_MAX9759 is not set
+# CONFIG_SND_SOC_MAX98088 is not set
+# CONFIG_SND_SOC_MAX98090 is not set
+# CONFIG_SND_SOC_MAX98357A is not set
+# CONFIG_SND_SOC_MAX98373 is not set
+# CONFIG_SND_SOC_MAX98373_I2C is not set
+# CONFIG_SND_SOC_MAX98388 is not set
+# CONFIG_SND_SOC_MAX98390 is not set
+# CONFIG_SND_SOC_MAX98396 is not set
+# CONFIG_SND_SOC_MAX98504 is not set
+# CONFIG_SND_SOC_MAX98520 is not set
+# CONFIG_SND_SOC_MAX9860 is not set
+# CONFIG_SND_SOC_MAX9867 is not set
+# CONFIG_SND_SOC_MAX98927 is not set
+# CONFIG_SND_SOC_MEDIATEK is not set
+# CONFIG_SND_SOC_MPC5200_AC97 is not set
+# CONFIG_SND_SOC_MPC5200_I2S is not set
+# CONFIG_SND_SOC_MSM8916_WCD_ANALOG is not set
+# CONFIG_SND_SOC_MSM8916_WCD_DIGITAL is not set
+# CONFIG_SND_SOC_MT2701 is not set
+# CONFIG_SND_SOC_MT6351 is not set
+# CONFIG_SND_SOC_MT6357 is not set
+# CONFIG_SND_SOC_MT6358 is not set
+# CONFIG_SND_SOC_MT6359 is not set
+# CONFIG_SND_SOC_MT6359_ACCDET is not set
+# CONFIG_SND_SOC_MT6660 is not set
+# CONFIG_SND_SOC_MT6797 is not set
+# CONFIG_SND_SOC_MT8173 is not set
+# CONFIG_SND_SOC_MT8183 is not set
+# CONFIG_SND_SOC_MT8186 is not set
+# CONFIG_SND_SOC_MT8188 is not set
+# CONFIG_SND_SOC_MT8192 is not set
+# CONFIG_SND_SOC_MT8195 is not set
+# CONFIG_SND_SOC_MT8365 is not set
+# CONFIG_SND_SOC_MTK_BTCVSD is not set
+# CONFIG_SND_SOC_NAU8315 is not set
+# CONFIG_SND_SOC_NAU8540 is not set
+# CONFIG_SND_SOC_NAU8810 is not set
+# CONFIG_SND_SOC_NAU8821 is not set
+# CONFIG_SND_SOC_NAU8822 is not set
+# CONFIG_SND_SOC_NAU8824 is not set
+# CONFIG_SND_SOC_PCM1681 is not set
+# CONFIG_SND_SOC_PCM1789_I2C is not set
+# CONFIG_SND_SOC_PCM179X_I2C is not set
+# CONFIG_SND_SOC_PCM179X_SPI is not set
+# CONFIG_SND_SOC_PCM186X_I2C is not set
+# CONFIG_SND_SOC_PCM186X_SPI is not set
+# CONFIG_SND_SOC_PCM3060_I2C is not set
+# CONFIG_SND_SOC_PCM3060_SPI is not set
+# CONFIG_SND_SOC_PCM3168A_I2C is not set
+# CONFIG_SND_SOC_PCM3168A_SPI is not set
+# CONFIG_SND_SOC_PCM5102A is not set
+# CONFIG_SND_SOC_PCM512x_I2C is not set
+# CONFIG_SND_SOC_PCM512x_SPI is not set
+# CONFIG_SND_SOC_PCM6240 is not set
+# CONFIG_SND_SOC_PEB2466 is not set
+# CONFIG_SND_SOC_QCOM is not set
+# CONFIG_SND_SOC_RK3308 is not set
+# CONFIG_SND_SOC_RK3328 is not set
+# CONFIG_SND_SOC_RK817 is not set
+# CONFIG_SND_SOC_ROCKCHIP is not set
+# CONFIG_SND_SOC_RT5616 is not set
+# CONFIG_SND_SOC_RT5631 is not set
+# CONFIG_SND_SOC_RT5640 is not set
+# CONFIG_SND_SOC_RT5659 is not set
+# CONFIG_SND_SOC_RT5677_SPI is not set
+# CONFIG_SND_SOC_RT9120 is not set
+# CONFIG_SND_SOC_RTQ9128 is not set
+# CONFIG_SND_SOC_SGTL5000 is not set
+# CONFIG_SND_SOC_SIMPLE_AMPLIFIER is not set
+# CONFIG_SND_SOC_SIMPLE_MUX is not set
+# CONFIG_SND_SOC_SMA1303 is not set
+# CONFIG_SND_SOC_SOF_TOPLEVEL is not set
+# CONFIG_SND_SOC_SPDIF is not set
+# CONFIG_SND_SOC_SRC4XXX_I2C is not set
+# CONFIG_SND_SOC_SSM2305 is not set
+# CONFIG_SND_SOC_SSM2518 is not set
+# CONFIG_SND_SOC_SSM2602_I2C is not set
+# CONFIG_SND_SOC_SSM2602_SPI is not set
+# CONFIG_SND_SOC_SSM3515 is not set
+# CONFIG_SND_SOC_SSM4567 is not set
+# CONFIG_SND_SOC_STA32X is not set
+# CONFIG_SND_SOC_STA350 is not set
+# CONFIG_SND_SOC_STI_SAS is not set
+# CONFIG_SND_SOC_TAS2552 is not set
+# CONFIG_SND_SOC_TAS2562 is not set
+# CONFIG_SND_SOC_TAS2764 is not set
+# CONFIG_SND_SOC_TAS2770 is not set
+# CONFIG_SND_SOC_TAS2780 is not set
+# CONFIG_SND_SOC_TAS2781_I2C is not set
+# CONFIG_SND_SOC_TAS5086 is not set
+# CONFIG_SND_SOC_TAS571X is not set
+# CONFIG_SND_SOC_TAS5720 is not set
+# CONFIG_SND_SOC_TAS5805M is not set
+# CONFIG_SND_SOC_TAS6424 is not set
+# CONFIG_SND_SOC_TDA7419 is not set
+# CONFIG_SND_SOC_TFA9879 is not set
+# CONFIG_SND_SOC_TFA989X is not set
+# CONFIG_SND_SOC_TLV320ADC3XXX is not set
+# CONFIG_SND_SOC_TLV320ADCX140 is not set
+# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC31XX is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC3X is not set
+# CONFIG_SND_SOC_TLV320AIC3X_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC3X_SPI is not set
+# CONFIG_SND_SOC_TPA6130A2 is not set
+# CONFIG_SND_SOC_TS3A227E is not set
+# CONFIG_SND_SOC_TSCS42XX is not set
+# CONFIG_SND_SOC_TSCS454 is not set
+# CONFIG_SND_SOC_UDA1334 is not set
+# CONFIG_SND_SOC_WM8510 is not set
+# CONFIG_SND_SOC_WM8523 is not set
+# CONFIG_SND_SOC_WM8524 is not set
+# CONFIG_SND_SOC_WM8580 is not set
+# CONFIG_SND_SOC_WM8711 is not set
+# CONFIG_SND_SOC_WM8728 is not set
+# CONFIG_SND_SOC_WM8731 is not set
+# CONFIG_SND_SOC_WM8731_I2C is not set
+# CONFIG_SND_SOC_WM8731_SPI is not set
+# CONFIG_SND_SOC_WM8737 is not set
+# CONFIG_SND_SOC_WM8741 is not set
+# CONFIG_SND_SOC_WM8750 is not set
+# CONFIG_SND_SOC_WM8753 is not set
+# CONFIG_SND_SOC_WM8770 is not set
+# CONFIG_SND_SOC_WM8776 is not set
+# CONFIG_SND_SOC_WM8782 is not set
+# CONFIG_SND_SOC_WM8804_I2C is not set
+# CONFIG_SND_SOC_WM8804_SPI is not set
+# CONFIG_SND_SOC_WM8903 is not set
+# CONFIG_SND_SOC_WM8904 is not set
+# CONFIG_SND_SOC_WM8940 is not set
+# CONFIG_SND_SOC_WM8960 is not set
+# CONFIG_SND_SOC_WM8961 is not set
+# CONFIG_SND_SOC_WM8962 is not set
+# CONFIG_SND_SOC_WM8974 is not set
+# CONFIG_SND_SOC_WM8978 is not set
+# CONFIG_SND_SOC_WM8985 is not set
+# CONFIG_SND_SOC_XILINX_AUDIO_FORMATTER is not set
+# CONFIG_SND_SOC_XILINX_I2S is not set
+# CONFIG_SND_SOC_XILINX_SPDIF is not set
+# CONFIG_SND_SOC_XTFPGA_I2S is not set
+# CONFIG_SND_SOC_ZL38060 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_SPI is not set
+# CONFIG_SND_SSCAPE is not set
+# CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_ACPI is not set
+# CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_PCI is not set
+# CONFIG_SND_SUN4I_CODEC is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_TEST_COMPONENT is not set
+# CONFIG_SND_TIMER is not set
+# CONFIG_SND_TRIDENT is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_AUDIO_MIDI_V2 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_US122L is not set
+# CONFIG_SND_USB_USX2Y is not set
+# CONFIG_SND_USB_VARIAX is not set
+# CONFIG_SND_UTIMER is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTIO is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_WAVEFRONT is not set
+CONFIG_SND_X86=y
+# CONFIG_SND_XEN_FRONTEND is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
+# CONFIG_SOCK_CGROUP_DATA is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_BRCMSTB is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_SOC_HAS_OMAP2_SDRC is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_SONYPI is not set
+# CONFIG_SONY_LAPTOP is not set
+# CONFIG_SOUND is not set
+# CONFIG_SOUNDWIRE is not set
+# CONFIG_SOUND_OSS_CORE is not set
+# CONFIG_SOUND_OSS_CORE_PRECLAIM is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+# CONFIG_SPARSE_IRQ is not set
+# CONFIG_SPEAKUP is not set
+# CONFIG_SPI is not set
+# CONFIG_SPINLOCK_TEST is not set
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AMD is not set
+# CONFIG_SPI_AU1550 is not set
+# CONFIG_SPI_AX88796C is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BCM2835 is not set
+# CONFIG_SPI_BCM63XX_HSSPI is not set
+# CONFIG_SPI_BCMBCA_HSSPI is not set
+# CONFIG_SPI_BCM_QSPI is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_BUTTERFLY is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+# CONFIG_SPI_CADENCE_XSPI is not set
+# CONFIG_SPI_CH341 is not set
+# CONFIG_SPI_DEBUG is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_FSL_DSPI is not set
+# CONFIG_SPI_FSL_ESPI is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_IMG_SPFI is not set
+# CONFIG_SPI_LANTIQ_SSC is not set
+# CONFIG_SPI_LM70_LLP is not set
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_SPI_MEM is not set
+# CONFIG_SPI_MICROCHIP_CORE is not set
+# CONFIG_SPI_MICROCHIP_CORE_QSPI is not set
+# CONFIG_SPI_MPC52xx is not set
+# CONFIG_SPI_MPC52xx_PSC is not set
+# CONFIG_SPI_MUX is not set
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_NXP_FLEXSPI is not set
+# CONFIG_SPI_OCTEON is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_ORION is not set
+# CONFIG_SPI_PCI1XXXX is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PPC4xx is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_QCOM_QSPI is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_S3C64XX is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SIFIVE is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPI_SN_F_OSPI is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_THUNDERX is not set
+# CONFIG_SPI_TI_QSPI is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_SPS30 is not set
+# CONFIG_SPS30_I2C is not set
+# CONFIG_SPS30_SERIAL is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_CHOICE_DECOMP_BY_MOUNT is not set
+# CONFIG_SQUASHFS_COMPILE_DECOMP_MULTI is not set
+CONFIG_SQUASHFS_COMPILE_DECOMP_MULTI_PERCPU=y
+# CONFIG_SQUASHFS_COMPILE_DECOMP_SINGLE is not set
+CONFIG_SQUASHFS_EMBEDDED=y
+# CONFIG_SQUASHFS_FILE_CACHE is not set
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_LZ4 is not set
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XATTR is not set
+CONFIG_SQUASHFS_XZ=y
+# CONFIG_SQUASHFS_ZLIB is not set
+# CONFIG_SQUASHFS_ZSTD is not set
+# CONFIG_SRAM is not set
+# CONFIG_SRF04 is not set
+# CONFIG_SRF08 is not set
+# CONFIG_SSB is not set
+# CONFIG_SSB_DRIVER_GPIO is not set
+# CONFIG_SSB_HOST_SOC is not set
+# CONFIG_SSB_PCMCIAHOST is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB_SDIOHOST is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SSIF_IPMI_BMC is not set
+# CONFIG_STACKPROTECTOR is not set
+# CONFIG_STACKPROTECTOR_PER_TASK is not set
+# CONFIG_STACKPROTECTOR_STRONG is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_STACKTRACE_BUILD_ID is not set
+CONFIG_STACKTRACE_SUPPORT=y
+# CONFIG_STACK_TRACER is not set
+# CONFIG_STACK_VALIDATION is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_MEDIA is not set
+CONFIG_STANDALONE=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+# CONFIG_STE10XP is not set
+# CONFIG_STK3310 is not set
+# CONFIG_STK8312 is not set
+# CONFIG_STK8BA50 is not set
+# CONFIG_STM is not set
+# CONFIG_STMMAC_ETH is not set
+# CONFIG_STMMAC_PCI is not set
+# CONFIG_STMMAC_PLATFORM is not set
+# CONFIG_STMMAC_SELFTESTS is not set
+# CONFIG_STMPE_ADC is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+CONFIG_STP=y
+# CONFIG_STREAM_PARSER is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_STX104 is not set
+# CONFIG_ST_UVIS25 is not set
+# CONFIG_SUN4I_GPADC is not set
+# CONFIG_SUN50I_DE2_BUS is not set
+# CONFIG_SUN50I_ERRATUM_UNKNOWN1 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_SUNRPC is not set
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_SUNRPC_GSS is not set
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+# CONFIG_SUSPEND is not set
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_SWAP=y
+# CONFIG_SWCONFIG is not set
+# CONFIG_SWCONFIG_B53 is not set
+# CONFIG_SWCONFIG_B53_MMAP_DRIVER is not set
+# CONFIG_SWCONFIG_B53_SPI_DRIVER is not set
+# CONFIG_SWCONFIG_B53_SRAB_DRIVER is not set
+# CONFIG_SWCONFIG_LEDS is not set
+# CONFIG_SWIOTLB is not set
+# CONFIG_SWIOTLB_DYNAMIC is not set
+# CONFIG_SW_SYNC is not set
+# CONFIG_SX9310 is not set
+# CONFIG_SX9324 is not set
+# CONFIG_SX9360 is not set
+# CONFIG_SX9500 is not set
+# CONFIG_SXGBE_ETH is not set
+CONFIG_SYMBOLIC_ERRNAME=y
+# CONFIG_SYNC_FILE is not set
+# CONFIG_SYNTH_EVENTS is not set
+# CONFIG_SYNTH_EVENT_GEN_TEST is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_SYSCON_REBOOT_MODE is not set
+CONFIG_SYSCTL=y
+CONFIG_SYSFS=y
+# CONFIG_SYSFS_SYSCALL is not set
+# CONFIG_SYSTEMPORT is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_T5403 is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_TASKS_RCU is not set
+# CONFIG_TASK_XACCT is not set
+# CONFIG_TC35815 is not set
+# CONFIG_TCG_ATMEL is not set
+# CONFIG_TCG_CRB is not set
+# CONFIG_TCG_FTPM_TEE is not set
+# CONFIG_TCG_INFINEON is not set
+# CONFIG_TCG_NSC is not set
+# CONFIG_TCG_TIS is not set
+# CONFIG_TCG_TIS_I2C is not set
+# CONFIG_TCG_TIS_I2C_ATMEL is not set
+# CONFIG_TCG_TIS_I2C_CR50 is not set
+# CONFIG_TCG_TIS_I2C_INFINEON is not set
+# CONFIG_TCG_TIS_I2C_NUVOTON is not set
+# CONFIG_TCG_TIS_SPI is not set
+# CONFIG_TCG_TIS_ST33ZP24_I2C is not set
+# CONFIG_TCG_TIS_ST33ZP24_SPI is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TCG_TPM2_HMAC is not set
+# CONFIG_TCG_VTPM_PROXY is not set
+# CONFIG_TCG_XEN is not set
+# CONFIG_TCIC is not set
+# CONFIG_TCP_AO is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BBR is not set
+# CONFIG_TCP_CONG_BIC is not set
+# CONFIG_TCP_CONG_CDG is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_DCTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_NV is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_TCS3414 is not set
+# CONFIG_TCS3472 is not set
+# CONFIG_TEE is not set
+# CONFIG_TEGRA_AHB is not set
+# CONFIG_TEGRA_HOST1X is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_TEHUTI_TN40 is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_BITOPS is not set
+# CONFIG_TEST_BLACKHOLE_DEV is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_CLOCKSOURCE_WATCHDOG is not set
+# CONFIG_TEST_DEBUG_VIRTUAL is not set
+# CONFIG_TEST_DHRY is not set
+# CONFIG_TEST_DIV64 is not set
+# CONFIG_TEST_DYNAMIC_DEBUG is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_FREE_PAGES is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_LOCKUP is not set
+# CONFIG_TEST_MAPLE_TREE is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_TEST_MEMINIT is not set
+# CONFIG_TEST_MIN_HEAP is not set
+# CONFIG_TEST_MULDIV64 is not set
+# CONFIG_TEST_OBJPOOL is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_REF_TRACKER is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_SCANF is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UBSAN is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_VMALLOC is not set
+# CONFIG_TEST_XARRAY is not set
+CONFIG_TEXTSEARCH=y
+# CONFIG_TEXTSEARCH_BM is not set
+# CONFIG_TEXTSEARCH_FSM is not set
+# CONFIG_TEXTSEARCH_KMP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_CORE_TESTING is not set
+# CONFIG_THERMAL_DEBUGFS is not set
+# CONFIG_THERMAL_DEFAULT_GOV_BANG_BANG is not set
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_THERMAL_GOV_BANG_BANG is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_THERMAL_MMIO is not set
+# CONFIG_THERMAL_NETLINK is not set
+# CONFIG_THERMAL_STATISTICS is not set
+# CONFIG_THINKPAD_ACPI is not set
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_THUMB2_KERNEL is not set
+# CONFIG_THUNDER_NIC_BGX is not set
+# CONFIG_THUNDER_NIC_PF is not set
+# CONFIG_THUNDER_NIC_RGX is not set
+# CONFIG_THUNDER_NIC_VF is not set
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_TICK_ONESHOT=y
+# CONFIG_TIFM_CORE is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_TIMB_DMA is not set
+CONFIG_TIMERFD=y
+# CONFIG_TIMERLAT_TRACER is not set
+# CONFIG_TIME_NS is not set
+# CONFIG_TINYDRM_HX8357D is not set
+# CONFIG_TINYDRM_ILI9163 is not set
+# CONFIG_TINYDRM_ILI9225 is not set
+# CONFIG_TINYDRM_ILI9341 is not set
+# CONFIG_TINYDRM_ILI9486 is not set
+# CONFIG_TINYDRM_MI0283QT is not set
+# CONFIG_TINYDRM_REPAPER is not set
+# CONFIG_TINYDRM_ST7586 is not set
+# CONFIG_TINYDRM_ST7735R is not set
+CONFIG_TINY_RCU=y
+# CONFIG_TIPC is not set
+# CONFIG_TI_ADC081C is not set
+# CONFIG_TI_ADC0832 is not set
+# CONFIG_TI_ADC084S021 is not set
+# CONFIG_TI_ADC108S102 is not set
+# CONFIG_TI_ADC12138 is not set
+# CONFIG_TI_ADC128S052 is not set
+# CONFIG_TI_ADC161S626 is not set
+# CONFIG_TI_ADS1015 is not set
+# CONFIG_TI_ADS1100 is not set
+# CONFIG_TI_ADS1119 is not set
+# CONFIG_TI_ADS124S08 is not set
+# CONFIG_TI_ADS1298 is not set
+# CONFIG_TI_ADS131E08 is not set
+# CONFIG_TI_ADS7924 is not set
+# CONFIG_TI_ADS7950 is not set
+# CONFIG_TI_ADS8344 is not set
+# CONFIG_TI_ADS8688 is not set
+# CONFIG_TI_AM335X_ADC is not set
+# CONFIG_TI_CPSW is not set
+# CONFIG_TI_CPSW_PHY_SEL is not set
+# CONFIG_TI_CPTS is not set
+# CONFIG_TI_DAC082S085 is not set
+# CONFIG_TI_DAC5571 is not set
+# CONFIG_TI_DAC7311 is not set
+# CONFIG_TI_DAC7612 is not set
+# CONFIG_TI_DAVINCI_MDIO is not set
+# CONFIG_TI_LMP92064 is not set
+# CONFIG_TI_ST is not set
+# CONFIG_TI_TLC4541 is not set
+# CONFIG_TI_TMAG5273 is not set
+# CONFIG_TI_TSC2046 is not set
+# CONFIG_TLAN is not set
+# CONFIG_TLS is not set
+# CONFIG_TLS_DEVICE is not set
+# CONFIG_TLS_TOE is not set
+# CONFIG_TMP006 is not set
+# CONFIG_TMP007 is not set
+# CONFIG_TMP117 is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_INODE64 is not set
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_QUOTA is not set
+CONFIG_TMPFS_XATTR=y
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_TOSHIBA_HAPS is not set
+# CONFIG_TOUCHSCREEN_88PM860X is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_ADC is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT_T37 is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_BU21029 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8505 is not set
+# CONFIG_TOUCHSCREEN_COLIBRI_VF50 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMA140 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP5 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_I2C is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_SPI is not set
+# CONFIG_TOUCHSCREEN_DA9034 is not set
+# CONFIG_TOUCHSCREEN_DA9052 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
+# CONFIG_TOUCHSCREEN_EKTF2127 is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_EXC3000 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GOODIX is not set
+# CONFIG_TOUCHSCREEN_GOODIX_BERLIN_I2C is not set
+# CONFIG_TOUCHSCREEN_GOODIX_BERLIN_SPI is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_HIDEEP is not set
+# CONFIG_TOUCHSCREEN_HIMAX_HX83112B is not set
+# CONFIG_TOUCHSCREEN_HP600 is not set
+# CONFIG_TOUCHSCREEN_HP7XX is not set
+# CONFIG_TOUCHSCREEN_HTCPEN is not set
+# CONFIG_TOUCHSCREEN_HYCON_HY46XX is not set
+# CONFIG_TOUCHSCREEN_HYNITRON_CSTXXX is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_ILITEK is not set
+# CONFIG_TOUCHSCREEN_IMAGIS is not set
+# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_IPAQ_MICRO is not set
+# CONFIG_TOUCHSCREEN_IPROC is not set
+# CONFIG_TOUCHSCREEN_IQS5XX is not set
+# CONFIG_TOUCHSCREEN_IQS7211 is not set
+# CONFIG_TOUCHSCREEN_LPC32XX is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MC13783 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
+# CONFIG_TOUCHSCREEN_MIGOR is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MSG2638 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MX25 is not set
+# CONFIG_TOUCHSCREEN_MXS_LRADC is not set
+# CONFIG_TOUCHSCREEN_NOVATEK_NVT_TS is not set
+# CONFIG_TOUCHSCREEN_PCAP is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_RASPBERRYPI_FW is not set
+# CONFIG_TOUCHSCREEN_RM_TS is not set
+# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
+# CONFIG_TOUCHSCREEN_S6SY761 is not set
+# CONFIG_TOUCHSCREEN_SILEAD is not set
+# CONFIG_TOUCHSCREEN_SIS_I2C is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_STMFTS is not set
+# CONFIG_TOUCHSCREEN_STMPE is not set
+# CONFIG_TOUCHSCREEN_SUN4I is not set
+# CONFIG_TOUCHSCREEN_SUR40 is not set
+# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
+# CONFIG_TOUCHSCREEN_SX8654 is not set
+# CONFIG_TOUCHSCREEN_TI_AM335X_TSC is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_TS4800 is not set
+# CONFIG_TOUCHSCREEN_TSC2004 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_TSC2007_IIO is not set
+# CONFIG_TOUCHSCREEN_TSC200X_CORE is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_USB_3M is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_USB_DMC_TSC10 is not set
+# CONFIG_TOUCHSCREEN_USB_E2I is not set
+# CONFIG_TOUCHSCREEN_USB_EASYTOUCH is not set
+# CONFIG_TOUCHSCREEN_USB_EGALAX is not set
+# CONFIG_TOUCHSCREEN_USB_ELO is not set
+# CONFIG_TOUCHSCREEN_USB_ETT_TC45USB is not set
+# CONFIG_TOUCHSCREEN_USB_ETURBO is not set
+# CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH is not set
+# CONFIG_TOUCHSCREEN_USB_GOTOP is not set
+# CONFIG_TOUCHSCREEN_USB_GUNZE is not set
+# CONFIG_TOUCHSCREEN_USB_IDEALTEK is not set
+# CONFIG_TOUCHSCREEN_USB_IRTOUCH is not set
+# CONFIG_TOUCHSCREEN_USB_ITM is not set
+# CONFIG_TOUCHSCREEN_USB_JASTEC is not set
+# CONFIG_TOUCHSCREEN_USB_NEXIO is not set
+# CONFIG_TOUCHSCREEN_USB_PANJIT is not set
+# CONFIG_TOUCHSCREEN_USB_ZYTRONIC is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_WM831X is not set
+# CONFIG_TOUCHSCREEN_WM9705 is not set
+# CONFIG_TOUCHSCREEN_WM9712 is not set
+# CONFIG_TOUCHSCREEN_WM9713 is not set
+# CONFIG_TOUCHSCREEN_WM97XX is not set
+# CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE is not set
+# CONFIG_TOUCHSCREEN_ZET6223 is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+# CONFIG_TOUCHSCREEN_ZINITIX is not set
+# CONFIG_TPL0102 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_TRACE_EVAL_MAP_FILE is not set
+# CONFIG_TRACE_EVENT_INJECT is not set
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_TRACE_MMIO_ACCESS is not set
+CONFIG_TRACING_SUPPORT=y
+CONFIG_TRAD_SIGNALS=y
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_TREE_RCU is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+# CONFIG_TRUSTED_FOUNDATIONS is not set
+# CONFIG_TRUSTED_KEYS is not set
+# CONFIG_TRUSTED_KEYS_CAAM is not set
+# CONFIG_TRUSTED_KEYS_TEE is not set
+# CONFIG_TRUSTED_KEYS_TPM is not set
+# CONFIG_TSL2583 is not set
+# CONFIG_TSL2591 is not set
+# CONFIG_TSL2772 is not set
+# CONFIG_TSL4531 is not set
+# CONFIG_TSNEP is not set
+# CONFIG_TSYS01 is not set
+# CONFIG_TSYS02D is not set
+# CONFIG_TTPCI_EEPROM is not set
+CONFIG_TTY=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL4030_MADC is not set
+# CONFIG_TWL6030_GPADC is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_TXGBE is not set
+# CONFIG_TYPEC is not set
+# CONFIG_TYPEC_DP_ALTMODE is not set
+# CONFIG_TYPEC_TCPM is not set
+# CONFIG_TYPEC_UCSI is not set
+# CONFIG_TYPHOON is not set
+# CONFIG_UACCE is not set
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_UBIFS_ATIME_SUPPORT is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+# CONFIG_UBIFS_FS_AUTHENTICATION is not set
+CONFIG_UBIFS_FS_LZO=y
+# CONFIG_UBIFS_FS_SECURITY is not set
+CONFIG_UBIFS_FS_XATTR=y
+CONFIG_UBIFS_FS_ZLIB=y
+CONFIG_UBIFS_FS_ZSTD=y
+# CONFIG_UBSAN is not set
+CONFIG_UBSAN_ALIGNMENT=y
+CONFIG_UBSAN_BOOL=y
+# CONFIG_UBSAN_DIV_ZERO is not set
+CONFIG_UBSAN_ENUM=y
+CONFIG_UBSAN_SHIFT=y
+# CONFIG_UBSAN_UNREACHABLE is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDMABUF is not set
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_UFS_FS is not set
+# CONFIG_UHID is not set
+CONFIG_UID16=y
+# CONFIG_UIMAGE_FIT_BLK is not set
+# CONFIG_UIO is not set
+# CONFIG_ULTRA is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_UNICODE is not set
+CONFIG_UNIX=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_UNWINDER_FRAME_POINTER is not set
+# CONFIG_UPROBES is not set
+# CONFIG_UPROBE_EVENTS is not set
+# CONFIG_US5182D is not set
+# CONFIG_USB is not set
+# CONFIG_USB4 is not set
+# CONFIG_USBIP_CORE is not set
+CONFIG_USBIP_VHCI_HC_PORTS=8
+CONFIG_USBIP_VHCI_NR_HCS=1
+# CONFIG_USBIP_VUDC is not set
+# CONFIG_USBPCWATCHDOG is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AIRSPY is not set
+CONFIG_USB_ALI_M5632=y
+# CONFIG_USB_AMD5536UDC is not set
+CONFIG_USB_AN2720=y
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_ATM is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_AUTOSUSPEND_DELAY=2
+# CONFIG_USB_BDC_UDC is not set
+CONFIG_USB_BELKIN=y
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_CDNS3 is not set
+# CONFIG_USB_CDNS3_IMX is not set
+# CONFIG_USB_CDNS3_PCI_WRAP is not set
+# CONFIG_USB_CDNSP_PCI is not set
+# CONFIG_USB_CDNS_SUPPORT is not set
+# CONFIG_USB_CHAOSKEY is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_CHIPIDEA_GENERIC is not set
+# CONFIG_USB_CHIPIDEA_IMX is not set
+# CONFIG_USB_CHIPIDEA_MSM is not set
+# CONFIG_USB_CHIPIDEA_NPCM is not set
+# CONFIG_USB_CHIPIDEA_PCI is not set
+# CONFIG_USB_CHIPIDEA_TEGRA is not set
+# CONFIG_USB_CONFIGFS is not set
+# CONFIG_USB_CONN_GPIO is not set
+# CONFIG_USB_CXACRU is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+CONFIG_USB_DEFAULT_AUTHORIZATION_MODE=1
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_DUMMY_HCD is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_DWC2_DEBUG is not set
+# CONFIG_USB_DWC2_DUAL_ROLE is not set
+# CONFIG_USB_DWC2_HOST is not set
+# CONFIG_USB_DWC2_PERIPHERAL is not set
+# CONFIG_USB_DWC2_TRACK_MISSED_SOFS is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC3_EXYNOS is not set
+# CONFIG_USB_DWC3_HAPS is not set
+# CONFIG_USB_DWC3_KEYSTONE is not set
+# CONFIG_USB_DWC3_OCTEON is not set
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+# CONFIG_USB_DWC3_PCI is not set
+# CONFIG_USB_DWC3_QCOM is not set
+# CONFIG_USB_DWC3_ULPI is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_USB_EHCI_FSL is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_EHCI_HCD_AT91 is not set
+# CONFIG_USB_EHCI_HCD_OMAP is not set
+# CONFIG_USB_EHCI_HCD_PPC_OF is not set
+# CONFIG_USB_EHCI_MV is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_FEW_INIT_RETRIES is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_FSL_USB2 is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_GADGET_VBUS_DRAW=2
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_GSPCA is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_DTCS033 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STK1135 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TOUPTEK is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_G_WEBCAM is not set
+# CONFIG_USB_HACKRF is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+# CONFIG_USB_HID is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_ISP1760 is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_KC2190 is not set
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
+# CONFIG_USB_LED_TRIG is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LGM_PHY is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_MAX3420_UDC is not set
+# CONFIG_USB_MAX3421_HCD is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_MSI2500 is not set
+# CONFIG_USB_MTU3 is not set
+# CONFIG_USB_MUSB_GADGET is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MXS_PHY is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_NET_AQC111 is not set
+# CONFIG_USB_NET_AX88179_178A is not set
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_CDC_MBIM is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_CH9200 is not set
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_DM9601 is not set
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_QMI_WWAN is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_SR9700 is not set
+# CONFIG_USB_NET_SR9800 is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_OHCI_HCD_PCI is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF_BE is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF_LE is not set
+# CONFIG_USB_OHCI_HCD_SSB is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_ONBOARD_DEV is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_DISABLE_EXTERNAL_HUB is not set
+# CONFIG_USB_OTG_FSM is not set
+# CONFIG_USB_OTG_PRODUCTLIST is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_PCI is not set
+# CONFIG_USB_PCI_AMD is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_PHY is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_PWC_INPUT_EVDEV is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_QCOM_EUD is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_RAW_GADGET is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+# CONFIG_USB_ROLES_INTEL_XHCI is not set
+# CONFIG_USB_ROLE_SWITCH is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_RTL8153_ECM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_USB_SERIAL is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_CH348 is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_F8153X is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7715_PARPORT is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MXUPORT is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+CONFIG_USB_SERIAL_SAFE_PADDED=y
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SIMPLE is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_UPD78F0730 is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_XR is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_SNP_UDC_PLAT is not set
+# CONFIG_USB_SPEEDTOUCH is not set
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_TMC is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_UEAGLEATM is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_USS720 is not set
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+# CONFIG_USB_VL600 is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_XEN_HCD is not set
+# CONFIG_USB_XHCI_DBGCAP is not set
+# CONFIG_USB_XHCI_HCD is not set
+# CONFIG_USB_XHCI_MVEBU is not set
+# CONFIG_USB_XHCI_PCI_RENESAS is not set
+# CONFIG_USB_XUSBATM is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USELIB is not set
+# CONFIG_USERFAULTFD is not set
+# CONFIG_USERIO is not set
+# CONFIG_USER_DECRYPTED_DATA is not set
+# CONFIG_USER_EVENTS is not set
+# CONFIG_USE_OF is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_U_SERIAL_CONSOLE is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+# CONFIG_VALIDATE_FS_PARSER is not set
+# CONFIG_VBOXGUEST is not set
+# CONFIG_VCAP is not set
+# CONFIG_VCNL3020 is not set
+# CONFIG_VCNL4000 is not set
+# CONFIG_VCNL4035 is not set
+# CONFIG_VCPU_STALL_DETECTOR is not set
+# CONFIG_VDPA is not set
+CONFIG_VDSO=y
+# CONFIG_VEML6030 is not set
+# CONFIG_VEML6040 is not set
+# CONFIG_VEML6070 is not set
+# CONFIG_VEML6075 is not set
+# CONFIG_VETH is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_VF610_ADC is not set
+# CONFIG_VF610_DAC is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_VFIO is not set
+# CONFIG_VFIO_DEBUGFS is not set
+# CONFIG_VFIO_FSL_MC is not set
+# CONFIG_VFIO_PLATFORM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VGA_ARB is not set
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_VGA_SWITCHEROO is not set
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+CONFIG_VHOST_MENU=y
+# CONFIG_VHOST_NET is not set
+# CONFIG_VHOST_VSOCK is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_VIDEO_AD5820 is not set
+# CONFIG_VIDEO_ADP1653 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_ADV748X is not set
+# CONFIG_VIDEO_ADV7511 is not set
+# CONFIG_VIDEO_ADV7604 is not set
+# CONFIG_VIDEO_ADV7842 is not set
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_AK7375 is not set
+# CONFIG_VIDEO_AK881X is not set
+# CONFIG_VIDEO_AM437X_VPFE is not set
+# CONFIG_VIDEO_AR0521 is not set
+# CONFIG_VIDEO_ASPEED is not set
+# CONFIG_VIDEO_ATMEL_ISC is not set
+# CONFIG_VIDEO_ATMEL_ISI is not set
+# CONFIG_VIDEO_AU0828 is not set
+# CONFIG_VIDEO_BCM2835 is not set
+# CONFIG_VIDEO_BCM2835_UNICAM is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_CADENCE_CSI2RX is not set
+# CONFIG_VIDEO_CADENCE_CSI2TX is not set
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_VIDEO_CAMERA_SENSOR is not set
+# CONFIG_VIDEO_CCS is not set
+# CONFIG_VIDEO_COBALT is not set
+# CONFIG_VIDEO_CODA is not set
+# CONFIG_VIDEO_CS3308 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_CX2341X is not set
+# CONFIG_VIDEO_CX25821 is not set
+# CONFIG_VIDEO_CX25840 is not set
+# CONFIG_VIDEO_CX88 is not set
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_VIDEO_DS90UB913 is not set
+# CONFIG_VIDEO_DS90UB953 is not set
+# CONFIG_VIDEO_DS90UB960 is not set
+# CONFIG_VIDEO_DT3155 is not set
+# CONFIG_VIDEO_DW9714 is not set
+# CONFIG_VIDEO_DW9719 is not set
+# CONFIG_VIDEO_DW9768 is not set
+# CONFIG_VIDEO_DW9807_VCM is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_ET8EK8 is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_GO7007 is not set
+# CONFIG_VIDEO_GS1662 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_HI556 is not set
+# CONFIG_VIDEO_HI846 is not set
+# CONFIG_VIDEO_HI847 is not set
+# CONFIG_VIDEO_I2C is not set
+# CONFIG_VIDEO_IMX208 is not set
+# CONFIG_VIDEO_IMX214 is not set
+# CONFIG_VIDEO_IMX219 is not set
+# CONFIG_VIDEO_IMX258 is not set
+# CONFIG_VIDEO_IMX274 is not set
+# CONFIG_VIDEO_IMX290 is not set
+# CONFIG_VIDEO_IMX296 is not set
+# CONFIG_VIDEO_IMX319 is not set
+# CONFIG_VIDEO_IMX334 is not set
+# CONFIG_VIDEO_IMX335 is not set
+# CONFIG_VIDEO_IMX355 is not set
+# CONFIG_VIDEO_IMX412 is not set
+# CONFIG_VIDEO_IMX7_CSI is not set
+# CONFIG_VIDEO_IMX8MQ_MIPI_CSI2 is not set
+# CONFIG_VIDEO_IMX8_ISI is not set
+# CONFIG_VIDEO_IMX8_JPEG is not set
+# CONFIG_VIDEO_IMX_MIPI_CSIS is not set
+# CONFIG_VIDEO_IMX_PXP is not set
+# CONFIG_VIDEO_IR_I2C is not set
+# CONFIG_VIDEO_ISL7998X is not set
+# CONFIG_VIDEO_IVTV is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_LM3560 is not set
+# CONFIG_VIDEO_LM3646 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_MAX9286 is not set
+# CONFIG_VIDEO_MAX96714 is not set
+# CONFIG_VIDEO_MAX96717 is not set
+# CONFIG_VIDEO_MEM2MEM_DEINTERLACE is not set
+# CONFIG_VIDEO_MGB4 is not set
+# CONFIG_VIDEO_ML86V7667 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_MT9M001 is not set
+# CONFIG_VIDEO_MT9M111 is not set
+# CONFIG_VIDEO_MT9P031 is not set
+# CONFIG_VIDEO_MT9T112 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MT9V032 is not set
+# CONFIG_VIDEO_MT9V111 is not set
+# CONFIG_VIDEO_MUX is not set
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_OG01A1B is not set
+# CONFIG_VIDEO_OMAP2_VOUT is not set
+# CONFIG_VIDEO_OV02A10 is not set
+# CONFIG_VIDEO_OV08D10 is not set
+# CONFIG_VIDEO_OV13858 is not set
+# CONFIG_VIDEO_OV13B10 is not set
+# CONFIG_VIDEO_OV2640 is not set
+# CONFIG_VIDEO_OV2659 is not set
+# CONFIG_VIDEO_OV2680 is not set
+# CONFIG_VIDEO_OV2685 is not set
+# CONFIG_VIDEO_OV2740 is not set
+# CONFIG_VIDEO_OV5640 is not set
+# CONFIG_VIDEO_OV5645 is not set
+# CONFIG_VIDEO_OV5647 is not set
+# CONFIG_VIDEO_OV5648 is not set
+# CONFIG_VIDEO_OV5670 is not set
+# CONFIG_VIDEO_OV5675 is not set
+# CONFIG_VIDEO_OV5693 is not set
+# CONFIG_VIDEO_OV5695 is not set
+# CONFIG_VIDEO_OV6650 is not set
+# CONFIG_VIDEO_OV7251 is not set
+# CONFIG_VIDEO_OV7640 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_OV772X is not set
+# CONFIG_VIDEO_OV7740 is not set
+# CONFIG_VIDEO_OV8856 is not set
+# CONFIG_VIDEO_OV8865 is not set
+# CONFIG_VIDEO_OV9282 is not set
+# CONFIG_VIDEO_OV9640 is not set
+# CONFIG_VIDEO_OV9650 is not set
+# CONFIG_VIDEO_OV9734 is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_RASPBERRYPI_PISP_BE is not set
+# CONFIG_VIDEO_RCAR_CSI2 is not set
+# CONFIG_VIDEO_RCAR_ISP is not set
+# CONFIG_VIDEO_RCAR_VIN is not set
+# CONFIG_VIDEO_RDACM20 is not set
+# CONFIG_VIDEO_RDACM21 is not set
+# CONFIG_VIDEO_RJ54N1 is not set
+# CONFIG_VIDEO_ROCKCHIP_ISP1 is not set
+# CONFIG_VIDEO_S5C73M3 is not set
+# CONFIG_VIDEO_S5K5BAF is not set
+# CONFIG_VIDEO_S5K6A3 is not set
+# CONFIG_VIDEO_SAA6588 is not set
+# CONFIG_VIDEO_SAA6752HS is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7134 is not set
+# CONFIG_VIDEO_SAA7164 is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_SOLO6X10 is not set
+# CONFIG_VIDEO_SONY_BTF_MPX is not set
+# CONFIG_VIDEO_STK1160 is not set
+# CONFIG_VIDEO_ST_MIPID02 is not set
+# CONFIG_VIDEO_SUN4I_CSI is not set
+# CONFIG_VIDEO_SUN6I_CSI is not set
+# CONFIG_VIDEO_SUN8I_A83T_MIPI_CSI2 is not set
+# CONFIG_VIDEO_TC358743 is not set
+# CONFIG_VIDEO_TC358746 is not set
+# CONFIG_VIDEO_TDA1997X is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_THP7312 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_THS8200 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_TW2804 is not set
+# CONFIG_VIDEO_TW5864 is not set
+# CONFIG_VIDEO_TW68 is not set
+# CONFIG_VIDEO_TW9900 is not set
+# CONFIG_VIDEO_TW9903 is not set
+# CONFIG_VIDEO_TW9906 is not set
+# CONFIG_VIDEO_TW9910 is not set
+# CONFIG_VIDEO_UDA1342 is not set
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_USBTV is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+# CONFIG_VIDEO_VPX3220 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_XILINX is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_CONSOLE is not set
+# CONFIG_VIRTIO_FS is not set
+# CONFIG_VIRTIO_INPUT is not set
+CONFIG_VIRTIO_MENU=y
+# CONFIG_VIRTIO_MMIO is not set
+# CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES is not set
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_VFIO_PCI is not set
+# CONFIG_VIRTUALIZATION is not set
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_VL53L0X_I2C is not set
+# CONFIG_VL6180 is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_VMAP_STACK is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_VMLINUX_MAP is not set
+# CONFIG_VMSPLIT_1G is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_2G_OPT is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_VMWARE_VMCI is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_VORTEX is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_VSOCKETS_DIAG is not set
+# CONFIG_VT is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_VXLAN is not set
+# CONFIG_VZ89X is not set
+# CONFIG_W1 is not set
+# CONFIG_W1_CON is not set
+# CONFIG_W1_MASTER_AMD_AXI is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_GPIO is not set
+# CONFIG_W1_MASTER_MATROX is not set
+# CONFIG_W1_MASTER_SGI is not set
+# CONFIG_W1_MASTER_UART is not set
+# CONFIG_W1_SLAVE_DS2405 is not set
+# CONFIG_W1_SLAVE_DS2406 is not set
+# CONFIG_W1_SLAVE_DS2408 is not set
+# CONFIG_W1_SLAVE_DS2413 is not set
+# CONFIG_W1_SLAVE_DS2423 is not set
+# CONFIG_W1_SLAVE_DS2430 is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+# CONFIG_W1_SLAVE_DS2438 is not set
+# CONFIG_W1_SLAVE_DS250X is not set
+# CONFIG_W1_SLAVE_DS2780 is not set
+# CONFIG_W1_SLAVE_DS2781 is not set
+# CONFIG_W1_SLAVE_DS2805 is not set
+# CONFIG_W1_SLAVE_DS28E04 is not set
+# CONFIG_W1_SLAVE_DS28E17 is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_WAN is not set
+# CONFIG_WANXL is not set
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=y
+# CONFIG_WATCHDOG_HRTIMER_PRETIMEOUT is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+CONFIG_WATCHDOG_OPEN_TIMEOUT=0
+# CONFIG_WATCHDOG_PRETIMEOUT_GOV is not set
+# CONFIG_WATCHDOG_SYSFS is not set
+# CONFIG_WATCH_QUEUE is not set
+# CONFIG_WD80x3 is not set
+# CONFIG_WDAT_WDT is not set
+# CONFIG_WDTPCI is not set
+# CONFIG_WERROR is not set
+# CONFIG_WEXT_CORE is not set
+# CONFIG_WEXT_PRIV is not set
+# CONFIG_WEXT_PROC is not set
+# CONFIG_WEXT_SPY is not set
+# CONFIG_WIREGUARD is not set
+CONFIG_WIRELESS=y
+# CONFIG_WIRELESS_EXT is not set
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+# CONFIG_WL1251 is not set
+# CONFIG_WL12XX is not set
+# CONFIG_WL18XX is not set
+CONFIG_WLAN=y
+# CONFIG_WLAN_VENDOR_ADMTEK is not set
+# CONFIG_WLAN_VENDOR_ATH is not set
+# CONFIG_WLAN_VENDOR_ATMEL is not set
+# CONFIG_WLAN_VENDOR_BROADCOM is not set
+# CONFIG_WLAN_VENDOR_INTEL is not set
+# CONFIG_WLAN_VENDOR_INTERSIL is not set
+# CONFIG_WLAN_VENDOR_MARVELL is not set
+# CONFIG_WLAN_VENDOR_MEDIATEK is not set
+# CONFIG_WLAN_VENDOR_MICROCHIP is not set
+# CONFIG_WLAN_VENDOR_PURELIFI is not set
+# CONFIG_WLAN_VENDOR_QUANTENNA is not set
+# CONFIG_WLAN_VENDOR_RALINK is not set
+# CONFIG_WLAN_VENDOR_REALTEK is not set
+# CONFIG_WLAN_VENDOR_RSI is not set
+# CONFIG_WLAN_VENDOR_SILABS is not set
+# CONFIG_WLAN_VENDOR_ST is not set
+# CONFIG_WLAN_VENDOR_TI is not set
+# CONFIG_WLAN_VENDOR_ZYDAS is not set
+# CONFIG_WLCORE is not set
+# CONFIG_WPCM450_SOC is not set
+# CONFIG_WQ_CPU_INTENSIVE_REPORT is not set
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_WWAN is not set
+# CONFIG_WWAN_HWSIM is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_X25 is not set
+# CONFIG_X509_CERTIFICATE_PARSER is not set
+# CONFIG_X86_PKG_TEMP_THERMAL is not set
+# CONFIG_X9250 is not set
+# CONFIG_XDP_SOCKETS is not set
+# CONFIG_XEN is not set
+# CONFIG_XEN_GRANT_DMA_ALLOC is not set
+# CONFIG_XEN_PVCALLS_FRONTEND is not set
+CONFIG_XEN_SCRUB_PAGES_DEFAULT=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_INTERFACE is not set
+# CONFIG_XFRM_IPCOMP is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_ONLINE_SCRUB is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_SUPPORT_ASCII_CI is not set
+# CONFIG_XFS_SUPPORT_V4 is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XILINX_AXI_EMAC is not set
+# CONFIG_XILINX_DMA is not set
+# CONFIG_XILINX_EMACLITE is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_XILINX_INTC is not set
+# CONFIG_XILINX_LL_TEMAC is not set
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_XILINX_VCU is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_XILINX_WINDOW_WATCHDOG is not set
+# CONFIG_XILINX_XADC is not set
+# CONFIG_XILINX_XDMA is not set
+# CONFIG_XILINX_ZYNQMP_DMA is not set
+# CONFIG_XILINX_ZYNQMP_DPDMA is not set
+# CONFIG_XILLYBUS is not set
+# CONFIG_XILLYUSB is not set
+# CONFIG_XIL_AXIS_FIFO is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_XMON is not set
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARM64 is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_BCJ is not set
+# CONFIG_XZ_DEC_MICROLZMA is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_RISCV is not set
+# CONFIG_XZ_DEC_SPARC is not set
+# CONFIG_XZ_DEC_TEST is not set
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_YAM is not set
+# CONFIG_YAMAHA_YAS530 is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_YENTA is not set
+# CONFIG_YENTA_O2 is not set
+# CONFIG_YENTA_RICOH is not set
+# CONFIG_YENTA_TI is not set
+# CONFIG_YENTA_TOSHIBA is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_ZD1211RW_DEBUG is not set
+# CONFIG_ZEROPLUS_FF is not set
+# CONFIG_ZERO_CALL_USED_REGS is not set
+# CONFIG_ZIIRAVE_WATCHDOG is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_ZLIB_DEFLATE is not set
+# CONFIG_ZLIB_INFLATE is not set
+CONFIG_ZONE_DMA=y
+# CONFIG_ZOPT2201 is not set
+# CONFIG_ZPA2326 is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZRAM is not set
+# CONFIG_ZRAM_BACKEND_842 is not set
+# CONFIG_ZRAM_BACKEND_DEFLATE is not set
+# CONFIG_ZRAM_BACKEND_LZ4 is not set
+# CONFIG_ZRAM_BACKEND_LZ4HC is not set
+# CONFIG_ZRAM_BACKEND_LZO is not set
+# CONFIG_ZRAM_BACKEND_ZSTD is not set
+CONFIG_ZRAM_DEF_COMP="unset-value"
+# CONFIG_ZRAM_DEF_COMP_842 is not set
+# CONFIG_ZRAM_DEF_COMP_LZ4 is not set
+# CONFIG_ZRAM_DEF_COMP_LZ4HC is not set
+# CONFIG_ZRAM_DEF_COMP_LZO is not set
+# CONFIG_ZRAM_DEF_COMP_LZORLE is not set
+# CONFIG_ZRAM_DEF_COMP_ZSTD is not set
+# CONFIG_ZRAM_MEMORY_TRACKING is not set
+# CONFIG_ZRAM_MULTI_COMP is not set
+# CONFIG_ZRAM_TRACK_ENTRY_ACTIME is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_ZSMALLOC_CHAIN_SIZE=8
+# CONFIG_ZSWAP is not set
diff --git a/target/linux/generic/config-6.6 b/target/linux/generic/config-6.6
index 46283ac3bd..58e97fdf70 100644
--- a/target/linux/generic/config-6.6
+++ b/target/linux/generic/config-6.6
@@ -5149,6 +5149,7 @@ CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
 # CONFIG_RTL8187 is not set
 # CONFIG_RTL8192E is not set
 # CONFIG_RTL8192U is not set
+# CONFIG_RTL8261N_PHY is not set
 # CONFIG_RTL8306_PHY is not set
 # CONFIG_RTL8366RB_PHY is not set
 # CONFIG_RTL8366S_PHY is not set
diff --git a/target/linux/generic/config-filter b/target/linux/generic/config-filter
index 274c31ecb0..eaf3bc7035 100644
--- a/target/linux/generic/config-filter
+++ b/target/linux/generic/config-filter
@@ -13,8 +13,12 @@ CONFIG_FRAME_WARN=.*
 # CONFIG_INLINE_.* is not set
 # CONFIG_LD_.* is not set
 CONFIG_LLD_VERSION=.*
+CONFIG_PAHOLE_HAS_LANG_EXCLUDE=.*
 CONFIG_PAHOLE_HAS_SPLIT_BTF=.*
 CONFIG_PAHOLE_VERSION=.*
 CONFIG_PLUGIN_HOSTCC=".*"
+CONFIG_RUSTC_LLVM_VERSION=.*
+CONFIG_RUSTC_SUPPORTS_.*=.*
+CONFIG_RUSTC_VERSION=.*
 # CONFIG_SET_FS is not set
 # CONFIG_TASKS_.* is not set
diff --git a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_lzma.c b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_lzma.c
index c58f7ae4bf..6dcffd0420 100644
--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_lzma.c
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_lzma.c
@@ -14,8 +14,13 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/of.h>
+#include <linux/version.h>
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,12,0)
 #include <asm/unaligned.h>
+#else
+#include <linux/unaligned.h>
+#endif
 
 #include "mtdsplit.h"
 
diff --git a/target/linux/generic/files/drivers/mtd/nand/mtk_bmt_v2.c b/target/linux/generic/files/drivers/mtd/nand/mtk_bmt_v2.c
index 6b06948c0f..a17b729026 100644
--- a/target/linux/generic/files/drivers/mtd/nand/mtk_bmt_v2.c
+++ b/target/linux/generic/files/drivers/mtd/nand/mtk_bmt_v2.c
@@ -304,7 +304,7 @@ mtk_bmt_get_mapping_mask(void)
 	unsigned long *used;
 	int i, k;
 
-	used = kcalloc(sizeof(unsigned long), BIT_WORD(bmtd.bmt_blk_idx) + 1, GFP_KERNEL);
+	used = kcalloc(BIT_WORD(bmtd.bmt_blk_idx) + 1, sizeof(unsigned long), GFP_KERNEL);
 	if (!used)
 		return NULL;
 
diff --git a/target/linux/generic/files/drivers/net/phy/adm6996.c b/target/linux/generic/files/drivers/net/phy/adm6996.c
index 66013f273d..dfee13c0bf 100644
--- a/target/linux/generic/files/drivers/net/phy/adm6996.c
+++ b/target/linux/generic/files/drivers/net/phy/adm6996.c
@@ -1199,19 +1199,17 @@ static int adm6996_gpio_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int adm6996_gpio_remove(struct platform_device *pdev)
+static void adm6996_gpio_remove(struct platform_device *pdev)
 {
 	struct adm6996_priv *priv = platform_get_drvdata(pdev);
 
 	if (priv && (priv->model == ADM6996M || priv->model == ADM6996L))
 		unregister_switch(&priv->dev);
-
-	return 0;
 }
 
 static struct platform_driver adm6996_gpio_driver = {
 	.probe = adm6996_gpio_probe,
-	.remove = adm6996_gpio_remove,
+	.remove_new = adm6996_gpio_remove,
 	.driver = {
 		.name = "adm6996_gpio",
 	},
diff --git a/target/linux/generic/files/drivers/net/phy/b53/b53_mmap.c b/target/linux/generic/files/drivers/net/phy/b53/b53_mmap.c
index 0a21ff1de5..62dfe1c242 100644
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_mmap.c
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_mmap.c
@@ -217,19 +217,17 @@ static int b53_mmap_probe(struct platform_device *pdev)
 	return b53_swconfig_switch_register(dev);
 }
 
-static int b53_mmap_remove(struct platform_device *pdev)
+static void b53_mmap_remove(struct platform_device *pdev)
 {
 	struct b53_device *dev = platform_get_drvdata(pdev);
 
 	if (dev)
 		b53_switch_remove(dev);
-
-	return 0;
 }
 
 static struct platform_driver b53_mmap_driver = {
 	.probe = b53_mmap_probe,
-	.remove = b53_mmap_remove,
+	.remove_new = b53_mmap_remove,
 	.driver = {
 		.name = "b53-switch",
 	},
diff --git a/target/linux/generic/files/drivers/net/phy/b53/b53_srab.c b/target/linux/generic/files/drivers/net/phy/b53/b53_srab.c
index ead5209cf0..f8cb99383f 100644
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_srab.c
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_srab.c
@@ -354,19 +354,17 @@ static int b53_srab_probe(struct platform_device *pdev)
 	return b53_swconfig_switch_register(dev);
 }
 
-static int b53_srab_remove(struct platform_device *pdev)
+static void b53_srab_remove(struct platform_device *pdev)
 {
 	struct b53_device *dev = platform_get_drvdata(pdev);
 
 	if (dev)
 		b53_switch_remove(dev);
-
-	return 0;
 }
 
 static struct platform_driver b53_srab_driver = {
 	.probe = b53_srab_probe,
-	.remove = b53_srab_remove,
+	.remove_new = b53_srab_remove,
 	.driver = {
 		.name = "b53-srab-switch",
 	},
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/Kconfig b/target/linux/generic/files/drivers/net/phy/rtl8261n/Kconfig
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/Kconfig
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/Kconfig
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/Makefile b/target/linux/generic/files/drivers/net/phy/rtl8261n/Makefile
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/Makefile
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/Makefile
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/construct/conf_rtl8261n_c.c b/target/linux/generic/files/drivers/net/phy/rtl8261n/construct/conf_rtl8261n_c.c
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/construct/conf_rtl8261n_c.c
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/construct/conf_rtl8261n_c.c
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/construct/conf_rtl8264b.c b/target/linux/generic/files/drivers/net/phy/rtl8261n/construct/conf_rtl8264b.c
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/construct/conf_rtl8264b.c
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/construct/conf_rtl8264b.c
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/error.h b/target/linux/generic/files/drivers/net/phy/rtl8261n/error.h
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/error.h
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/error.h
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/phy_patch.c b/target/linux/generic/files/drivers/net/phy/rtl8261n/phy_patch.c
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/phy_patch.c
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/phy_patch.c
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/phy_patch.h b/target/linux/generic/files/drivers/net/phy/rtl8261n/phy_patch.h
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/phy_patch.h
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/phy_patch.h
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.c b/target/linux/generic/files/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.c
similarity index 99%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.c
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.c
index 90a792a17b..0bfd93033f 100644
--- a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.c
+++ b/target/linux/generic/files/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.c
@@ -66,7 +66,7 @@ static uint16 _phy_rtl826xb_mmd_convert(uint16 page, uint16 addr)
     return reg;
 }
 
-int32
+static int32
 _phy_rtl826xb_patch_wait(uint32 unit, rtk_port_t port, uint32 mmdAddr, uint32 mmdReg, uint32 data, uint32 mask, uint8 patch_mode)
 {
     int32  ret = 0;
@@ -211,7 +211,7 @@ _phy_rtl826xb_patch_wait(uint32 unit, rtk_port_t port, uint32 mmdAddr, uint32 mm
     return RT_ERR_OK;
 }
 
-int32
+static int32
 _phy_rtl826xb_patch_wait_not_equal(uint32 unit, rtk_port_t port, uint32 mmdAddr, uint32 mmdReg, uint32 data, uint32 mask, uint8 patch_mode)
 {
     int32  ret = 0;
@@ -355,7 +355,7 @@ _phy_rtl826xb_patch_wait_not_equal(uint32 unit, rtk_port_t port, uint32 mmdAddr,
     return RT_ERR_OK;
 }
 
-int32
+static int32
 _phy_rtl826xb_patch_top_get(uint32 unit, rtk_port_t port, uint32 topPage, uint32 topReg, uint32 *pData)
 {
     int32  ret = 0;
@@ -368,7 +368,7 @@ _phy_rtl826xb_patch_top_get(uint32 unit, rtk_port_t port, uint32 topPage, uint32
     return RT_ERR_OK;
 }
 
-int32
+static int32
 _phy_rtl826xb_patch_top_set(uint32 unit, rtk_port_t port, uint32 topPage, uint32 topReg, uint32 wData)
 {
     int32  ret = 0;
@@ -378,7 +378,7 @@ _phy_rtl826xb_patch_top_set(uint32 unit, rtk_port_t port, uint32 topPage, uint32
     return RT_ERR_OK;
 }
 
-int32
+static int32
 _phy_rtl826xb_patch_sds_get(uint32 unit, rtk_port_t port, uint32 sdsPage, uint32 sdsReg, uint32 *pData)
 {
     int32  ret = 0;
@@ -393,7 +393,7 @@ _phy_rtl826xb_patch_sds_get(uint32 unit, rtk_port_t port, uint32 sdsPage, uint32
     return _phy_rtl826xb_patch_wait(unit, port, PHY_MMD_VEND1, 0x143, 0, BIT_15, PHY_PATCH_MODE_NORMAL);
 }
 
-int32
+static int32
 _phy_rtl826xb_patch_sds_set(uint32 unit, rtk_port_t port, uint32 sdsPage, uint32 sdsReg, uint32 wData, uint8 patch_mode)
 {
     int32  ret = 0;
@@ -693,7 +693,7 @@ static int32 _phy_rtl826xb_flow_s(uint32 unit, rtk_port_t port, uint8 portOffset
     return RT_ERR_OK;
 }
 
-int32 phy_rtl826xb_patch_op(uint32 unit, rtk_port_t port, uint8 portOffset, rtk_hwpatch_t *pPatch_data, uint8 patch_mode)
+static int32 phy_rtl826xb_patch_op(uint32 unit, rtk_port_t port, uint8 portOffset, rtk_hwpatch_t *pPatch_data, uint8 patch_mode)
 {
     int32 ret = RT_ERR_OK;
     uint32 rData = 0, wData = 0;
@@ -803,7 +803,7 @@ int32 phy_rtl826xb_patch_op(uint32 unit, rtk_port_t port, uint8 portOffset, rtk_
     return ret;
 }
 
-int32 phy_rtl826xb_patch_flow(uint32 unit, rtk_port_t port, uint8 portOffset, uint8 patch_flow, uint8 patch_mode)
+static int32 phy_rtl826xb_patch_flow(uint32 unit, rtk_port_t port, uint8 portOffset, uint8 patch_flow, uint8 patch_mode)
 {
     int32 ret = RT_ERR_OK;
 
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.h b/target/linux/generic/files/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.h
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.h
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/phy_rtl826xb_patch.h
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_osal.c b/target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_osal.c
similarity index 98%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_osal.c
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_osal.c
index bf3ac4b124..35339400d0 100644
--- a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_osal.c
+++ b/target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_osal.c
@@ -7,6 +7,7 @@
 #include "type.h"
 #include "error.h"
 #include "rtk_phylib_def.h"
+#include "rtk_osal.h"
 
 #include <linux/version.h>
 #include <linux/jiffies.h>
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_osal.h b/target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_osal.h
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_osal.h
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_osal.h
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phy.c b/target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phy.c
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phy.c
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phy.c
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib.c b/target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib.c
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib.c
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib.c
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib.h b/target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib.h
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib.h
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib.h
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib_def.h b/target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib_def.h
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib_def.h
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib_def.h
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.c b/target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.c
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.c
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.c
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.h b/target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.h
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.h
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/rtk_phylib_rtl826xb.h
diff --git a/target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/type.h b/target/linux/generic/files/drivers/net/phy/rtl8261n/type.h
similarity index 100%
rename from target/linux/mediatek/files-6.6/drivers/net/phy/rtl8261n/type.h
rename to target/linux/generic/files/drivers/net/phy/rtl8261n/type.h
diff --git a/target/linux/generic/files/drivers/net/phy/rtl8366rb.c b/target/linux/generic/files/drivers/net/phy/rtl8366rb.c
index 0878ca9f14..7057b25252 100644
--- a/target/linux/generic/files/drivers/net/phy/rtl8366rb.c
+++ b/target/linux/generic/files/drivers/net/phy/rtl8366rb.c
@@ -1478,7 +1478,7 @@ static int rtl8366rb_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int rtl8366rb_remove(struct platform_device *pdev)
+static void rtl8366rb_remove(struct platform_device *pdev)
 {
 	struct rtl8366_smi *smi = platform_get_drvdata(pdev);
 
@@ -1488,8 +1488,6 @@ static int rtl8366rb_remove(struct platform_device *pdev)
 		rtl8366_smi_cleanup(smi);
 		kfree(smi);
 	}
-
-	return 0;
 }
 
 #ifdef CONFIG_OF
@@ -1506,7 +1504,7 @@ static struct platform_driver rtl8366rb_driver = {
 		.of_match_table = of_match_ptr(rtl8366rb_match),
 	},
 	.probe		= rtl8366rb_probe,
-	.remove		= rtl8366rb_remove,
+	.remove_new		= rtl8366rb_remove,
 };
 
 static int __init rtl8366rb_module_init(void)
diff --git a/target/linux/generic/files/drivers/net/phy/rtl8366s.c b/target/linux/generic/files/drivers/net/phy/rtl8366s.c
index d4045fcc06..5458c50487 100644
--- a/target/linux/generic/files/drivers/net/phy/rtl8366s.c
+++ b/target/linux/generic/files/drivers/net/phy/rtl8366s.c
@@ -1266,7 +1266,7 @@ static int rtl8366s_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int rtl8366s_remove(struct platform_device *pdev)
+static void rtl8366s_remove(struct platform_device *pdev)
 {
 	struct rtl8366_smi *smi = platform_get_drvdata(pdev);
 
@@ -1276,8 +1276,6 @@ static int rtl8366s_remove(struct platform_device *pdev)
 		rtl8366_smi_cleanup(smi);
 		kfree(smi);
 	}
-
-	return 0;
 }
 
 #ifdef CONFIG_OF
@@ -1296,7 +1294,7 @@ static struct platform_driver rtl8366s_driver = {
 #endif
 	},
 	.probe		= rtl8366s_probe,
-	.remove		= rtl8366s_remove,
+	.remove_new	= rtl8366s_remove,
 };
 
 static int __init rtl8366s_module_init(void)
diff --git a/target/linux/generic/files/drivers/net/phy/rtl8367.c b/target/linux/generic/files/drivers/net/phy/rtl8367.c
index 950e9d2767..1b996019a6 100644
--- a/target/linux/generic/files/drivers/net/phy/rtl8367.c
+++ b/target/linux/generic/files/drivers/net/phy/rtl8367.c
@@ -1801,7 +1801,7 @@ static int rtl8367_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int rtl8367_remove(struct platform_device *pdev)
+static void rtl8367_remove(struct platform_device *pdev)
 {
 	struct rtl8366_smi *smi = platform_get_drvdata(pdev);
 
@@ -1811,8 +1811,6 @@ static int rtl8367_remove(struct platform_device *pdev)
 		rtl8366_smi_cleanup(smi);
 		kfree(smi);
 	}
-
-	return 0;
 }
 
 static void rtl8367_shutdown(struct platform_device *pdev)
@@ -1839,7 +1837,7 @@ static struct platform_driver rtl8367_driver = {
 #endif
 	},
 	.probe		= rtl8367_probe,
-	.remove		= rtl8367_remove,
+	.remove_new	= rtl8367_remove,
 	.shutdown	= rtl8367_shutdown,
 };
 
diff --git a/target/linux/generic/files/drivers/net/phy/rtl8367b.c b/target/linux/generic/files/drivers/net/phy/rtl8367b.c
index 5f885aa5be..5adcf00f0c 100644
--- a/target/linux/generic/files/drivers/net/phy/rtl8367b.c
+++ b/target/linux/generic/files/drivers/net/phy/rtl8367b.c
@@ -1600,7 +1600,7 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int rtl8367b_remove(struct platform_device *pdev)
+static void rtl8367b_remove(struct platform_device *pdev)
 {
 	struct rtl8366_smi *smi = platform_get_drvdata(pdev);
 
@@ -1610,8 +1610,6 @@ static int rtl8367b_remove(struct platform_device *pdev)
 		rtl8366_smi_cleanup(smi);
 		kfree(smi);
 	}
-
-	return 0;
 }
 
 static void rtl8367b_shutdown(struct platform_device *pdev)
@@ -1638,7 +1636,7 @@ static struct platform_driver rtl8367b_driver = {
 #endif
 	},
 	.probe		= rtl8367b_probe,
-	.remove		= rtl8367b_remove,
+	.remove_new	= rtl8367b_remove,
 	.shutdown	= rtl8367b_shutdown,
 };
 
diff --git a/target/linux/generic/hack-6.12/200-tools_portability.patch b/target/linux/generic/hack-6.12/200-tools_portability.patch
new file mode 100644
index 0000000000..58ef2231c0
--- /dev/null
+++ b/target/linux/generic/hack-6.12/200-tools_portability.patch
@@ -0,0 +1,176 @@
+From a7ae4ed0a3951c45d4a59ee575951b64ae4a23fb Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 7 May 2024 12:22:15 +0200
+Subject: [PATCH] kernel: fix tools build breakage on macos with x86
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+--- a/tools/scripts/Makefile.include
++++ b/tools/scripts/Makefile.include
+@@ -72,8 +72,6 @@ $(call allow-override,CXX,$(CROSS_COMPIL
+ $(call allow-override,STRIP,$(CROSS_COMPILE)strip)
+ endif
+ 
+-CC_NO_CLANG := $(shell $(CC) -dM -E -x c /dev/null | grep -Fq "__clang__"; echo $$?)
+-
+ ifneq ($(LLVM),)
+ HOSTAR  ?= $(LLVM_PREFIX)llvm-ar$(LLVM_SUFFIX)
+ HOSTCC  ?= $(LLVM_PREFIX)clang$(LLVM_SUFFIX)
+@@ -84,6 +82,9 @@ HOSTCC  ?= gcc
+ HOSTLD  ?= ld
+ endif
+ 
++CC_NO_CLANG := $(shell $(CC) -dM -E -x c /dev/null | grep -Fq "__clang__"; echo $$?)
++HOSTCC_NO_CLANG := $(shell $(HOSTCC) -dM -E -x c /dev/null | grep -Fq "__clang__"; echo $$?)
++
+ # Some tools require Clang, LLC and/or LLVM utils
+ CLANG		?= clang
+ LLC		?= llc
+@@ -92,8 +93,9 @@ LLVM_OBJCOPY	?= llvm-objcopy
+ LLVM_STRIP	?= llvm-strip
+ 
+ ifeq ($(CC_NO_CLANG), 1)
+-EXTRA_WARNINGS += -Wstrict-aliasing=3
+-
++  ifeq ($(HOSTCC_NO_CLANG), 1)
++    EXTRA_WARNINGS += -Wstrict-aliasing=3
++  endif
+ else ifneq ($(CROSS_COMPILE),)
+ # Allow userspace to override CLANG_CROSS_FLAGS to specify their own
+ # sysroots and flags or to avoid the GCC call in pure Clang builds.
+--- a/tools/include/linux/types.h
++++ b/tools/include/linux/types.h
+@@ -56,6 +56,7 @@ typedef __s8  s8;
+ #define __user
+ #endif
+ #define __must_check
++#undef __cold
+ #define __cold
+ 
+ typedef __u16 __bitwise __le16;
+--- a/tools/objtool/include/objtool/objtool.h
++++ b/tools/objtool/include/objtool/objtool.h
+@@ -12,6 +12,7 @@
+ 
+ #include <objtool/elf.h>
+ 
++#undef __weak
+ #define __weak __attribute__((weak))
+ 
+ struct pv_state {
+--- a/tools/include/asm-generic/bitops/fls.h
++++ b/tools/include/asm-generic/bitops/fls.h
+@@ -2,6 +2,8 @@
+ #ifndef _ASM_GENERIC_BITOPS_FLS_H_
+ #define _ASM_GENERIC_BITOPS_FLS_H_
+ 
++#include <string.h>
++
+ /**
+  * generic_fls - find last (most-significant) bit set
+  * @x: the word to search
+@@ -10,6 +12,7 @@
+  * Note fls(0) = 0, fls(1) = 1, fls(0x80000000) = 32.
+  */
+ 
++#define generic_fls __linux_fls
+ static __always_inline int generic_fls(unsigned int x)
+ {
+ 	int r = 32;
+--- a/tools/lib/string.c
++++ b/tools/lib/string.c
+@@ -96,6 +96,7 @@ int strtobool(const char *s, bool *res)
+  * If libc has strlcpy() then that version will override this
+  * implementation:
+  */
++#ifndef __APPLE__
+ #ifdef __clang__
+ #pragma clang diagnostic push
+ #pragma clang diagnostic ignored "-Wignored-attributes"
+@@ -114,6 +115,7 @@ size_t __weak strlcpy(char *dest, const
+ #ifdef __clang__
+ #pragma clang diagnostic pop
+ #endif
++#endif
+ 
+ /**
+  * skip_spaces - Removes leading whitespace from @str.
+--- a/tools/arch/x86/include/asm/insn.h
++++ b/tools/arch/x86/include/asm/insn.h
+@@ -7,7 +7,7 @@
+  * Copyright (C) IBM Corporation, 2009
+  */
+ 
+-#include <asm/byteorder.h>
++#include <linux/kernel.h>
+ /* insn_attr_t is defined in inat.h */
+ #include "inat.h" /* __ignore_sync_check__ */
+ 
+--- a/tools/arch/x86/include/asm/orc_types.h
++++ b/tools/arch/x86/include/asm/orc_types.h
+@@ -46,7 +46,17 @@
+ #define ORC_TYPE_REGS_PARTIAL		4
+ 
+ #ifndef __ASSEMBLY__
++#ifdef __APPLE__
++#include <endian.h>
++
++#if __BYTE_ORDER == __LITTLE_ENDIAN
++#define __LITTLE_ENDIAN_BITFIELD
++#elif __BYTE_ORDER == __BIG_ENDIAN
++#define __BIG_ENDIAN_BITFIELD
++#endif
++#else
+ #include <asm/byteorder.h>
++#endif
+ 
+ /*
+  * This struct is more or less a vastly simplified version of the DWARF Call
+--- a/tools/include/linux/rbtree.h
++++ b/tools/include/linux/rbtree.h
+@@ -18,7 +18,6 @@
+ #define __TOOLS_LINUX_PERF_RBTREE_H
+ 
+ #include <linux/kernel.h>
+-#include <linux/stddef.h>
+ 
+ struct rb_node {
+ 	unsigned long  __rb_parent_color;
+--- a/tools/lib/subcmd/exec-cmd.c
++++ b/tools/lib/subcmd/exec-cmd.c
+@@ -12,7 +12,10 @@
+ #include "subcmd-config.h"
+ 
+ #define MAX_ARGS	32
++
++#ifndef PATH_MAX
+ #define PATH_MAX	4096
++#endif
+ 
+ static const char *argv_exec_path;
+ static const char *argv0_path;
+--- a/tools/objtool/Makefile
++++ b/tools/objtool/Makefile
+@@ -39,6 +39,8 @@ OBJTOOL_LDFLAGS := $(LIBELF_LIBS) $(LIBS
+ elfshdr := $(shell echo '$(pound)include <libelf.h>' | $(HOSTCC) $(OBJTOOL_CFLAGS) -x c -E - | grep elf_getshdr)
+ OBJTOOL_CFLAGS += $(if $(elfshdr),,-DLIBELF_USE_DEPRECATED)
+ 
++OBJTOOL_CFLAGS += $(HOST_EXTRACFLAGS)
++
+ # Always want host compilation.
+ HOST_OVERRIDES := CC="$(HOSTCC)" LD="$(HOSTLD)" AR="$(HOSTAR)"
+ 
+--- a/tools/arch/x86/lib/insn.c
++++ b/tools/arch/x86/lib/insn.c
+@@ -15,7 +15,11 @@
+ #include "../include/asm/insn.h" /* __ignore_sync_check__ */
+ #include <linux/unaligned.h> /* __ignore_sync_check__ */
+ 
++#ifdef __KERNEL__
+ #include <linux/errno.h>
++#else
++#include <errno.h>
++#endif
+ #include <linux/kconfig.h>
+ 
+ #include "../include/asm/emulate_prefix.h" /* __ignore_sync_check__ */
diff --git a/target/linux/generic/hack-6.12/204-module_strip.patch b/target/linux/generic/hack-6.12/204-module_strip.patch
new file mode 100644
index 0000000000..d999e0992c
--- /dev/null
+++ b/target/linux/generic/hack-6.12/204-module_strip.patch
@@ -0,0 +1,201 @@
+From a779a482fb9b9f8fcdf8b2519c789b4b9bb5dd05 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 7 Jul 2017 16:56:48 +0200
+Subject: build: add a hack for removing non-essential module info
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ include/linux/module.h      | 13 ++++++++-----
+ include/linux/moduleparam.h | 15 ++++++++++++---
+ init/Kconfig                |  7 +++++++
+ kernel/module.c             |  5 ++++-
+ scripts/mod/modpost.c       | 12 ++++++++++++
+ 5 files changed, 43 insertions(+), 9 deletions(-)
+
+--- a/include/linux/module.h
++++ b/include/linux/module.h
+@@ -166,6 +166,7 @@ struct module_kobject *lookup_or_create_
+ 
+ /* Generic info of form tag = "info" */
+ #define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)
++#define MODULE_INFO_STRIP(tag, info) __MODULE_INFO_STRIP(tag, tag, info)
+ 
+ /* For userspace: you can also call me... */
+ #define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)
+@@ -241,12 +242,12 @@ struct module_kobject *lookup_or_create_
+  * Author(s), use "Name <email>" or just "Name", for multiple
+  * authors use multiple MODULE_AUTHOR() statements/lines.
+  */
+-#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)
++#define MODULE_AUTHOR(_author) MODULE_INFO_STRIP(author, _author)
+ 
+ /* What your module does. */
+-#define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)
++#define MODULE_DESCRIPTION(_description) MODULE_INFO_STRIP(description, _description)
+ 
+-#ifdef MODULE
++#if defined(MODULE) && !defined(CONFIG_MODULE_STRIPPED)
+ /* Creates an alias so file2alias.c can find device table. */
+ #define MODULE_DEVICE_TABLE(type, name)					\
+ extern typeof(name) __mod_##type##__##name##_device_table		\
+@@ -273,7 +274,9 @@ extern typeof(name) __mod_##type##__##na
+  */
+ 
+ #if defined(MODULE) || !defined(CONFIG_SYSFS)
+-#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
++#define MODULE_VERSION(_version) MODULE_INFO_STRIP(version, _version)
++#elif defined(CONFIG_MODULE_STRIPPED)
++#define MODULE_VERSION(_version) __MODULE_INFO_DISABLED(version)
+ #else
+ #define MODULE_VERSION(_version)					\
+ 	MODULE_INFO(version, _version);					\
+@@ -296,7 +299,7 @@ extern typeof(name) __mod_##type##__##na
+ /* Optional firmware file (or files) needed by the module
+  * format is simply firmware file name.  Multiple firmware
+  * files require multiple MODULE_FIRMWARE() specifiers */
+-#define MODULE_FIRMWARE(_firmware) MODULE_INFO(firmware, _firmware)
++#define MODULE_FIRMWARE(_firmware) MODULE_INFO_STRIP(firmware, _firmware)
+ 
+ #define MODULE_IMPORT_NS(ns)	MODULE_INFO(import_ns, __stringify(ns))
+ 
+--- a/include/linux/moduleparam.h
++++ b/include/linux/moduleparam.h
+@@ -20,6 +20,16 @@
+ /* Chosen so that structs with an unsigned long line up. */
+ #define MAX_PARAM_PREFIX_LEN (64 - sizeof(unsigned long))
+ 
++/* This struct is here for syntactic coherency, it is not used */
++#define __MODULE_INFO_DISABLED(name)					  \
++  struct __UNIQUE_ID(name) {}
++
++#ifdef CONFIG_MODULE_STRIPPED
++#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO_DISABLED(name)
++#else
++#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO(tag, name, info)
++#endif
++
+ #define __MODULE_INFO(tag, name, info)					  \
+ 	static const char __UNIQUE_ID(name)[]				  \
+ 		__used __section(".modinfo") __aligned(1)		  \
+@@ -31,7 +41,7 @@
+ /* One for each parameter, describing how to use it.  Some files do
+    multiple of these per line, so can't just use MODULE_INFO. */
+ #define MODULE_PARM_DESC(_parm, desc) \
+-	__MODULE_INFO(parm, _parm, #_parm ":" desc)
++	__MODULE_INFO_STRIP(parm, _parm, #_parm ":" desc)
+ 
+ struct kernel_param;
+ 
+--- a/kernel/module/Kconfig
++++ b/kernel/module/Kconfig
+@@ -402,4 +402,11 @@ config MODULES_TREE_LOOKUP
+ 	def_bool y
+ 	depends on PERF_EVENTS || TRACING || CFI_CLANG
+ 
++config MODULE_STRIPPED
++	bool "Reduce module size"
++	depends on MODULES
++	help
++	  Remove module parameter descriptions, author info, version, aliases,
++	  device tables, etc.
++
+ endif # MODULES
+--- a/kernel/module/main.c
++++ b/kernel/module/main.c
+@@ -999,6 +999,7 @@ size_t modinfo_attrs_count = ARRAY_SIZE(
+ 
+ static const char vermagic[] = VERMAGIC_STRING;
+ 
++#if defined(CONFIG_MODVERSIONS) || !defined(CONFIG_MODULE_STRIPPED)
+ int try_to_force_load(struct module *mod, const char *reason)
+ {
+ #ifdef CONFIG_MODULE_FORCE_LOAD
+@@ -1010,6 +1011,7 @@ int try_to_force_load(struct module *mod
+ 	return -ENOEXEC;
+ #endif
+ }
++#endif
+ 
+ /* Parse tag=value strings from .modinfo section */
+ char *module_next_tag_pair(char *string, unsigned long *secsize)
+@@ -2093,9 +2095,11 @@ static void module_augment_kernel_taints
+ 
+ static int check_modinfo(struct module *mod, struct load_info *info, int flags)
+ {
+-	const char *modmagic = get_modinfo(info, "vermagic");
+ 	int err;
+ 
++#ifndef CONFIG_MODULE_STRIPPED
++	const char *modmagic = get_modinfo(info, "vermagic");
++
+ 	if (flags & MODULE_INIT_IGNORE_VERMAGIC)
+ 		modmagic = NULL;
+ 
+@@ -2109,6 +2113,7 @@ static int check_modinfo(struct module *
+ 		       info->name, modmagic, vermagic);
+ 		return -ENOEXEC;
+ 	}
++#endif
+ 
+ 	err = check_modinfo_livepatch(mod, info);
+ 	if (err)
+--- a/scripts/mod/modpost.c
++++ b/scripts/mod/modpost.c
+@@ -1601,7 +1601,9 @@ static void read_symbols(const char *mod
+ 		symname = remove_dot(info.strtab + sym->st_name);
+ 
+ 		handle_symbol(mod, &info, sym, symname);
++#ifndef CONFIG_MODULE_STRIPPED
+ 		handle_moddevtable(mod, &info, sym, symname);
++#endif
+ 	}
+ 
+ 	check_sec_ref(mod, &info);
+@@ -1758,7 +1760,9 @@ static void add_header(struct buffer *b,
+ 	buf_printf(b, "#include <linux/export-internal.h>\n");
+ 	buf_printf(b, "#include <linux/compiler.h>\n");
+ 	buf_printf(b, "\n");
++#ifndef CONFIG_MODULE_STRIPPED
+ 	buf_printf(b, "MODULE_INFO(name, KBUILD_MODNAME);\n");
++#endif
+ 	buf_printf(b, "\n");
+ 	buf_printf(b, "__visible struct module __this_module\n");
+ 	buf_printf(b, "__section(\".gnu.linkonce.this_module\") = {\n");
+@@ -1772,11 +1776,13 @@ static void add_header(struct buffer *b,
+ 	buf_printf(b, "\t.arch = MODULE_ARCH_INIT,\n");
+ 	buf_printf(b, "};\n");
+ 
++#ifndef CONFIG_MODULE_STRIPPED
+ 	if (!external_module)
+ 		buf_printf(b, "\nMODULE_INFO(intree, \"Y\");\n");
+ 
+ 	if (strstarts(mod->name, "drivers/staging"))
+ 		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
++#endif
+ 
+ 	if (strstarts(mod->name, "tools/testing"))
+ 		buf_printf(b, "\nMODULE_INFO(test, \"Y\");\n");
+@@ -1886,11 +1892,13 @@ static void add_depends(struct buffer *b
+ 
+ static void add_srcversion(struct buffer *b, struct module *mod)
+ {
++#ifndef CONFIG_MODULE_STRIPPED
+ 	if (mod->srcversion[0]) {
+ 		buf_printf(b, "\n");
+ 		buf_printf(b, "MODULE_INFO(srcversion, \"%s\");\n",
+ 			   mod->srcversion);
+ 	}
++#endif
+ }
+ 
+ static void write_buf(struct buffer *b, const char *fname)
+@@ -1973,7 +1981,9 @@ static void write_mod_c_file(struct modu
+ 	add_exported_symbols(&buf, mod);
+ 	add_versions(&buf, mod);
+ 	add_depends(&buf, mod);
++#ifndef CONFIG_MODULE_STRIPPED
+ 	add_moddevtable(&buf, mod);
++#endif
+ 	add_srcversion(&buf, mod);
+ 
+ 	ret = snprintf(fname, sizeof(fname), "%s.mod.c", mod->name);
diff --git a/target/linux/generic/hack-6.12/205-kconfig-abort-configuration-on-unset-symbol.patch b/target/linux/generic/hack-6.12/205-kconfig-abort-configuration-on-unset-symbol.patch
new file mode 100644
index 0000000000..d7416d81a9
--- /dev/null
+++ b/target/linux/generic/hack-6.12/205-kconfig-abort-configuration-on-unset-symbol.patch
@@ -0,0 +1,41 @@
+From 310e8e04a05d9eb43fa9dd7f00143300afcaa37a Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Fri, 11 Nov 2022 13:33:44 +0100
+Subject: [PATCH] kconfig: abort configuration on unset symbol
+
+When a target configuration has unset Kconfig symbols, the build will
+fail when OpenWrt is compiled with V=s and stdin is connected to a tty.
+
+In case OpenWrt is compiled without either of these preconditions, the
+build will succeed with the symbols in question being unset.
+
+Modify the kernel configuration in a way it fails on unset symbols
+regardless of the aforementioned preconditions.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ scripts/kconfig/conf.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/scripts/kconfig/conf.c
++++ b/scripts/kconfig/conf.c
+@@ -312,6 +312,9 @@ static int conf_askvalue(struct symbol *
+ 		}
+ 		/* fall through */
+ 	default:
++		if (!tty_stdio && getenv("FAIL_ON_UNCONFIGURED")) {
++			exit(1);
++		}
+ 		fflush(stdout);
+ 		xfgets(line, sizeof(line), stdin);
+ 		break;
+@@ -470,6 +473,9 @@ static void conf_choice(struct menu *men
+ 			}
+ 			/* fall through */
+ 		case oldaskconfig:
++			if (!tty_stdio && getenv("FAIL_ON_UNCONFIGURED")) {
++				exit(1);
++			}
+ 			fflush(stdout);
+ 			xfgets(line, sizeof(line), stdin);
+ 			strip(line);
diff --git a/target/linux/generic/hack-6.12/210-darwin_scripts_include.patch b/target/linux/generic/hack-6.12/210-darwin_scripts_include.patch
new file mode 100644
index 0000000000..be59ca4fc9
--- /dev/null
+++ b/target/linux/generic/hack-6.12/210-darwin_scripts_include.patch
@@ -0,0 +1,3053 @@
+From db7c30dcd9a0391bf13b62c9f91e144d762ef43a Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Fri, 7 Jul 2017 17:00:49 +0200
+Subject: Add an OSX specific patch to make the kernel be compiled
+
+lede-commit: 3fc2a24f0422b2f55f9ed43f116db3111f700526
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+---
+ scripts/kconfig/Makefile   |    3 +
+ scripts/mod/elf.h          | 3007 ++++++++++++++++++++++++++++++++++++++++++++
+ scripts/mod/mk_elfconfig.c |    4 +
+ scripts/mod/modpost.h      |    4 +
+ 4 files changed, 3018 insertions(+)
+ create mode 100644 scripts/mod/elf.h
+
+--- /dev/null
++++ b/scripts/mod/elf.h
+@@ -0,0 +1,3007 @@
++/* This file defines standard ELF types, structures, and macros.
++   Copyright (C) 1995-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _ELF_H
++#define	_ELF_H 1
++
++/* Standard ELF types.  */
++
++#include <stdint.h>
++
++/* Type for a 16-bit quantity.  */
++typedef uint16_t Elf32_Half;
++typedef uint16_t Elf64_Half;
++
++/* Types for signed and unsigned 32-bit quantities.  */
++typedef uint32_t Elf32_Word;
++typedef	int32_t  Elf32_Sword;
++typedef uint32_t Elf64_Word;
++typedef	int32_t  Elf64_Sword;
++
++/* Types for signed and unsigned 64-bit quantities.  */
++typedef uint64_t Elf32_Xword;
++typedef	int64_t  Elf32_Sxword;
++typedef uint64_t Elf64_Xword;
++typedef	int64_t  Elf64_Sxword;
++
++/* Type of addresses.  */
++typedef uint32_t Elf32_Addr;
++typedef uint64_t Elf64_Addr;
++
++/* Type of file offsets.  */
++typedef uint32_t Elf32_Off;
++typedef uint64_t Elf64_Off;
++
++/* Type for section indices, which are 16-bit quantities.  */
++typedef uint16_t Elf32_Section;
++typedef uint16_t Elf64_Section;
++
++/* Type for version symbol information.  */
++typedef Elf32_Half Elf32_Versym;
++typedef Elf64_Half Elf64_Versym;
++
++
++/* The ELF file header.  This appears at the start of every ELF file.  */
++
++#define EI_NIDENT (16)
++
++typedef struct
++{
++  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
++  Elf32_Half	e_type;			/* Object file type */
++  Elf32_Half	e_machine;		/* Architecture */
++  Elf32_Word	e_version;		/* Object file version */
++  Elf32_Addr	e_entry;		/* Entry point virtual address */
++  Elf32_Off	e_phoff;		/* Program header table file offset */
++  Elf32_Off	e_shoff;		/* Section header table file offset */
++  Elf32_Word	e_flags;		/* Processor-specific flags */
++  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
++  Elf32_Half	e_phentsize;		/* Program header table entry size */
++  Elf32_Half	e_phnum;		/* Program header table entry count */
++  Elf32_Half	e_shentsize;		/* Section header table entry size */
++  Elf32_Half	e_shnum;		/* Section header table entry count */
++  Elf32_Half	e_shstrndx;		/* Section header string table index */
++} Elf32_Ehdr;
++
++typedef struct
++{
++  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
++  Elf64_Half	e_type;			/* Object file type */
++  Elf64_Half	e_machine;		/* Architecture */
++  Elf64_Word	e_version;		/* Object file version */
++  Elf64_Addr	e_entry;		/* Entry point virtual address */
++  Elf64_Off	e_phoff;		/* Program header table file offset */
++  Elf64_Off	e_shoff;		/* Section header table file offset */
++  Elf64_Word	e_flags;		/* Processor-specific flags */
++  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
++  Elf64_Half	e_phentsize;		/* Program header table entry size */
++  Elf64_Half	e_phnum;		/* Program header table entry count */
++  Elf64_Half	e_shentsize;		/* Section header table entry size */
++  Elf64_Half	e_shnum;		/* Section header table entry count */
++  Elf64_Half	e_shstrndx;		/* Section header string table index */
++} Elf64_Ehdr;
++
++/* Fields in the e_ident array.  The EI_* macros are indices into the
++   array.  The macros under each EI_* macro are the values the byte
++   may have.  */
++
++#define EI_MAG0		0		/* File identification byte 0 index */
++#define ELFMAG0		0x7f		/* Magic number byte 0 */
++
++#define EI_MAG1		1		/* File identification byte 1 index */
++#define ELFMAG1		'E'		/* Magic number byte 1 */
++
++#define EI_MAG2		2		/* File identification byte 2 index */
++#define ELFMAG2		'L'		/* Magic number byte 2 */
++
++#define EI_MAG3		3		/* File identification byte 3 index */
++#define ELFMAG3		'F'		/* Magic number byte 3 */
++
++/* Conglomeration of the identification bytes, for easy testing as a word.  */
++#define	ELFMAG		"\177ELF"
++#define	SELFMAG		4
++
++#define EI_CLASS	4		/* File class byte index */
++#define ELFCLASSNONE	0		/* Invalid class */
++#define ELFCLASS32	1		/* 32-bit objects */
++#define ELFCLASS64	2		/* 64-bit objects */
++#define ELFCLASSNUM	3
++
++#define EI_DATA		5		/* Data encoding byte index */
++#define ELFDATANONE	0		/* Invalid data encoding */
++#define ELFDATA2LSB	1		/* 2's complement, little endian */
++#define ELFDATA2MSB	2		/* 2's complement, big endian */
++#define ELFDATANUM	3
++
++#define EI_VERSION	6		/* File version byte index */
++					/* Value must be EV_CURRENT */
++
++#define EI_OSABI	7		/* OS ABI identification */
++#define ELFOSABI_NONE		0	/* UNIX System V ABI */
++#define ELFOSABI_SYSV		0	/* Alias.  */
++#define ELFOSABI_HPUX		1	/* HP-UX */
++#define ELFOSABI_NETBSD		2	/* NetBSD.  */
++#define ELFOSABI_GNU		3	/* Object uses GNU ELF extensions.  */
++#define ELFOSABI_LINUX		ELFOSABI_GNU /* Compatibility alias.  */
++#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
++#define ELFOSABI_AIX		7	/* IBM AIX.  */
++#define ELFOSABI_IRIX		8	/* SGI Irix.  */
++#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
++#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
++#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
++#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
++#define ELFOSABI_ARM_AEABI	64	/* ARM EABI */
++#define ELFOSABI_ARM		97	/* ARM */
++#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
++
++#define EI_ABIVERSION	8		/* ABI version */
++
++#define EI_PAD		9		/* Byte index of padding bytes */
++
++/* Legal values for e_type (object file type).  */
++
++#define ET_NONE		0		/* No file type */
++#define ET_REL		1		/* Relocatable file */
++#define ET_EXEC		2		/* Executable file */
++#define ET_DYN		3		/* Shared object file */
++#define ET_CORE		4		/* Core file */
++#define	ET_NUM		5		/* Number of defined types */
++#define ET_LOOS		0xfe00		/* OS-specific range start */
++#define ET_HIOS		0xfeff		/* OS-specific range end */
++#define ET_LOPROC	0xff00		/* Processor-specific range start */
++#define ET_HIPROC	0xffff		/* Processor-specific range end */
++
++/* Legal values for e_machine (architecture).  */
++
++#define EM_NONE		 0		/* No machine */
++#define EM_M32		 1		/* AT&T WE 32100 */
++#define EM_SPARC	 2		/* SUN SPARC */
++#define EM_386		 3		/* Intel 80386 */
++#define EM_68K		 4		/* Motorola m68k family */
++#define EM_88K		 5		/* Motorola m88k family */
++#define EM_860		 7		/* Intel 80860 */
++#define EM_MIPS		 8		/* MIPS R3000 big-endian */
++#define EM_S370		 9		/* IBM System/370 */
++#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
++
++#define EM_PARISC	15		/* HPPA */
++#define EM_VPP500	17		/* Fujitsu VPP500 */
++#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
++#define EM_960		19		/* Intel 80960 */
++#define EM_PPC		20		/* PowerPC */
++#define EM_PPC64	21		/* PowerPC 64-bit */
++#define EM_S390		22		/* IBM S390 */
++
++#define EM_V800		36		/* NEC V800 series */
++#define EM_FR20		37		/* Fujitsu FR20 */
++#define EM_RH32		38		/* TRW RH-32 */
++#define EM_RCE		39		/* Motorola RCE */
++#define EM_ARM		40		/* ARM */
++#define EM_FAKE_ALPHA	41		/* Digital Alpha */
++#define EM_SH		42		/* Hitachi SH */
++#define EM_SPARCV9	43		/* SPARC v9 64-bit */
++#define EM_TRICORE	44		/* Siemens Tricore */
++#define EM_ARC		45		/* Argonaut RISC Core */
++#define EM_H8_300	46		/* Hitachi H8/300 */
++#define EM_H8_300H	47		/* Hitachi H8/300H */
++#define EM_H8S		48		/* Hitachi H8S */
++#define EM_H8_500	49		/* Hitachi H8/500 */
++#define EM_IA_64	50		/* Intel Merced */
++#define EM_MIPS_X	51		/* Stanford MIPS-X */
++#define EM_COLDFIRE	52		/* Motorola Coldfire */
++#define EM_68HC12	53		/* Motorola M68HC12 */
++#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
++#define EM_PCP		55		/* Siemens PCP */
++#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
++#define EM_NDR1		57		/* Denso NDR1 microprocessor */
++#define EM_STARCORE	58		/* Motorola Start*Core processor */
++#define EM_ME16		59		/* Toyota ME16 processor */
++#define EM_ST100	60		/* STMicroelectronic ST100 processor */
++#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
++#define EM_X86_64	62		/* AMD x86-64 architecture */
++#define EM_PDSP		63		/* Sony DSP Processor */
++
++#define EM_FX66		66		/* Siemens FX66 microcontroller */
++#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
++#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
++#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
++#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
++#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
++#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
++#define EM_SVX		73		/* Silicon Graphics SVx */
++#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
++#define EM_VAX		75		/* Digital VAX */
++#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
++#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
++#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
++#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
++#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
++#define EM_HUANY	81		/* Harvard University machine-independent object files */
++#define EM_PRISM	82		/* SiTera Prism */
++#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
++#define EM_FR30		84		/* Fujitsu FR30 */
++#define EM_D10V		85		/* Mitsubishi D10V */
++#define EM_D30V		86		/* Mitsubishi D30V */
++#define EM_V850		87		/* NEC v850 */
++#define EM_M32R		88		/* Mitsubishi M32R */
++#define EM_MN10300	89		/* Matsushita MN10300 */
++#define EM_MN10200	90		/* Matsushita MN10200 */
++#define EM_PJ		91		/* picoJava */
++#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
++#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
++#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
++#define EM_TILEPRO	188		/* Tilera TILEPro */
++#define EM_TILEGX	191		/* Tilera TILE-Gx */
++#define EM_NUM		192
++
++/* If it is necessary to assign new unofficial EM_* values, please
++   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
++   chances of collision with official or non-GNU unofficial values.  */
++
++#define EM_ALPHA	0x9026
++
++/* Legal values for e_version (version).  */
++
++#define EV_NONE		0		/* Invalid ELF version */
++#define EV_CURRENT	1		/* Current version */
++#define EV_NUM		2
++
++/* Section header.  */
++
++typedef struct
++{
++  Elf32_Word	sh_name;		/* Section name (string tbl index) */
++  Elf32_Word	sh_type;		/* Section type */
++  Elf32_Word	sh_flags;		/* Section flags */
++  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
++  Elf32_Off	sh_offset;		/* Section file offset */
++  Elf32_Word	sh_size;		/* Section size in bytes */
++  Elf32_Word	sh_link;		/* Link to another section */
++  Elf32_Word	sh_info;		/* Additional section information */
++  Elf32_Word	sh_addralign;		/* Section alignment */
++  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
++} Elf32_Shdr;
++
++typedef struct
++{
++  Elf64_Word	sh_name;		/* Section name (string tbl index) */
++  Elf64_Word	sh_type;		/* Section type */
++  Elf64_Xword	sh_flags;		/* Section flags */
++  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
++  Elf64_Off	sh_offset;		/* Section file offset */
++  Elf64_Xword	sh_size;		/* Section size in bytes */
++  Elf64_Word	sh_link;		/* Link to another section */
++  Elf64_Word	sh_info;		/* Additional section information */
++  Elf64_Xword	sh_addralign;		/* Section alignment */
++  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
++} Elf64_Shdr;
++
++/* Special section indices.  */
++
++#define SHN_UNDEF	0		/* Undefined section */
++#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
++#define SHN_LOPROC	0xff00		/* Start of processor-specific */
++#define SHN_BEFORE	0xff00		/* Order section before all others
++					   (Solaris).  */
++#define SHN_AFTER	0xff01		/* Order section after all others
++					   (Solaris).  */
++#define SHN_HIPROC	0xff1f		/* End of processor-specific */
++#define SHN_LOOS	0xff20		/* Start of OS-specific */
++#define SHN_HIOS	0xff3f		/* End of OS-specific */
++#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
++#define SHN_COMMON	0xfff2		/* Associated symbol is common */
++#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
++#define SHN_HIRESERVE	0xffff		/* End of reserved indices */
++
++/* Legal values for sh_type (section type).  */
++
++#define SHT_NULL	  0		/* Section header table entry unused */
++#define SHT_PROGBITS	  1		/* Program data */
++#define SHT_SYMTAB	  2		/* Symbol table */
++#define SHT_STRTAB	  3		/* String table */
++#define SHT_RELA	  4		/* Relocation entries with addends */
++#define SHT_HASH	  5		/* Symbol hash table */
++#define SHT_DYNAMIC	  6		/* Dynamic linking information */
++#define SHT_NOTE	  7		/* Notes */
++#define SHT_NOBITS	  8		/* Program space with no data (bss) */
++#define SHT_REL		  9		/* Relocation entries, no addends */
++#define SHT_SHLIB	  10		/* Reserved */
++#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
++#define SHT_INIT_ARRAY	  14		/* Array of constructors */
++#define SHT_FINI_ARRAY	  15		/* Array of destructors */
++#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
++#define SHT_GROUP	  17		/* Section group */
++#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
++#define	SHT_NUM		  19		/* Number of defined types.  */
++#define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
++#define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
++#define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
++#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
++#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
++#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
++#define SHT_SUNW_move	  0x6ffffffa
++#define SHT_SUNW_COMDAT   0x6ffffffb
++#define SHT_SUNW_syminfo  0x6ffffffc
++#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
++#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
++#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
++#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
++#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
++#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
++#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
++#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
++#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
++
++/* Legal values for sh_flags (section flags).  */
++
++#define SHF_WRITE	     (1 << 0)	/* Writable */
++#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
++#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
++#define SHF_MERGE	     (1 << 4)	/* Might be merged */
++#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
++#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
++#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
++#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
++					   required */
++#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
++#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
++#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
++#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
++#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
++					   (Solaris).  */
++#define SHF_EXCLUDE	     (1 << 31)	/* Section is excluded unless
++					   referenced or allocated (Solaris).*/
++
++/* Section group handling.  */
++#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */
++
++/* Symbol table entry.  */
++
++typedef struct
++{
++  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
++  Elf32_Addr	st_value;		/* Symbol value */
++  Elf32_Word	st_size;		/* Symbol size */
++  unsigned char	st_info;		/* Symbol type and binding */
++  unsigned char	st_other;		/* Symbol visibility */
++  Elf32_Section	st_shndx;		/* Section index */
++} Elf32_Sym;
++
++typedef struct
++{
++  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
++  unsigned char	st_info;		/* Symbol type and binding */
++  unsigned char st_other;		/* Symbol visibility */
++  Elf64_Section	st_shndx;		/* Section index */
++  Elf64_Addr	st_value;		/* Symbol value */
++  Elf64_Xword	st_size;		/* Symbol size */
++} Elf64_Sym;
++
++/* The syminfo section if available contains additional information about
++   every dynamic symbol.  */
++
++typedef struct
++{
++  Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
++  Elf32_Half si_flags;			/* Per symbol flags */
++} Elf32_Syminfo;
++
++typedef struct
++{
++  Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
++  Elf64_Half si_flags;			/* Per symbol flags */
++} Elf64_Syminfo;
++
++/* Possible values for si_boundto.  */
++#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
++#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
++#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */
++
++/* Possible bitmasks for si_flags.  */
++#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
++#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
++#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
++#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
++					   loaded */
++/* Syminfo version values.  */
++#define SYMINFO_NONE		0
++#define SYMINFO_CURRENT		1
++#define SYMINFO_NUM		2
++
++
++/* How to extract and insert information held in the st_info field.  */
++
++#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
++#define ELF32_ST_TYPE(val)		((val) & 0xf)
++#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
++
++/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
++#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
++#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
++#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
++
++/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
++
++#define STB_LOCAL	0		/* Local symbol */
++#define STB_GLOBAL	1		/* Global symbol */
++#define STB_WEAK	2		/* Weak symbol */
++#define	STB_NUM		3		/* Number of defined types.  */
++#define STB_LOOS	10		/* Start of OS-specific */
++#define STB_GNU_UNIQUE	10		/* Unique symbol.  */
++#define STB_HIOS	12		/* End of OS-specific */
++#define STB_LOPROC	13		/* Start of processor-specific */
++#define STB_HIPROC	15		/* End of processor-specific */
++
++/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
++
++#define STT_NOTYPE	0		/* Symbol type is unspecified */
++#define STT_OBJECT	1		/* Symbol is a data object */
++#define STT_FUNC	2		/* Symbol is a code object */
++#define STT_SECTION	3		/* Symbol associated with a section */
++#define STT_FILE	4		/* Symbol's name is file name */
++#define STT_COMMON	5		/* Symbol is a common data object */
++#define STT_TLS		6		/* Symbol is thread-local data object*/
++#define	STT_NUM		7		/* Number of defined types.  */
++#define STT_LOOS	10		/* Start of OS-specific */
++#define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
++#define STT_HIOS	12		/* End of OS-specific */
++#define STT_LOPROC	13		/* Start of processor-specific */
++#define STT_HIPROC	15		/* End of processor-specific */
++
++
++/* Symbol table indices are found in the hash buckets and chain table
++   of a symbol hash table section.  This special index value indicates
++   the end of a chain, meaning no further symbols are found in that bucket.  */
++
++#define STN_UNDEF	0		/* End of a chain.  */
++
++
++/* How to extract and insert information held in the st_other field.  */
++
++#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
++
++/* For ELF64 the definitions are the same.  */
++#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
++
++/* Symbol visibility specification encoded in the st_other field.  */
++#define STV_DEFAULT	0		/* Default symbol visibility rules */
++#define STV_INTERNAL	1		/* Processor specific hidden class */
++#define STV_HIDDEN	2		/* Sym unavailable in other modules */
++#define STV_PROTECTED	3		/* Not preemptible, not exported */
++
++
++/* Relocation table entry without addend (in section of type SHT_REL).  */
++
++typedef struct
++{
++  Elf32_Addr	r_offset;		/* Address */
++  Elf32_Word	r_info;			/* Relocation type and symbol index */
++} Elf32_Rel;
++
++/* I have seen two different definitions of the Elf64_Rel and
++   Elf64_Rela structures, so we'll leave them out until Novell (or
++   whoever) gets their act together.  */
++/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
++
++typedef struct
++{
++  Elf64_Addr	r_offset;		/* Address */
++  Elf64_Xword	r_info;			/* Relocation type and symbol index */
++} Elf64_Rel;
++
++/* Relocation table entry with addend (in section of type SHT_RELA).  */
++
++typedef struct
++{
++  Elf32_Addr	r_offset;		/* Address */
++  Elf32_Word	r_info;			/* Relocation type and symbol index */
++  Elf32_Sword	r_addend;		/* Addend */
++} Elf32_Rela;
++
++typedef struct
++{
++  Elf64_Addr	r_offset;		/* Address */
++  Elf64_Xword	r_info;			/* Relocation type and symbol index */
++  Elf64_Sxword	r_addend;		/* Addend */
++} Elf64_Rela;
++
++/* How to extract and insert information held in the r_info field.  */
++
++#define ELF32_R_SYM(val)		((val) >> 8)
++#define ELF32_R_TYPE(val)		((val) & 0xff)
++#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
++
++#define ELF64_R_SYM(i)			((i) >> 32)
++#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
++#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
++
++/* Program segment header.  */
++
++typedef struct
++{
++  Elf32_Word	p_type;			/* Segment type */
++  Elf32_Off	p_offset;		/* Segment file offset */
++  Elf32_Addr	p_vaddr;		/* Segment virtual address */
++  Elf32_Addr	p_paddr;		/* Segment physical address */
++  Elf32_Word	p_filesz;		/* Segment size in file */
++  Elf32_Word	p_memsz;		/* Segment size in memory */
++  Elf32_Word	p_flags;		/* Segment flags */
++  Elf32_Word	p_align;		/* Segment alignment */
++} Elf32_Phdr;
++
++typedef struct
++{
++  Elf64_Word	p_type;			/* Segment type */
++  Elf64_Word	p_flags;		/* Segment flags */
++  Elf64_Off	p_offset;		/* Segment file offset */
++  Elf64_Addr	p_vaddr;		/* Segment virtual address */
++  Elf64_Addr	p_paddr;		/* Segment physical address */
++  Elf64_Xword	p_filesz;		/* Segment size in file */
++  Elf64_Xword	p_memsz;		/* Segment size in memory */
++  Elf64_Xword	p_align;		/* Segment alignment */
++} Elf64_Phdr;
++
++/* Special value for e_phnum.  This indicates that the real number of
++   program headers is too large to fit into e_phnum.  Instead the real
++   value is in the field sh_info of section 0.  */
++
++#define PN_XNUM		0xffff
++
++/* Legal values for p_type (segment type).  */
++
++#define	PT_NULL		0		/* Program header table entry unused */
++#define PT_LOAD		1		/* Loadable program segment */
++#define PT_DYNAMIC	2		/* Dynamic linking information */
++#define PT_INTERP	3		/* Program interpreter */
++#define PT_NOTE		4		/* Auxiliary information */
++#define PT_SHLIB	5		/* Reserved */
++#define PT_PHDR		6		/* Entry for header table itself */
++#define PT_TLS		7		/* Thread-local storage segment */
++#define	PT_NUM		8		/* Number of defined types */
++#define PT_LOOS		0x60000000	/* Start of OS-specific */
++#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
++#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
++#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
++#define PT_LOSUNW	0x6ffffffa
++#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
++#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
++#define PT_HISUNW	0x6fffffff
++#define PT_HIOS		0x6fffffff	/* End of OS-specific */
++#define PT_LOPROC	0x70000000	/* Start of processor-specific */
++#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
++
++/* Legal values for p_flags (segment flags).  */
++
++#define PF_X		(1 << 0)	/* Segment is executable */
++#define PF_W		(1 << 1)	/* Segment is writable */
++#define PF_R		(1 << 2)	/* Segment is readable */
++#define PF_MASKOS	0x0ff00000	/* OS-specific */
++#define PF_MASKPROC	0xf0000000	/* Processor-specific */
++
++/* Legal values for note segment descriptor types for core files. */
++
++#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
++#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
++#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
++#define NT_PRXREG	4		/* Contains copy of prxregset struct */
++#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
++#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
++#define NT_AUXV		6		/* Contains copy of auxv array */
++#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
++#define NT_ASRS		8		/* Contains copy of asrset struct */
++#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
++#define NT_PSINFO	13		/* Contains copy of psinfo struct */
++#define NT_PRCRED	14		/* Contains copy of prcred struct */
++#define NT_UTSNAME	15		/* Contains copy of utsname struct */
++#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
++#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
++#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct */
++#define NT_PRXFPREG	0x46e62b7f	/* Contains copy of user_fxsr_struct */
++#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
++#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
++#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
++#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
++#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
++#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
++
++/* Legal values for the note segment descriptor types for object files.  */
++
++#define NT_VERSION	1		/* Contains a version string.  */
++
++
++/* Dynamic section entry.  */
++
++typedef struct
++{
++  Elf32_Sword	d_tag;			/* Dynamic entry type */
++  union
++    {
++      Elf32_Word d_val;			/* Integer value */
++      Elf32_Addr d_ptr;			/* Address value */
++    } d_un;
++} Elf32_Dyn;
++
++typedef struct
++{
++  Elf64_Sxword	d_tag;			/* Dynamic entry type */
++  union
++    {
++      Elf64_Xword d_val;		/* Integer value */
++      Elf64_Addr d_ptr;			/* Address value */
++    } d_un;
++} Elf64_Dyn;
++
++/* Legal values for d_tag (dynamic entry type).  */
++
++#define DT_NULL		0		/* Marks end of dynamic section */
++#define DT_NEEDED	1		/* Name of needed library */
++#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
++#define DT_PLTGOT	3		/* Processor defined value */
++#define DT_HASH		4		/* Address of symbol hash table */
++#define DT_STRTAB	5		/* Address of string table */
++#define DT_SYMTAB	6		/* Address of symbol table */
++#define DT_RELA		7		/* Address of Rela relocs */
++#define DT_RELASZ	8		/* Total size of Rela relocs */
++#define DT_RELAENT	9		/* Size of one Rela reloc */
++#define DT_STRSZ	10		/* Size of string table */
++#define DT_SYMENT	11		/* Size of one symbol table entry */
++#define DT_INIT		12		/* Address of init function */
++#define DT_FINI		13		/* Address of termination function */
++#define DT_SONAME	14		/* Name of shared object */
++#define DT_RPATH	15		/* Library search path (deprecated) */
++#define DT_SYMBOLIC	16		/* Start symbol search here */
++#define DT_REL		17		/* Address of Rel relocs */
++#define DT_RELSZ	18		/* Total size of Rel relocs */
++#define DT_RELENT	19		/* Size of one Rel reloc */
++#define DT_PLTREL	20		/* Type of reloc in PLT */
++#define DT_DEBUG	21		/* For debugging; unspecified */
++#define DT_TEXTREL	22		/* Reloc might modify .text */
++#define DT_JMPREL	23		/* Address of PLT relocs */
++#define	DT_BIND_NOW	24		/* Process relocations of object */
++#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
++#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
++#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
++#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
++#define DT_RUNPATH	29		/* Library search path */
++#define DT_FLAGS	30		/* Flags for the object being loaded */
++#define DT_ENCODING	32		/* Start of encoded range */
++#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
++#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
++#define	DT_NUM		34		/* Number used */
++#define DT_LOOS		0x6000000d	/* Start of OS-specific */
++#define DT_HIOS		0x6ffff000	/* End of OS-specific */
++#define DT_LOPROC	0x70000000	/* Start of processor-specific */
++#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
++#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
++
++/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
++   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
++   approach.  */
++#define DT_VALRNGLO	0x6ffffd00
++#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
++#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
++#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
++#define DT_CHECKSUM	0x6ffffdf8
++#define DT_PLTPADSZ	0x6ffffdf9
++#define DT_MOVEENT	0x6ffffdfa
++#define DT_MOVESZ	0x6ffffdfb
++#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
++#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
++					   the following DT_* entry.  */
++#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
++#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
++#define DT_VALRNGHI	0x6ffffdff
++#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
++#define DT_VALNUM 12
++
++/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
++   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
++
++   If any adjustment is made to the ELF object after it has been
++   built these entries will need to be adjusted.  */
++#define DT_ADDRRNGLO	0x6ffffe00
++#define DT_GNU_HASH	0x6ffffef5	/* GNU-style hash table.  */
++#define DT_TLSDESC_PLT	0x6ffffef6
++#define DT_TLSDESC_GOT	0x6ffffef7
++#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
++#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
++#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
++#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
++#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
++#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
++#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
++#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
++#define DT_ADDRRNGHI	0x6ffffeff
++#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
++#define DT_ADDRNUM 11
++
++/* The versioning entry types.  The next are defined as part of the
++   GNU extension.  */
++#define DT_VERSYM	0x6ffffff0
++
++#define DT_RELACOUNT	0x6ffffff9
++#define DT_RELCOUNT	0x6ffffffa
++
++/* These were chosen by Sun.  */
++#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
++#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
++					   table */
++#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
++#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
++					   versions */
++#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
++#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
++#define DT_VERSIONTAGNUM 16
++
++/* Sun added these machine-independent extensions in the "processor-specific"
++   range.  Be compatible.  */
++#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
++#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
++#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
++#define DT_EXTRANUM	3
++
++/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
++#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
++#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
++#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
++#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
++#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
++
++/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
++   entry in the dynamic section.  */
++#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
++#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
++#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
++#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
++#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
++#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
++#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
++#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
++#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
++#define DF_1_TRANS	0x00000200
++#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
++#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
++#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
++#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
++#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
++#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
++#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
++
++/* Flags for the feature selection in DT_FEATURE_1.  */
++#define DTF_1_PARINIT	0x00000001
++#define DTF_1_CONFEXP	0x00000002
++
++/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
++#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
++#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
++					   generally available.  */
++
++/* Version definition sections.  */
++
++typedef struct
++{
++  Elf32_Half	vd_version;		/* Version revision */
++  Elf32_Half	vd_flags;		/* Version information */
++  Elf32_Half	vd_ndx;			/* Version Index */
++  Elf32_Half	vd_cnt;			/* Number of associated aux entries */
++  Elf32_Word	vd_hash;		/* Version name hash value */
++  Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
++  Elf32_Word	vd_next;		/* Offset in bytes to next verdef
++					   entry */
++} Elf32_Verdef;
++
++typedef struct
++{
++  Elf64_Half	vd_version;		/* Version revision */
++  Elf64_Half	vd_flags;		/* Version information */
++  Elf64_Half	vd_ndx;			/* Version Index */
++  Elf64_Half	vd_cnt;			/* Number of associated aux entries */
++  Elf64_Word	vd_hash;		/* Version name hash value */
++  Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
++  Elf64_Word	vd_next;		/* Offset in bytes to next verdef
++					   entry */
++} Elf64_Verdef;
++
++
++/* Legal values for vd_version (version revision).  */
++#define VER_DEF_NONE	0		/* No version */
++#define VER_DEF_CURRENT	1		/* Current version */
++#define VER_DEF_NUM	2		/* Given version number */
++
++/* Legal values for vd_flags (version information flags).  */
++#define VER_FLG_BASE	0x1		/* Version definition of file itself */
++#define VER_FLG_WEAK	0x2		/* Weak version identifier */
++
++/* Versym symbol index values.  */
++#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
++#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
++#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
++#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */
++
++/* Auxialiary version information.  */
++
++typedef struct
++{
++  Elf32_Word	vda_name;		/* Version or dependency names */
++  Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
++					   entry */
++} Elf32_Verdaux;
++
++typedef struct
++{
++  Elf64_Word	vda_name;		/* Version or dependency names */
++  Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
++					   entry */
++} Elf64_Verdaux;
++
++
++/* Version dependency section.  */
++
++typedef struct
++{
++  Elf32_Half	vn_version;		/* Version of structure */
++  Elf32_Half	vn_cnt;			/* Number of associated aux entries */
++  Elf32_Word	vn_file;		/* Offset of filename for this
++					   dependency */
++  Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
++  Elf32_Word	vn_next;		/* Offset in bytes to next verneed
++					   entry */
++} Elf32_Verneed;
++
++typedef struct
++{
++  Elf64_Half	vn_version;		/* Version of structure */
++  Elf64_Half	vn_cnt;			/* Number of associated aux entries */
++  Elf64_Word	vn_file;		/* Offset of filename for this
++					   dependency */
++  Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
++  Elf64_Word	vn_next;		/* Offset in bytes to next verneed
++					   entry */
++} Elf64_Verneed;
++
++
++/* Legal values for vn_version (version revision).  */
++#define VER_NEED_NONE	 0		/* No version */
++#define VER_NEED_CURRENT 1		/* Current version */
++#define VER_NEED_NUM	 2		/* Given version number */
++
++/* Auxiliary needed version information.  */
++
++typedef struct
++{
++  Elf32_Word	vna_hash;		/* Hash value of dependency name */
++  Elf32_Half	vna_flags;		/* Dependency specific information */
++  Elf32_Half	vna_other;		/* Unused */
++  Elf32_Word	vna_name;		/* Dependency name string offset */
++  Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
++					   entry */
++} Elf32_Vernaux;
++
++typedef struct
++{
++  Elf64_Word	vna_hash;		/* Hash value of dependency name */
++  Elf64_Half	vna_flags;		/* Dependency specific information */
++  Elf64_Half	vna_other;		/* Unused */
++  Elf64_Word	vna_name;		/* Dependency name string offset */
++  Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
++					   entry */
++} Elf64_Vernaux;
++
++
++/* Legal values for vna_flags.  */
++#define VER_FLG_WEAK	0x2		/* Weak version identifier */
++
++
++/* Auxiliary vector.  */
++
++/* This vector is normally only used by the program interpreter.  The
++   usual definition in an ABI supplement uses the name auxv_t.  The
++   vector is not usually defined in a standard <elf.h> file, but it
++   can't hurt.  We rename it to avoid conflicts.  The sizes of these
++   types are an arrangement between the exec server and the program
++   interpreter, so we don't fully specify them here.  */
++
++typedef struct
++{
++  uint32_t a_type;		/* Entry type */
++  union
++    {
++      uint32_t a_val;		/* Integer value */
++      /* We use to have pointer elements added here.  We cannot do that,
++	 though, since it does not work when using 32-bit definitions
++	 on 64-bit platforms and vice versa.  */
++    } a_un;
++} Elf32_auxv_t;
++
++typedef struct
++{
++  uint64_t a_type;		/* Entry type */
++  union
++    {
++      uint64_t a_val;		/* Integer value */
++      /* We use to have pointer elements added here.  We cannot do that,
++	 though, since it does not work when using 32-bit definitions
++	 on 64-bit platforms and vice versa.  */
++    } a_un;
++} Elf64_auxv_t;
++
++/* Legal values for a_type (entry type).  */
++
++#define AT_NULL		0		/* End of vector */
++#define AT_IGNORE	1		/* Entry should be ignored */
++#define AT_EXECFD	2		/* File descriptor of program */
++#define AT_PHDR		3		/* Program headers for program */
++#define AT_PHENT	4		/* Size of program header entry */
++#define AT_PHNUM	5		/* Number of program headers */
++#define AT_PAGESZ	6		/* System page size */
++#define AT_BASE		7		/* Base address of interpreter */
++#define AT_FLAGS	8		/* Flags */
++#define AT_ENTRY	9		/* Entry point of program */
++#define AT_NOTELF	10		/* Program is not ELF */
++#define AT_UID		11		/* Real uid */
++#define AT_EUID		12		/* Effective uid */
++#define AT_GID		13		/* Real gid */
++#define AT_EGID		14		/* Effective gid */
++#define AT_CLKTCK	17		/* Frequency of times() */
++
++/* Some more special a_type values describing the hardware.  */
++#define AT_PLATFORM	15		/* String identifying platform.  */
++#define AT_HWCAP	16		/* Machine dependent hints about
++					   processor capabilities.  */
++
++/* This entry gives some information about the FPU initialization
++   performed by the kernel.  */
++#define AT_FPUCW	18		/* Used FPU control word.  */
++
++/* Cache block sizes.  */
++#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
++#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
++#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */
++
++/* A special ignored value for PPC, used by the kernel to control the
++   interpretation of the AUXV. Must be > 16.  */
++#define AT_IGNOREPPC	22		/* Entry should be ignored.  */
++
++#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
++
++#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/
++
++#define AT_RANDOM	25		/* Address of 16 random bytes.  */
++
++#define AT_EXECFN	31		/* Filename of executable.  */
++
++/* Pointer to the global system page used for system calls and other
++   nice things.  */
++#define AT_SYSINFO	32
++#define AT_SYSINFO_EHDR	33
++
++/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
++   log2 of line size; mask those to get cache size.  */
++#define AT_L1I_CACHESHAPE	34
++#define AT_L1D_CACHESHAPE	35
++#define AT_L2_CACHESHAPE	36
++#define AT_L3_CACHESHAPE	37
++
++/* Note section contents.  Each entry in the note section begins with
++   a header of a fixed form.  */
++
++typedef struct
++{
++  Elf32_Word n_namesz;			/* Length of the note's name.  */
++  Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
++  Elf32_Word n_type;			/* Type of the note.  */
++} Elf32_Nhdr;
++
++typedef struct
++{
++  Elf64_Word n_namesz;			/* Length of the note's name.  */
++  Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
++  Elf64_Word n_type;			/* Type of the note.  */
++} Elf64_Nhdr;
++
++/* Known names of notes.  */
++
++/* Solaris entries in the note section have this name.  */
++#define ELF_NOTE_SOLARIS	"SUNW Solaris"
++
++/* Note entries for GNU systems have this name.  */
++#define ELF_NOTE_GNU		"GNU"
++
++
++/* Defined types of notes for Solaris.  */
++
++/* Value of descriptor (one word) is desired pagesize for the binary.  */
++#define ELF_NOTE_PAGESIZE_HINT	1
++
++
++/* Defined note types for GNU systems.  */
++
++/* ABI information.  The descriptor consists of words:
++   word 0: OS descriptor
++   word 1: major version of the ABI
++   word 2: minor version of the ABI
++   word 3: subminor version of the ABI
++*/
++#define NT_GNU_ABI_TAG	1
++#define ELF_NOTE_ABI	NT_GNU_ABI_TAG /* Old name.  */
++
++/* Known OSes.  These values can appear in word 0 of an
++   NT_GNU_ABI_TAG note section entry.  */
++#define ELF_NOTE_OS_LINUX	0
++#define ELF_NOTE_OS_GNU		1
++#define ELF_NOTE_OS_SOLARIS2	2
++#define ELF_NOTE_OS_FREEBSD	3
++
++/* Synthetic hwcap information.  The descriptor begins with two words:
++   word 0: number of entries
++   word 1: bitmask of enabled entries
++   Then follow variable-length entries, one byte followed by a
++   '\0'-terminated hwcap name string.  The byte gives the bit
++   number to test if enabled, (1U << bit) & bitmask.  */
++#define NT_GNU_HWCAP	2
++
++/* Build ID bits as generated by ld --build-id.
++   The descriptor consists of any nonzero number of bytes.  */
++#define NT_GNU_BUILD_ID	3
++
++/* Version note generated by GNU gold containing a version string.  */
++#define NT_GNU_GOLD_VERSION	4
++
++
++/* Move records.  */
++typedef struct
++{
++  Elf32_Xword m_value;		/* Symbol value.  */
++  Elf32_Word m_info;		/* Size and index.  */
++  Elf32_Word m_poffset;		/* Symbol offset.  */
++  Elf32_Half m_repeat;		/* Repeat count.  */
++  Elf32_Half m_stride;		/* Stride info.  */
++} Elf32_Move;
++
++typedef struct
++{
++  Elf64_Xword m_value;		/* Symbol value.  */
++  Elf64_Xword m_info;		/* Size and index.  */
++  Elf64_Xword m_poffset;	/* Symbol offset.  */
++  Elf64_Half m_repeat;		/* Repeat count.  */
++  Elf64_Half m_stride;		/* Stride info.  */
++} Elf64_Move;
++
++/* Macro to construct move records.  */
++#define ELF32_M_SYM(info)	((info) >> 8)
++#define ELF32_M_SIZE(info)	((unsigned char) (info))
++#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
++
++#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
++#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
++#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
++
++
++/* Motorola 68k specific definitions.  */
++
++/* Values for Elf32_Ehdr.e_flags.  */
++#define EF_CPU32	0x00810000
++
++/* m68k relocs.  */
++
++#define R_68K_NONE	0		/* No reloc */
++#define R_68K_32	1		/* Direct 32 bit  */
++#define R_68K_16	2		/* Direct 16 bit  */
++#define R_68K_8		3		/* Direct 8 bit  */
++#define R_68K_PC32	4		/* PC relative 32 bit */
++#define R_68K_PC16	5		/* PC relative 16 bit */
++#define R_68K_PC8	6		/* PC relative 8 bit */
++#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
++#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
++#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
++#define R_68K_GOT32O	10		/* 32 bit GOT offset */
++#define R_68K_GOT16O	11		/* 16 bit GOT offset */
++#define R_68K_GOT8O	12		/* 8 bit GOT offset */
++#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
++#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
++#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
++#define R_68K_PLT32O	16		/* 32 bit PLT offset */
++#define R_68K_PLT16O	17		/* 16 bit PLT offset */
++#define R_68K_PLT8O	18		/* 8 bit PLT offset */
++#define R_68K_COPY	19		/* Copy symbol at runtime */
++#define R_68K_GLOB_DAT	20		/* Create GOT entry */
++#define R_68K_JMP_SLOT	21		/* Create PLT entry */
++#define R_68K_RELATIVE	22		/* Adjust by program base */
++#define R_68K_TLS_GD32      25          /* 32 bit GOT offset for GD */
++#define R_68K_TLS_GD16      26          /* 16 bit GOT offset for GD */
++#define R_68K_TLS_GD8       27          /* 8 bit GOT offset for GD */
++#define R_68K_TLS_LDM32     28          /* 32 bit GOT offset for LDM */
++#define R_68K_TLS_LDM16     29          /* 16 bit GOT offset for LDM */
++#define R_68K_TLS_LDM8      30          /* 8 bit GOT offset for LDM */
++#define R_68K_TLS_LDO32     31          /* 32 bit module-relative offset */
++#define R_68K_TLS_LDO16     32          /* 16 bit module-relative offset */
++#define R_68K_TLS_LDO8      33          /* 8 bit module-relative offset */
++#define R_68K_TLS_IE32      34          /* 32 bit GOT offset for IE */
++#define R_68K_TLS_IE16      35          /* 16 bit GOT offset for IE */
++#define R_68K_TLS_IE8       36          /* 8 bit GOT offset for IE */
++#define R_68K_TLS_LE32      37          /* 32 bit offset relative to
++					   static TLS block */
++#define R_68K_TLS_LE16      38          /* 16 bit offset relative to
++					   static TLS block */
++#define R_68K_TLS_LE8       39          /* 8 bit offset relative to
++					   static TLS block */
++#define R_68K_TLS_DTPMOD32  40          /* 32 bit module number */
++#define R_68K_TLS_DTPREL32  41          /* 32 bit module-relative offset */
++#define R_68K_TLS_TPREL32   42          /* 32 bit TP-relative offset */
++/* Keep this the last entry.  */
++#define R_68K_NUM	43
++
++/* Intel 80386 specific definitions.  */
++
++/* i386 relocs.  */
++
++#define R_386_NONE	   0		/* No reloc */
++#define R_386_32	   1		/* Direct 32 bit  */
++#define R_386_PC32	   2		/* PC relative 32 bit */
++#define R_386_GOT32	   3		/* 32 bit GOT entry */
++#define R_386_PLT32	   4		/* 32 bit PLT address */
++#define R_386_COPY	   5		/* Copy symbol at runtime */
++#define R_386_GLOB_DAT	   6		/* Create GOT entry */
++#define R_386_JMP_SLOT	   7		/* Create PLT entry */
++#define R_386_RELATIVE	   8		/* Adjust by program base */
++#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
++#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
++#define R_386_32PLT	   11
++#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
++#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
++					   block offset */
++#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
++					   offset */
++#define R_386_TLS_LE	   17		/* Offset relative to static TLS
++					   block */
++#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
++					   general dynamic thread local data */
++#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
++					   local dynamic thread local data
++					   in LE code */
++#define R_386_16	   20
++#define R_386_PC16	   21
++#define R_386_8		   22
++#define R_386_PC8	   23
++#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
++					   thread local data */
++#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
++#define R_386_TLS_GD_CALL  26		/* Relocation for call to
++					   __tls_get_addr() */
++#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
++#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
++					   thread local data in LE code */
++#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
++#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
++					   __tls_get_addr() in LDM code */
++#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
++#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
++#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
++					   block offset */
++#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
++					   TLS block */
++#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
++#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
++#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
++/* 38? */
++#define R_386_TLS_GOTDESC  39		/* GOT offset for TLS descriptor.  */
++#define R_386_TLS_DESC_CALL 40		/* Marker of call through TLS
++					   descriptor for
++					   relaxation.  */
++#define R_386_TLS_DESC     41		/* TLS descriptor containing
++					   pointer to code and to
++					   argument, returning the TLS
++					   offset for the symbol.  */
++#define R_386_IRELATIVE	   42		/* Adjust indirectly by program base */
++/* Keep this the last entry.  */
++#define R_386_NUM	   43
++
++/* SUN SPARC specific definitions.  */
++
++/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
++
++#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */
++
++/* Values for Elf64_Ehdr.e_flags.  */
++
++#define EF_SPARCV9_MM		3
++#define EF_SPARCV9_TSO		0
++#define EF_SPARCV9_PSO		1
++#define EF_SPARCV9_RMO		2
++#define EF_SPARC_LEDATA		0x800000 /* little endian data */
++#define EF_SPARC_EXT_MASK	0xFFFF00
++#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
++#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
++#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
++#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */
++
++/* SPARC relocs.  */
++
++#define R_SPARC_NONE		0	/* No reloc */
++#define R_SPARC_8		1	/* Direct 8 bit */
++#define R_SPARC_16		2	/* Direct 16 bit */
++#define R_SPARC_32		3	/* Direct 32 bit */
++#define R_SPARC_DISP8		4	/* PC relative 8 bit */
++#define R_SPARC_DISP16		5	/* PC relative 16 bit */
++#define R_SPARC_DISP32		6	/* PC relative 32 bit */
++#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
++#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
++#define R_SPARC_HI22		9	/* High 22 bit */
++#define R_SPARC_22		10	/* Direct 22 bit */
++#define R_SPARC_13		11	/* Direct 13 bit */
++#define R_SPARC_LO10		12	/* Truncated 10 bit */
++#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
++#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
++#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
++#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
++#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
++#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
++#define R_SPARC_COPY		19	/* Copy symbol at runtime */
++#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
++#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
++#define R_SPARC_RELATIVE	22	/* Adjust by program base */
++#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */
++
++/* Additional Sparc64 relocs.  */
++
++#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
++#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
++#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
++#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
++#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
++#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
++#define R_SPARC_10		30	/* Direct 10 bit */
++#define R_SPARC_11		31	/* Direct 11 bit */
++#define R_SPARC_64		32	/* Direct 64 bit */
++#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
++#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
++#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
++#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
++#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
++#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
++#define R_SPARC_PC_LM22		39	/* Low miggle 22 bits of ... */
++#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
++#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
++#define R_SPARC_GLOB_JMP	42	/* was part of v9 ABI but was removed */
++#define R_SPARC_7		43	/* Direct 7 bit */
++#define R_SPARC_5		44	/* Direct 5 bit */
++#define R_SPARC_6		45	/* Direct 6 bit */
++#define R_SPARC_DISP64		46	/* PC relative 64 bit */
++#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
++#define R_SPARC_HIX22		48	/* High 22 bit complemented */
++#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
++#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
++#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
++#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
++#define R_SPARC_REGISTER	53	/* Global register usage */
++#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
++#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
++#define R_SPARC_TLS_GD_HI22	56
++#define R_SPARC_TLS_GD_LO10	57
++#define R_SPARC_TLS_GD_ADD	58
++#define R_SPARC_TLS_GD_CALL	59
++#define R_SPARC_TLS_LDM_HI22	60
++#define R_SPARC_TLS_LDM_LO10	61
++#define R_SPARC_TLS_LDM_ADD	62
++#define R_SPARC_TLS_LDM_CALL	63
++#define R_SPARC_TLS_LDO_HIX22	64
++#define R_SPARC_TLS_LDO_LOX10	65
++#define R_SPARC_TLS_LDO_ADD	66
++#define R_SPARC_TLS_IE_HI22	67
++#define R_SPARC_TLS_IE_LO10	68
++#define R_SPARC_TLS_IE_LD	69
++#define R_SPARC_TLS_IE_LDX	70
++#define R_SPARC_TLS_IE_ADD	71
++#define R_SPARC_TLS_LE_HIX22	72
++#define R_SPARC_TLS_LE_LOX10	73
++#define R_SPARC_TLS_DTPMOD32	74
++#define R_SPARC_TLS_DTPMOD64	75
++#define R_SPARC_TLS_DTPOFF32	76
++#define R_SPARC_TLS_DTPOFF64	77
++#define R_SPARC_TLS_TPOFF32	78
++#define R_SPARC_TLS_TPOFF64	79
++#define R_SPARC_GOTDATA_HIX22	80
++#define R_SPARC_GOTDATA_LOX10	81
++#define R_SPARC_GOTDATA_OP_HIX22	82
++#define R_SPARC_GOTDATA_OP_LOX10	83
++#define R_SPARC_GOTDATA_OP	84
++#define R_SPARC_H34		85
++#define R_SPARC_SIZE32		86
++#define R_SPARC_SIZE64		87
++#define R_SPARC_WDISP10		88
++#define R_SPARC_JMP_IREL	248
++#define R_SPARC_IRELATIVE	249
++#define R_SPARC_GNU_VTINHERIT	250
++#define R_SPARC_GNU_VTENTRY	251
++#define R_SPARC_REV32		252
++/* Keep this the last entry.  */
++#define R_SPARC_NUM		253
++
++/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
++
++#define DT_SPARC_REGISTER 0x70000001
++#define DT_SPARC_NUM	2
++
++/* MIPS R3000 specific definitions.  */
++
++/* Legal values for e_flags field of Elf32_Ehdr.  */
++
++#define EF_MIPS_NOREORDER   1		/* A .noreorder directive was used */
++#define EF_MIPS_PIC	    2		/* Contains PIC code */
++#define EF_MIPS_CPIC	    4		/* Uses PIC calling sequence */
++#define EF_MIPS_XGOT	    8
++#define EF_MIPS_64BIT_WHIRL 16
++#define EF_MIPS_ABI2	    32
++#define EF_MIPS_ABI_ON32    64
++#define EF_MIPS_ARCH	    0xf0000000	/* MIPS architecture level */
++
++/* Legal values for MIPS architecture level.  */
++
++#define EF_MIPS_ARCH_1	    0x00000000	/* -mips1 code.  */
++#define EF_MIPS_ARCH_2	    0x10000000	/* -mips2 code.  */
++#define EF_MIPS_ARCH_3	    0x20000000	/* -mips3 code.  */
++#define EF_MIPS_ARCH_4	    0x30000000	/* -mips4 code.  */
++#define EF_MIPS_ARCH_5	    0x40000000	/* -mips5 code.  */
++#define EF_MIPS_ARCH_32	    0x60000000	/* MIPS32 code.  */
++#define EF_MIPS_ARCH_64	    0x70000000	/* MIPS64 code.  */
++
++/* The following are non-official names and should not be used.  */
++
++#define E_MIPS_ARCH_1	  0x00000000	/* -mips1 code.  */
++#define E_MIPS_ARCH_2	  0x10000000	/* -mips2 code.  */
++#define E_MIPS_ARCH_3	  0x20000000	/* -mips3 code.  */
++#define E_MIPS_ARCH_4	  0x30000000	/* -mips4 code.  */
++#define E_MIPS_ARCH_5	  0x40000000	/* -mips5 code.  */
++#define E_MIPS_ARCH_32	  0x60000000	/* MIPS32 code.  */
++#define E_MIPS_ARCH_64	  0x70000000	/* MIPS64 code.  */
++
++/* Special section indices.  */
++
++#define SHN_MIPS_ACOMMON    0xff00	/* Allocated common symbols */
++#define SHN_MIPS_TEXT	    0xff01	/* Allocated test symbols.  */
++#define SHN_MIPS_DATA	    0xff02	/* Allocated data symbols.  */
++#define SHN_MIPS_SCOMMON    0xff03	/* Small common symbols */
++#define SHN_MIPS_SUNDEFINED 0xff04	/* Small undefined symbols */
++
++/* Legal values for sh_type field of Elf32_Shdr.  */
++
++#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
++#define SHT_MIPS_MSYM	       0x70000001
++#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
++#define SHT_MIPS_GPTAB	       0x70000003 /* Global data area sizes */
++#define SHT_MIPS_UCODE	       0x70000004 /* Reserved for SGI/MIPS compilers */
++#define SHT_MIPS_DEBUG	       0x70000005 /* MIPS ECOFF debugging information*/
++#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
++#define SHT_MIPS_PACKAGE       0x70000007
++#define SHT_MIPS_PACKSYM       0x70000008
++#define SHT_MIPS_RELD	       0x70000009
++#define SHT_MIPS_IFACE         0x7000000b
++#define SHT_MIPS_CONTENT       0x7000000c
++#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
++#define SHT_MIPS_SHDR	       0x70000010
++#define SHT_MIPS_FDESC	       0x70000011
++#define SHT_MIPS_EXTSYM	       0x70000012
++#define SHT_MIPS_DENSE	       0x70000013
++#define SHT_MIPS_PDESC	       0x70000014
++#define SHT_MIPS_LOCSYM	       0x70000015
++#define SHT_MIPS_AUXSYM	       0x70000016
++#define SHT_MIPS_OPTSYM	       0x70000017
++#define SHT_MIPS_LOCSTR	       0x70000018
++#define SHT_MIPS_LINE	       0x70000019
++#define SHT_MIPS_RFDESC	       0x7000001a
++#define SHT_MIPS_DELTASYM      0x7000001b
++#define SHT_MIPS_DELTAINST     0x7000001c
++#define SHT_MIPS_DELTACLASS    0x7000001d
++#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
++#define SHT_MIPS_DELTADECL     0x7000001f
++#define SHT_MIPS_SYMBOL_LIB    0x70000020
++#define SHT_MIPS_EVENTS	       0x70000021 /* Event section.  */
++#define SHT_MIPS_TRANSLATE     0x70000022
++#define SHT_MIPS_PIXIE	       0x70000023
++#define SHT_MIPS_XLATE	       0x70000024
++#define SHT_MIPS_XLATE_DEBUG   0x70000025
++#define SHT_MIPS_WHIRL	       0x70000026
++#define SHT_MIPS_EH_REGION     0x70000027
++#define SHT_MIPS_XLATE_OLD     0x70000028
++#define SHT_MIPS_PDR_EXCEPTION 0x70000029
++
++/* Legal values for sh_flags field of Elf32_Shdr.  */
++
++#define SHF_MIPS_GPREL	 0x10000000	/* Must be part of global data area */
++#define SHF_MIPS_MERGE	 0x20000000
++#define SHF_MIPS_ADDR	 0x40000000
++#define SHF_MIPS_STRINGS 0x80000000
++#define SHF_MIPS_NOSTRIP 0x08000000
++#define SHF_MIPS_LOCAL	 0x04000000
++#define SHF_MIPS_NAMES	 0x02000000
++#define SHF_MIPS_NODUPE	 0x01000000
++
++
++/* Symbol tables.  */
++
++/* MIPS specific values for `st_other'.  */
++#define STO_MIPS_DEFAULT		0x0
++#define STO_MIPS_INTERNAL		0x1
++#define STO_MIPS_HIDDEN			0x2
++#define STO_MIPS_PROTECTED		0x3
++#define STO_MIPS_PLT			0x8
++#define STO_MIPS_SC_ALIGN_UNUSED	0xff
++
++/* MIPS specific values for `st_info'.  */
++#define STB_MIPS_SPLIT_COMMON		13
++
++/* Entries found in sections of type SHT_MIPS_GPTAB.  */
++
++typedef union
++{
++  struct
++    {
++      Elf32_Word gt_current_g_value;	/* -G value used for compilation */
++      Elf32_Word gt_unused;		/* Not used */
++    } gt_header;			/* First entry in section */
++  struct
++    {
++      Elf32_Word gt_g_value;		/* If this value were used for -G */
++      Elf32_Word gt_bytes;		/* This many bytes would be used */
++    } gt_entry;				/* Subsequent entries in section */
++} Elf32_gptab;
++
++/* Entry found in sections of type SHT_MIPS_REGINFO.  */
++
++typedef struct
++{
++  Elf32_Word	ri_gprmask;		/* General registers used */
++  Elf32_Word	ri_cprmask[4];		/* Coprocessor registers used */
++  Elf32_Sword	ri_gp_value;		/* $gp register value */
++} Elf32_RegInfo;
++
++/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
++
++typedef struct
++{
++  unsigned char kind;		/* Determines interpretation of the
++				   variable part of descriptor.  */
++  unsigned char size;		/* Size of descriptor, including header.  */
++  Elf32_Section section;	/* Section header index of section affected,
++				   0 for global options.  */
++  Elf32_Word info;		/* Kind-specific information.  */
++} Elf_Options;
++
++/* Values for `kind' field in Elf_Options.  */
++
++#define ODK_NULL	0	/* Undefined.  */
++#define ODK_REGINFO	1	/* Register usage information.  */
++#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
++#define ODK_PAD		3	/* Section padding options.  */
++#define ODK_HWPATCH	4	/* Hardware workarounds performed */
++#define ODK_FILL	5	/* record the fill value used by the linker. */
++#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
++#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
++#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */
++
++/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
++
++#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
++#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
++#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
++#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
++#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
++#define OEX_PRECISEFP	OEX_FPDBUG
++#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */
++
++#define OEX_FPU_INVAL	0x10
++#define OEX_FPU_DIV0	0x08
++#define OEX_FPU_OFLO	0x04
++#define OEX_FPU_UFLO	0x02
++#define OEX_FPU_INEX	0x01
++
++/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
++
++#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
++#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
++#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
++#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */
++
++#define OPAD_PREFIX	0x1
++#define OPAD_POSTFIX	0x2
++#define OPAD_SYMBOL	0x4
++
++/* Entry found in `.options' section.  */
++
++typedef struct
++{
++  Elf32_Word hwp_flags1;	/* Extra flags.  */
++  Elf32_Word hwp_flags2;	/* Extra flags.  */
++} Elf_Options_Hw;
++
++/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
++
++#define OHWA0_R4KEOP_CHECKED	0x00000001
++#define OHWA1_R4KEOP_CLEAN	0x00000002
++
++/* MIPS relocs.  */
++
++#define R_MIPS_NONE		0	/* No reloc */
++#define R_MIPS_16		1	/* Direct 16 bit */
++#define R_MIPS_32		2	/* Direct 32 bit */
++#define R_MIPS_REL32		3	/* PC relative 32 bit */
++#define R_MIPS_26		4	/* Direct 26 bit shifted */
++#define R_MIPS_HI16		5	/* High 16 bit */
++#define R_MIPS_LO16		6	/* Low 16 bit */
++#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
++#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
++#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
++#define R_MIPS_PC16		10	/* PC relative 16 bit */
++#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
++#define R_MIPS_GPREL32		12	/* GP relative 32 bit */
++
++#define R_MIPS_SHIFT5		16
++#define R_MIPS_SHIFT6		17
++#define R_MIPS_64		18
++#define R_MIPS_GOT_DISP		19
++#define R_MIPS_GOT_PAGE		20
++#define R_MIPS_GOT_OFST		21
++#define R_MIPS_GOT_HI16		22
++#define R_MIPS_GOT_LO16		23
++#define R_MIPS_SUB		24
++#define R_MIPS_INSERT_A		25
++#define R_MIPS_INSERT_B		26
++#define R_MIPS_DELETE		27
++#define R_MIPS_HIGHER		28
++#define R_MIPS_HIGHEST		29
++#define R_MIPS_CALL_HI16	30
++#define R_MIPS_CALL_LO16	31
++#define R_MIPS_SCN_DISP		32
++#define R_MIPS_REL16		33
++#define R_MIPS_ADD_IMMEDIATE	34
++#define R_MIPS_PJUMP		35
++#define R_MIPS_RELGOT		36
++#define R_MIPS_JALR		37
++#define R_MIPS_TLS_DTPMOD32	38	/* Module number 32 bit */
++#define R_MIPS_TLS_DTPREL32	39	/* Module-relative offset 32 bit */
++#define R_MIPS_TLS_DTPMOD64	40	/* Module number 64 bit */
++#define R_MIPS_TLS_DTPREL64	41	/* Module-relative offset 64 bit */
++#define R_MIPS_TLS_GD		42	/* 16 bit GOT offset for GD */
++#define R_MIPS_TLS_LDM		43	/* 16 bit GOT offset for LDM */
++#define R_MIPS_TLS_DTPREL_HI16	44	/* Module-relative offset, high 16 bits */
++#define R_MIPS_TLS_DTPREL_LO16	45	/* Module-relative offset, low 16 bits */
++#define R_MIPS_TLS_GOTTPREL	46	/* 16 bit GOT offset for IE */
++#define R_MIPS_TLS_TPREL32	47	/* TP-relative offset, 32 bit */
++#define R_MIPS_TLS_TPREL64	48	/* TP-relative offset, 64 bit */
++#define R_MIPS_TLS_TPREL_HI16	49	/* TP-relative offset, high 16 bits */
++#define R_MIPS_TLS_TPREL_LO16	50	/* TP-relative offset, low 16 bits */
++#define R_MIPS_GLOB_DAT		51
++#define R_MIPS_COPY		126
++#define R_MIPS_JUMP_SLOT        127
++/* Keep this the last entry.  */
++#define R_MIPS_NUM		128
++
++/* Legal values for p_type field of Elf32_Phdr.  */
++
++#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
++#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
++#define PT_MIPS_OPTIONS 0x70000002
++
++/* Special program header types.  */
++
++#define PF_MIPS_LOCAL	0x10000000
++
++/* Legal values for d_tag field of Elf32_Dyn.  */
++
++#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
++#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
++#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
++#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
++#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
++#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
++#define DT_MIPS_MSYM	     0x70000007
++#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
++#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
++#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
++#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
++#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
++#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
++#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
++#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
++#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
++#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
++#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
++#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
++						DT_MIPS_DELTA_CLASS.  */
++#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
++#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
++						DT_MIPS_DELTA_INSTANCE.  */
++#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
++#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
++					     DT_MIPS_DELTA_RELOC.  */
++#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
++					   relocations refer to.  */
++#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
++					   DT_MIPS_DELTA_SYM.  */
++#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
++					     class declaration.  */
++#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
++						DT_MIPS_DELTA_CLASSSYM.  */
++#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
++#define DT_MIPS_PIXIE_INIT   0x70000023
++#define DT_MIPS_SYMBOL_LIB   0x70000024
++#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
++#define DT_MIPS_LOCAL_GOTIDX 0x70000026
++#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
++#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
++#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
++#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
++#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
++#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
++#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
++						    function stored in GOT.  */
++#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
++					   by rld on dlopen() calls.  */
++#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
++#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
++#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
++/* The address of .got.plt in an executable using the new non-PIC ABI.  */
++#define DT_MIPS_PLTGOT	     0x70000032
++/* The base of the PLT in an executable using the new non-PIC ABI if that
++   PLT is writable.  For a non-writable PLT, this is omitted or has a zero
++   value.  */
++#define DT_MIPS_RWPLT        0x70000034
++#define DT_MIPS_NUM	     0x35
++
++/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
++
++#define RHF_NONE		   0		/* No flags */
++#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
++#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
++#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
++#define RHF_NO_MOVE		   (1 << 3)
++#define RHF_SGI_ONLY		   (1 << 4)
++#define RHF_GUARANTEE_INIT	   (1 << 5)
++#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
++#define RHF_GUARANTEE_START_INIT   (1 << 7)
++#define RHF_PIXIE		   (1 << 8)
++#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
++#define RHF_REQUICKSTART	   (1 << 10)
++#define RHF_REQUICKSTARTED	   (1 << 11)
++#define RHF_CORD		   (1 << 12)
++#define RHF_NO_UNRES_UNDEF	   (1 << 13)
++#define RHF_RLD_ORDER_SAFE	   (1 << 14)
++
++/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
++
++typedef struct
++{
++  Elf32_Word l_name;		/* Name (string table index) */
++  Elf32_Word l_time_stamp;	/* Timestamp */
++  Elf32_Word l_checksum;	/* Checksum */
++  Elf32_Word l_version;		/* Interface version */
++  Elf32_Word l_flags;		/* Flags */
++} Elf32_Lib;
++
++typedef struct
++{
++  Elf64_Word l_name;		/* Name (string table index) */
++  Elf64_Word l_time_stamp;	/* Timestamp */
++  Elf64_Word l_checksum;	/* Checksum */
++  Elf64_Word l_version;		/* Interface version */
++  Elf64_Word l_flags;		/* Flags */
++} Elf64_Lib;
++
++
++/* Legal values for l_flags.  */
++
++#define LL_NONE		  0
++#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
++#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
++#define LL_REQUIRE_MINOR  (1 << 2)
++#define LL_EXPORTS	  (1 << 3)
++#define LL_DELAY_LOAD	  (1 << 4)
++#define LL_DELTA	  (1 << 5)
++
++/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
++
++typedef Elf32_Addr Elf32_Conflict;
++
++
++/* HPPA specific definitions.  */
++
++/* Legal values for e_flags field of Elf32_Ehdr.  */
++
++#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
++#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
++#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
++#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
++#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
++					      prediction.  */
++#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
++#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
++
++/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
++
++#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
++#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
++#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */
++
++/* Additional section indeces.  */
++
++#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively declared
++					      symbols in ANSI C.  */
++#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */
++
++/* Legal values for sh_type field of Elf32_Shdr.  */
++
++#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
++#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
++#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */
++
++/* Legal values for sh_flags field of Elf32_Shdr.  */
++
++#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
++#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
++#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */
++
++/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
++
++#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */
++
++#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
++#define STT_HP_STUB		(STT_LOOS + 0x2)
++
++/* HPPA relocs.  */
++
++#define R_PARISC_NONE		0	/* No reloc.  */
++#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
++#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
++#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
++#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
++#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
++#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
++#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
++#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
++#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
++#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
++#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
++#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
++#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
++#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
++#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
++#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
++#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
++#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
++#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
++#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
++#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
++#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
++#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
++#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
++#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
++#define R_PARISC_PLABEL21L	66	/* Left 21 bits of fdesc address.  */
++#define R_PARISC_PLABEL14R	70	/* Right 14 bits of fdesc address.  */
++#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
++#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
++#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
++#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
++#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
++#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
++#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
++#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
++#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
++#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
++#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
++#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
++#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
++#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
++#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
++#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
++#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
++#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
++#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
++#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
++#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
++#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
++#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
++#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
++#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
++#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
++#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
++#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
++#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
++#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
++#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
++#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
++#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
++#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
++#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
++#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
++#define R_PARISC_LORESERVE	128
++#define R_PARISC_COPY		128	/* Copy relocation.  */
++#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
++#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
++#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
++#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
++#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
++#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
++#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
++#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
++#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
++#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
++#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
++#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
++#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
++#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
++#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
++#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
++#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
++#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
++#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
++#define R_PARISC_GNU_VTENTRY	232
++#define R_PARISC_GNU_VTINHERIT	233
++#define R_PARISC_TLS_GD21L	234	/* GD 21-bit left.  */
++#define R_PARISC_TLS_GD14R	235	/* GD 14-bit right.  */
++#define R_PARISC_TLS_GDCALL	236	/* GD call to __t_g_a.  */
++#define R_PARISC_TLS_LDM21L	237	/* LD module 21-bit left.  */
++#define R_PARISC_TLS_LDM14R	238	/* LD module 14-bit right.  */
++#define R_PARISC_TLS_LDMCALL	239	/* LD module call to __t_g_a.  */
++#define R_PARISC_TLS_LDO21L	240	/* LD offset 21-bit left.  */
++#define R_PARISC_TLS_LDO14R	241	/* LD offset 14-bit right.  */
++#define R_PARISC_TLS_DTPMOD32	242	/* DTP module 32-bit.  */
++#define R_PARISC_TLS_DTPMOD64	243	/* DTP module 64-bit.  */
++#define R_PARISC_TLS_DTPOFF32	244	/* DTP offset 32-bit.  */
++#define R_PARISC_TLS_DTPOFF64	245	/* DTP offset 32-bit.  */
++#define R_PARISC_TLS_LE21L	R_PARISC_TPREL21L
++#define R_PARISC_TLS_LE14R	R_PARISC_TPREL14R
++#define R_PARISC_TLS_IE21L	R_PARISC_LTOFF_TP21L
++#define R_PARISC_TLS_IE14R	R_PARISC_LTOFF_TP14R
++#define R_PARISC_TLS_TPREL32	R_PARISC_TPREL32
++#define R_PARISC_TLS_TPREL64	R_PARISC_TPREL64
++#define R_PARISC_HIRESERVE	255
++
++/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
++
++#define PT_HP_TLS		(PT_LOOS + 0x0)
++#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
++#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
++#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
++#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
++#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
++#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
++#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
++#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
++#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
++#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
++#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
++#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
++#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
++#define PT_HP_STACK		(PT_LOOS + 0x14)
++
++#define PT_PARISC_ARCHEXT	0x70000000
++#define PT_PARISC_UNWIND	0x70000001
++
++/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
++
++#define PF_PARISC_SBP		0x08000000
++
++#define PF_HP_PAGE_SIZE		0x00100000
++#define PF_HP_FAR_SHARED	0x00200000
++#define PF_HP_NEAR_SHARED	0x00400000
++#define PF_HP_CODE		0x01000000
++#define PF_HP_MODIFY		0x02000000
++#define PF_HP_LAZYSWAP		0x04000000
++#define PF_HP_SBP		0x08000000
++
++
++/* Alpha specific definitions.  */
++
++/* Legal values for e_flags field of Elf64_Ehdr.  */
++
++#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
++#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */
++
++/* Legal values for sh_type field of Elf64_Shdr.  */
++
++/* These two are primerily concerned with ECOFF debugging info.  */
++#define SHT_ALPHA_DEBUG		0x70000001
++#define SHT_ALPHA_REGINFO	0x70000002
++
++/* Legal values for sh_flags field of Elf64_Shdr.  */
++
++#define SHF_ALPHA_GPREL		0x10000000
++
++/* Legal values for st_other field of Elf64_Sym.  */
++#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
++#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */
++
++/* Alpha relocs.  */
++
++#define R_ALPHA_NONE		0	/* No reloc */
++#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
++#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
++#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
++#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
++#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
++#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
++#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
++#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
++#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
++#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
++#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
++#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
++#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
++#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
++#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
++#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
++#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
++#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
++#define R_ALPHA_TLS_GD_HI	28
++#define R_ALPHA_TLSGD		29
++#define R_ALPHA_TLS_LDM		30
++#define R_ALPHA_DTPMOD64	31
++#define R_ALPHA_GOTDTPREL	32
++#define R_ALPHA_DTPREL64	33
++#define R_ALPHA_DTPRELHI	34
++#define R_ALPHA_DTPRELLO	35
++#define R_ALPHA_DTPREL16	36
++#define R_ALPHA_GOTTPREL	37
++#define R_ALPHA_TPREL64		38
++#define R_ALPHA_TPRELHI		39
++#define R_ALPHA_TPRELLO		40
++#define R_ALPHA_TPREL16		41
++/* Keep this the last entry.  */
++#define R_ALPHA_NUM		46
++
++/* Magic values of the LITUSE relocation addend.  */
++#define LITUSE_ALPHA_ADDR	0
++#define LITUSE_ALPHA_BASE	1
++#define LITUSE_ALPHA_BYTOFF	2
++#define LITUSE_ALPHA_JSR	3
++#define LITUSE_ALPHA_TLS_GD	4
++#define LITUSE_ALPHA_TLS_LDM	5
++
++/* Legal values for d_tag of Elf64_Dyn.  */
++#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
++#define DT_ALPHA_NUM		1
++
++/* PowerPC specific declarations */
++
++/* Values for Elf32/64_Ehdr.e_flags.  */
++#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */
++
++/* Cygnus local bits below */
++#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
++#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
++						   flag */
++
++/* PowerPC relocations defined by the ABIs */
++#define R_PPC_NONE		0
++#define R_PPC_ADDR32		1	/* 32bit absolute address */
++#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
++#define R_PPC_ADDR16		3	/* 16bit absolute address */
++#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
++#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
++#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
++#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
++#define R_PPC_ADDR14_BRTAKEN	8
++#define R_PPC_ADDR14_BRNTAKEN	9
++#define R_PPC_REL24		10	/* PC relative 26 bit */
++#define R_PPC_REL14		11	/* PC relative 16 bit */
++#define R_PPC_REL14_BRTAKEN	12
++#define R_PPC_REL14_BRNTAKEN	13
++#define R_PPC_GOT16		14
++#define R_PPC_GOT16_LO		15
++#define R_PPC_GOT16_HI		16
++#define R_PPC_GOT16_HA		17
++#define R_PPC_PLTREL24		18
++#define R_PPC_COPY		19
++#define R_PPC_GLOB_DAT		20
++#define R_PPC_JMP_SLOT		21
++#define R_PPC_RELATIVE		22
++#define R_PPC_LOCAL24PC		23
++#define R_PPC_UADDR32		24
++#define R_PPC_UADDR16		25
++#define R_PPC_REL32		26
++#define R_PPC_PLT32		27
++#define R_PPC_PLTREL32		28
++#define R_PPC_PLT16_LO		29
++#define R_PPC_PLT16_HI		30
++#define R_PPC_PLT16_HA		31
++#define R_PPC_SDAREL16		32
++#define R_PPC_SECTOFF		33
++#define R_PPC_SECTOFF_LO	34
++#define R_PPC_SECTOFF_HI	35
++#define R_PPC_SECTOFF_HA	36
++
++/* PowerPC relocations defined for the TLS access ABI.  */
++#define R_PPC_TLS		67 /* none	(sym+add)@tls */
++#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
++#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
++#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
++#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
++#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
++#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
++#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
++#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
++#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
++#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
++#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
++#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
++#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
++#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
++#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
++#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
++#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
++#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
++#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
++#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
++#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
++#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
++#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
++#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
++#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
++#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
++#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */
++
++/* The remaining relocs are from the Embedded ELF ABI, and are not
++   in the SVR4 ELF ABI.  */
++#define R_PPC_EMB_NADDR32	101
++#define R_PPC_EMB_NADDR16	102
++#define R_PPC_EMB_NADDR16_LO	103
++#define R_PPC_EMB_NADDR16_HI	104
++#define R_PPC_EMB_NADDR16_HA	105
++#define R_PPC_EMB_SDAI16	106
++#define R_PPC_EMB_SDA2I16	107
++#define R_PPC_EMB_SDA2REL	108
++#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
++#define R_PPC_EMB_MRKREF	110
++#define R_PPC_EMB_RELSEC16	111
++#define R_PPC_EMB_RELST_LO	112
++#define R_PPC_EMB_RELST_HI	113
++#define R_PPC_EMB_RELST_HA	114
++#define R_PPC_EMB_BIT_FLD	115
++#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */
++
++/* Diab tool relocations.  */
++#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
++#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
++#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
++#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
++#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
++#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */
++
++/* GNU extension to support local ifunc.  */
++#define R_PPC_IRELATIVE		248
++
++/* GNU relocs used in PIC code sequences.  */
++#define R_PPC_REL16		249	/* half16   (sym+add-.) */
++#define R_PPC_REL16_LO		250	/* half16   (sym+add-.)@l */
++#define R_PPC_REL16_HI		251	/* half16   (sym+add-.)@h */
++#define R_PPC_REL16_HA		252	/* half16   (sym+add-.)@ha */
++
++/* This is a phony reloc to handle any old fashioned TOC16 references
++   that may still be in object files.  */
++#define R_PPC_TOC16		255
++
++/* PowerPC specific values for the Dyn d_tag field.  */
++#define DT_PPC_GOT		(DT_LOPROC + 0)
++#define DT_PPC_NUM		1
++
++/* PowerPC64 relocations defined by the ABIs */
++#define R_PPC64_NONE		R_PPC_NONE
++#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
++#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
++#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
++#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
++#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
++#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
++#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
++#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
++#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
++#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
++#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
++#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
++#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
++#define R_PPC64_GOT16		R_PPC_GOT16
++#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
++#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
++#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
++
++#define R_PPC64_COPY		R_PPC_COPY
++#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
++#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
++#define R_PPC64_RELATIVE	R_PPC_RELATIVE
++
++#define R_PPC64_UADDR32		R_PPC_UADDR32
++#define R_PPC64_UADDR16		R_PPC_UADDR16
++#define R_PPC64_REL32		R_PPC_REL32
++#define R_PPC64_PLT32		R_PPC_PLT32
++#define R_PPC64_PLTREL32	R_PPC_PLTREL32
++#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
++#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
++#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
++
++#define R_PPC64_SECTOFF		R_PPC_SECTOFF
++#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
++#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
++#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
++#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
++#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
++#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
++#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
++#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
++#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
++#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
++#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
++#define R_PPC64_PLT64		45 /* doubleword64 L + A */
++#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
++#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
++#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
++#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
++#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
++#define R_PPC64_TOC		51 /* doubleword64 .TOC */
++#define R_PPC64_PLTGOT16	52 /* half16* M + A */
++#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
++#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
++#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */
++
++#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
++#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
++#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
++#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
++#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
++#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
++#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
++#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
++#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
++#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
++#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */
++
++/* PowerPC64 relocations defined for the TLS access ABI.  */
++#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
++#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
++#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
++#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
++#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
++#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
++#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
++#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
++#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
++#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
++#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
++#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
++#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
++#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
++#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
++#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
++#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
++#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
++#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
++#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
++#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
++#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
++#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
++#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
++#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
++#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
++#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
++#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
++#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
++#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
++#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
++#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
++#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
++#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
++#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
++#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
++#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
++#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
++#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
++#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */
++
++/* GNU extension to support local ifunc.  */
++#define R_PPC64_JMP_IREL	247
++#define R_PPC64_IRELATIVE	248
++#define R_PPC64_REL16		249	/* half16   (sym+add-.) */
++#define R_PPC64_REL16_LO	250	/* half16   (sym+add-.)@l */
++#define R_PPC64_REL16_HI	251	/* half16   (sym+add-.)@h */
++#define R_PPC64_REL16_HA	252	/* half16   (sym+add-.)@ha */
++
++/* PowerPC64 specific values for the Dyn d_tag field.  */
++#define DT_PPC64_GLINK  (DT_LOPROC + 0)
++#define DT_PPC64_OPD	(DT_LOPROC + 1)
++#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
++#define DT_PPC64_NUM    3
++
++
++/* ARM specific declarations */
++
++/* Processor specific flags for the ELF header e_flags field.  */
++#define EF_ARM_RELEXEC		0x01
++#define EF_ARM_HASENTRY		0x02
++#define EF_ARM_INTERWORK	0x04
++#define EF_ARM_APCS_26		0x08
++#define EF_ARM_APCS_FLOAT	0x10
++#define EF_ARM_PIC		0x20
++#define EF_ARM_ALIGN8		0x40 /* 8-bit structure alignment is in use */
++#define EF_ARM_NEW_ABI		0x80
++#define EF_ARM_OLD_ABI		0x100
++#define EF_ARM_SOFT_FLOAT	0x200
++#define EF_ARM_VFP_FLOAT	0x400
++#define EF_ARM_MAVERICK_FLOAT	0x800
++
++
++/* Other constants defined in the ARM ELF spec. version B-01.  */
++/* NB. These conflict with values defined above.  */
++#define EF_ARM_SYMSARESORTED	0x04
++#define EF_ARM_DYNSYMSUSESEGIDX	0x08
++#define EF_ARM_MAPSYMSFIRST	0x10
++#define EF_ARM_EABIMASK		0XFF000000
++
++/* Constants defined in AAELF.  */
++#define EF_ARM_BE8	    0x00800000
++#define EF_ARM_LE8	    0x00400000
++
++#define EF_ARM_EABI_VERSION(flags)	((flags) & EF_ARM_EABIMASK)
++#define EF_ARM_EABI_UNKNOWN	0x00000000
++#define EF_ARM_EABI_VER1	0x01000000
++#define EF_ARM_EABI_VER2	0x02000000
++#define EF_ARM_EABI_VER3	0x03000000
++#define EF_ARM_EABI_VER4	0x04000000
++#define EF_ARM_EABI_VER5	0x05000000
++
++/* Additional symbol types for Thumb.  */
++#define STT_ARM_TFUNC		STT_LOPROC /* A Thumb function.  */
++#define STT_ARM_16BIT		STT_HIPROC /* A Thumb label.  */
++
++/* ARM-specific values for sh_flags */
++#define SHF_ARM_ENTRYSECT	0x10000000 /* Section contains an entry point */
++#define SHF_ARM_COMDEF		0x80000000 /* Section may be multiply defined
++					      in the input to a link step.  */
++
++/* ARM-specific program header flags */
++#define PF_ARM_SB		0x10000000 /* Segment contains the location
++					      addressed by the static base. */
++#define PF_ARM_PI		0x20000000 /* Position-independent segment.  */
++#define PF_ARM_ABS		0x40000000 /* Absolute segment.  */
++
++/* Processor specific values for the Phdr p_type field.  */
++#define PT_ARM_EXIDX		(PT_LOPROC + 1)	/* ARM unwind segment.  */
++
++/* Processor specific values for the Shdr sh_type field.  */
++#define SHT_ARM_EXIDX		(SHT_LOPROC + 1) /* ARM unwind section.  */
++#define SHT_ARM_PREEMPTMAP	(SHT_LOPROC + 2) /* Preemption details.  */
++#define SHT_ARM_ATTRIBUTES	(SHT_LOPROC + 3) /* ARM attributes section.  */
++
++
++/* ARM relocs.  */
++
++#define R_ARM_NONE		0	/* No reloc */
++#define R_ARM_PC24		1	/* PC relative 26 bit branch */
++#define R_ARM_ABS32		2	/* Direct 32 bit  */
++#define R_ARM_REL32		3	/* PC relative 32 bit */
++#define R_ARM_PC13		4
++#define R_ARM_ABS16		5	/* Direct 16 bit */
++#define R_ARM_ABS12		6	/* Direct 12 bit */
++#define R_ARM_THM_ABS5		7
++#define R_ARM_ABS8		8	/* Direct 8 bit */
++#define R_ARM_SBREL32		9
++#define R_ARM_THM_PC22		10
++#define R_ARM_THM_PC8		11
++#define R_ARM_AMP_VCALL9	12
++#define R_ARM_SWI24		13	/* Obsolete static relocation.  */
++#define R_ARM_TLS_DESC		13      /* Dynamic relocation.  */
++#define R_ARM_THM_SWI8		14
++#define R_ARM_XPC25		15
++#define R_ARM_THM_XPC22		16
++#define R_ARM_TLS_DTPMOD32	17	/* ID of module containing symbol */
++#define R_ARM_TLS_DTPOFF32	18	/* Offset in TLS block */
++#define R_ARM_TLS_TPOFF32	19	/* Offset in static TLS block */
++#define R_ARM_COPY		20	/* Copy symbol at runtime */
++#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
++#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
++#define R_ARM_RELATIVE		23	/* Adjust by program base */
++#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
++#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
++#define R_ARM_GOT32		26	/* 32 bit GOT entry */
++#define R_ARM_PLT32		27	/* 32 bit PLT address */
++#define R_ARM_ALU_PCREL_7_0	32
++#define R_ARM_ALU_PCREL_15_8	33
++#define R_ARM_ALU_PCREL_23_15	34
++#define R_ARM_LDR_SBREL_11_0	35
++#define R_ARM_ALU_SBREL_19_12	36
++#define R_ARM_ALU_SBREL_27_20	37
++#define R_ARM_TLS_GOTDESC	90
++#define R_ARM_TLS_CALL		91
++#define R_ARM_TLS_DESCSEQ	92
++#define R_ARM_THM_TLS_CALL	93
++#define R_ARM_GNU_VTENTRY	100
++#define R_ARM_GNU_VTINHERIT	101
++#define R_ARM_THM_PC11		102	/* thumb unconditional branch */
++#define R_ARM_THM_PC9		103	/* thumb conditional branch */
++#define R_ARM_TLS_GD32		104	/* PC-rel 32 bit for global dynamic
++					   thread local data */
++#define R_ARM_TLS_LDM32		105	/* PC-rel 32 bit for local dynamic
++					   thread local data */
++#define R_ARM_TLS_LDO32		106	/* 32 bit offset relative to TLS
++					   block */
++#define R_ARM_TLS_IE32		107	/* PC-rel 32 bit for GOT entry of
++					   static TLS block offset */
++#define R_ARM_TLS_LE32		108	/* 32 bit offset relative to static
++					   TLS block */
++#define	R_ARM_THM_TLS_DESCSEQ	129
++#define R_ARM_IRELATIVE		160
++#define R_ARM_RXPC25		249
++#define R_ARM_RSBREL32		250
++#define R_ARM_THM_RPC22		251
++#define R_ARM_RREL32		252
++#define R_ARM_RABS22		253
++#define R_ARM_RPC24		254
++#define R_ARM_RBASE		255
++/* Keep this the last entry.  */
++#define R_ARM_NUM		256
++
++/* IA-64 specific declarations.  */
++
++/* Processor specific flags for the Ehdr e_flags field.  */
++#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
++#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
++#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */
++
++/* Processor specific values for the Phdr p_type field.  */
++#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
++#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
++#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
++#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
++#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
++
++/* Processor specific flags for the Phdr p_flags field.  */
++#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */
++
++/* Processor specific values for the Shdr sh_type field.  */
++#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
++#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */
++
++/* Processor specific flags for the Shdr sh_flags field.  */
++#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
++#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */
++
++/* Processor specific values for the Dyn d_tag field.  */
++#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
++#define DT_IA_64_NUM		1
++
++/* IA-64 relocations.  */
++#define R_IA64_NONE		0x00	/* none */
++#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
++#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
++#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
++#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
++#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
++#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
++#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
++#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
++#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
++#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
++#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
++#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
++#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
++#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
++#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
++#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
++#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
++#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
++#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
++#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
++#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
++#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
++#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
++#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
++#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
++#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
++#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
++#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
++#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
++#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
++#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
++#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
++#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
++#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
++#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
++#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
++#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
++#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
++#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
++#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
++#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
++#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
++#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
++#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
++#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
++#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
++#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
++#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
++#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
++#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
++#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
++#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
++#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
++#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
++#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
++#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
++#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
++#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
++#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
++#define R_IA64_COPY		0x84	/* copy relocation */
++#define R_IA64_SUB		0x85	/* Addend and symbol difference */
++#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
++#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
++#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
++#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
++#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
++#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
++#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
++#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
++#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
++#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
++#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
++#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
++#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
++#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
++#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
++#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
++#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
++#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
++#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */
++
++/* SH specific declarations */
++
++/* Processor specific flags for the ELF header e_flags field.  */
++#define EF_SH_MACH_MASK		0x1f
++#define EF_SH_UNKNOWN		0x0
++#define EF_SH1			0x1
++#define EF_SH2			0x2
++#define EF_SH3			0x3
++#define EF_SH_DSP		0x4
++#define EF_SH3_DSP		0x5
++#define EF_SH4AL_DSP		0x6
++#define EF_SH3E			0x8
++#define EF_SH4			0x9
++#define EF_SH2E			0xb
++#define EF_SH4A			0xc
++#define EF_SH2A			0xd
++#define EF_SH4_NOFPU		0x10
++#define EF_SH4A_NOFPU		0x11
++#define EF_SH4_NOMMU_NOFPU	0x12
++#define EF_SH2A_NOFPU		0x13
++#define EF_SH3_NOMMU		0x14
++#define EF_SH2A_SH4_NOFPU	0x15
++#define EF_SH2A_SH3_NOFPU	0x16
++#define EF_SH2A_SH4		0x17
++#define EF_SH2A_SH3E		0x18
++
++/* SH relocs.  */
++#define	R_SH_NONE		0
++#define	R_SH_DIR32		1
++#define	R_SH_REL32		2
++#define	R_SH_DIR8WPN		3
++#define	R_SH_IND12W		4
++#define	R_SH_DIR8WPL		5
++#define	R_SH_DIR8WPZ		6
++#define	R_SH_DIR8BP		7
++#define	R_SH_DIR8W		8
++#define	R_SH_DIR8L		9
++#define	R_SH_SWITCH16		25
++#define	R_SH_SWITCH32		26
++#define	R_SH_USES		27
++#define	R_SH_COUNT		28
++#define	R_SH_ALIGN		29
++#define	R_SH_CODE		30
++#define	R_SH_DATA		31
++#define	R_SH_LABEL		32
++#define	R_SH_SWITCH8		33
++#define	R_SH_GNU_VTINHERIT	34
++#define	R_SH_GNU_VTENTRY	35
++#define	R_SH_TLS_GD_32		144
++#define	R_SH_TLS_LD_32		145
++#define	R_SH_TLS_LDO_32		146
++#define	R_SH_TLS_IE_32		147
++#define	R_SH_TLS_LE_32		148
++#define	R_SH_TLS_DTPMOD32	149
++#define	R_SH_TLS_DTPOFF32	150
++#define	R_SH_TLS_TPOFF32	151
++#define	R_SH_GOT32		160
++#define	R_SH_PLT32		161
++#define	R_SH_COPY		162
++#define	R_SH_GLOB_DAT		163
++#define	R_SH_JMP_SLOT		164
++#define	R_SH_RELATIVE		165
++#define	R_SH_GOTOFF		166
++#define	R_SH_GOTPC		167
++/* Keep this the last entry.  */
++#define	R_SH_NUM		256
++
++/* S/390 specific definitions.  */
++
++/* Valid values for the e_flags field.  */
++
++#define EF_S390_HIGH_GPRS    0x00000001  /* High GPRs kernel facility needed.  */
++
++/* Additional s390 relocs */
++
++#define R_390_NONE		0	/* No reloc.  */
++#define R_390_8			1	/* Direct 8 bit.  */
++#define R_390_12		2	/* Direct 12 bit.  */
++#define R_390_16		3	/* Direct 16 bit.  */
++#define R_390_32		4	/* Direct 32 bit.  */
++#define R_390_PC32		5	/* PC relative 32 bit.	*/
++#define R_390_GOT12		6	/* 12 bit GOT offset.  */
++#define R_390_GOT32		7	/* 32 bit GOT offset.  */
++#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
++#define R_390_COPY		9	/* Copy symbol at runtime.  */
++#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
++#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
++#define R_390_RELATIVE		12	/* Adjust by program base.  */
++#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
++#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
++#define R_390_GOT16		15	/* 16 bit GOT offset.  */
++#define R_390_PC16		16	/* PC relative 16 bit.	*/
++#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
++#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
++#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
++#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
++#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
++#define R_390_64		22	/* Direct 64 bit.  */
++#define R_390_PC64		23	/* PC relative 64 bit.	*/
++#define R_390_GOT64		24	/* 64 bit GOT offset.  */
++#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
++#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
++#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
++#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
++#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
++#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
++#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
++#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
++#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
++#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
++#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
++#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
++#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
++#define R_390_TLS_GDCALL	38	/* Tag for function call in general
++					   dynamic TLS code. */
++#define R_390_TLS_LDCALL	39	/* Tag for function call in local
++					   dynamic TLS code. */
++#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
++					   thread local data.  */
++#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
++					  thread local data.  */
++#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
++					   block offset.  */
++#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
++					   block offset.  */
++#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
++					   block offset. */
++#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
++					   thread local data in LE code.  */
++#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
++					   thread local data in LE code.  */
++#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
++					   negated static TLS block offset.  */
++#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
++					   negated static TLS block offset.  */
++#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
++					   negated static TLS block offset.  */
++#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
++					   static TLS block.  */
++#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
++					   static TLS block.  */
++#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
++					   block.  */
++#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
++					   block.  */
++#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
++#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
++#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
++					   block.  */
++#define R_390_20		57	/* Direct 20 bit.  */
++#define R_390_GOT20		58	/* 20 bit GOT offset.  */
++#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
++#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
++					   block offset.  */
++#define R_390_IRELATIVE         61      /* STT_GNU_IFUNC relocation.  */
++/* Keep this the last entry.  */
++#define R_390_NUM		62
++
++
++/* CRIS relocations.  */
++#define R_CRIS_NONE		0
++#define R_CRIS_8		1
++#define R_CRIS_16		2
++#define R_CRIS_32		3
++#define R_CRIS_8_PCREL		4
++#define R_CRIS_16_PCREL		5
++#define R_CRIS_32_PCREL		6
++#define R_CRIS_GNU_VTINHERIT	7
++#define R_CRIS_GNU_VTENTRY	8
++#define R_CRIS_COPY		9
++#define R_CRIS_GLOB_DAT		10
++#define R_CRIS_JUMP_SLOT	11
++#define R_CRIS_RELATIVE		12
++#define R_CRIS_16_GOT		13
++#define R_CRIS_32_GOT		14
++#define R_CRIS_16_GOTPLT	15
++#define R_CRIS_32_GOTPLT	16
++#define R_CRIS_32_GOTREL	17
++#define R_CRIS_32_PLT_GOTREL	18
++#define R_CRIS_32_PLT_PCREL	19
++
++#define R_CRIS_NUM		20
++
++
++/* AMD x86-64 relocations.  */
++#define R_X86_64_NONE		0	/* No reloc */
++#define R_X86_64_64		1	/* Direct 64 bit  */
++#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
++#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
++#define R_X86_64_PLT32		4	/* 32 bit PLT address */
++#define R_X86_64_COPY		5	/* Copy symbol at runtime */
++#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
++#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
++#define R_X86_64_RELATIVE	8	/* Adjust by program base */
++#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
++					   offset to GOT */
++#define R_X86_64_32		10	/* Direct 32 bit zero extended */
++#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
++#define R_X86_64_16		12	/* Direct 16 bit zero extended */
++#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
++#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
++#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
++#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
++#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
++#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
++#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
++					   to two GOT entries for GD symbol */
++#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
++					   to two GOT entries for LD symbol */
++#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
++#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
++					   to GOT entry for IE symbol */
++#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
++#define R_X86_64_PC64		24	/* PC relative 64 bit */
++#define R_X86_64_GOTOFF64	25	/* 64 bit offset to GOT */
++#define R_X86_64_GOTPC32	26	/* 32 bit signed pc relative
++					   offset to GOT */
++#define R_X86_64_GOT64		27	/* 64-bit GOT entry offset */
++#define R_X86_64_GOTPCREL64	28	/* 64-bit PC relative offset
++					   to GOT entry */
++#define R_X86_64_GOTPC64	29	/* 64-bit PC relative offset to GOT */
++#define R_X86_64_GOTPLT64	30 	/* like GOT64, says PLT entry needed */
++#define R_X86_64_PLTOFF64	31	/* 64-bit GOT relative offset
++					   to PLT entry */
++#define R_X86_64_SIZE32		32	/* Size of symbol plus 32-bit addend */
++#define R_X86_64_SIZE64		33	/* Size of symbol plus 64-bit addend */
++#define R_X86_64_GOTPC32_TLSDESC 34	/* GOT offset for TLS descriptor.  */
++#define R_X86_64_TLSDESC_CALL   35	/* Marker for call through TLS
++					   descriptor.  */
++#define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
++#define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
++#define R_X86_64_RELATIVE64	38	/* 64-bit adjust by program base */
++
++#define R_X86_64_NUM		39
++
++
++/* AM33 relocations.  */
++#define R_MN10300_NONE		0	/* No reloc.  */
++#define R_MN10300_32		1	/* Direct 32 bit.  */
++#define R_MN10300_16		2	/* Direct 16 bit.  */
++#define R_MN10300_8		3	/* Direct 8 bit.  */
++#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
++#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
++#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
++#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
++#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
++#define R_MN10300_24		9	/* Direct 24 bit.  */
++#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
++#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
++#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
++#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
++#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
++#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
++#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
++#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
++#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
++#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
++#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
++#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
++#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
++#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
++
++#define R_MN10300_NUM		24
++
++
++/* M32R relocs.  */
++#define R_M32R_NONE		0	/* No reloc. */
++#define R_M32R_16		1	/* Direct 16 bit. */
++#define R_M32R_32		2	/* Direct 32 bit. */
++#define R_M32R_24		3	/* Direct 24 bit. */
++#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
++#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
++#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
++#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
++#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
++#define R_M32R_LO16		9	/* Low 16 bit. */
++#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
++#define R_M32R_GNU_VTINHERIT	11
++#define R_M32R_GNU_VTENTRY	12
++/* M32R relocs use SHT_RELA.  */
++#define R_M32R_16_RELA		33	/* Direct 16 bit. */
++#define R_M32R_32_RELA		34	/* Direct 32 bit. */
++#define R_M32R_24_RELA		35	/* Direct 24 bit. */
++#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
++#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
++#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
++#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
++#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
++#define R_M32R_LO16_RELA	41	/* Low 16 bit */
++#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
++#define R_M32R_RELA_GNU_VTINHERIT	43
++#define R_M32R_RELA_GNU_VTENTRY	44
++#define R_M32R_REL32		45	/* PC relative 32 bit.  */
++
++#define R_M32R_GOT24		48	/* 24 bit GOT entry */
++#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
++#define R_M32R_COPY		50	/* Copy symbol at runtime */
++#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
++#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
++#define R_M32R_RELATIVE		53	/* Adjust by program base */
++#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
++#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
++#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
++					   low */
++#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
++					   low */
++#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
++#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
++					   GOT with unsigned low */
++#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
++					   GOT with signed low */
++#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
++					   GOT */
++#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
++					   with unsigned low */
++#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
++					   with signed low */
++#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
++#define R_M32R_NUM		256	/* Keep this the last entry. */
++
++
++/* TILEPro relocations.  */
++#define R_TILEPRO_NONE		0	/* No reloc */
++#define R_TILEPRO_32		1	/* Direct 32 bit */
++#define R_TILEPRO_16		2	/* Direct 16 bit */
++#define R_TILEPRO_8		3	/* Direct 8 bit */
++#define R_TILEPRO_32_PCREL	4	/* PC relative 32 bit */
++#define R_TILEPRO_16_PCREL	5	/* PC relative 16 bit */
++#define R_TILEPRO_8_PCREL	6	/* PC relative 8 bit */
++#define R_TILEPRO_LO16		7	/* Low 16 bit */
++#define R_TILEPRO_HI16		8	/* High 16 bit */
++#define R_TILEPRO_HA16		9	/* High 16 bit, adjusted */
++#define R_TILEPRO_COPY		10	/* Copy relocation */
++#define R_TILEPRO_GLOB_DAT	11	/* Create GOT entry */
++#define R_TILEPRO_JMP_SLOT	12	/* Create PLT entry */
++#define R_TILEPRO_RELATIVE	13	/* Adjust by program base */
++#define R_TILEPRO_BROFF_X1	14	/* X1 pipe branch offset */
++#define R_TILEPRO_JOFFLONG_X1	15	/* X1 pipe jump offset */
++#define R_TILEPRO_JOFFLONG_X1_PLT 16	/* X1 pipe jump offset to PLT */
++#define R_TILEPRO_IMM8_X0	17	/* X0 pipe 8-bit */
++#define R_TILEPRO_IMM8_Y0	18	/* Y0 pipe 8-bit */
++#define R_TILEPRO_IMM8_X1	19	/* X1 pipe 8-bit */
++#define R_TILEPRO_IMM8_Y1	20	/* Y1 pipe 8-bit */
++#define R_TILEPRO_MT_IMM15_X1	21	/* X1 pipe mtspr */
++#define R_TILEPRO_MF_IMM15_X1	22	/* X1 pipe mfspr */
++#define R_TILEPRO_IMM16_X0	23	/* X0 pipe 16-bit */
++#define R_TILEPRO_IMM16_X1	24	/* X1 pipe 16-bit */
++#define R_TILEPRO_IMM16_X0_LO	25	/* X0 pipe low 16-bit */
++#define R_TILEPRO_IMM16_X1_LO	26	/* X1 pipe low 16-bit */
++#define R_TILEPRO_IMM16_X0_HI	27	/* X0 pipe high 16-bit */
++#define R_TILEPRO_IMM16_X1_HI	28	/* X1 pipe high 16-bit */
++#define R_TILEPRO_IMM16_X0_HA	29	/* X0 pipe high 16-bit, adjusted */
++#define R_TILEPRO_IMM16_X1_HA	30	/* X1 pipe high 16-bit, adjusted */
++#define R_TILEPRO_IMM16_X0_PCREL 31	/* X0 pipe PC relative 16 bit */
++#define R_TILEPRO_IMM16_X1_PCREL 32	/* X1 pipe PC relative 16 bit */
++#define R_TILEPRO_IMM16_X0_LO_PCREL 33	/* X0 pipe PC relative low 16 bit */
++#define R_TILEPRO_IMM16_X1_LO_PCREL 34	/* X1 pipe PC relative low 16 bit */
++#define R_TILEPRO_IMM16_X0_HI_PCREL 35	/* X0 pipe PC relative high 16 bit */
++#define R_TILEPRO_IMM16_X1_HI_PCREL 36	/* X1 pipe PC relative high 16 bit */
++#define R_TILEPRO_IMM16_X0_HA_PCREL 37	/* X0 pipe PC relative ha() 16 bit */
++#define R_TILEPRO_IMM16_X1_HA_PCREL 38	/* X1 pipe PC relative ha() 16 bit */
++#define R_TILEPRO_IMM16_X0_GOT	39	/* X0 pipe 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT	40	/* X1 pipe 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X0_GOT_LO 41	/* X0 pipe low 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT_LO 42	/* X1 pipe low 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X0_GOT_HI 43	/* X0 pipe high 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT_HI 44	/* X1 pipe high 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X0_GOT_HA 45	/* X0 pipe ha() 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT_HA 46	/* X1 pipe ha() 16-bit GOT offset */
++#define R_TILEPRO_MMSTART_X0	47	/* X0 pipe mm "start" */
++#define R_TILEPRO_MMEND_X0	48	/* X0 pipe mm "end" */
++#define R_TILEPRO_MMSTART_X1	49	/* X1 pipe mm "start" */
++#define R_TILEPRO_MMEND_X1	50	/* X1 pipe mm "end" */
++#define R_TILEPRO_SHAMT_X0	51	/* X0 pipe shift amount */
++#define R_TILEPRO_SHAMT_X1	52	/* X1 pipe shift amount */
++#define R_TILEPRO_SHAMT_Y0	53	/* Y0 pipe shift amount */
++#define R_TILEPRO_SHAMT_Y1	54	/* Y1 pipe shift amount */
++#define R_TILEPRO_DEST_IMM8_X1	55	/* X1 pipe destination 8-bit */
++/* Relocs 56-59 are currently not defined.  */
++#define R_TILEPRO_TLS_GD_CALL	60	/* "jal" for TLS GD */
++#define R_TILEPRO_IMM8_X0_TLS_GD_ADD 61	/* X0 pipe "addi" for TLS GD */
++#define R_TILEPRO_IMM8_X1_TLS_GD_ADD 62	/* X1 pipe "addi" for TLS GD */
++#define R_TILEPRO_IMM8_Y0_TLS_GD_ADD 63	/* Y0 pipe "addi" for TLS GD */
++#define R_TILEPRO_IMM8_Y1_TLS_GD_ADD 64	/* Y1 pipe "addi" for TLS GD */
++#define R_TILEPRO_TLS_IE_LOAD	65	/* "lw_tls" for TLS IE */
++#define R_TILEPRO_IMM16_X0_TLS_GD 66	/* X0 pipe 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD 67	/* X1 pipe 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_GD_LO 68	/* X0 pipe low 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD_LO 69	/* X1 pipe low 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_GD_HI 70	/* X0 pipe high 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD_HI 71	/* X1 pipe high 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_GD_HA 72	/* X0 pipe ha() 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD_HA 73	/* X1 pipe ha() 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE 74	/* X0 pipe 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE 75	/* X1 pipe 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE_LO 76	/* X0 pipe low 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE_LO 77	/* X1 pipe low 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE_HI 78	/* X0 pipe high 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE_HI 79	/* X1 pipe high 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE_HA 80	/* X0 pipe ha() 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE_HA 81	/* X1 pipe ha() 16-bit TLS IE offset */
++#define R_TILEPRO_TLS_DTPMOD32	82	/* ID of module containing symbol */
++#define R_TILEPRO_TLS_DTPOFF32	83	/* Offset in TLS block */
++#define R_TILEPRO_TLS_TPOFF32	84	/* Offset in static TLS block */
++#define R_TILEPRO_IMM16_X0_TLS_LE 85	/* X0 pipe 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE 86	/* X1 pipe 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X0_TLS_LE_LO 87	/* X0 pipe low 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE_LO 88	/* X1 pipe low 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X0_TLS_LE_HI 89	/* X0 pipe high 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE_HI 90	/* X1 pipe high 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X0_TLS_LE_HA 91	/* X0 pipe ha() 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE_HA 92	/* X1 pipe ha() 16-bit TLS LE offset */
++
++#define R_TILEPRO_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
++#define R_TILEPRO_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
++
++#define R_TILEPRO_NUM		130
++
++
++/* TILE-Gx relocations.  */
++#define R_TILEGX_NONE		0	/* No reloc */
++#define R_TILEGX_64		1	/* Direct 64 bit */
++#define R_TILEGX_32		2	/* Direct 32 bit */
++#define R_TILEGX_16		3	/* Direct 16 bit */
++#define R_TILEGX_8		4	/* Direct 8 bit */
++#define R_TILEGX_64_PCREL	5	/* PC relative 64 bit */
++#define R_TILEGX_32_PCREL	6	/* PC relative 32 bit */
++#define R_TILEGX_16_PCREL	7	/* PC relative 16 bit */
++#define R_TILEGX_8_PCREL	8	/* PC relative 8 bit */
++#define R_TILEGX_HW0		9	/* hword 0 16-bit */
++#define R_TILEGX_HW1		10	/* hword 1 16-bit */
++#define R_TILEGX_HW2		11	/* hword 2 16-bit */
++#define R_TILEGX_HW3		12	/* hword 3 16-bit */
++#define R_TILEGX_HW0_LAST	13	/* last hword 0 16-bit */
++#define R_TILEGX_HW1_LAST	14	/* last hword 1 16-bit */
++#define R_TILEGX_HW2_LAST	15	/* last hword 2 16-bit */
++#define R_TILEGX_COPY		16	/* Copy relocation */
++#define R_TILEGX_GLOB_DAT	17	/* Create GOT entry */
++#define R_TILEGX_JMP_SLOT	18	/* Create PLT entry */
++#define R_TILEGX_RELATIVE	19	/* Adjust by program base */
++#define R_TILEGX_BROFF_X1	20	/* X1 pipe branch offset */
++#define R_TILEGX_JUMPOFF_X1	21	/* X1 pipe jump offset */
++#define R_TILEGX_JUMPOFF_X1_PLT	22	/* X1 pipe jump offset to PLT */
++#define R_TILEGX_IMM8_X0	23	/* X0 pipe 8-bit */
++#define R_TILEGX_IMM8_Y0	24	/* Y0 pipe 8-bit */
++#define R_TILEGX_IMM8_X1	25	/* X1 pipe 8-bit */
++#define R_TILEGX_IMM8_Y1	26	/* Y1 pipe 8-bit */
++#define R_TILEGX_DEST_IMM8_X1	27	/* X1 pipe destination 8-bit */
++#define R_TILEGX_MT_IMM14_X1	28	/* X1 pipe mtspr */
++#define R_TILEGX_MF_IMM14_X1	29	/* X1 pipe mfspr */
++#define R_TILEGX_MMSTART_X0	30	/* X0 pipe mm "start" */
++#define R_TILEGX_MMEND_X0	31	/* X0 pipe mm "end" */
++#define R_TILEGX_SHAMT_X0	32	/* X0 pipe shift amount */
++#define R_TILEGX_SHAMT_X1	33	/* X1 pipe shift amount */
++#define R_TILEGX_SHAMT_Y0	34	/* Y0 pipe shift amount */
++#define R_TILEGX_SHAMT_Y1	35	/* Y1 pipe shift amount */
++#define R_TILEGX_IMM16_X0_HW0	36	/* X0 pipe hword 0 */
++#define R_TILEGX_IMM16_X1_HW0	37	/* X1 pipe hword 0 */
++#define R_TILEGX_IMM16_X0_HW1	38	/* X0 pipe hword 1 */
++#define R_TILEGX_IMM16_X1_HW1	39	/* X1 pipe hword 1 */
++#define R_TILEGX_IMM16_X0_HW2	40	/* X0 pipe hword 2 */
++#define R_TILEGX_IMM16_X1_HW2	41	/* X1 pipe hword 2 */
++#define R_TILEGX_IMM16_X0_HW3	42	/* X0 pipe hword 3 */
++#define R_TILEGX_IMM16_X1_HW3	43	/* X1 pipe hword 3 */
++#define R_TILEGX_IMM16_X0_HW0_LAST 44	/* X0 pipe last hword 0 */
++#define R_TILEGX_IMM16_X1_HW0_LAST 45	/* X1 pipe last hword 0 */
++#define R_TILEGX_IMM16_X0_HW1_LAST 46	/* X0 pipe last hword 1 */
++#define R_TILEGX_IMM16_X1_HW1_LAST 47	/* X1 pipe last hword 1 */
++#define R_TILEGX_IMM16_X0_HW2_LAST 48	/* X0 pipe last hword 2 */
++#define R_TILEGX_IMM16_X1_HW2_LAST 49	/* X1 pipe last hword 2 */
++#define R_TILEGX_IMM16_X0_HW0_PCREL 50	/* X0 pipe PC relative hword 0 */
++#define R_TILEGX_IMM16_X1_HW0_PCREL 51	/* X1 pipe PC relative hword 0 */
++#define R_TILEGX_IMM16_X0_HW1_PCREL 52	/* X0 pipe PC relative hword 1 */
++#define R_TILEGX_IMM16_X1_HW1_PCREL 53	/* X1 pipe PC relative hword 1 */
++#define R_TILEGX_IMM16_X0_HW2_PCREL 54	/* X0 pipe PC relative hword 2 */
++#define R_TILEGX_IMM16_X1_HW2_PCREL 55	/* X1 pipe PC relative hword 2 */
++#define R_TILEGX_IMM16_X0_HW3_PCREL 56	/* X0 pipe PC relative hword 3 */
++#define R_TILEGX_IMM16_X1_HW3_PCREL 57	/* X1 pipe PC relative hword 3 */
++#define R_TILEGX_IMM16_X0_HW0_LAST_PCREL 58 /* X0 pipe PC-rel last hword 0 */
++#define R_TILEGX_IMM16_X1_HW0_LAST_PCREL 59 /* X1 pipe PC-rel last hword 0 */
++#define R_TILEGX_IMM16_X0_HW1_LAST_PCREL 60 /* X0 pipe PC-rel last hword 1 */
++#define R_TILEGX_IMM16_X1_HW1_LAST_PCREL 61 /* X1 pipe PC-rel last hword 1 */
++#define R_TILEGX_IMM16_X0_HW2_LAST_PCREL 62 /* X0 pipe PC-rel last hword 2 */
++#define R_TILEGX_IMM16_X1_HW2_LAST_PCREL 63 /* X1 pipe PC-rel last hword 2 */
++#define R_TILEGX_IMM16_X0_HW0_GOT 64	/* X0 pipe hword 0 GOT offset */
++#define R_TILEGX_IMM16_X1_HW0_GOT 65	/* X1 pipe hword 0 GOT offset */
++/* Relocs 66-71 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_LAST_GOT 72 /* X0 pipe last hword 0 GOT offset */
++#define R_TILEGX_IMM16_X1_HW0_LAST_GOT 73 /* X1 pipe last hword 0 GOT offset */
++#define R_TILEGX_IMM16_X0_HW1_LAST_GOT 74 /* X0 pipe last hword 1 GOT offset */
++#define R_TILEGX_IMM16_X1_HW1_LAST_GOT 75 /* X1 pipe last hword 1 GOT offset */
++/* Relocs 76-77 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_TLS_GD 78	/* X0 pipe hword 0 TLS GD offset */
++#define R_TILEGX_IMM16_X1_HW0_TLS_GD 79	/* X1 pipe hword 0 TLS GD offset */
++#define R_TILEGX_IMM16_X0_HW0_TLS_LE 80	/* X0 pipe hword 0 TLS LE offset */
++#define R_TILEGX_IMM16_X1_HW0_TLS_LE 81	/* X1 pipe hword 0 TLS LE offset */
++#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE 82 /* X0 pipe last hword 0 LE off */
++#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE 83 /* X1 pipe last hword 0 LE off */
++#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE 84 /* X0 pipe last hword 1 LE off */
++#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE 85 /* X1 pipe last hword 1 LE off */
++#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD 86 /* X0 pipe last hword 0 GD off */
++#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD 87 /* X1 pipe last hword 0 GD off */
++#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD 88 /* X0 pipe last hword 1 GD off */
++#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD 89 /* X1 pipe last hword 1 GD off */
++/* Relocs 90-91 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_TLS_IE 92	/* X0 pipe hword 0 TLS IE offset */
++#define R_TILEGX_IMM16_X1_HW0_TLS_IE 93	/* X1 pipe hword 0 TLS IE offset */
++/* Relocs 94-99 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE 100 /* X0 pipe last hword 0 IE off */
++#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE 101 /* X1 pipe last hword 0 IE off */
++#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE 102 /* X0 pipe last hword 1 IE off */
++#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE 103 /* X1 pipe last hword 1 IE off */
++/* Relocs 104-105 are currently not defined.  */
++#define R_TILEGX_TLS_DTPMOD64	106	/* 64-bit ID of symbol's module */
++#define R_TILEGX_TLS_DTPOFF64	107	/* 64-bit offset in TLS block */
++#define R_TILEGX_TLS_TPOFF64	108	/* 64-bit offset in static TLS block */
++#define R_TILEGX_TLS_DTPMOD32	109	/* 32-bit ID of symbol's module */
++#define R_TILEGX_TLS_DTPOFF32	110	/* 32-bit offset in TLS block */
++#define R_TILEGX_TLS_TPOFF32	111	/* 32-bit offset in static TLS block */
++#define R_TILEGX_TLS_GD_CALL	112	/* "jal" for TLS GD */
++#define R_TILEGX_IMM8_X0_TLS_GD_ADD 113	/* X0 pipe "addi" for TLS GD */
++#define R_TILEGX_IMM8_X1_TLS_GD_ADD 114	/* X1 pipe "addi" for TLS GD */
++#define R_TILEGX_IMM8_Y0_TLS_GD_ADD 115	/* Y0 pipe "addi" for TLS GD */
++#define R_TILEGX_IMM8_Y1_TLS_GD_ADD 116	/* Y1 pipe "addi" for TLS GD */
++#define R_TILEGX_TLS_IE_LOAD	117	/* "ld_tls" for TLS IE */
++#define R_TILEGX_IMM8_X0_TLS_ADD 118	/* X0 pipe "addi" for TLS GD/IE */
++#define R_TILEGX_IMM8_X1_TLS_ADD 119	/* X1 pipe "addi" for TLS GD/IE */
++#define R_TILEGX_IMM8_Y0_TLS_ADD 120	/* Y0 pipe "addi" for TLS GD/IE */
++#define R_TILEGX_IMM8_Y1_TLS_ADD 121	/* Y1 pipe "addi" for TLS GD/IE */
++
++#define R_TILEGX_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
++#define R_TILEGX_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
++
++#define R_TILEGX_NUM		130
++
++#endif	/* elf.h */
+--- a/scripts/mod/mk_elfconfig.c
++++ b/scripts/mod/mk_elfconfig.c
+@@ -2,7 +2,11 @@
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
++#ifndef __APPLE__
+ #include <elf.h>
++#else
++#include "elf.h"
++#endif
+ 
+ int
+ main(int argc, char **argv)
+--- a/scripts/mod/modpost.h
++++ b/scripts/mod/modpost.h
+@@ -10,7 +10,11 @@
+ #include <sys/mman.h>
+ #include <fcntl.h>
+ #include <unistd.h>
++#if !(defined(__APPLE__) || defined(__CYGWIN__))
+ #include <elf.h>
++#else
++#include "elf.h"
++#endif
+ #include "../../include/linux/module_symbol.h"
+ 
+ #include <list_types.h>
diff --git a/target/linux/generic/hack-6.12/211-darwin-uuid-typedef-clash.patch b/target/linux/generic/hack-6.12/211-darwin-uuid-typedef-clash.patch
new file mode 100644
index 0000000000..c0e0b24e3c
--- /dev/null
+++ b/target/linux/generic/hack-6.12/211-darwin-uuid-typedef-clash.patch
@@ -0,0 +1,22 @@
+From e44fc2af1ddc452b6659d08c16973d65c73b7d0a Mon Sep 17 00:00:00 2001
+From: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
+Date: Wed, 5 Feb 2020 18:36:43 +0000
+Subject: [PATCH] file2alias: build on macos
+
+Signed-off-by: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
+---
+ scripts/mod/file2alias.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/scripts/mod/file2alias.c
++++ b/scripts/mod/file2alias.c
+@@ -35,6 +35,9 @@ typedef uint32_t	__u32;
+ typedef uint16_t	__u16;
+ typedef unsigned char	__u8;
+ 
++#ifdef __APPLE__
++#define uuid_t compat_uuid_t
++#endif
+ /* UUID types for backward compatibility, don't use in new code */
+ typedef struct {
+ 	__u8 b[16];
diff --git a/target/linux/generic/hack-6.12/214-spidev_h_portability.patch b/target/linux/generic/hack-6.12/214-spidev_h_portability.patch
new file mode 100644
index 0000000000..db754a2903
--- /dev/null
+++ b/target/linux/generic/hack-6.12/214-spidev_h_portability.patch
@@ -0,0 +1,24 @@
+From be9be95ff10e16a5b4ad36f903978d0cc5747024 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 7 Jul 2017 17:04:08 +0200
+Subject: kernel: fix linux/spi/spidev.h portability issues with musl
+
+Felix will try to get this define included into musl
+
+lede-commit: 795e7cf60de19e7a076a46874fab7bb88b43bbff
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ include/uapi/linux/spi/spidev.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/include/uapi/linux/spi/spidev.h
++++ b/include/uapi/linux/spi/spidev.h
+@@ -93,7 +93,7 @@ struct spi_ioc_transfer {
+ 
+ /* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */
+ #define SPI_MSGSIZE(N) \
+-	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \
++	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << 13)) \
+ 		? ((N)*(sizeof (struct spi_ioc_transfer))) : 0)
+ #define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])
+ 
diff --git a/target/linux/generic/hack-6.12/230-openwrt_lzma_options.patch b/target/linux/generic/hack-6.12/230-openwrt_lzma_options.patch
new file mode 100644
index 0000000000..20f2b29bf1
--- /dev/null
+++ b/target/linux/generic/hack-6.12/230-openwrt_lzma_options.patch
@@ -0,0 +1,38 @@
+From b3d00b452467f621317953d9e4c6f9ae8dcfd271 Mon Sep 17 00:00:00 2001
+From: Imre Kaloz <kaloz@openwrt.org>
+Date: Fri, 7 Jul 2017 17:06:55 +0200
+Subject: use the openwrt lzma options for now
+
+lede-commit: 548de949f392049420a6a1feeef118b30ab8ea8c
+Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
+---
+ lib/decompress.c              |  1 +
+ scripts/Makefile.lib          |  2 +-
+ usr/gen_initramfs_list.sh | 10 +++++-----
+ 3 files changed, 7 insertions(+), 6 deletions(-)
+
+--- a/lib/decompress.c
++++ b/lib/decompress.c
+@@ -53,6 +53,7 @@ static const struct compress_format comp
+ 	{ {0x1f, 0x9e}, "gzip", gunzip },
+ 	{ {0x42, 0x5a}, "bzip2", bunzip2 },
+ 	{ {0x5d, 0x00}, "lzma", unlzma },
++	{ {0x6d, 0x00}, "lzma-openwrt", unlzma },
+ 	{ {0xfd, 0x37}, "xz", unxz },
+ 	{ {0x89, 0x4c}, "lzo", unlzo },
+ 	{ {0x02, 0x21}, "lz4", unlz4 },
+--- a/scripts/Makefile.lib
++++ b/scripts/Makefile.lib
+@@ -359,10 +359,10 @@ quiet_cmd_bzip2_with_size = BZIP2   $@
+ # ---------------------------------------------------------------------------
+ 
+ quiet_cmd_lzma = LZMA    $@
+-      cmd_lzma = cat $(real-prereqs) | $(LZMA) -9 > $@
++      cmd_lzma = cat $(real-prereqs) | $(LZMA) e -d20 -lc1 -lp2 -pb2 -eos -si -so > $@
+ 
+ quiet_cmd_lzma_with_size = LZMA    $@
+-      cmd_lzma_with_size = { cat $(real-prereqs) | $(LZMA) -9; $(size_append); } > $@
++      cmd_lzma_with_size = { cat $(real-prereqs) | $(LZMA) e -d20 -lc1 -lp2 -pb2 -eos -si -so; $(size_append); } > $@
+ 
+ quiet_cmd_lzo = LZO     $@
+       cmd_lzo = cat $(real-prereqs) | $(KLZOP) -9 > $@
diff --git a/target/linux/generic/hack-6.12/250-netfilter_depends.patch b/target/linux/generic/hack-6.12/250-netfilter_depends.patch
new file mode 100644
index 0000000000..43faa9959e
--- /dev/null
+++ b/target/linux/generic/hack-6.12/250-netfilter_depends.patch
@@ -0,0 +1,27 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: hack: net: remove bogus netfilter dependencies
+
+lede-commit: 589d2a377dee27d206fc3725325309cf649e4df6
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ net/netfilter/Kconfig | 2 --
+ 1 file changed, 2 deletions(-)
+
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -259,7 +259,6 @@ config NF_CONNTRACK_FTP
+ 
+ config NF_CONNTRACK_H323
+ 	tristate "H.323 protocol support"
+-	depends on IPV6 || IPV6=n
+ 	depends on NETFILTER_ADVANCED
+ 	help
+ 	  H.323 is a VoIP signalling protocol from ITU-T. As one of the most
+@@ -1120,7 +1119,6 @@ config NETFILTER_XT_TARGET_SECMARK
+ 
+ config NETFILTER_XT_TARGET_TCPMSS
+ 	tristate '"TCPMSS" target support'
+-	depends on IPV6 || IPV6=n
+ 	default m if NETFILTER_ADVANCED=n
+ 	help
+ 	  This option adds a `TCPMSS' target, which allows you to alter the
diff --git a/target/linux/generic/hack-6.12/251-kconfig.patch b/target/linux/generic/hack-6.12/251-kconfig.patch
new file mode 100644
index 0000000000..dd73e79453
--- /dev/null
+++ b/target/linux/generic/hack-6.12/251-kconfig.patch
@@ -0,0 +1,157 @@
+From da3c50704f14132f4adf80d48e9a4cd5d46e54c9 Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Fri, 7 Jul 2017 17:09:21 +0200
+Subject: kconfig: owrt specifc dependencies
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ crypto/Kconfig        | 10 +++++-----
+ drivers/bcma/Kconfig  |  1 +
+ drivers/ssb/Kconfig   |  3 ++-
+ lib/Kconfig           |  8 ++++----
+ net/netfilter/Kconfig |  2 +-
+ net/wireless/Kconfig  | 17 ++++++++++-------
+ sound/core/Kconfig    |  4 ++--
+ 7 files changed, 25 insertions(+), 20 deletions(-)
+
+--- a/crypto/Kconfig
++++ b/crypto/Kconfig
+@@ -55,7 +55,7 @@ config CRYPTO_FIPS_VERSION
+ 	  By default the KERNELRELEASE value is used.
+ 
+ config CRYPTO_ALGAPI
+-	tristate
++	tristate "ALGAPI"
+ 	select CRYPTO_ALGAPI2
+ 	help
+ 	  This option provides the API for cryptographic algorithms.
+@@ -64,7 +64,7 @@ config CRYPTO_ALGAPI2
+ 	tristate
+ 
+ config CRYPTO_AEAD
+-	tristate
++	tristate "AEAD"
+ 	select CRYPTO_AEAD2
+ 	select CRYPTO_ALGAPI
+ 
+@@ -82,7 +82,7 @@ config CRYPTO_SIG2
+ 	select CRYPTO_ALGAPI2
+ 
+ config CRYPTO_SKCIPHER
+-	tristate
++	tristate "SKCIPHER"
+ 	select CRYPTO_SKCIPHER2
+ 	select CRYPTO_ALGAPI
+ 	select CRYPTO_ECB
+@@ -92,7 +92,7 @@ config CRYPTO_SKCIPHER2
+ 	select CRYPTO_ALGAPI2
+ 
+ config CRYPTO_HASH
+-	tristate
++	tristate "HASH"
+ 	select CRYPTO_HASH2
+ 	select CRYPTO_ALGAPI
+ 
+@@ -101,7 +101,7 @@ config CRYPTO_HASH2
+ 	select CRYPTO_ALGAPI2
+ 
+ config CRYPTO_RNG
+-	tristate
++	tristate "RNG"
+ 	select CRYPTO_RNG2
+ 	select CRYPTO_ALGAPI
+ 
+--- a/drivers/bcma/Kconfig
++++ b/drivers/bcma/Kconfig
+@@ -16,6 +16,7 @@ if BCMA
+ # Support for Block-I/O. SELECT this from the driver that needs it.
+ config BCMA_BLOCKIO
+ 	bool
++	default y
+ 
+ config BCMA_HOST_PCI_POSSIBLE
+ 	bool
+--- a/drivers/ssb/Kconfig
++++ b/drivers/ssb/Kconfig
+@@ -29,6 +29,7 @@ config SSB_SPROM
+ config SSB_BLOCKIO
+ 	bool
+ 	depends on SSB
++	default y
+ 
+ config SSB_PCIHOST_POSSIBLE
+ 	bool
+@@ -49,7 +50,7 @@ config SSB_PCIHOST
+ config SSB_B43_PCI_BRIDGE
+ 	bool
+ 	depends on SSB_PCIHOST
+-	default n
++	default y
+ 
+ config SSB_PCMCIAHOST_POSSIBLE
+ 	bool
+--- a/lib/Kconfig
++++ b/lib/Kconfig
+@@ -457,16 +457,16 @@ config BCH_CONST_T
+ # Textsearch support is select'ed if needed
+ #
+ config TEXTSEARCH
+-	bool
++	bool "Textsearch support"
+ 
+ config TEXTSEARCH_KMP
+-	tristate
++	tristate "Textsearch KMP"
+ 
+ config TEXTSEARCH_BM
+-	tristate
++	tristate "Textsearch BM"
+ 
+ config TEXTSEARCH_FSM
+-	tristate
++	tristate "Textsearch FSM"
+ 
+ config BTREE
+ 	bool
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -22,7 +22,7 @@ config NETFILTER_SKIP_EGRESS
+ 	def_bool NETFILTER_EGRESS && (NET_CLS_ACT || IFB)
+ 
+ config NETFILTER_NETLINK
+-	tristate
++	tristate "Netfilter NFNETLINK interface"
+ 
+ config NETFILTER_FAMILY_BRIDGE
+ 	bool
+--- a/sound/core/Kconfig
++++ b/sound/core/Kconfig
+@@ -17,7 +17,7 @@ config SND_DMAENGINE_PCM
+ 	tristate
+ 
+ config SND_HWDEP
+-	tristate
++	tristate "Sound hardware support"
+ 
+ config SND_SEQ_DEVICE
+ 	tristate
+@@ -57,7 +57,7 @@ config SND_CORE_TEST
+ 
+ 
+ config SND_COMPRESS_OFFLOAD
+-	tristate
++	tristate "Compression offloading support"
+ 
+ config SND_JACK
+ 	bool
+--- a/net/Kconfig
++++ b/net/Kconfig
+@@ -484,7 +484,7 @@ config NET_DEVLINK
+ 	default n
+ 
+ config PAGE_POOL
+-	bool
++	bool "Page pool support"
+ 
+ config PAGE_POOL_STATS
+ 	default n
diff --git a/target/linux/generic/hack-6.12/253-ksmbd-config.patch b/target/linux/generic/hack-6.12/253-ksmbd-config.patch
new file mode 100644
index 0000000000..a48f528116
--- /dev/null
+++ b/target/linux/generic/hack-6.12/253-ksmbd-config.patch
@@ -0,0 +1,32 @@
+From dcd966fa7ca63f38cf7147e1184d13d66e2ca340 Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 13:33:30 +0200
+Subject: [PATCH] Kconfig: add tristate for OID and ASNI string
+
+---
+ init/Kconfig | 2 +-
+ lib/Kconfig  | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -2059,7 +2059,7 @@ config PADATA
+ 	bool
+ 
+ config ASN1
+-	tristate
++	tristate "ASN1"
+ 	help
+ 	  Build a simple ASN.1 grammar compiler that produces a bytecode output
+ 	  that can be interpreted by the ASN.1 stream decoder and used to
+--- a/lib/Kconfig
++++ b/lib/Kconfig
+@@ -642,7 +642,7 @@ config LIBFDT
+ 	bool
+ 
+ config OID_REGISTRY
+-	tristate
++	tristate "OID"
+ 	help
+ 	  Enable fast lookup object identifier registry.
+ 
diff --git a/target/linux/generic/hack-6.12/259-regmap_dynamic.patch b/target/linux/generic/hack-6.12/259-regmap_dynamic.patch
new file mode 100644
index 0000000000..e7614d6822
--- /dev/null
+++ b/target/linux/generic/hack-6.12/259-regmap_dynamic.patch
@@ -0,0 +1,156 @@
+From 811d9e2268a62b830cfe93cd8bc929afcb8b198b Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 15 Jul 2017 21:12:38 +0200
+Subject: kernel: move regmap bloat out of the kernel image if it is only being used in modules
+
+lede-commit: 96f39119815028073583e4fca3a9c5fe9141e998
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/base/regmap/Kconfig  | 15 ++++++++++-----
+ drivers/base/regmap/Makefile | 12 ++++++++----
+ drivers/base/regmap/regmap.c |  3 +++
+ include/linux/regmap.h       |  2 +-
+ 4 files changed, 22 insertions(+), 10 deletions(-)
+
+--- a/drivers/base/regmap/Kconfig
++++ b/drivers/base/regmap/Kconfig
+@@ -4,8 +4,7 @@
+ # subsystems should select the appropriate symbols.
+ 
+ config REGMAP
+-	bool
+-	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_SPMI || REGMAP_W1 || REGMAP_AC97 || REGMAP_MMIO || REGMAP_IRQ || REGMAP_SOUNDWIRE || REGMAP_SOUNDWIRE_MBQ || REGMAP_SCCB || REGMAP_I3C || REGMAP_SPI_AVMM || REGMAP_MDIO || REGMAP_FSI)
++	tristate
+ 	select IRQ_DOMAIN if REGMAP_IRQ
+ 	select MDIO_BUS if REGMAP_MDIO
+ 	help
+@@ -19,7 +18,7 @@ config REGMAP
+ 
+ config REGMAP_KUNIT
+ 	tristate "KUnit tests for regmap"
+-	depends on KUNIT && REGMAP
++	depends on KUNIT
+ 	default KUNIT_ALL_TESTS
+ 	select REGMAP_RAM
+ 
+@@ -34,60 +33,76 @@ config REGMAP_BUILD
+ 	  normally enabled.
+ 
+ config REGMAP_AC97
++	select REGMAP
+ 	tristate
+ 
+ config REGMAP_I2C
++	select REGMAP
+ 	tristate
+ 	depends on I2C
+ 
+ config REGMAP_SLIMBUS
++	select REGMAP
+ 	tristate
+ 	depends on SLIMBUS
+ 
+ config REGMAP_SPI
++	select REGMAP
+ 	tristate
+ 	depends on SPI
+ 
+ config REGMAP_SPMI
++	select REGMAP
+ 	tristate
+ 	depends on SPMI
+ 
+ config REGMAP_W1
++	select REGMAP
+ 	tristate
+ 	depends on W1
+ 
+ config REGMAP_MDIO
++	select REGMAP
+ 	tristate
+ 
+ config REGMAP_MMIO
++	select REGMAP
+ 	tristate
+ 
+ config REGMAP_IRQ
++	select REGMAP
+ 	bool
+ 
+ config REGMAP_RAM
++	select REGMAP
+ 	tristate
+ 
+ config REGMAP_SOUNDWIRE
++	select REGMAP
+ 	tristate
+ 	depends on SOUNDWIRE
+ 
+ config REGMAP_SOUNDWIRE_MBQ
++	select REGMAP
+ 	tristate
+ 	depends on SOUNDWIRE
+ 
+ config REGMAP_SCCB
++	select REGMAP
+ 	tristate
+ 	depends on I2C
+ 
+ config REGMAP_I3C
++	select REGMAP
+ 	tristate
+ 	depends on I3C
+ 
+ config REGMAP_SPI_AVMM
++	select REGMAP
+ 	tristate
+ 	depends on SPI
+ 
+ config REGMAP_FSI
++	select REGMAP
+ 	tristate
+ 	depends on FSI
+--- a/drivers/base/regmap/Makefile
++++ b/drivers/base/regmap/Makefile
+@@ -2,9 +2,11 @@
+ # For include/trace/define_trace.h to include trace.h
+ CFLAGS_regmap.o := -I$(src)
+ 
+-obj-$(CONFIG_REGMAP) += regmap.o regcache.o
+-obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-flat.o regcache-maple.o
+-obj-$(CONFIG_DEBUG_FS) += regmap-debugfs.o
++regmap-core-objs = regmap.o regcache.o regcache-rbtree.o regcache-flat.o regcache-maple.o
++ifdef CONFIG_DEBUG_FS
++regmap-core-objs += regmap-debugfs.o
++endif
++obj-$(CONFIG_REGMAP) += regmap-core.o
+ obj-$(CONFIG_REGMAP_KUNIT) += regmap-kunit.o
+ obj-$(CONFIG_REGMAP_AC97) += regmap-ac97.o
+ obj-$(CONFIG_REGMAP_I2C) += regmap-i2c.o
+--- a/drivers/base/regmap/regmap.c
++++ b/drivers/base/regmap/regmap.c
+@@ -9,6 +9,7 @@
+ #include <linux/device.h>
+ #include <linux/slab.h>
+ #include <linux/export.h>
++#include <linux/module.h>
+ #include <linux/mutex.h>
+ #include <linux/err.h>
+ #include <linux/property.h>
+@@ -3519,3 +3520,5 @@ static int __init regmap_initcall(void)
+ 	return 0;
+ }
+ postcore_initcall(regmap_initcall);
++
++MODULE_LICENSE("GPL");
+--- a/include/linux/regmap.h
++++ b/include/linux/regmap.h
+@@ -197,7 +197,7 @@ struct reg_sequence {
+ 	__ret ?: __tmp; \
+ })
+ 
+-#ifdef CONFIG_REGMAP
++#if IS_REACHABLE(CONFIG_REGMAP)
+ 
+ enum regmap_endian {
+ 	/* Unspecified -> 0 -> Backwards compatible default */
diff --git a/target/linux/generic/hack-6.12/260-crypto_test_dependencies.patch b/target/linux/generic/hack-6.12/260-crypto_test_dependencies.patch
new file mode 100644
index 0000000000..ce900a87ea
--- /dev/null
+++ b/target/linux/generic/hack-6.12/260-crypto_test_dependencies.patch
@@ -0,0 +1,54 @@
+From fd1799b0bf5efa46dd3e6dfbbf3955564807e508 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 7 Jul 2017 17:12:51 +0200
+Subject: kernel: prevent cryptomgr from pulling in useless extra dependencies for tests that are not run
+
+Reduces kernel size after LZMA by about 5k on MIPS
+
+lede-commit: 044c316167e076479a344c59905e5b435b84a77f
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ crypto/Kconfig   | 13 ++++++-------
+ crypto/algboss.c |  4 ++++
+ 2 files changed, 10 insertions(+), 7 deletions(-)
+
+--- a/crypto/Kconfig
++++ b/crypto/Kconfig
+@@ -149,15 +149,15 @@ config CRYPTO_MANAGER
+ 	  cbc(aes).
+ 
+ config CRYPTO_MANAGER2
+-	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y)
+-	select CRYPTO_ACOMP2
+-	select CRYPTO_AEAD2
+-	select CRYPTO_AKCIPHER2
+-	select CRYPTO_SIG2
+-	select CRYPTO_HASH2
+-	select CRYPTO_KPP2
+-	select CRYPTO_RNG2
+-	select CRYPTO_SKCIPHER2
++	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y && !CRYPTO_MANAGER_DISABLE_TESTS)
++	select CRYPTO_ACOMP2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_AEAD2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_AKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_SIG2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_HASH2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_KPP2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_RNG2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_SKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
+ 
+ config CRYPTO_USER
+ 	tristate "Userspace cryptographic algorithm configuration"
+--- a/crypto/algboss.c
++++ b/crypto/algboss.c
+@@ -203,6 +203,10 @@ static int cryptomgr_schedule_test(struc
+ 	memcpy(param->alg, alg->cra_name, sizeof(param->alg));
+ 	param->type = alg->cra_flags;
+ 
++#ifdef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS
++	param->type |= CRYPTO_ALG_TESTED;
++#endif
++
+ 	thread = kthread_run(cryptomgr_test, param, "cryptomgr_test");
+ 	if (IS_ERR(thread))
+ 		goto err_free_param;
diff --git a/target/linux/generic/hack-6.12/261-lib-arc4-unhide.patch b/target/linux/generic/hack-6.12/261-lib-arc4-unhide.patch
new file mode 100644
index 0000000000..f1e1ad4c40
--- /dev/null
+++ b/target/linux/generic/hack-6.12/261-lib-arc4-unhide.patch
@@ -0,0 +1,24 @@
+From 241e5d3f7b0dd3c01f8c7fa83cbc9a3882286d53 Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 13:35:18 +0200
+Subject: [PATCH] lib/crypto: add tristate string for ARC4
+
+This makes it possible to select CONFIG_CRYPTO_LIB_ARC4 directly. We 
+need this to be able to compile this into the kernel and make use of it 
+from backports.
+
+---
+ lib/crypto/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/lib/crypto/Kconfig
++++ b/lib/crypto/Kconfig
+@@ -20,7 +20,7 @@ config CRYPTO_LIB_AESGCM
+ 	select CRYPTO_LIB_UTILS
+ 
+ config CRYPTO_LIB_ARC4
+-	tristate
++	tristate "ARC4 cipher library"
+ 
+ config CRYPTO_LIB_GF128MUL
+ 	tristate
diff --git a/target/linux/generic/hack-6.12/280-rfkill-stubs.patch b/target/linux/generic/hack-6.12/280-rfkill-stubs.patch
new file mode 100644
index 0000000000..ff6638f7a0
--- /dev/null
+++ b/target/linux/generic/hack-6.12/280-rfkill-stubs.patch
@@ -0,0 +1,84 @@
+From 236c1acdfef5958010ac9814a9872e0a46fd78ee Mon Sep 17 00:00:00 2001
+From: John Crispin <john@phrozen.org>
+Date: Fri, 7 Jul 2017 17:13:44 +0200
+Subject: rfkill: add fake rfkill support
+
+allow building of modules depending on RFKILL even if RFKILL is not enabled.
+
+Signed-off-by: John Crispin <john@phrozen.org>
+---
+ include/linux/rfkill.h |  2 +-
+ net/Makefile           |  2 +-
+ net/rfkill/Kconfig     | 14 +++++++++-----
+ net/rfkill/Makefile    |  2 +-
+ 4 files changed, 12 insertions(+), 8 deletions(-)
+
+--- a/include/linux/rfkill.h
++++ b/include/linux/rfkill.h
+@@ -64,7 +64,7 @@ struct rfkill_ops {
+ 	int	(*set_block)(void *data, bool blocked);
+ };
+ 
+-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
++#if defined(CONFIG_RFKILL_FULL) || defined(CONFIG_RFKILL_FULL_MODULE)
+ /**
+  * rfkill_alloc - Allocate rfkill structure
+  * @name: name of the struct -- the string is not copied internally
+--- a/net/Makefile
++++ b/net/Makefile
+@@ -51,7 +51,7 @@ obj-$(CONFIG_TIPC)		+= tipc/
+ obj-$(CONFIG_NETLABEL)		+= netlabel/
+ obj-$(CONFIG_IUCV)		+= iucv/
+ obj-$(CONFIG_SMC)		+= smc/
+-obj-$(CONFIG_RFKILL)		+= rfkill/
++obj-$(CONFIG_RFKILL_FULL)	+= rfkill/
+ obj-$(CONFIG_NET_9P)		+= 9p/
+ obj-$(CONFIG_CAIF)		+= caif/
+ obj-$(CONFIG_DCB)		+= dcb/
+--- a/net/rfkill/Kconfig
++++ b/net/rfkill/Kconfig
+@@ -2,7 +2,11 @@
+ #
+ # RF switch subsystem configuration
+ #
+-menuconfig RFKILL
++config RFKILL
++	bool
++	default y
++
++menuconfig RFKILL_FULL
+ 	tristate "RF switch subsystem support"
+ 	help
+ 	  Say Y here if you want to have control over RF switches
+@@ -14,19 +18,19 @@ menuconfig RFKILL
+ # LED trigger support
+ config RFKILL_LEDS
+ 	bool
+-	depends on RFKILL
++	depends on RFKILL_FULL
+ 	depends on LEDS_TRIGGERS = y || RFKILL = LEDS_TRIGGERS
+ 	default y
+ 
+ config RFKILL_INPUT
+ 	bool "RF switch input support" if EXPERT
+-	depends on RFKILL
++	depends on RFKILL_FULL
+ 	depends on INPUT = y || RFKILL = INPUT
+ 	default y if !EXPERT
+ 
+ config RFKILL_GPIO
+ 	tristate "GPIO RFKILL driver"
+-	depends on RFKILL
++	depends on RFKILL_FULL
+ 	depends on GPIOLIB || COMPILE_TEST
+ 	default n
+ 	help
+--- a/net/rfkill/Makefile
++++ b/net/rfkill/Makefile
+@@ -5,5 +5,5 @@
+ 
+ rfkill-y			+= core.o
+ rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
+-obj-$(CONFIG_RFKILL)		+= rfkill.o
++obj-$(CONFIG_RFKILL_FULL)	+= rfkill.o
+ obj-$(CONFIG_RFKILL_GPIO)	+= rfkill-gpio.o
diff --git a/target/linux/generic/hack-6.12/300-MIPS-r4k_cache-use-more-efficient-cache-blast.patch b/target/linux/generic/hack-6.12/300-MIPS-r4k_cache-use-more-efficient-cache-blast.patch
new file mode 100644
index 0000000000..6ee98ebfa2
--- /dev/null
+++ b/target/linux/generic/hack-6.12/300-MIPS-r4k_cache-use-more-efficient-cache-blast.patch
@@ -0,0 +1,64 @@
+From: Ben Menchaca <ben.menchaca@qca.qualcomm.com>
+Date: Fri, 7 Jun 2013 18:35:22 -0500
+Subject: MIPS: r4k_cache: use more efficient cache blast
+
+Optimize the compiler output for larger cache blast cases that are
+common for DMA-based networking.
+
+Signed-off-by: Ben Menchaca <ben.menchaca@qca.qualcomm.com>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+--- a/arch/mips/include/asm/r4kcache.h
++++ b/arch/mips/include/asm/r4kcache.h
+@@ -290,14 +290,46 @@ static inline void prot##extra##blast_##
+ 						    unsigned long end)	\
+ {									\
+ 	unsigned long lsize = cpu_##desc##_line_size();			\
++	unsigned long lsize_2 = lsize * 2;				\
++	unsigned long lsize_3 = lsize * 3;				\
++	unsigned long lsize_4 = lsize * 4;				\
++	unsigned long lsize_5 = lsize * 5;				\
++	unsigned long lsize_6 = lsize * 6;				\
++	unsigned long lsize_7 = lsize * 7;				\
++	unsigned long lsize_8 = lsize * 8;				\
+ 	unsigned long addr = start & ~(lsize - 1);			\
+-	unsigned long aend = (end - 1) & ~(lsize - 1);			\
++	unsigned long aend = (end + lsize - 1) & ~(lsize - 1);		\
++	int lines = (aend - addr) / lsize;				\
+ 									\
+-	while (1) {							\
++	while (lines >= 8) {						\
++		prot##cache_op(hitop, addr);				\
++		prot##cache_op(hitop, addr + lsize);			\
++		prot##cache_op(hitop, addr + lsize_2);			\
++		prot##cache_op(hitop, addr + lsize_3);			\
++		prot##cache_op(hitop, addr + lsize_4);			\
++		prot##cache_op(hitop, addr + lsize_5);			\
++		prot##cache_op(hitop, addr + lsize_6);			\
++		prot##cache_op(hitop, addr + lsize_7);			\
++		addr += lsize_8;					\
++		lines -= 8;						\
++	}								\
++									\
++	if (lines & 0x4) {						\
++		prot##cache_op(hitop, addr);				\
++		prot##cache_op(hitop, addr + lsize);			\
++		prot##cache_op(hitop, addr + lsize_2);			\
++		prot##cache_op(hitop, addr + lsize_3);			\
++		addr += lsize_4;					\
++	}								\
++									\
++	if (lines & 0x2) {						\
++		prot##cache_op(hitop, addr);				\
++		prot##cache_op(hitop, addr + lsize);			\
++		addr += lsize_2;					\
++	}								\
++									\
++	if (lines & 0x1) {						\
+ 		prot##cache_op(hitop, addr);				\
+-		if (addr == aend)					\
+-			break;						\
+-		addr += lsize;						\
+ 	}								\
+ }
+ 
diff --git a/target/linux/generic/hack-6.12/301-01-mm-permit-to-declare-custom-execmem-alloc-free-funct.patch b/target/linux/generic/hack-6.12/301-01-mm-permit-to-declare-custom-execmem-alloc-free-funct.patch
new file mode 100644
index 0000000000..3128ed3a68
--- /dev/null
+++ b/target/linux/generic/hack-6.12/301-01-mm-permit-to-declare-custom-execmem-alloc-free-funct.patch
@@ -0,0 +1,62 @@
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Mon, 14 Apr 2025 18:04:25 +0200
+Subject: [PATCH 1/2] mm: permit to declare custom execmem alloc/free function
+
+Permit to declare custom execmem alloc/free function that bypass the
+execmem API. This works by making the alloc/free function weak
+permitting an arch to declare a replacement for them.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+Co-authored-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ include/linux/moduleloader.h |  4 ++++
+ mm/execmem.c                 | 14 ++++++++++++--
+ 2 files changed, 16 insertions(+), 2 deletions(-)
+
+--- a/include/linux/moduleloader.h
++++ b/include/linux/moduleloader.h
+@@ -122,4 +122,8 @@ void module_arch_cleanup(struct module *
+ /* Any cleanup before freeing mod->module_init */
+ void module_arch_freeing_init(struct module *mod);
+ 
++enum execmem_type;
++void *arch_execmem_alloc(enum execmem_type type, size_t size);
++void arch_execmem_free(void *ptr);
++
+ #endif
+--- a/mm/execmem.c
++++ b/mm/execmem.c
+@@ -52,14 +52,19 @@ static void *__execmem_alloc(struct exec
+ 	return kasan_reset_tag(p);
+ }
+ 
+-void *execmem_alloc(enum execmem_type type, size_t size)
++void *__weak arch_execmem_alloc(enum execmem_type type, size_t size)
+ {
+ 	struct execmem_range *range = &execmem_info->ranges[type];
+ 
+ 	return __execmem_alloc(range, size);
+ }
+ 
+-void execmem_free(void *ptr)
++void *execmem_alloc(enum execmem_type type, size_t size)
++{
++	return arch_execmem_alloc(type, size);
++}
++
++void __weak arch_execmem_free(void *ptr)
+ {
+ 	/*
+ 	 * This memory may be RO, and freeing RO memory in an interrupt is not
+@@ -69,6 +74,11 @@ void execmem_free(void *ptr)
+ 	vfree(ptr);
+ }
+ 
++void execmem_free(void *ptr)
++{
++	arch_execmem_free(ptr);
++}
++
+ static bool execmem_validate(struct execmem_info *info)
+ {
+ 	struct execmem_range *r = &info->ranges[EXECMEM_DEFAULT];
diff --git a/target/linux/generic/hack-6.12/301-02-mips-replace-mlong-calls-with-mno-long-calls-if-poss.patch b/target/linux/generic/hack-6.12/301-02-mips-replace-mlong-calls-with-mno-long-calls-if-poss.patch
new file mode 100644
index 0000000000..eaf4de1e89
--- /dev/null
+++ b/target/linux/generic/hack-6.12/301-02-mips-replace-mlong-calls-with-mno-long-calls-if-poss.patch
@@ -0,0 +1,396 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 14 Apr 2025 18:05:45 +0200
+Subject: [PATCH 2/2] mips: replace -mlong-calls with -mno-long-calls if
+ possible
+
+This is a really old patch ported from MikroTik. It needs a an
+additional patch to actually be implemented and both this and the old
+one are considered HACK as they bypass normal kernel linux to make it
+work.
+
+The original message quote:
+
+replace -mlong-calls with -mno-long-calls to make function
+calls faster in kernel modules to achieve this, try to load
+kernel modules to KSEG0 and if that doesn't work, use vmalloc
+and fix up relocations with a jump table based on code from a
+kernel patch by MikroTik.
+
+SVN-Revision: 16772
+
+lede-commit: 3b3d64743ba2a874df9d70cd19e242205b0a788c
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ arch/mips/Makefile             |  10 ++
+ arch/mips/include/asm/module.h |   5 +
+ arch/mips/kernel/module.c      | 281 ++++++++++++++++++++++++++++++++-
+ 3 files changed, 292 insertions(+), 4 deletions(-)
+
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -97,8 +97,18 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
+ cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
+ cflags-y			+= -msoft-float -Wa,-msoft-float
+ LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
++ifdef CONFIG_64BIT
+ KBUILD_AFLAGS_MODULE		+= -mlong-calls
+ KBUILD_CFLAGS_MODULE		+= -mlong-calls
++else
++  ifdef CONFIG_DYNAMIC_FTRACE
++    KBUILD_AFLAGS_MODULE	+= -mlong-calls
++    KBUILD_CFLAGS_MODULE	+= -mlong-calls
++  else
++    KBUILD_AFLAGS_MODULE	+= -mno-long-calls
++    KBUILD_CFLAGS_MODULE	+= -mno-long-calls
++  endif
++endif
+ 
+ ifeq ($(CONFIG_RELOCATABLE),y)
+ LDFLAGS_vmlinux			+= --emit-relocs
+--- a/arch/mips/include/asm/module.h
++++ b/arch/mips/include/asm/module.h
+@@ -12,6 +12,11 @@ struct mod_arch_specific {
+ 	const struct exception_table_entry *dbe_start;
+ 	const struct exception_table_entry *dbe_end;
+ 	struct mips_hi16 *r_mips_hi16_list;
++
++	void *phys_plt_tbl;
++	void *virt_plt_tbl;
++	unsigned int phys_plt_offset;
++	unsigned int virt_plt_offset;
+ };
+ 
+ typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
+--- a/arch/mips/kernel/module.c
++++ b/arch/mips/kernel/module.c
+@@ -8,6 +8,7 @@
+ 
+ #undef DEBUG
+ 
++#include <linux/execmem.h>
+ #include <linux/extable.h>
+ #include <linux/moduleloader.h>
+ #include <linux/elf.h>
+@@ -19,6 +20,7 @@
+ #include <linux/kernel.h>
+ #include <linux/spinlock.h>
+ #include <linux/jump_label.h>
++#include <linux/vmalloc.h>
+ #include <asm/jump_label.h>
+ 
+ struct mips_hi16 {
+@@ -30,14 +32,254 @@ struct mips_hi16 {
+ static LIST_HEAD(dbe_list);
+ static DEFINE_SPINLOCK(dbe_lock);
+ 
++/*
++ * Get the potential max trampolines size required of the init and
++ * non-init sections. Only used if we cannot find enough contiguous
++ * physically mapped memory to put the module into.
++ */
++static unsigned int
++get_plt_size(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
++             const char *secstrings, unsigned int symindex, bool is_init)
++{
++	unsigned long ret = 0;
++	unsigned int i, j;
++	Elf_Sym *syms;
++
++	/* Everything marked ALLOC (this includes the exported symbols) */
++	for (i = 1; i < hdr->e_shnum; ++i) {
++		unsigned int info = sechdrs[i].sh_info;
++
++		if (sechdrs[i].sh_type != SHT_REL
++		    && sechdrs[i].sh_type != SHT_RELA)
++			continue;
++
++		/* Not a valid relocation section? */
++		if (info >= hdr->e_shnum)
++			continue;
++
++		/* Don't bother with non-allocated sections */
++		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
++			continue;
++
++		/* If it's called *.init*, and we're not init, we're
++                   not interested */
++		if ((strstr(secstrings + sechdrs[i].sh_name, ".init") != 0)
++		    != is_init)
++			continue;
++
++		syms = (Elf_Sym *) sechdrs[symindex].sh_addr;
++		if (sechdrs[i].sh_type == SHT_REL) {
++			Elf_Mips_Rel *rel = (void *) sechdrs[i].sh_addr;
++			unsigned int size = sechdrs[i].sh_size / sizeof(*rel);
++
++			for (j = 0; j < size; ++j) {
++				Elf_Sym *sym;
++
++				if (ELF_MIPS_R_TYPE(rel[j]) != R_MIPS_26)
++					continue;
++
++				sym = syms + ELF_MIPS_R_SYM(rel[j]);
++				if (!is_init && sym->st_shndx != SHN_UNDEF)
++					continue;
++
++				ret += 4 * sizeof(int);
++			}
++		} else {
++			Elf_Mips_Rela *rela = (void *) sechdrs[i].sh_addr;
++			unsigned int size = sechdrs[i].sh_size / sizeof(*rela);
++
++			for (j = 0; j < size; ++j) {
++				Elf_Sym *sym;
++
++				if (ELF_MIPS_R_TYPE(rela[j]) != R_MIPS_26)
++					continue;
++
++				sym = syms + ELF_MIPS_R_SYM(rela[j]);
++				if (!is_init && sym->st_shndx != SHN_UNDEF)
++					continue;
++
++				ret += 4 * sizeof(int);
++			}
++		}
++	}
++
++	return ret;
++}
++
++#ifndef MODULES_VADDR
++static void *alloc_phys(unsigned long size)
++{
++	unsigned order;
++	struct page *page;
++	struct page *p;
++
++	size = PAGE_ALIGN(size);
++	order = get_order(size);
++
++	page = alloc_pages(GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN |
++			__GFP_THISNODE, order);
++	if (!page)
++		return NULL;
++
++	split_page(page, order);
++
++	/* mark all pages except for the last one */
++	for (p = page; p + 1 < page + (size >> PAGE_SHIFT); ++p)
++		set_bit(PG_owner_priv_1, &p->flags);
++
++	for (p = page + (size >> PAGE_SHIFT); p < page + (1 << order); ++p)
++		__free_page(p);
++
++	return page_address(page);
++}
++
++static void free_phys(void *ptr)
++{
++	struct page *page;
++	bool free;
++
++	page = virt_to_page(ptr);
++	do {
++		free = test_and_clear_bit(PG_owner_priv_1, &page->flags);
++		__free_page(page);
++		page++;
++	} while (free);
++}
++
++void *arch_execmem_alloc(enum execmem_type type,
++			 size_t size)
++{
++	void *ptr;
++
++	ptr = alloc_phys(size);
++
++	/* If we failed to allocate physically contiguous memory,
++	 * fall back to regular vmalloc. The module loader code will
++	 * create jump tables to handle long jumps */
++	if (!ptr)
++		return vmalloc(size);
++
++	return ptr;
++}
++#endif
++
++static inline bool is_phys_addr(void *ptr)
++{
++#ifdef CONFIG_64BIT
++	return (KSEGX((unsigned long)ptr) == CKSEG0);
++#else
++	return (KSEGX(ptr) == KSEG0);
++#endif
++}
++
++#ifndef MODULES_VADDR
++/* Free memory returned from module_alloc */
++void arch_execmem_free(void *ptr)
++{
++	if (is_phys_addr(ptr))
++		free_phys(ptr);
++	else
++		vfree(ptr);
++}
++#endif
++
++static void *__module_alloc(int size, bool phys)
++{
++	void *ptr;
++
++	if (phys)
++		ptr = kmalloc(size, GFP_KERNEL);
++	else
++		ptr = vmalloc(size);
++	return ptr;
++}
++
++static void __module_free(void *ptr)
++{
++	if (is_phys_addr(ptr))
++		kfree(ptr);
++	else
++		vfree(ptr);
++}
++
++int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
++			      char *secstrings, struct module *mod)
++{
++	unsigned int symindex = 0;
++	unsigned int core_size, init_size;
++	int i;
++
++	mod->arch.phys_plt_offset = 0;
++	mod->arch.virt_plt_offset = 0;
++	mod->arch.phys_plt_tbl = NULL;
++	mod->arch.virt_plt_tbl = NULL;
++
++	if (IS_ENABLED(CONFIG_64BIT))
++		return 0;
++
++	for (i = 1; i < hdr->e_shnum; i++)
++		if (sechdrs[i].sh_type == SHT_SYMTAB)
++			symindex = i;
++
++	core_size = get_plt_size(hdr, sechdrs, secstrings, symindex, false);
++	init_size = get_plt_size(hdr, sechdrs, secstrings, symindex, true);
++
++	if ((core_size + init_size) == 0)
++		return 0;
++
++	mod->arch.phys_plt_tbl = __module_alloc(core_size + init_size, 1);
++	if (!mod->arch.phys_plt_tbl)
++		return -ENOMEM;
++
++	mod->arch.virt_plt_tbl = __module_alloc(core_size + init_size, 0);
++	if (!mod->arch.virt_plt_tbl) {
++		__module_free(mod->arch.phys_plt_tbl);
++		mod->arch.phys_plt_tbl = NULL;
++		return -ENOMEM;
++	}
++
++	return 0;
++}
++
+ static void apply_r_mips_32(u32 *location, u32 base, Elf_Addr v)
+ {
+ 	*location = base + v;
+ }
+ 
++static Elf_Addr add_plt_entry_to(unsigned *plt_offset,
++				 void *start, Elf_Addr v)
++{
++	unsigned *tramp = start + *plt_offset;
++	*plt_offset += 4 * sizeof(int);
++
++	/* adjust carry for addiu */
++	if (v & 0x00008000)
++		v += 0x10000;
++
++	tramp[0] = 0x3c190000 | (v >> 16);      /* lui t9, hi16 */
++	tramp[1] = 0x27390000 | (v & 0xffff);   /* addiu t9, t9, lo16 */
++	tramp[2] = 0x03200008;                  /* jr t9 */
++	tramp[3] = 0x00000000;                  /* nop */
++
++	return (Elf_Addr) tramp;
++}
++
++static Elf_Addr add_plt_entry(struct module *me, void *location, Elf_Addr v)
++{
++	if (is_phys_addr(location))
++		return add_plt_entry_to(&me->arch.phys_plt_offset,
++				me->arch.phys_plt_tbl, v);
++	else
++		return add_plt_entry_to(&me->arch.virt_plt_offset,
++				me->arch.virt_plt_tbl, v);
++
++}
++
+ static int apply_r_mips_26(struct module *me, u32 *location, u32 base,
+ 			   Elf_Addr v)
+ {
++	u32 ofs = base & 0x03ffffff;
++
+ 	if (v % 4) {
+ 		pr_err("module %s: dangerous R_MIPS_26 relocation\n",
+ 		       me->name);
+@@ -45,13 +287,17 @@ static int apply_r_mips_26(struct module
+ 	}
+ 
+ 	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+-		pr_err("module %s: relocation overflow\n",
+-		       me->name);
+-		return -ENOEXEC;
++		v = add_plt_entry(me, location, v + (ofs << 2));
++		if (!v) {
++			pr_err("module %s: relocation overflow\n",
++			       me->name);
++			return -ENOEXEC;
++		}
++		ofs = 0;
+ 	}
+ 
+ 	*location = (*location & ~0x03ffffff) |
+-		    ((base + (v >> 2)) & 0x03ffffff);
++		    ((ofs + (v >> 2)) & 0x03ffffff);
+ 
+ 	return 0;
+ }
+@@ -431,9 +677,36 @@ int module_finalize(const Elf_Ehdr *hdr,
+ 		list_add(&me->arch.dbe_list, &dbe_list);
+ 		spin_unlock_irq(&dbe_lock);
+ 	}
++
++	/* Get rid of the fixup trampoline if we're running the module
++	 * from physically mapped address space */
++	if (me->arch.phys_plt_offset == 0) {
++		__module_free(me->arch.phys_plt_tbl);
++		me->arch.phys_plt_tbl = NULL;
++	}
++	if (me->arch.virt_plt_offset == 0) {
++		__module_free(me->arch.virt_plt_tbl);
++		me->arch.virt_plt_tbl = NULL;
++	}
++
+ 	return 0;
+ }
+ 
++void module_arch_freeing_init(struct module *mod)
++{
++	if (mod->state == MODULE_STATE_LIVE)
++		return;
++
++	if (mod->arch.phys_plt_tbl) {
++		__module_free(mod->arch.phys_plt_tbl);
++		mod->arch.phys_plt_tbl = NULL;
++	}
++	if (mod->arch.virt_plt_tbl) {
++		__module_free(mod->arch.virt_plt_tbl);
++		mod->arch.virt_plt_tbl = NULL;
++	}
++}
++
+ void module_arch_cleanup(struct module *mod)
+ {
+ 	spin_lock_irq(&dbe_lock);
diff --git a/target/linux/generic/hack-6.12/402-mtd-blktrans-call-add-disks-after-mtd-device.patch b/target/linux/generic/hack-6.12/402-mtd-blktrans-call-add-disks-after-mtd-device.patch
new file mode 100644
index 0000000000..5ccb6bc7d8
--- /dev/null
+++ b/target/linux/generic/hack-6.12/402-mtd-blktrans-call-add-disks-after-mtd-device.patch
@@ -0,0 +1,112 @@
+From 0bccc3722bdd88e8ae995e77ef9f7b77ee4cbdee Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Wed, 7 Apr 2021 22:45:54 +0100
+Subject: [PATCH 2/2] mtd: blktrans: call add disks after mtd device
+To: linux-mtd@lists.infradead.org
+Cc: Vignesh Raghavendra <vigneshr@ti.com>,
+    Richard Weinberger <richard@nod.at>,
+    Miquel Raynal <miquel.raynal@bootlin.com>,
+    David Woodhouse <dwmw2@infradead.org>
+
+Calling device_add_disk while holding mtd_table_mutex leads
+to deadlock in case part_bits!=0 as block partition parsers
+will try to open the newly created disks, trying to acquire
+mutex once again.
+Move device_add_disk to additional function called after
+add partitions of an MTD device have been added and locks
+have been released.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/mtd/mtd_blkdevs.c    | 33 ++++++++++++++++++++++++++-------
+ drivers/mtd/mtdcore.c        |  3 +++
+ include/linux/mtd/blktrans.h |  1 +
+ 3 files changed, 30 insertions(+), 7 deletions(-)
+
+--- a/drivers/mtd/mtd_blkdevs.c
++++ b/drivers/mtd/mtd_blkdevs.c
+@@ -379,19 +379,8 @@ int add_mtd_blktrans_dev(struct mtd_blkt
+ 	if (new->readonly)
+ 		set_disk_ro(gd, 1);
+ 
+-	ret = device_add_disk(&new->mtd->dev, gd, NULL);
+-	if (ret)
+-		goto out_cleanup_disk;
+-
+-	if (new->disk_attributes) {
+-		ret = sysfs_create_group(&disk_to_dev(gd)->kobj,
+-					new->disk_attributes);
+-		WARN_ON(ret);
+-	}
+ 	return 0;
+ 
+-out_cleanup_disk:
+-	put_disk(new->disk);
+ out_free_tag_set:
+ 	blk_mq_free_tag_set(new->tag_set);
+ out_kfree_tag_set:
+@@ -401,6 +390,35 @@ out_list_del:
+ 	return ret;
+ }
+ 
++void register_mtd_blktrans_devs(void)
++{
++	struct mtd_blktrans_ops *tr;
++	struct mtd_blktrans_dev *dev, *next;
++	int ret;
++
++	list_for_each_entry(tr, &blktrans_majors, list) {
++		list_for_each_entry_safe(dev, next, &tr->devs, list) {
++			if (disk_live(dev->disk))
++				continue;
++
++			ret = device_add_disk(&dev->mtd->dev, dev->disk, NULL);
++			if (ret)
++				goto out_cleanup_disk;
++
++			if (dev->disk_attributes) {
++				ret = sysfs_create_group(&disk_to_dev(dev->disk)->kobj,
++							dev->disk_attributes);
++				WARN_ON(ret);
++			}
++		}
++	}
++
++	return;
++
++out_cleanup_disk:
++	put_disk(dev->disk);
++}
++
+ int del_mtd_blktrans_dev(struct mtd_blktrans_dev *old)
+ {
+ 	unsigned long flags;
+--- a/drivers/mtd/mtdcore.c
++++ b/drivers/mtd/mtdcore.c
+@@ -34,6 +34,7 @@
+ 
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
++#include <linux/mtd/blktrans.h>
+ 
+ #include "mtdcore.h"
+ 
+@@ -1132,6 +1133,8 @@ int mtd_device_parse_register(struct mtd
+ 		register_reboot_notifier(&mtd->reboot_notifier);
+ 	}
+ 
++	register_mtd_blktrans_devs();
++
+ out:
+ 	if (ret) {
+ 		nvmem_unregister(mtd->otp_user_nvmem);
+--- a/include/linux/mtd/blktrans.h
++++ b/include/linux/mtd/blktrans.h
+@@ -76,6 +76,7 @@ extern int deregister_mtd_blktrans(struc
+ extern int add_mtd_blktrans_dev(struct mtd_blktrans_dev *dev);
+ extern int del_mtd_blktrans_dev(struct mtd_blktrans_dev *dev);
+ extern int mtd_blktrans_cease_background(struct mtd_blktrans_dev *dev);
++extern void register_mtd_blktrans_devs(void);
+ 
+ /**
+  * module_mtd_blktrans() - Helper macro for registering a mtd blktrans driver
diff --git a/target/linux/generic/hack-6.12/420-mtd-support-OpenWrt-s-MTD_ROOTFS_ROOT_DEV.patch b/target/linux/generic/hack-6.12/420-mtd-support-OpenWrt-s-MTD_ROOTFS_ROOT_DEV.patch
new file mode 100644
index 0000000000..5296541800
--- /dev/null
+++ b/target/linux/generic/hack-6.12/420-mtd-support-OpenWrt-s-MTD_ROOTFS_ROOT_DEV.patch
@@ -0,0 +1,24 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 7 Nov 2022 23:48:24 +0100
+Subject: [PATCH] mtd: support OpenWrt's MTD_ROOTFS_ROOT_DEV
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This allows setting ROOT_DEV to MTD partition named "rootfs".
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+---
+
+--- a/drivers/mtd/mtdcore.c
++++ b/drivers/mtd/mtdcore.c
+@@ -803,7 +803,8 @@ int add_mtd_device(struct mtd_info *mtd)
+ 
+ 	mutex_unlock(&mtd_table_mutex);
+ 
+-	if (of_property_read_bool(mtd_get_of_node(mtd), "linux,rootfs")) {
++	if (of_property_read_bool(mtd_get_of_node(mtd), "linux,rootfs") ||
++	    (IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) && !strcmp(mtd->name, "rootfs") && ROOT_DEV == 0)) {
+ 		if (IS_BUILTIN(CONFIG_MTD)) {
+ 			pr_info("mtd: setting mtd%d (%s) as root device\n", mtd->index, mtd->name);
+ 			ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
diff --git a/target/linux/generic/hack-6.12/421-drivers-mtd-parsers-add-nvmem-support-to-cmdlinepart.patch b/target/linux/generic/hack-6.12/421-drivers-mtd-parsers-add-nvmem-support-to-cmdlinepart.patch
new file mode 100644
index 0000000000..190fecc1a0
--- /dev/null
+++ b/target/linux/generic/hack-6.12/421-drivers-mtd-parsers-add-nvmem-support-to-cmdlinepart.patch
@@ -0,0 +1,120 @@
+From 6fa9e3678eb002246df1280322b6a024853950a5 Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Mon, 11 Oct 2021 00:53:14 +0200
+Subject: [PATCH] drivers: mtd: parsers: add nvmem support to cmdlinepart
+
+Assuming cmdlinepart is only one level deep partition scheme and that
+static partition are also defined in DTS, we can assign an of_node for
+partition declared from bootargs. cmdlinepart have priority than
+fiexed-partition parser so in this specific case the parser doesn't
+assign an of_node. Fix this by searching a defined of_node using a
+similar fixed_partition parser and if a partition is found with the same
+label, check that it has the same offset and size and return the DT
+of_node to correctly use NVMEM cells.
+
+Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
+---
+ drivers/mtd/parsers/cmdlinepart.c | 71 +++++++++++++++++++++++++++++++
+ 1 file changed, 71 insertions(+)
+
+--- a/drivers/mtd/parsers/cmdlinepart.c
++++ b/drivers/mtd/parsers/cmdlinepart.c
+@@ -43,6 +43,7 @@
+ #include <linux/mtd/partitions.h>
+ #include <linux/module.h>
+ #include <linux/err.h>
++#include <linux/of.h>
+ 
+ /* special size referring to all the remaining space in a partition */
+ #define SIZE_REMAINING ULLONG_MAX
+@@ -315,6 +316,68 @@ static int mtdpart_setup_real(char *s)
+ 	return 0;
+ }
+ 
++static int search_fixed_partition(struct mtd_info *master,
++				  struct mtd_partition *target_part,
++				  struct mtd_partition *fixed_part)
++{
++	struct device_node *mtd_node;
++	struct device_node *ofpart_node;
++	struct device_node *pp;
++	struct mtd_partition part;
++	const char *partname;
++
++	mtd_node = mtd_get_of_node(master);
++	if (!mtd_node)
++		return -EINVAL;
++
++	ofpart_node = of_get_child_by_name(mtd_node, "partitions");
++
++	for_each_child_of_node(ofpart_node,  pp) {
++		const __be32 *reg;
++		int len;
++		int a_cells, s_cells;
++
++		reg = of_get_property(pp, "reg", &len);
++		if (!reg) {
++			pr_debug("%s: ofpart partition %pOF (%pOF) missing reg property.\n",
++				 master->name, pp,
++				 mtd_node);
++			continue;
++		}
++
++		a_cells = of_n_addr_cells(pp);
++		s_cells = of_n_size_cells(pp);
++		if (len / 4 != a_cells + s_cells) {
++			pr_debug("%s: ofpart partition %pOF (%pOF) error parsing reg property.\n",
++				 master->name, pp,
++				 mtd_node);
++			continue;
++		}
++
++		part.offset = of_read_number(reg, a_cells);
++		part.size = of_read_number(reg + a_cells, s_cells);
++		part.of_node = pp;
++
++		partname = of_get_property(pp, "label", &len);
++		if (!partname)
++			partname = of_get_property(pp, "name", &len);
++		part.name = partname;
++
++		if (!strncmp(target_part->name, part.name, len)) {
++			if (part.offset != target_part->offset)
++				return -EINVAL;
++
++			if (part.size != target_part->size)
++				return -EINVAL;
++
++			memcpy(fixed_part, &part, sizeof(struct mtd_partition));
++			return 0;
++		}
++	}
++
++	return -EINVAL;
++}
++
+ /*
+  * Main function to be called from the MTD mapping driver/device to
+  * obtain the partitioning information. At this point the command line
+@@ -330,6 +393,7 @@ static int parse_cmdline_partitions(stru
+ 	int i, err;
+ 	struct cmdline_mtd_partition *part;
+ 	const char *mtd_id = master->name;
++	struct mtd_partition fixed_part;
+ 
+ 	/* parse command line */
+ 	if (!cmdline_parsed) {
+@@ -374,6 +438,13 @@ static int parse_cmdline_partitions(stru
+ 				sizeof(*part->parts) * (part->num_parts - i));
+ 			i--;
+ 		}
++
++		err = search_fixed_partition(master, &part->parts[i], &fixed_part);
++		if (!err) {
++			part->parts[i].of_node = fixed_part.of_node;
++			pr_info("Found partition defined in DT for %s. Assigning OF node to support nvmem.",
++				part->parts[i].name);
++		}
+ 	}
+ 
+ 	*pparts = kmemdup(part->parts, sizeof(*part->parts) * part->num_parts,
diff --git a/target/linux/generic/hack-6.12/430-mtk-bmt-support.patch b/target/linux/generic/hack-6.12/430-mtk-bmt-support.patch
new file mode 100644
index 0000000000..90b5a64b51
--- /dev/null
+++ b/target/linux/generic/hack-6.12/430-mtk-bmt-support.patch
@@ -0,0 +1,33 @@
+From ac84397efb3b3868c71c10ad7521161773228a17 Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 13:41:44 +0200
+Subject: [PATCH] mtd/nand: add MediaTek NAND bad block managment table
+
+---
+ drivers/mtd/nand/Kconfig  | 4 ++++
+ drivers/mtd/nand/Makefile | 1 +
+ 2 files changed, 5 insertions(+)
+
+--- a/drivers/mtd/nand/Kconfig
++++ b/drivers/mtd/nand/Kconfig
+@@ -46,6 +46,10 @@ config MTD_NAND_ECC_SW_BCH
+ 	  ECC codes. They are used with NAND devices requiring more than 1 bit
+ 	  of error correction.
+ 
++config MTD_NAND_MTK_BMT
++	bool "Support MediaTek NAND Bad-block Management Table"
++	default n
++
+ config MTD_NAND_ECC_MXIC
+ 	bool "Macronix external hardware ECC engine"
+ 	depends on HAS_IOMEM
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -3,6 +3,7 @@
+ nandcore-objs := core.o bbt.o
+ obj-$(CONFIG_MTD_NAND_CORE) += nandcore.o
+ obj-$(CONFIG_MTD_NAND_ECC_MEDIATEK) += ecc-mtk.o
++obj-$(CONFIG_MTD_NAND_MTK_BMT)	+= mtk_bmt.o mtk_bmt_v2.o mtk_bmt_bbt.o mtk_bmt_nmbm.o
+ ifeq ($(CONFIG_SPI_QPIC_SNAND),y)
+ obj-$(CONFIG_SPI_QPIC_SNAND) += qpic_common.o
+ else
diff --git a/target/linux/generic/hack-6.12/499-LEGACY-block-partitions-populate-fwnode.patch b/target/linux/generic/hack-6.12/499-LEGACY-block-partitions-populate-fwnode.patch
new file mode 100644
index 0000000000..f7ec9efba7
--- /dev/null
+++ b/target/linux/generic/hack-6.12/499-LEGACY-block-partitions-populate-fwnode.patch
@@ -0,0 +1,130 @@
+From: Daniel Golle <daniel@makrotopia.org>
+Subject: [PATCH] LEGACY block: partitions: populate fwnode
+
+Assign matching firmware nodes to block partitions in order to allow
+them to be referenced e.g. as NVMEM providers.
+
+REMOVE THIS PATCH ONCE ALL TARGETS ARE USING LINUX 6.12 AND ALL BOARDS
+HAVE MIGRATED TO UPSTREAM DT BINDINGS.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+--- a/block/partitions/core.c
++++ b/block/partitions/core.c
+@@ -11,6 +11,8 @@
+ #include <linux/vmalloc.h>
+ #include <linux/device.h>
+ #include <linux/raid/detect.h>
++#include <linux/property.h>
++
+ #include "check.h"
+ 
+ static int (*const check_part[])(struct parsed_partitions *) = {
+@@ -285,6 +287,74 @@ static ssize_t whole_disk_show(struct de
+ }
+ static const DEVICE_ATTR(whole_disk, 0444, whole_disk_show, NULL);
+ 
++static bool part_meta_match(const char *attr, const char *member, size_t length)
++{
++	/* check if length of attr exceeds specified maximum length */
++	if (strnlen(attr, length) == length)
++		return false;
++
++	/* return true if strings match */
++	return !strncmp(attr, member, length);
++}
++
++static struct fwnode_handle *find_partition_fwnode(struct block_device *bdev)
++{
++	struct fwnode_handle *fw_parts, *fw_part;
++	struct device *ddev = disk_to_dev(bdev->bd_disk);
++	const char *partname, *uuid;
++	u32 partno;
++	bool got_uuid, got_partname, got_partno;
++
++	fw_parts = device_get_named_child_node(ddev, "partitions");
++	if (!fw_parts)
++		return NULL;
++
++	fwnode_for_each_child_node(fw_parts, fw_part) {
++		got_uuid = false;
++		got_partname = false;
++		got_partno = false;
++		/*
++		 * In case 'uuid' is defined in the partitions firmware node
++		 * require partition meta info being present and the specified
++		 * uuid to match.
++		 */
++		got_uuid = !fwnode_property_read_string(fw_part, "uuid", &uuid);
++		if (got_uuid && (!bdev->bd_meta_info ||
++				 !part_meta_match(uuid, bdev->bd_meta_info->uuid,
++						  PARTITION_META_INFO_UUIDLTH)))
++			continue;
++
++		/*
++		 * In case 'partname' is defined in the partitions firmware node
++		 * require partition meta info being present and the specified
++		 * volname to match.
++		 */
++		got_partname = !fwnode_property_read_string(fw_part, "partname",
++							    &partname);
++		if (got_partname && (!bdev->bd_meta_info ||
++				     !part_meta_match(partname,
++						      bdev->bd_meta_info->volname,
++						      PARTITION_META_INFO_VOLNAMELTH)))
++			continue;
++
++		/*
++		 * In case 'partno' is defined in the partitions firmware node
++		 * the specified partno needs to match.
++		 */
++		got_partno = !fwnode_property_read_u32(fw_part, "partno", &partno);
++		if (got_partno && bdev_partno(bdev) != partno)
++			continue;
++
++		/* Skip if no matching criteria is present in firmware node */
++		if (!got_uuid && !got_partname && !got_partno)
++			continue;
++
++		return fw_part;
++	}
++
++	return NULL;
++}
++
+ /*
+  * Must be called either with open_mutex held, before a disk can be opened or
+  * after all disk users are gone.
+@@ -361,6 +431,9 @@ static struct block_device *add_partitio
+ 			goto out_put;
+ 	}
+ 
++	if (!pdev->fwnode && !pdev->of_node)
++		device_set_node(pdev, find_partition_fwnode(bdev));
++
+ 	/* delay uevent until 'holders' subdir is created */
+ 	dev_set_uevent_suppress(pdev, 1);
+ 	err = device_add(pdev);
+--- a/drivers/mmc/core/bus.c
++++ b/drivers/mmc/core/bus.c
+@@ -368,6 +368,8 @@ int mmc_add_card(struct mmc_card *card)
+ 
+ 	mmc_add_card_debugfs(card);
+ 	card->dev.of_node = mmc_of_find_child_device(card->host, 0);
++	if (card->dev.of_node && !card->dev.fwnode)
++		card->dev.fwnode = &card->dev.of_node->fwnode;
+ 
+ 	device_enable_async_suspend(&card->dev);
+ 
+--- a/drivers/mmc/core/block.c
++++ b/drivers/mmc/core/block.c
+@@ -2679,6 +2679,10 @@ static struct mmc_blk_data *mmc_blk_allo
+ 	if (area_type == MMC_BLK_DATA_AREA_MAIN)
+ 		dev_set_drvdata(&card->dev, md);
+ 	disk_fwnode = mmc_blk_get_partitions_node(parent, subname);
++	if (!disk_fwnode)
++		disk_fwnode = device_get_named_child_node(subname ? md->parent->parent :
++							  md->parent,
++							  subname ? subname : "block");
+ 	ret = add_disk_fwnode(md->parent, md->disk, mmc_disk_attr_groups,
+ 			      disk_fwnode);
+ 	if (ret)
diff --git a/target/linux/generic/hack-6.12/600-net-enable-fraglist-GRO-by-default.patch b/target/linux/generic/hack-6.12/600-net-enable-fraglist-GRO-by-default.patch
new file mode 100644
index 0000000000..feed2cd2e0
--- /dev/null
+++ b/target/linux/generic/hack-6.12/600-net-enable-fraglist-GRO-by-default.patch
@@ -0,0 +1,24 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 23 Apr 2024 12:35:21 +0200
+Subject: [PATCH] net: enable fraglist GRO by default
+
+This can significantly improve performance for packet forwarding/bridging
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/linux/netdev_features.h
++++ b/include/linux/netdev_features.h
+@@ -235,10 +235,10 @@ static inline int find_next_netdev_featu
+ #define NETIF_F_UPPER_DISABLES	NETIF_F_LRO
+ 
+ /* changeable features with no special hardware requirements */
+-#define NETIF_F_SOFT_FEATURES	(NETIF_F_GSO | NETIF_F_GRO)
++#define NETIF_F_SOFT_FEATURES	(NETIF_F_GSO | NETIF_F_GRO | NETIF_F_GRO_FRAGLIST)
+ 
+ /* Changeable features with no special hardware requirements that defaults to off. */
+-#define NETIF_F_SOFT_FEATURES_OFF	(NETIF_F_GRO_FRAGLIST | NETIF_F_GRO_UDP_FWD)
++#define NETIF_F_SOFT_FEATURES_OFF	(NETIF_F_GRO_UDP_FWD)
+ 
+ #define NETIF_F_VLAN_FEATURES	(NETIF_F_HW_VLAN_CTAG_FILTER | \
+ 				 NETIF_F_HW_VLAN_CTAG_RX | \
diff --git a/target/linux/generic/hack-6.12/610-net-page_pool-try-to-free-deferred-skbs-while-waitin.patch b/target/linux/generic/hack-6.12/610-net-page_pool-try-to-free-deferred-skbs-while-waitin.patch
new file mode 100644
index 0000000000..9537bb76e3
--- /dev/null
+++ b/target/linux/generic/hack-6.12/610-net-page_pool-try-to-free-deferred-skbs-while-waitin.patch
@@ -0,0 +1,45 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 3 Jan 2025 19:29:00 +0100
+Subject: [PATCH] net: page_pool: try to free deferred skbs while waiting for
+ pool release
+
+The NAPI defer list can accumulate no longer used skbs, which can be reused
+during alloc. If this happens on a CPU that otherwise does not do any
+rx softirq processing, skbs can be held indefinitely, causing warnings
+on releasing page pools.
+Deal with this by scheduling rx softirq on all CPUs.
+
+Patch by Lorenzo Bianconi
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/core/page_pool.c
++++ b/net/core/page_pool.c
+@@ -1063,7 +1063,7 @@ static void page_pool_release_retry(stru
+ 	struct delayed_work *dwq = to_delayed_work(wq);
+ 	struct page_pool *pool = container_of(dwq, typeof(*pool), release_dw);
+ 	void *netdev;
+-	int inflight;
++	int cpu, inflight;
+ 
+ 	inflight = page_pool_release(pool);
+ 	/* In rare cases, a driver bug may cause inflight to go negative.
+@@ -1075,6 +1075,17 @@ static void page_pool_release_retry(stru
+ 	if (inflight <= 0)
+ 		return;
+ 
++	/* Run NET_RX_SOFTIRQ in order to free pending skbs in softnet_data
++	 * defer_list that can stay in the list until we have enough queued
++	 * traffic.
++	 */
++	for_each_online_cpu(cpu) {
++		struct softnet_data *sd = &per_cpu(softnet_data, cpu);
++
++		if (!cmpxchg(&sd->defer_ipi_scheduled, 0, 1))
++			smp_call_function_single_async(cpu, &sd->defer_csd);
++	}
++
+ 	/* Periodic warning for page pools the user can't see */
+ 	netdev = READ_ONCE(pool->slow.netdev);
+ 	if (time_after_eq(jiffies, pool->defer_warn) &&
diff --git a/target/linux/generic/hack-6.12/645-netfilter-connmark-introduce-set-dscpmark.patch b/target/linux/generic/hack-6.12/645-netfilter-connmark-introduce-set-dscpmark.patch
new file mode 100644
index 0000000000..bb802857d6
--- /dev/null
+++ b/target/linux/generic/hack-6.12/645-netfilter-connmark-introduce-set-dscpmark.patch
@@ -0,0 +1,231 @@
+From eda40b8c8c82e0f2789d6bc8bf63846dce2e8f32 Mon Sep 17 00:00:00 2001
+From: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
+Date: Sat, 23 Mar 2019 09:29:49 +0000
+Subject: [PATCH] netfilter: connmark: introduce set-dscpmark
+
+set-dscpmark is a method of storing the DSCP of an ip packet into
+conntrack mark.  In combination with a suitable tc filter action
+(act_ctinfo) DSCP values are able to be stored in the mark on egress and
+restored on ingress across links that otherwise alter or bleach DSCP.
+
+This is useful for qdiscs such as CAKE which are able to shape according
+to policies based on DSCP.
+
+Ingress classification is traditionally a challenging task since
+iptables rules haven't yet run and tc filter/eBPF programs are pre-NAT
+lookups, hence are unable to see internal IPv4 addresses as used on the
+typical home masquerading gateway.
+
+x_tables CONNMARK set-dscpmark target solves the problem of storing the
+DSCP to the conntrack mark in a way suitable for the new act_ctinfo tc
+action to restore.
+
+The set-dscpmark option accepts 2 parameters, a 32bit 'dscpmask' and a
+32bit 'statemask'.  The dscp mask must be 6 contiguous bits and
+represents the area where the DSCP will be stored in the connmark.  The
+state mask is a minimum 1 bit length mask that must not overlap with the
+dscpmask.  It represents a flag which is set when the DSCP has been
+stored in the conntrack mark. This is useful to implement a 'one shot'
+iptables based classification where the 'complicated' iptables rules are
+only run once to classify the connection on initial (egress) packet and
+subsequent packets are all marked/restored with the same DSCP.  A state
+mask of zero disables the setting of a status bit/s.
+
+example syntax with a suitably modified iptables user space application:
+
+iptables -A QOS_MARK_eth0 -t mangle -j CONNMARK --set-dscpmark 0xfc000000/0x01000000
+
+Would store the DSCP in the top 6 bits of the 32bit mark field, and use
+the LSB of the top byte as the 'DSCP has been stored' marker.
+
+|----0xFC----conntrack mark----000000---|
+| Bits 31-26 | bit 25 | bit24 |~~~ Bit 0|
+| DSCP       | unused | flag  |unused   |
+|-----------------------0x01---000000---|
+      ^                   ^
+      |                   |
+      ---|             Conditional flag
+         |             set this when dscp
+|-ip diffserv-|        stored in mark
+| 6 bits      |
+|-------------|
+
+an identically configured tc action to restore looks like:
+
+tc filter show dev eth0 ingress
+filter parent ffff: protocol all pref 10 u32 chain 0
+filter parent ffff: protocol all pref 10 u32 chain 0 fh 800: ht divisor 1
+filter parent ffff: protocol all pref 10 u32 chain 0 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1: not_in_hw
+  match 00000000/00000000 at 0
+	action order 1: ctinfo zone 0 pipe
+	 index 2 ref 1 bind 1 dscp 0xfc000000/0x1000000
+
+	action order 2: mirred (Egress Redirect to device ifb4eth0) stolen
+	index 1 ref 1 bind 1
+
+|----0xFC----conntrack mark----000000---|
+| Bits 31-26 | bit 25 | bit24 |~~~ Bit 0|
+| DSCP       | unused | flag  |unused   |
+|-----------------------0x01---000000---|
+      |                   |
+      |                   |
+      ---|             Conditional flag
+         v             only restore if set
+|-ip diffserv-|
+| 6 bits      |
+|-------------|
+
+Signed-off-by: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
+---
+ include/uapi/linux/netfilter/xt_connmark.h | 10 ++++
+ net/netfilter/xt_connmark.c                | 55 ++++++++++++++++++----
+ 2 files changed, 57 insertions(+), 8 deletions(-)
+
+--- a/include/uapi/linux/netfilter/xt_connmark.h
++++ b/include/uapi/linux/netfilter/xt_connmark.h
+@@ -15,6 +15,11 @@ enum {
+ };
+ 
+ enum {
++	XT_CONNMARK_VALUE =	(1 << 0),
++	XT_CONNMARK_DSCP = 	(1 << 1)
++};
++
++enum {
+ 	D_SHIFT_LEFT = 0,
+ 	D_SHIFT_RIGHT,
+ };
+@@ -29,6 +34,11 @@ struct xt_connmark_tginfo2 {
+ 	__u8 shift_dir, shift_bits, mode;
+ };
+ 
++struct xt_connmark_tginfo3 {
++	__u32 ctmark, ctmask, nfmask;
++	__u8 shift_dir, shift_bits, mode, func;
++};
++
+ struct xt_connmark_mtinfo1 {
+ 	__u32 mark, mask;
+ 	__u8 invert;
+--- a/net/netfilter/xt_connmark.c
++++ b/net/netfilter/xt_connmark.c
+@@ -24,13 +24,13 @@ MODULE_ALIAS("ipt_connmark");
+ MODULE_ALIAS("ip6t_connmark");
+ 
+ static unsigned int
+-connmark_tg_shift(struct sk_buff *skb, const struct xt_connmark_tginfo2 *info)
++connmark_tg_shift(struct sk_buff *skb, const struct xt_connmark_tginfo3 *info)
+ {
+ 	enum ip_conntrack_info ctinfo;
+ 	u_int32_t new_targetmark;
+ 	struct nf_conn *ct;
+ 	u_int32_t newmark;
+-	u_int32_t oldmark;
++	u_int8_t dscp;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (ct == NULL)
+@@ -38,13 +38,24 @@ connmark_tg_shift(struct sk_buff *skb, c
+ 
+ 	switch (info->mode) {
+ 	case XT_CONNMARK_SET:
+-		oldmark = READ_ONCE(ct->mark);
+-		newmark = (oldmark & ~info->ctmask) ^ info->ctmark;
+-		if (info->shift_dir == D_SHIFT_RIGHT)
+-			newmark >>= info->shift_bits;
+-		else
+-			newmark <<= info->shift_bits;
++		newmark = READ_ONCE(ct->mark);
++		if (info->func & XT_CONNMARK_VALUE) {
++			newmark = (newmark & ~info->ctmask) ^ info->ctmark;
++			if (info->shift_dir == D_SHIFT_RIGHT)
++				newmark >>= info->shift_bits;
++			else
++				newmark <<= info->shift_bits;
++		} else if (info->func & XT_CONNMARK_DSCP) {
++			if (skb->protocol == htons(ETH_P_IP))
++				dscp = ipv4_get_dsfield(ip_hdr(skb)) >> 2;
++			else if (skb->protocol == htons(ETH_P_IPV6))
++				dscp = ipv6_get_dsfield(ipv6_hdr(skb)) >> 2;
++			else	/* protocol doesn't have diffserv */
++				break;
+ 
++			newmark = (newmark & ~info->ctmark) |
++				  (info->ctmask | (dscp << info->shift_bits));
++		}
+ 		if (READ_ONCE(ct->mark) != newmark) {
+ 			WRITE_ONCE(ct->mark, newmark);
+ 			nf_conntrack_event_cache(IPCT_MARK, ct);
+@@ -83,20 +94,36 @@ static unsigned int
+ connmark_tg(struct sk_buff *skb, const struct xt_action_param *par)
+ {
+ 	const struct xt_connmark_tginfo1 *info = par->targinfo;
+-	const struct xt_connmark_tginfo2 info2 = {
++	const struct xt_connmark_tginfo3 info3 = {
+ 		.ctmark	= info->ctmark,
+ 		.ctmask	= info->ctmask,
+ 		.nfmask	= info->nfmask,
+ 		.mode	= info->mode,
++		.func	= XT_CONNMARK_VALUE
+ 	};
+ 
+-	return connmark_tg_shift(skb, &info2);
++	return connmark_tg_shift(skb, &info3);
+ }
+ 
+ static unsigned int
+ connmark_tg_v2(struct sk_buff *skb, const struct xt_action_param *par)
+ {
+ 	const struct xt_connmark_tginfo2 *info = par->targinfo;
++	const struct xt_connmark_tginfo3 info3 = {
++		.ctmark	= info->ctmark,
++		.ctmask	= info->ctmask,
++		.nfmask	= info->nfmask,
++		.mode	= info->mode,
++		.func	= XT_CONNMARK_VALUE
++	};
++
++	return connmark_tg_shift(skb, &info3);
++}
++
++static unsigned int
++connmark_tg_v3(struct sk_buff *skb, const struct xt_action_param *par)
++{
++	const struct xt_connmark_tginfo3 *info = par->targinfo;
+ 
+ 	return connmark_tg_shift(skb, info);
+ }
+@@ -168,6 +195,16 @@ static struct xt_target connmark_tg_reg[
+ 		.destroy        = connmark_tg_destroy,
+ 		.me             = THIS_MODULE,
+ 	},
++	{
++		.name           = "CONNMARK",
++		.revision       = 3,
++		.family         = NFPROTO_IPV4,
++		.checkentry     = connmark_tg_check,
++		.target         = connmark_tg_v3,
++		.targetsize     = sizeof(struct xt_connmark_tginfo3),
++		.destroy        = connmark_tg_destroy,
++		.me             = THIS_MODULE,
++	},
+ #if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)
+ 	{
+ 		.name           = "CONNMARK",
+@@ -189,6 +226,16 @@ static struct xt_target connmark_tg_reg[
+ 		.destroy        = connmark_tg_destroy,
+ 		.me             = THIS_MODULE,
+ 	},
++	{
++		.name           = "CONNMARK",
++		.revision       = 3,
++		.family         = NFPROTO_IPV6,
++		.checkentry     = connmark_tg_check,
++		.target         = connmark_tg_v3,
++		.targetsize     = sizeof(struct xt_connmark_tginfo3),
++		.destroy        = connmark_tg_destroy,
++		.me             = THIS_MODULE,
++	},
+ #endif
+ };
+ 
diff --git a/target/linux/generic/hack-6.12/650-netfilter-add-xt_FLOWOFFLOAD-target.patch b/target/linux/generic/hack-6.12/650-netfilter-add-xt_FLOWOFFLOAD-target.patch
new file mode 100644
index 0000000000..53093daa36
--- /dev/null
+++ b/target/linux/generic/hack-6.12/650-netfilter-add-xt_FLOWOFFLOAD-target.patch
@@ -0,0 +1,812 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 20 Feb 2018 15:56:02 +0100
+Subject: [PATCH] netfilter: add xt_FLOWOFFLOAD target
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ create mode 100644 net/netfilter/xt_OFFLOAD.c
+
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -729,7 +729,6 @@ config NF_FLOW_TABLE
+ 	tristate "Netfilter flow table module"
+ 	depends on NETFILTER_INGRESS
+ 	depends on NF_CONNTRACK
+-	depends on NF_TABLES
+ 	help
+ 	  This option adds the flow table core infrastructure.
+ 
+@@ -1025,6 +1024,15 @@ config NETFILTER_XT_TARGET_NOTRACK
+ 	depends on NETFILTER_ADVANCED
+ 	select NETFILTER_XT_TARGET_CT
+ 
++config NETFILTER_XT_TARGET_FLOWOFFLOAD
++	tristate '"FLOWOFFLOAD" target support'
++	depends on NF_FLOW_TABLE
++	depends on NETFILTER_INGRESS
++	help
++	  This option adds a `FLOWOFFLOAD' target, which uses the nf_flow_offload
++	  module to speed up processing of packets by bypassing the usual
++	  netfilter chains
++
+ config NETFILTER_XT_TARGET_RATEEST
+ 	tristate '"RATEEST" target support'
+ 	depends on NETFILTER_ADVANCED
+--- a/net/netfilter/Makefile
++++ b/net/netfilter/Makefile
+@@ -168,6 +168,7 @@ obj-$(CONFIG_NETFILTER_XT_TARGET_CLASSIF
+ obj-$(CONFIG_NETFILTER_XT_TARGET_CONNSECMARK) += xt_CONNSECMARK.o
+ obj-$(CONFIG_NETFILTER_XT_TARGET_CT) += xt_CT.o
+ obj-$(CONFIG_NETFILTER_XT_TARGET_DSCP) += xt_DSCP.o
++obj-$(CONFIG_NETFILTER_XT_TARGET_FLOWOFFLOAD) += xt_FLOWOFFLOAD.o
+ obj-$(CONFIG_NETFILTER_XT_TARGET_HL) += xt_HL.o
+ obj-$(CONFIG_NETFILTER_XT_TARGET_HMARK) += xt_HMARK.o
+ obj-$(CONFIG_NETFILTER_XT_TARGET_LED) += xt_LED.o
+--- /dev/null
++++ b/net/netfilter/xt_FLOWOFFLOAD.c
+@@ -0,0 +1,703 @@
++/*
++ * Copyright (C) 2018-2021 Felix Fietkau <nbd@nbd.name>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/netfilter.h>
++#include <linux/netfilter/xt_FLOWOFFLOAD.h>
++#include <linux/if_vlan.h>
++#include <net/ip.h>
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_extend.h>
++#include <net/netfilter/nf_conntrack_helper.h>
++#include <net/netfilter/nf_flow_table.h>
++
++struct xt_flowoffload_hook {
++	struct hlist_node list;
++	struct nf_hook_ops ops;
++	struct net *net;
++	bool registered;
++	bool used;
++};
++
++struct xt_flowoffload_table {
++	struct nf_flowtable ft;
++	struct hlist_head hooks;
++	struct delayed_work work;
++};
++
++struct nf_forward_info {
++	const struct net_device *indev;
++	const struct net_device *outdev;
++	const struct net_device *hw_outdev;
++	struct id {
++		__u16	id;
++		__be16	proto;
++	} encap[NF_FLOW_TABLE_ENCAP_MAX];
++	u8 num_encaps;
++	u8 ingress_vlans;
++	u8 h_source[ETH_ALEN];
++	u8 h_dest[ETH_ALEN];
++	enum flow_offload_xmit_type xmit_type;
++};
++
++static DEFINE_SPINLOCK(hooks_lock);
++
++struct xt_flowoffload_table flowtable[2];
++
++static unsigned int
++xt_flowoffload_net_hook(void *priv, struct sk_buff *skb,
++			const struct nf_hook_state *state)
++{
++	struct vlan_ethhdr *veth;
++	__be16 proto;
++
++	switch (skb->protocol) {
++	case htons(ETH_P_8021Q):
++		veth = (struct vlan_ethhdr *)skb_mac_header(skb);
++		proto = veth->h_vlan_encapsulated_proto;
++		break;
++	case htons(ETH_P_PPP_SES):
++		if (!nf_flow_pppoe_proto(skb, &proto))
++			return NF_ACCEPT;
++		break;
++	default:
++		proto = skb->protocol;
++		break;
++	}
++
++	switch (proto) {
++	case htons(ETH_P_IP):
++		return nf_flow_offload_ip_hook(priv, skb, state);
++	case htons(ETH_P_IPV6):
++		return nf_flow_offload_ipv6_hook(priv, skb, state);
++	}
++
++	return NF_ACCEPT;
++}
++
++static int
++xt_flowoffload_create_hook(struct xt_flowoffload_table *table,
++			   struct net_device *dev)
++{
++	struct xt_flowoffload_hook *hook;
++	struct nf_hook_ops *ops;
++
++	hook = kzalloc(sizeof(*hook), GFP_ATOMIC);
++	if (!hook)
++		return -ENOMEM;
++
++	ops = &hook->ops;
++	ops->pf = NFPROTO_NETDEV;
++	ops->hooknum = NF_NETDEV_INGRESS;
++	ops->priority = 10;
++	ops->priv = &table->ft;
++	ops->hook = xt_flowoffload_net_hook;
++	ops->dev = dev;
++
++	hlist_add_head(&hook->list, &table->hooks);
++	mod_delayed_work(system_power_efficient_wq, &table->work, 0);
++
++	return 0;
++}
++
++static struct xt_flowoffload_hook *
++flow_offload_lookup_hook(struct xt_flowoffload_table *table,
++			 struct net_device *dev)
++{
++	struct xt_flowoffload_hook *hook;
++
++	hlist_for_each_entry(hook, &table->hooks, list) {
++		if (hook->ops.dev == dev)
++			return hook;
++	}
++
++	return NULL;
++}
++
++static void
++xt_flowoffload_check_device(struct xt_flowoffload_table *table,
++			    struct net_device *dev)
++{
++	struct xt_flowoffload_hook *hook;
++
++	if (!dev)
++		return;
++
++	spin_lock_bh(&hooks_lock);
++	hook = flow_offload_lookup_hook(table, dev);
++	if (hook)
++		hook->used = true;
++	else
++		xt_flowoffload_create_hook(table, dev);
++	spin_unlock_bh(&hooks_lock);
++}
++
++static void
++xt_flowoffload_register_hooks(struct xt_flowoffload_table *table)
++{
++	struct xt_flowoffload_hook *hook;
++
++restart:
++	hlist_for_each_entry(hook, &table->hooks, list) {
++		if (hook->registered)
++			continue;
++
++		hook->registered = true;
++		hook->net = dev_net(hook->ops.dev);
++		spin_unlock_bh(&hooks_lock);
++		nf_register_net_hook(hook->net, &hook->ops);
++		if (table->ft.flags & NF_FLOWTABLE_HW_OFFLOAD)
++			table->ft.type->setup(&table->ft, hook->ops.dev,
++					      FLOW_BLOCK_BIND);
++		spin_lock_bh(&hooks_lock);
++		goto restart;
++	}
++
++}
++
++static bool
++xt_flowoffload_cleanup_hooks(struct xt_flowoffload_table *table)
++{
++	struct xt_flowoffload_hook *hook;
++	bool active = false;
++
++restart:
++	spin_lock_bh(&hooks_lock);
++	hlist_for_each_entry(hook, &table->hooks, list) {
++		if (hook->used || !hook->registered) {
++			active = true;
++			continue;
++		}
++
++		hlist_del(&hook->list);
++		spin_unlock_bh(&hooks_lock);
++		if (table->ft.flags & NF_FLOWTABLE_HW_OFFLOAD)
++			table->ft.type->setup(&table->ft, hook->ops.dev,
++					      FLOW_BLOCK_UNBIND);
++		nf_unregister_net_hook(hook->net, &hook->ops);
++		kfree(hook);
++		goto restart;
++	}
++	spin_unlock_bh(&hooks_lock);
++
++	return active;
++}
++
++static void
++xt_flowoffload_check_hook(struct nf_flowtable *flowtable,
++			  struct flow_offload *flow, void *data)
++{
++	struct xt_flowoffload_table *table;
++	struct flow_offload_tuple *tuple0 = &flow->tuplehash[0].tuple;
++	struct flow_offload_tuple *tuple1 = &flow->tuplehash[1].tuple;
++	struct xt_flowoffload_hook *hook;
++
++	table = container_of(flowtable, struct xt_flowoffload_table, ft);
++
++	spin_lock_bh(&hooks_lock);
++	hlist_for_each_entry(hook, &table->hooks, list) {
++		if (hook->ops.dev->ifindex != tuple0->iifidx &&
++		    hook->ops.dev->ifindex != tuple1->iifidx)
++			continue;
++
++		hook->used = true;
++	}
++	spin_unlock_bh(&hooks_lock);
++}
++
++static void
++xt_flowoffload_hook_work(struct work_struct *work)
++{
++	struct xt_flowoffload_table *table;
++	struct xt_flowoffload_hook *hook;
++	int err;
++
++	table = container_of(work, struct xt_flowoffload_table, work.work);
++
++	spin_lock_bh(&hooks_lock);
++	xt_flowoffload_register_hooks(table);
++	hlist_for_each_entry(hook, &table->hooks, list)
++		hook->used = false;
++	spin_unlock_bh(&hooks_lock);
++
++	err = nf_flow_table_iterate(&table->ft, xt_flowoffload_check_hook,
++				    NULL);
++	if (err && err != -EAGAIN)
++		goto out;
++
++	if (!xt_flowoffload_cleanup_hooks(table))
++		return;
++
++out:
++	queue_delayed_work(system_power_efficient_wq, &table->work, HZ);
++}
++
++static bool
++xt_flowoffload_skip(struct sk_buff *skb, int family)
++{
++	if (skb_sec_path(skb))
++		return true;
++
++	if (family == NFPROTO_IPV4) {
++		const struct ip_options *opt = &(IPCB(skb)->opt);
++
++		if (unlikely(opt->optlen))
++			return true;
++	}
++
++	return false;
++}
++
++static enum flow_offload_xmit_type nf_xmit_type(struct dst_entry *dst)
++{
++	if (dst_xfrm(dst))
++		return FLOW_OFFLOAD_XMIT_XFRM;
++
++	return FLOW_OFFLOAD_XMIT_NEIGH;
++}
++
++static void nf_default_forward_path(struct nf_flow_route *route,
++				    struct dst_entry *dst_cache,
++				    enum ip_conntrack_dir dir,
++				    struct net_device **dev)
++{
++	dev[!dir] = dst_cache->dev;
++	route->tuple[!dir].in.ifindex	= dst_cache->dev->ifindex;
++	route->tuple[dir].dst		= dst_cache;
++	route->tuple[dir].xmit_type	= nf_xmit_type(dst_cache);
++}
++
++static bool nf_is_valid_ether_device(const struct net_device *dev)
++{
++	if (!dev || (dev->flags & IFF_LOOPBACK) || dev->type != ARPHRD_ETHER ||
++	    dev->addr_len != ETH_ALEN || !is_valid_ether_addr(dev->dev_addr))
++		return false;
++
++	return true;
++}
++
++static void nf_dev_path_info(const struct net_device_path_stack *stack,
++			     struct nf_forward_info *info,
++			     unsigned char *ha)
++{
++	const struct net_device_path *path;
++	int i;
++
++	memcpy(info->h_dest, ha, ETH_ALEN);
++
++	for (i = 0; i < stack->num_paths; i++) {
++		path = &stack->path[i];
++		switch (path->type) {
++		case DEV_PATH_ETHERNET:
++		case DEV_PATH_DSA:
++		case DEV_PATH_VLAN:
++		case DEV_PATH_PPPOE:
++			info->indev = path->dev;
++			if (is_zero_ether_addr(info->h_source))
++				memcpy(info->h_source, path->dev->dev_addr, ETH_ALEN);
++
++			if (path->type == DEV_PATH_ETHERNET)
++				break;
++			if (path->type == DEV_PATH_DSA) {
++				i = stack->num_paths;
++				break;
++			}
++
++			/* DEV_PATH_VLAN and DEV_PATH_PPPOE */
++			if (info->num_encaps >= NF_FLOW_TABLE_ENCAP_MAX) {
++				info->indev = NULL;
++				break;
++			}
++			if (!info->outdev)
++				info->outdev = path->dev;
++			info->encap[info->num_encaps].id = path->encap.id;
++			info->encap[info->num_encaps].proto = path->encap.proto;
++			info->num_encaps++;
++			if (path->type == DEV_PATH_PPPOE)
++				memcpy(info->h_dest, path->encap.h_dest, ETH_ALEN);
++			break;
++		case DEV_PATH_BRIDGE:
++			if (is_zero_ether_addr(info->h_source))
++				memcpy(info->h_source, path->dev->dev_addr, ETH_ALEN);
++
++			switch (path->bridge.vlan_mode) {
++			case DEV_PATH_BR_VLAN_UNTAG_HW:
++				info->ingress_vlans |= BIT(info->num_encaps - 1);
++				break;
++			case DEV_PATH_BR_VLAN_TAG:
++				info->encap[info->num_encaps].id = path->bridge.vlan_id;
++				info->encap[info->num_encaps].proto = path->bridge.vlan_proto;
++				info->num_encaps++;
++				break;
++			case DEV_PATH_BR_VLAN_UNTAG:
++				info->num_encaps--;
++				break;
++			case DEV_PATH_BR_VLAN_KEEP:
++				break;
++			}
++			break;
++		default:
++			info->indev = NULL;
++			break;
++		}
++	}
++	if (!info->outdev)
++		info->outdev = info->indev;
++
++	info->hw_outdev = info->indev;
++
++	if (nf_is_valid_ether_device(info->indev))
++		info->xmit_type = FLOW_OFFLOAD_XMIT_DIRECT;
++}
++
++static int nf_dev_fill_forward_path(const struct nf_flow_route *route,
++				     const struct dst_entry *dst_cache,
++				     const struct nf_conn *ct,
++				     enum ip_conntrack_dir dir, u8 *ha,
++				     struct net_device_path_stack *stack)
++{
++	const void *daddr = &ct->tuplehash[!dir].tuple.src.u3;
++	struct net_device *dev = dst_cache->dev;
++	struct neighbour *n;
++	u8 nud_state;
++
++	if (!nf_is_valid_ether_device(dev))
++		goto out;
++
++	n = dst_neigh_lookup(dst_cache, daddr);
++	if (!n)
++		return -1;
++
++	read_lock_bh(&n->lock);
++	nud_state = n->nud_state;
++	ether_addr_copy(ha, n->ha);
++	read_unlock_bh(&n->lock);
++	neigh_release(n);
++
++	if (!(nud_state & NUD_VALID))
++		return -1;
++
++out:
++	return dev_fill_forward_path(dev, ha, stack);
++}
++
++static void nf_dev_forward_path(struct nf_flow_route *route,
++				const struct nf_conn *ct,
++				enum ip_conntrack_dir dir,
++				struct net_device **devs)
++{
++	const struct dst_entry *dst = route->tuple[dir].dst;
++	struct net_device_path_stack stack;
++	struct nf_forward_info info = {};
++	unsigned char ha[ETH_ALEN];
++	int i;
++
++	if (nf_dev_fill_forward_path(route, dst, ct, dir, ha, &stack) >= 0)
++		nf_dev_path_info(&stack, &info, ha);
++
++	devs[!dir] = (struct net_device *)info.indev;
++	if (!info.indev)
++		return;
++
++	route->tuple[!dir].in.ifindex = info.indev->ifindex;
++	for (i = 0; i < info.num_encaps; i++) {
++		route->tuple[!dir].in.encap[i].id = info.encap[i].id;
++		route->tuple[!dir].in.encap[i].proto = info.encap[i].proto;
++	}
++	route->tuple[!dir].in.num_encaps = info.num_encaps;
++	route->tuple[!dir].in.ingress_vlans = info.ingress_vlans;
++
++	if (info.xmit_type == FLOW_OFFLOAD_XMIT_DIRECT) {
++		memcpy(route->tuple[dir].out.h_source, info.h_source, ETH_ALEN);
++		memcpy(route->tuple[dir].out.h_dest, info.h_dest, ETH_ALEN);
++		route->tuple[dir].out.ifindex = info.outdev->ifindex;
++		route->tuple[dir].out.hw_ifindex = info.hw_outdev->ifindex;
++		route->tuple[dir].xmit_type = info.xmit_type;
++	}
++}
++
++static int
++xt_flowoffload_route(struct sk_buff *skb, const struct nf_conn *ct,
++		     const struct xt_action_param *par,
++		     struct nf_flow_route *route, enum ip_conntrack_dir dir,
++		     struct net_device **devs)
++{
++	struct dst_entry *this_dst = skb_dst(skb);
++	struct dst_entry *other_dst = NULL;
++	struct flowi fl;
++
++	memset(&fl, 0, sizeof(fl));
++	switch (xt_family(par)) {
++	case NFPROTO_IPV4:
++		fl.u.ip4.daddr = ct->tuplehash[dir].tuple.src.u3.ip;
++		fl.u.ip4.flowi4_oif = xt_in(par)->ifindex;
++		break;
++	case NFPROTO_IPV6:
++		fl.u.ip6.saddr = ct->tuplehash[!dir].tuple.dst.u3.in6;
++		fl.u.ip6.daddr = ct->tuplehash[dir].tuple.src.u3.in6;
++		fl.u.ip6.flowi6_oif = xt_in(par)->ifindex;
++		break;
++	}
++
++	if (!dst_hold_safe(this_dst))
++		return -ENOENT;
++
++	nf_route(xt_net(par), &other_dst, &fl, false, xt_family(par));
++	if (!other_dst) {
++		dst_release(this_dst);
++		return -ENOENT;
++	}
++
++	nf_default_forward_path(route, this_dst, dir, devs);
++	nf_default_forward_path(route, other_dst, !dir, devs);
++
++	if (route->tuple[dir].xmit_type	== FLOW_OFFLOAD_XMIT_NEIGH &&
++	    route->tuple[!dir].xmit_type == FLOW_OFFLOAD_XMIT_NEIGH) {
++		nf_dev_forward_path(route, ct, dir, devs);
++		nf_dev_forward_path(route, ct, !dir, devs);
++	}
++
++	return 0;
++}
++
++static unsigned int
++flowoffload_tg(struct sk_buff *skb, const struct xt_action_param *par)
++{
++	struct xt_flowoffload_table *table;
++	const struct xt_flowoffload_target_info *info = par->targinfo;
++	struct tcphdr _tcph, *tcph = NULL;
++	enum ip_conntrack_info ctinfo;
++	enum ip_conntrack_dir dir;
++	struct nf_flow_route route = {};
++	struct flow_offload *flow = NULL;
++	struct net_device *devs[2] = {};
++	struct nf_conn *ct;
++	struct net *net;
++
++	if (xt_flowoffload_skip(skb, xt_family(par)))
++		return XT_CONTINUE;
++
++	ct = nf_ct_get(skb, &ctinfo);
++	if (ct == NULL)
++		return XT_CONTINUE;
++
++	switch (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum) {
++	case IPPROTO_TCP:
++		if (ct->proto.tcp.state != TCP_CONNTRACK_ESTABLISHED)
++			return XT_CONTINUE;
++
++		tcph = skb_header_pointer(skb, par->thoff,
++					  sizeof(_tcph), &_tcph);
++		if (unlikely(!tcph || tcph->fin || tcph->rst))
++			return XT_CONTINUE;
++		break;
++	case IPPROTO_UDP:
++		break;
++	default:
++		return XT_CONTINUE;
++	}
++
++	if (nf_ct_ext_exist(ct, NF_CT_EXT_HELPER) ||
++	    ct->status & (IPS_SEQ_ADJUST | IPS_NAT_CLASH))
++		return XT_CONTINUE;
++
++	if (!nf_ct_is_confirmed(ct))
++		return XT_CONTINUE;
++
++	dir = CTINFO2DIR(ctinfo);
++
++	devs[dir] = xt_out(par);
++	devs[!dir] = xt_in(par);
++
++	if (!devs[dir] || !devs[!dir])
++		return XT_CONTINUE;
++
++	if (test_and_set_bit(IPS_OFFLOAD_BIT, &ct->status))
++		return XT_CONTINUE;
++
++	if (xt_flowoffload_route(skb, ct, par, &route, dir, devs) < 0)
++		goto err_flow_route;
++
++	flow = flow_offload_alloc(ct);
++	if (!flow)
++		goto err_flow_alloc;
++
++	flow_offload_route_init(flow, &route);
++
++	if (tcph) {
++		ct->proto.tcp.seen[0].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;
++		ct->proto.tcp.seen[1].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;
++	}
++
++	table = &flowtable[!!(info->flags & XT_FLOWOFFLOAD_HW)];
++
++	net = read_pnet(&table->ft.net);
++	if (!net)
++		write_pnet(&table->ft.net, xt_net(par));
++
++	__set_bit(NF_FLOW_HW_BIDIRECTIONAL, &flow->flags);
++	if (flow_offload_add(&table->ft, flow) < 0)
++		goto err_flow_add;
++
++	xt_flowoffload_check_device(table, devs[0]);
++	xt_flowoffload_check_device(table, devs[1]);
++
++	return XT_CONTINUE;
++
++err_flow_add:
++	flow_offload_free(flow);
++err_flow_alloc:
++	dst_release(route.tuple[dir].dst);
++	dst_release(route.tuple[!dir].dst);
++err_flow_route:
++	clear_bit(IPS_OFFLOAD_BIT, &ct->status);
++
++	return XT_CONTINUE;
++}
++
++static int flowoffload_chk(const struct xt_tgchk_param *par)
++{
++	struct xt_flowoffload_target_info *info = par->targinfo;
++
++	if (info->flags & ~XT_FLOWOFFLOAD_MASK)
++		return -EINVAL;
++
++	return 0;
++}
++
++static struct xt_target offload_tg_reg __read_mostly = {
++	.family		= NFPROTO_UNSPEC,
++	.name		= "FLOWOFFLOAD",
++	.revision	= 0,
++	.targetsize	= sizeof(struct xt_flowoffload_target_info),
++	.usersize	= sizeof(struct xt_flowoffload_target_info),
++	.checkentry	= flowoffload_chk,
++	.target		= flowoffload_tg,
++	.me		= THIS_MODULE,
++};
++
++static int flow_offload_netdev_event(struct notifier_block *this,
++				     unsigned long event, void *ptr)
++{
++	struct xt_flowoffload_hook *hook0, *hook1;
++	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
++
++	if (event != NETDEV_UNREGISTER)
++		return NOTIFY_DONE;
++
++	spin_lock_bh(&hooks_lock);
++	hook0 = flow_offload_lookup_hook(&flowtable[0], dev);
++	if (hook0)
++		hlist_del(&hook0->list);
++
++	hook1 = flow_offload_lookup_hook(&flowtable[1], dev);
++	if (hook1)
++		hlist_del(&hook1->list);
++	spin_unlock_bh(&hooks_lock);
++
++	if (hook0) {
++		nf_unregister_net_hook(hook0->net, &hook0->ops);
++		kfree(hook0);
++	}
++
++	if (hook1) {
++		nf_unregister_net_hook(hook1->net, &hook1->ops);
++		kfree(hook1);
++	}
++
++	nf_flow_table_cleanup(dev);
++
++	return NOTIFY_DONE;
++}
++
++static struct notifier_block flow_offload_netdev_notifier = {
++	.notifier_call	= flow_offload_netdev_event,
++};
++
++static int nf_flow_rule_route_inet(struct net *net,
++				   struct flow_offload *flow,
++				   enum flow_offload_tuple_dir dir,
++				   struct nf_flow_rule *flow_rule)
++{
++	const struct flow_offload_tuple *flow_tuple = &flow->tuplehash[dir].tuple;
++	int err;
++
++	switch (flow_tuple->l3proto) {
++	case NFPROTO_IPV4:
++		err = nf_flow_rule_route_ipv4(net, flow, dir, flow_rule);
++		break;
++	case NFPROTO_IPV6:
++		err = nf_flow_rule_route_ipv6(net, flow, dir, flow_rule);
++		break;
++	default:
++		err = -1;
++		break;
++	}
++
++	return err;
++}
++
++static struct nf_flowtable_type flowtable_inet = {
++	.family		= NFPROTO_INET,
++	.init		= nf_flow_table_init,
++	.setup		= nf_flow_table_offload_setup,
++	.action		= nf_flow_rule_route_inet,
++	.free		= nf_flow_table_free,
++	.hook		= xt_flowoffload_net_hook,
++	.owner		= THIS_MODULE,
++};
++
++static int init_flowtable(struct xt_flowoffload_table *tbl)
++{
++	INIT_DELAYED_WORK(&tbl->work, xt_flowoffload_hook_work);
++	tbl->ft.type = &flowtable_inet;
++	tbl->ft.flags = NF_FLOWTABLE_COUNTER;
++
++	return nf_flow_table_init(&tbl->ft);
++}
++
++static int __init xt_flowoffload_tg_init(void)
++{
++	int ret;
++
++	register_netdevice_notifier(&flow_offload_netdev_notifier);
++
++	ret = init_flowtable(&flowtable[0]);
++	if (ret)
++		return ret;
++
++	ret = init_flowtable(&flowtable[1]);
++	if (ret)
++		goto cleanup;
++
++	flowtable[1].ft.flags |= NF_FLOWTABLE_HW_OFFLOAD;
++
++	ret = xt_register_target(&offload_tg_reg);
++	if (ret)
++		goto cleanup2;
++
++	return 0;
++
++cleanup2:
++	nf_flow_table_free(&flowtable[1].ft);
++cleanup:
++	nf_flow_table_free(&flowtable[0].ft);
++	return ret;
++}
++
++static void __exit xt_flowoffload_tg_exit(void)
++{
++	xt_unregister_target(&offload_tg_reg);
++	unregister_netdevice_notifier(&flow_offload_netdev_notifier);
++	nf_flow_table_free(&flowtable[0].ft);
++	nf_flow_table_free(&flowtable[1].ft);
++}
++
++MODULE_LICENSE("GPL");
++module_init(xt_flowoffload_tg_init);
++module_exit(xt_flowoffload_tg_exit);
+--- a/net/netfilter/nf_flow_table_core.c
++++ b/net/netfilter/nf_flow_table_core.c
+@@ -7,7 +7,6 @@
+ #include <linux/netdevice.h>
+ #include <net/ip.h>
+ #include <net/ip6_route.h>
+-#include <net/netfilter/nf_tables.h>
+ #include <net/netfilter/nf_flow_table.h>
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+@@ -373,8 +372,7 @@ flow_offload_lookup(struct nf_flowtable
+ }
+ EXPORT_SYMBOL_GPL(flow_offload_lookup);
+ 
+-static int
+-nf_flow_table_iterate(struct nf_flowtable *flow_table,
++int nf_flow_table_iterate(struct nf_flowtable *flow_table,
+ 		      void (*iter)(struct nf_flowtable *flowtable,
+ 				   struct flow_offload *flow, void *data),
+ 		      void *data)
+@@ -435,6 +433,7 @@ static void nf_flow_offload_gc_step(stru
+ 		nf_flow_offload_stats(flow_table, flow);
+ 	}
+ }
++EXPORT_SYMBOL_GPL(nf_flow_table_iterate);
+ 
+ void nf_flow_table_gc_run(struct nf_flowtable *flow_table)
+ {
+--- /dev/null
++++ b/include/uapi/linux/netfilter/xt_FLOWOFFLOAD.h
+@@ -0,0 +1,17 @@
++/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
++#ifndef _XT_FLOWOFFLOAD_H
++#define _XT_FLOWOFFLOAD_H
++
++#include <linux/types.h>
++
++enum {
++	XT_FLOWOFFLOAD_HW	= 1 << 0,
++
++	XT_FLOWOFFLOAD_MASK	= XT_FLOWOFFLOAD_HW
++};
++
++struct xt_flowoffload_target_info {
++	__u32 flags;
++};
++
++#endif /* _XT_FLOWOFFLOAD_H */
+--- a/include/net/netfilter/nf_flow_table.h
++++ b/include/net/netfilter/nf_flow_table.h
+@@ -294,6 +294,11 @@ void nf_flow_table_free(struct nf_flowta
+ 
+ void flow_offload_teardown(struct flow_offload *flow);
+ 
++int nf_flow_table_iterate(struct nf_flowtable *flow_table,
++                      void (*iter)(struct nf_flowtable *flowtable,
++                                   struct flow_offload *flow, void *data),
++                      void *data);
++
+ void nf_flow_snat_port(const struct flow_offload *flow,
+ 		       struct sk_buff *skb, unsigned int thoff,
+ 		       u8 protocol, enum flow_offload_tuple_dir dir);
diff --git a/target/linux/generic/hack-6.12/651-wireless_mesh_header.patch b/target/linux/generic/hack-6.12/651-wireless_mesh_header.patch
new file mode 100644
index 0000000000..d3f85ea1d1
--- /dev/null
+++ b/target/linux/generic/hack-6.12/651-wireless_mesh_header.patch
@@ -0,0 +1,24 @@
+From 6d3bc769657b0ee7c7506dad9911111c4226a7ea Mon Sep 17 00:00:00 2001
+From: Imre Kaloz <kaloz@openwrt.org>
+Date: Fri, 7 Jul 2017 17:21:05 +0200
+Subject: mac80211: increase wireless mesh header size
+
+lede-commit 3d4466cfd8f75f717efdb1f96fdde3c70d865fc1
+Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
+---
+ include/linux/netdevice.h | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -159,8 +159,8 @@ static inline bool dev_xmit_complete(int
+ 
+ #if defined(CONFIG_HYPERV_NET)
+ # define LL_MAX_HEADER 128
+-#elif defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)
+-# if defined(CONFIG_MAC80211_MESH)
++#elif defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25) || 1
++# if defined(CONFIG_MAC80211_MESH) || 1
+ #  define LL_MAX_HEADER 128
+ # else
+ #  define LL_MAX_HEADER 96
diff --git a/target/linux/generic/hack-6.12/660-fq_codel_defaults.patch b/target/linux/generic/hack-6.12/660-fq_codel_defaults.patch
new file mode 100644
index 0000000000..4d7b01d243
--- /dev/null
+++ b/target/linux/generic/hack-6.12/660-fq_codel_defaults.patch
@@ -0,0 +1,27 @@
+From a6ccb238939b25851474a279b20367fd24a0e816 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 7 Jul 2017 17:21:53 +0200
+Subject:  hack: net: fq_codel: tune defaults for small devices
+
+Assume that x86_64 devices always have a big memory and do not need this 
+optimization compared to devices with only 32 MB or 64 MB RAM.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ net/sched/sch_fq_codel.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -472,7 +472,11 @@ static int fq_codel_init(struct Qdisc *s
+ 
+ 	sch->limit = 10*1024;
+ 	q->flows_cnt = 1024;
++#ifdef CONFIG_X86_64
+ 	q->memory_limit = 32 << 20; /* 32 MBytes */
++#else
++	q->memory_limit = 4 << 20; /* 4 MBytes */
++#endif
+ 	q->drop_batch_size = 64;
+ 	q->quantum = psched_mtu(qdisc_dev(sch));
+ 	INIT_LIST_HEAD(&q->new_flows);
diff --git a/target/linux/generic/hack-6.12/661-kernel-ct-size-the-hashtable-more-adequately.patch b/target/linux/generic/hack-6.12/661-kernel-ct-size-the-hashtable-more-adequately.patch
new file mode 100644
index 0000000000..f548cdb9b5
--- /dev/null
+++ b/target/linux/generic/hack-6.12/661-kernel-ct-size-the-hashtable-more-adequately.patch
@@ -0,0 +1,25 @@
+From 804fbb3f2ec9283f7b778e057a68bfff440a0be6 Mon Sep 17 00:00:00 2001
+From: Rui Salvaterra <rsalvaterra@gmail.com>
+Date: Wed, 30 Mar 2022 22:51:55 +0100
+Subject: [PATCH] kernel: ct: size the hashtable more adequately
+
+To set the default size of the connection tracking hash table, a divider of
+16384 becomes inadequate for a router handling lots of connections. Divide by
+2048 instead, making the default size scale better with the available RAM.
+
+Signed-off-by: Rui Salvaterra <rsalvaterra@gmail.com>
+---
+ net/netfilter/nf_conntrack_core.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -2634,7 +2634,7 @@ int nf_conntrack_init_start(void)
+ 
+ 	if (!nf_conntrack_htable_size) {
+ 		nf_conntrack_htable_size
+-			= (((nr_pages << PAGE_SHIFT) / 16384)
++			= (((nr_pages << PAGE_SHIFT) / 2048)
+ 			   / sizeof(struct hlist_head));
+ 		if (BITS_PER_LONG >= 64 &&
+ 		    nr_pages > (4 * (1024 * 1024 * 1024 / PAGE_SIZE)))
diff --git a/target/linux/generic/hack-6.12/700-swconfig_switch_drivers.patch b/target/linux/generic/hack-6.12/700-swconfig_switch_drivers.patch
new file mode 100644
index 0000000000..4591a42f78
--- /dev/null
+++ b/target/linux/generic/hack-6.12/700-swconfig_switch_drivers.patch
@@ -0,0 +1,131 @@
+From 36e516290611e613aa92996cb4339561452695b4 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 7 Jul 2017 17:24:23 +0200
+Subject: net: swconfig: adds openwrt switch layer
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/net/phy/Kconfig   | 83 +++++++++++++++++++++++++++++++++++++++++++++++
+ drivers/net/phy/Makefile  | 15 +++++++++
+ include/uapi/linux/Kbuild |  1 +
+ 3 files changed, 99 insertions(+)
+
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -77,6 +77,80 @@ config SFP
+ 	depends on HWMON || HWMON=n
+ 	select MDIO_I2C
+ 
++comment "Switch configuration API + drivers"
++
++config SWCONFIG
++	tristate "Switch configuration API"
++	help
++	  Switch configuration API using netlink. This allows
++	  you to configure the VLAN features of certain switches.
++
++config SWCONFIG_LEDS
++	bool "Switch LED trigger support"
++	depends on (SWCONFIG && LEDS_TRIGGERS)
++
++config ADM6996_PHY
++	tristate "Driver for ADM6996 switches"
++	select SWCONFIG
++	help
++	  Currently supports the ADM6996FC and ADM6996M switches.
++	  Support for FC is very limited.
++
++config AR8216_PHY
++	tristate "Driver for Atheros AR8216/8327 switches"
++	select SWCONFIG
++	select ETHERNET_PACKET_MANGLE
++
++config AR8216_PHY_LEDS
++	bool "Atheros AR8216 switch LED support"
++	depends on (AR8216_PHY && LEDS_CLASS)
++
++source "drivers/net/phy/b53/Kconfig"
++
++config IP17XX_PHY
++	tristate "Driver for IC+ IP17xx switches"
++	select SWCONFIG
++
++config PSB6970_PHY
++	tristate "Lantiq XWAY Tantos (PSB6970) Ethernet switch"
++	select SWCONFIG
++
++config RTL8306_PHY
++	tristate "Driver for Realtek RTL8306S switches"
++	select SWCONFIG
++
++config RTL8366_SMI
++	tristate "Driver for the RTL8366 SMI interface"
++	depends on GPIOLIB
++	help
++	  This module implements the SMI interface protocol which is used
++	  by some RTL8366 ethernet switch devices via the generic GPIO API.
++
++if RTL8366_SMI
++
++config RTL8366_SMI_DEBUG_FS
++	bool "RTL8366 SMI interface debugfs support"
++        depends on DEBUG_FS
++        default n
++
++config RTL8366S_PHY
++	tristate "Driver for the Realtek RTL8366S switch"
++	select SWCONFIG
++
++config RTL8366RB_PHY
++	tristate "Driver for the Realtek RTL8366RB switch"
++	select SWCONFIG
++
++config RTL8367_PHY
++	tristate "Driver for the Realtek RTL8367R/M switches"
++	select SWCONFIG
++
++config RTL8367B_PHY
++	tristate "Driver fot the Realtek RTL8367R-VB switch"
++	select SWCONFIG
++
++endif # RTL8366_SMI
++
+ comment "MII PHY device drivers"
+ 
+ config AIR_EN8811H_PHY
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -27,6 +27,21 @@ libphy-$(CONFIG_OPEN_ALLIANCE_HELPERS) +
+ obj-$(CONFIG_PHYLINK)		+= phylink.o
+ obj-$(CONFIG_PHYLIB)		+= libphy.o
+ 
++obj-$(CONFIG_SWCONFIG)		+= swconfig.o
++obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
++obj-$(CONFIG_AR8216_PHY)	+= ar8xxx.o
++ar8xxx-y			+= ar8216.o
++ar8xxx-y			+= ar8327.o
++obj-$(CONFIG_SWCONFIG_B53)	+= b53/
++obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
++obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
++obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
++obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
++obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
++obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
++obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
++obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
++
+ obj-$(CONFIG_NETWORK_PHY_TIMESTAMPING) += mii_timestamper.o
+ 
+ obj-$(CONFIG_SFP)		+= sfp.o
+--- a/include/linux/platform_data/b53.h
++++ b/include/linux/platform_data/b53.h
+@@ -29,6 +29,9 @@ struct b53_platform_data {
+ 	u32 chip_id;
+ 	u16 enabled_ports;
+ 
++	/* allow to specify an ethX alias */
++	const char *alias;
++
+ 	/* only used by MMAP'd driver */
+ 	unsigned big_endian:1;
+ 	void __iomem *regs;
diff --git a/target/linux/generic/hack-6.12/711-net-dsa-mv88e6xxx-disable-ATU-violation.patch b/target/linux/generic/hack-6.12/711-net-dsa-mv88e6xxx-disable-ATU-violation.patch
new file mode 100644
index 0000000000..b8d8652d8f
--- /dev/null
+++ b/target/linux/generic/hack-6.12/711-net-dsa-mv88e6xxx-disable-ATU-violation.patch
@@ -0,0 +1,21 @@
+From ebd924d773223593142d417c41d4ee6fa16f1805 Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 13:45:56 +0200
+Subject: [PATCH] net/dsa/mv88e6xxx: disable ATU violation
+
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3582,6 +3582,9 @@ static int mv88e6xxx_setup_port(struct m
+ 	else
+ 		reg = 1 << port;
+ 
++	/* Disable ATU member violation interrupt */
++	reg |= MV88E6XXX_PORT_ASSOC_VECTOR_IGNORE_WRONG;
++
+ 	err = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_ASSOC_VECTOR,
+ 				   reg);
+ 	if (err)
diff --git a/target/linux/generic/hack-6.12/721-net-add-packet-mangeling.patch b/target/linux/generic/hack-6.12/721-net-add-packet-mangeling.patch
new file mode 100644
index 0000000000..5ad34a4517
--- /dev/null
+++ b/target/linux/generic/hack-6.12/721-net-add-packet-mangeling.patch
@@ -0,0 +1,159 @@
+From ffe387740bbe88dd88bbe04d6375902708003d6e Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 7 Jul 2017 17:25:00 +0200
+Subject: net: add packet mangeling
+
+ar8216 switches have a hardware bug, which renders normal 802.1q support
+unusable. Packet mangling is required to fix up the vlan for incoming
+packets.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ include/linux/netdevice.h | 10 ++++++++++
+ include/linux/skbuff.h    | 14 ++++----------
+ net/Kconfig               |  6 ++++++
+ net/core/dev.c            | 20 +++++++++++++++-----
+ net/core/skbuff.c         | 17 +++++++++++++++++
+ net/ethernet/eth.c        |  6 ++++++
+ 6 files changed, 58 insertions(+), 15 deletions(-)
+
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1687,6 +1687,7 @@ enum netdev_priv_flags {
+ 	IFF_L3MDEV_RX_HANDLER		= 1<<29,
+ 	IFF_NO_ADDRCONF			= BIT_ULL(30),
+ 	IFF_TX_SKB_NO_LINEAR		= BIT_ULL(31),
++	IFF_NO_IP_ALIGN			= BIT_ULL(32),
+ };
+ 
+ /* Specifies the type of the struct net_device::ml_priv pointer */
+@@ -2168,6 +2169,11 @@ struct net_device {
+ 	const struct tlsdev_ops *tlsdev_ops;
+ #endif
+ 
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	void (*eth_mangle_rx)(struct net_device *dev, struct sk_buff *skb);
++	struct sk_buff *(*eth_mangle_tx)(struct net_device *dev, struct sk_buff *skb);
++#endif
++
+ 	unsigned int		operstate;
+ 	unsigned char		link_mode;
+ 
+@@ -2237,6 +2243,10 @@ struct net_device {
+ 	struct mctp_dev __rcu	*mctp_ptr;
+ #endif
+ 
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	void			*phy_ptr; /* PHY device specific data */
++#endif
++
+ /*
+  * Cache lines mostly used on receive path (including eth_type_trans())
+  */
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -3213,6 +3213,10 @@ static inline int pskb_trim(struct sk_bu
+ 	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
+ }
+ 
++extern struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
++		unsigned int length, gfp_t gfp);
++
++
+ /**
+  *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer
+  *	@skb: buffer to alter
+@@ -3378,16 +3382,6 @@ static inline struct sk_buff *dev_alloc_
+ }
+ 
+ 
+-static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
+-		unsigned int length, gfp_t gfp)
+-{
+-	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
+-
+-	if (NET_IP_ALIGN && skb)
+-		skb_reserve(skb, NET_IP_ALIGN);
+-	return skb;
+-}
+-
+ static inline struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
+ 		unsigned int length)
+ {
+--- a/net/Kconfig
++++ b/net/Kconfig
+@@ -26,6 +26,12 @@ menuconfig NET
+ 
+ if NET
+ 
++config ETHERNET_PACKET_MANGLE
++	bool
++	help
++	  This option can be selected by phy drivers that need to mangle
++	  packets going in or out of an ethernet device.
++
+ config WANT_COMPAT_NETLINK_MESSAGES
+ 	bool
+ 	help
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -3646,6 +3646,11 @@ static int xmit_one(struct sk_buff *skb,
+ 	if (dev_nit_active(dev))
+ 		dev_queue_xmit_nit(skb, dev);
+ 
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	if (dev->eth_mangle_tx && !(skb = dev->eth_mangle_tx(dev, skb)))
++		return NETDEV_TX_OK;
++#endif
++
+ 	len = skb->len;
+ 	trace_net_dev_start_xmit(skb, dev);
+ 	rc = netdev_start_xmit(skb, dev, txq, more);
+--- a/net/core/skbuff.c
++++ b/net/core/skbuff.c
+@@ -64,6 +64,7 @@
+ #include <linux/mpls.h>
+ #include <linux/kcov.h>
+ #include <linux/iov_iter.h>
++#include <linux/if.h>
+ 
+ #include <net/protocol.h>
+ #include <net/dst.h>
+@@ -326,6 +327,22 @@ void *__napi_alloc_frag_align(unsigned i
+ }
+ EXPORT_SYMBOL(__napi_alloc_frag_align);
+ 
++struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
++		unsigned int length, gfp_t gfp)
++{
++	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
++
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	if (dev && (dev->priv_flags & IFF_NO_IP_ALIGN))
++		return skb;
++#endif
++
++	if (NET_IP_ALIGN && skb)
++		skb_reserve(skb, NET_IP_ALIGN);
++	return skb;
++}
++EXPORT_SYMBOL(__netdev_alloc_skb_ip_align);
++
+ void *__netdev_alloc_frag_align(unsigned int fragsz, unsigned int align_mask)
+ {
+ 	void *data;
+--- a/net/ethernet/eth.c
++++ b/net/ethernet/eth.c
+@@ -159,6 +159,12 @@ __be16 eth_type_trans(struct sk_buff *sk
+ 	const struct ethhdr *eth;
+ 
+ 	skb->dev = dev;
++
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	if (dev->eth_mangle_rx)
++		dev->eth_mangle_rx(dev, skb);
++#endif
++
+ 	skb_reset_mac_header(skb);
+ 
+ 	eth = eth_skb_pull_mac(skb);
diff --git a/target/linux/generic/hack-6.12/722-net-phy-aquantia-enable-AQR112-and-AQR412.patch b/target/linux/generic/hack-6.12/722-net-phy-aquantia-enable-AQR112-and-AQR412.patch
new file mode 100644
index 0000000000..2d7edc9e75
--- /dev/null
+++ b/target/linux/generic/hack-6.12/722-net-phy-aquantia-enable-AQR112-and-AQR412.patch
@@ -0,0 +1,117 @@
+From 5f62951fba63a9f9cfff564209426bdea5fcc371 Mon Sep 17 00:00:00 2001
+From: Alex Marginean <alexandru.marginean@nxp.com>
+Date: Tue, 27 Aug 2019 15:16:56 +0300
+Subject: [PATCH] drivers: net: phy: aquantia: enable AQR112 and AQR412
+
+Adds support for AQR112 and AQR412 which is mostly based on existing code
+with the addition of code configuring the protocol on system side.
+This allows changing the system side protocol without having to deploy a
+different firmware on the PHY.
+
+Signed-off-by: Alex Marginean <alexandru.marginean@nxp.com>
+---
+ drivers/net/phy/aquantia/aquantia_main.c | 88 +++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 88 insertions(+)
+
+--- a/drivers/net/phy/aquantia/aquantia_main.c
++++ b/drivers/net/phy/aquantia/aquantia_main.c
+@@ -97,6 +97,29 @@
+ #define AQR107_OP_IN_PROG_SLEEP		1000
+ #define AQR107_OP_IN_PROG_TIMEOUT	100000
+ 
++/* registers in MDIO_MMD_VEND1 region */
++#define AQUANTIA_VND1_GLOBAL_SC			0x000
++#define  AQUANTIA_VND1_GLOBAL_SC_LP		BIT(0xb)
++
++/* global start rate, the protocol associated with this speed is used by default
++ * on SI.
++ */
++#define AQUANTIA_VND1_GSTART_RATE		0x31a
++#define  AQUANTIA_VND1_GSTART_RATE_OFF		0
++#define  AQUANTIA_VND1_GSTART_RATE_100M		1
++#define  AQUANTIA_VND1_GSTART_RATE_1G		2
++#define  AQUANTIA_VND1_GSTART_RATE_10G		3
++#define  AQUANTIA_VND1_GSTART_RATE_2_5G		4
++#define  AQUANTIA_VND1_GSTART_RATE_5G		5
++
++/* SYSCFG registers for 100M, 1G, 2.5G, 5G, 10G */
++#define AQUANTIA_VND1_GSYSCFG_BASE		0x31b
++#define AQUANTIA_VND1_GSYSCFG_100M		0
++#define AQUANTIA_VND1_GSYSCFG_1G		1
++#define AQUANTIA_VND1_GSYSCFG_2_5G		2
++#define AQUANTIA_VND1_GSYSCFG_5G		3
++#define AQUANTIA_VND1_GSYSCFG_10G		4
++
+ static int aqr107_get_sset_count(struct phy_device *phydev)
+ {
+ 	return AQR107_SGMII_STAT_SZ;
+@@ -203,6 +226,51 @@ static int aqr_config_aneg(struct phy_de
+ 	return genphy_c45_check_and_restart_aneg(phydev, changed);
+ }
+ 
++static struct {
++	u16 syscfg;
++	int cnt;
++	u16 start_rate;
++} aquantia_syscfg[PHY_INTERFACE_MODE_MAX] = {
++	[PHY_INTERFACE_MODE_SGMII] =      {0x04b, AQUANTIA_VND1_GSYSCFG_1G,
++					   AQUANTIA_VND1_GSTART_RATE_1G},
++	[PHY_INTERFACE_MODE_2500BASEX] = {0x144, AQUANTIA_VND1_GSYSCFG_2_5G,
++					   AQUANTIA_VND1_GSTART_RATE_2_5G},
++	[PHY_INTERFACE_MODE_XGMII] =      {0x100, AQUANTIA_VND1_GSYSCFG_10G,
++					   AQUANTIA_VND1_GSTART_RATE_10G},
++	[PHY_INTERFACE_MODE_USXGMII] =    {0x080, AQUANTIA_VND1_GSYSCFG_10G,
++					   AQUANTIA_VND1_GSTART_RATE_10G},
++};
++
++/* Sets up protocol on system side before calling aqr_config_aneg */
++static int aqr_config_aneg_set_prot(struct phy_device *phydev)
++{
++	int if_type = phydev->interface;
++	int i;
++
++	if (!aquantia_syscfg[if_type].cnt)
++		return 0;
++
++	/* set PHY in low power mode so we can configure protocols */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GLOBAL_SC,
++		      AQUANTIA_VND1_GLOBAL_SC_LP);
++	mdelay(10);
++
++	/* set the default rate to enable the SI link */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GSTART_RATE,
++		      aquantia_syscfg[if_type].start_rate);
++
++	for (i = 0; i <= aquantia_syscfg[if_type].cnt; i++)
++		phy_write_mmd(phydev, MDIO_MMD_VEND1,
++			      AQUANTIA_VND1_GSYSCFG_BASE + i,
++			      aquantia_syscfg[if_type].syscfg);
++
++	/* wake PHY back up */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GLOBAL_SC, 0);
++	mdelay(10);
++
++	return aqr_config_aneg(phydev);
++}
++
+ static int aqr_config_intr(struct phy_device *phydev)
+ {
+ 	bool en = phydev->interrupts == PHY_INTERRUPT_ENABLED;
+@@ -972,7 +1040,7 @@ static struct phy_driver aqr_driver[] =
+ 	PHY_ID_MATCH_MODEL(PHY_ID_AQR112),
+ 	.name		= "Aquantia AQR112",
+ 	.probe		= aqr107_probe,
+-	.config_aneg    = aqr_config_aneg,
++	.config_aneg    = aqr_config_aneg_set_prot,
+ 	.config_intr	= aqr_config_intr,
+ 	.handle_interrupt = aqr_handle_interrupt,
+ 	.get_tunable    = aqr107_get_tunable,
+@@ -995,7 +1063,7 @@ static struct phy_driver aqr_driver[] =
+ 	PHY_ID_MATCH_MODEL(PHY_ID_AQR412),
+ 	.name		= "Aquantia AQR412",
+ 	.probe		= aqr107_probe,
+-	.config_aneg    = aqr_config_aneg,
++	.config_aneg    = aqr_config_aneg_set_prot,
+ 	.config_intr	= aqr_config_intr,
+ 	.handle_interrupt = aqr_handle_interrupt,
+ 	.get_tunable    = aqr107_get_tunable,
diff --git a/target/linux/generic/hack-6.12/723-net-phy-aquantia-fix-system-side-protocol-mi.patch b/target/linux/generic/hack-6.12/723-net-phy-aquantia-fix-system-side-protocol-mi.patch
new file mode 100644
index 0000000000..eaeb3b6a92
--- /dev/null
+++ b/target/linux/generic/hack-6.12/723-net-phy-aquantia-fix-system-side-protocol-mi.patch
@@ -0,0 +1,34 @@
+From 5f008cb22f60da4e10375f22266c1a4e20b1252e Mon Sep 17 00:00:00 2001
+From: Alex Marginean <alexandru.marginean@nxp.com>
+Date: Fri, 20 Sep 2019 18:22:52 +0300
+Subject: [PATCH] drivers: net: phy: aquantia: fix system side protocol
+ misconfiguration
+
+Do not set up protocols for speeds that are not supported by FW.  Enabling
+these protocols leads to link issues on system side.
+
+Signed-off-by: Alex Marginean <alexandru.marginean@nxp.com>
+---
+ drivers/net/phy/aquantia/aquantia_main.c | 8 +++++++-
+ 1 file changed, 7 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/phy/aquantia/aquantia_main.c
++++ b/drivers/net/phy/aquantia/aquantia_main.c
+@@ -259,10 +259,16 @@ static int aqr_config_aneg_set_prot(stru
+ 	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GSTART_RATE,
+ 		      aquantia_syscfg[if_type].start_rate);
+ 
+-	for (i = 0; i <= aquantia_syscfg[if_type].cnt; i++)
++	for (i = 0; i <= aquantia_syscfg[if_type].cnt; i++) {
++		u16 reg = phy_read_mmd(phydev, MDIO_MMD_VEND1,
++				       AQUANTIA_VND1_GSYSCFG_BASE + i);
++		if (!reg)
++			continue;
++
+ 		phy_write_mmd(phydev, MDIO_MMD_VEND1,
+ 			      AQUANTIA_VND1_GSYSCFG_BASE + i,
+ 			      aquantia_syscfg[if_type].syscfg);
++	}
+ 
+ 	/* wake PHY back up */
+ 	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GLOBAL_SC, 0);
diff --git a/target/linux/generic/hack-6.12/725-net-phy-aquantia-add-PHY_IDs-for-AQR112-variants.patch b/target/linux/generic/hack-6.12/725-net-phy-aquantia-add-PHY_IDs-for-AQR112-variants.patch
new file mode 100644
index 0000000000..98c4186a3e
--- /dev/null
+++ b/target/linux/generic/hack-6.12/725-net-phy-aquantia-add-PHY_IDs-for-AQR112-variants.patch
@@ -0,0 +1,63 @@
+From 3b92ee7b7899b6beffb2b484c58326e36612a873 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 23 Dec 2021 14:52:56 +0000
+Subject: [PATCH] net: phy: aquantia: add PHY_ID for AQR112R
+
+As advised by Ian Chang this PHY is used in Puzzle devices.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/phy/aquantia/aquantia_main.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/net/phy/aquantia/aquantia_main.c
++++ b/drivers/net/phy/aquantia/aquantia_main.c
+@@ -32,6 +32,8 @@
+ #define PHY_ID_AQR114C	0x31c31c22
+ #define PHY_ID_AQR115C	0x31c31c33
+ #define PHY_ID_AQR813	0x31c31cb2
++#define PHY_ID_AQR112C	0x03a1b790
++#define PHY_ID_AQR112R	0x31c31d12
+ 
+ #define MDIO_PHYXS_VEND_IF_STATUS		0xe812
+ #define MDIO_PHYXS_VEND_IF_STATUS_TYPE_MASK	GENMASK(7, 3)
+@@ -1205,6 +1207,30 @@ static struct phy_driver aqr_driver[] =
+ 	.led_hw_control_get = aqr_phy_led_hw_control_get,
+ 	.led_polarity_set = aqr_phy_led_polarity_set,
+ },
++{
++	PHY_ID_MATCH_MODEL(PHY_ID_AQR112C),
++	.name		= "Aquantia AQR112C",
++	.probe		= aqr107_probe,
++	.config_aneg	= aqr_config_aneg_set_prot,
++	.config_intr	= aqr_config_intr,
++	.handle_interrupt = aqr_handle_interrupt,
++	.read_status	= aqr107_read_status,
++	.get_sset_count	= aqr107_get_sset_count,
++	.get_strings	= aqr107_get_strings,
++	.get_stats	= aqr107_get_stats,
++},
++{
++	PHY_ID_MATCH_MODEL(PHY_ID_AQR112R),
++	.name		= "Aquantia AQR112R",
++	.probe		= aqr107_probe,
++	.config_aneg	= aqr_config_aneg_set_prot,
++	.config_intr	= aqr_config_intr,
++	.handle_interrupt = aqr_handle_interrupt,
++	.read_status	= aqr107_read_status,
++	.get_sset_count	= aqr107_get_sset_count,
++	.get_strings	= aqr107_get_strings,
++	.get_stats	= aqr107_get_stats,
++},
+ };
+ 
+ module_phy_driver(aqr_driver);
+@@ -1226,6 +1252,8 @@ static const struct mdio_device_id __may
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR114C) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR115C) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR813) },
++	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR112C) },
++	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR112R) },
+ 	{ }
+ };
+ 
diff --git a/target/linux/generic/hack-6.12/730-net-ethernet-mtk_eth_soc-add-hw-dump-for-forced-rese.patch b/target/linux/generic/hack-6.12/730-net-ethernet-mtk_eth_soc-add-hw-dump-for-forced-rese.patch
new file mode 100644
index 0000000000..d53794effc
--- /dev/null
+++ b/target/linux/generic/hack-6.12/730-net-ethernet-mtk_eth_soc-add-hw-dump-for-forced-rese.patch
@@ -0,0 +1,115 @@
+From bc51c337a3147c4a02c743489885a6657bc5371c Mon Sep 17 00:00:00 2001
+From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+Date: Wed, 27 Nov 2024 13:36:49 +0800
+Subject: [PATCH] net: ethernet: mtk_eth_soc: add hw dump for forced reset
+
+Without this patch, the ETH driver is unable to dump the registers
+before triggering a forced reset.
+
+Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+---
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c | 55 +++++++++++++++++++++
+ 1 files changed, 55 insertions(+)
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -66,6 +66,7 @@ static const struct mtk_reg_map mtk_reg_
+ 		.rx_ptr		= 0x1900,
+ 		.rx_cnt_cfg	= 0x1904,
+ 		.qcrx_ptr	= 0x1908,
++		.page		= 0x19f0,
+ 		.glo_cfg	= 0x1a04,
+ 		.rst_idx	= 0x1a08,
+ 		.delay_irq	= 0x1a0c,
+@@ -132,6 +133,7 @@ static const struct mtk_reg_map mt7986_r
+ 		.rx_ptr		= 0x4500,
+ 		.rx_cnt_cfg	= 0x4504,
+ 		.qcrx_ptr	= 0x4508,
++		.page		= 0x45f0,
+ 		.glo_cfg	= 0x4604,
+ 		.rst_idx	= 0x4608,
+ 		.delay_irq	= 0x460c,
+@@ -183,6 +185,7 @@ static const struct mtk_reg_map mt7988_r
+ 		.rx_ptr		= 0x4500,
+ 		.rx_cnt_cfg	= 0x4504,
+ 		.qcrx_ptr	= 0x4508,
++		.page		= 0x45f0,
+ 		.glo_cfg	= 0x4604,
+ 		.rst_idx	= 0x4608,
+ 		.delay_irq	= 0x460c,
+@@ -3904,6 +3907,56 @@ static void mtk_set_mcr_max_rx(struct mt
+ 		mtk_w32(mac->hw, mcr_new, MTK_MAC_MCR(mac->id));
+ }
+ 
++static void mtk_hw_dump_reg(struct mtk_eth *eth, char *name, u32 offset, u32 range)
++{
++	u32 cur = offset;
++
++	pr_info("\n==================== %s ====================\n", name);
++	while (cur < offset + range) {
++		pr_info("0x%08x: %08x %08x %08x %08x\n",
++			cur, mtk_r32(eth, cur), mtk_r32(eth, cur + 0x4),
++			mtk_r32(eth, cur + 0x8), mtk_r32(eth, cur + 0xc));
++		cur += 0x10;
++	}
++}
++
++static void mtk_hw_dump(struct mtk_eth *eth)
++{
++	const struct mtk_reg_map *reg_map = eth->soc->reg_map;
++	u32 id;
++
++	mtk_hw_dump_reg(eth, "FE", 0x0, 0x600);
++	mtk_hw_dump_reg(eth, "FE", 0x1400, 0x300);
++	mtk_hw_dump_reg(eth, "ADMA", reg_map->pdma.rx_ptr, 0x300);
++	if (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {
++		for (id = 0; id < MTK_QDMA_NUM_QUEUES / 16; id++) {
++			mtk_w32(eth, id, reg_map->qdma.page);
++			pr_info("\nQDMA PAGE:%x ", mtk_r32(eth, reg_map->qdma.page));
++			mtk_hw_dump_reg(eth, "QDMA", reg_map->qdma.qtx_cfg, 0x100);
++			mtk_w32(eth, 0, reg_map->qdma.page);
++		}
++		mtk_hw_dump_reg(eth, "QDMA", reg_map->qdma.rx_ptr, 0x300);
++	}
++	if (!MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628)) {
++		mtk_hw_dump_reg(eth, "WDMA0", reg_map->wdma_base[0], 0x400);
++		mtk_hw_dump_reg(eth, "WDMA1", reg_map->wdma_base[1], 0x400);
++		if (mtk_is_netsys_v3_or_greater(eth))
++			mtk_hw_dump_reg(eth, "WDMA2", reg_map->wdma_base[2], 0x400);
++	}
++	mtk_hw_dump_reg(eth, "PPE0", reg_map->ppe_base + 0x200, 0x200);
++	if (!mtk_is_netsys_v1(eth))
++		mtk_hw_dump_reg(eth, "PPE1", reg_map->ppe_base + 0x600, 0x200);
++	if (mtk_is_netsys_v3_or_greater(eth))
++		mtk_hw_dump_reg(eth, "PPE2", reg_map->ppe_base + 0xE00, 0x200);
++	mtk_hw_dump_reg(eth, "GMAC", 0x10000, 0x300);
++	if (mtk_is_netsys_v3_or_greater(eth))
++		mtk_hw_dump_reg(eth, "GMAC", 0x10300, 0x100);
++	if (mtk_is_netsys_v3_or_greater(eth)) {
++		mtk_hw_dump_reg(eth, "XGMAC0", 0x12000, 0x300);
++		mtk_hw_dump_reg(eth, "XGMAC1", 0x13000, 0x300);
++	}
++}
++
+ static void mtk_hw_reset(struct mtk_eth *eth)
+ {
+ 	u32 val;
+@@ -4383,6 +4436,8 @@ static void mtk_pending_work(struct work
+ 	rtnl_lock();
+ 	set_bit(MTK_RESETTING, &eth->state);
+ 
++	mtk_hw_dump(eth);
++
+ 	mtk_prepare_for_reset(eth);
+ 	mtk_wed_fe_reset();
+ 	/* Run again reset preliminary configuration in order to avoid any
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+@@ -1191,6 +1191,7 @@ struct mtk_reg_map {
+ 		u32	rx_ptr;		/* rx base pointer */
+ 		u32	rx_cnt_cfg;	/* rx max count configuration */
+ 		u32	qcrx_ptr;	/* rx cpu pointer */
++		u32	page;		/* page configuration */
+ 		u32	glo_cfg;	/* global configuration */
+ 		u32	rst_idx;	/* reset index */
+ 		u32	delay_irq;	/* delay interrupt */
diff --git a/target/linux/generic/hack-6.12/735-net-phy-realtek-rtl8261n.patch b/target/linux/generic/hack-6.12/735-net-phy-realtek-rtl8261n.patch
new file mode 100644
index 0000000000..616db25890
--- /dev/null
+++ b/target/linux/generic/hack-6.12/735-net-phy-realtek-rtl8261n.patch
@@ -0,0 +1,21 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -419,6 +419,8 @@ config QSEMI_PHY
+ 
+ source "drivers/net/phy/realtek/Kconfig"
+ 
++source "drivers/net/phy/rtl8261n/Kconfig"
++
+ config RENESAS_PHY
+ 	tristate "Renesas PHYs"
+ 	help
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -110,6 +110,7 @@ obj-$(CONFIG_NXP_TJA11XX_PHY)	+= nxp-tja
+ obj-y				+= qcom/
+ obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek/
++obj-y				+= rtl8261n/
+ obj-$(CONFIG_RENESAS_PHY)	+= uPD60620.o
+ obj-$(CONFIG_ROCKCHIP_PHY)	+= rockchip.o
+ obj-$(CONFIG_SMSC_PHY)		+= smsc.o
diff --git a/target/linux/generic/hack-6.12/750-net-pcs-mtk-lynxi-workaround-2500BaseX-no-an.patch b/target/linux/generic/hack-6.12/750-net-pcs-mtk-lynxi-workaround-2500BaseX-no-an.patch
new file mode 100644
index 0000000000..30a502a237
--- /dev/null
+++ b/target/linux/generic/hack-6.12/750-net-pcs-mtk-lynxi-workaround-2500BaseX-no-an.patch
@@ -0,0 +1,64 @@
+From 880d1311335120f64447ca9d11933872d734e19a Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Mon, 27 Mar 2023 18:41:54 +0100
+Subject: [PATCH] generic: pcs-mtk-lynxi: add hack to use 2500Base-X without AN
+
+Using 2500Base-T SFP modules e.g. on the BananaPi R3 requires manually
+disabling auto-negotiation, e.g. using ethtool. While a proper fix
+using SFP quirks is being discussed upstream, bring a work-around to
+restore user experience to what it was before the switch to the
+dedicated SGMII PCS driver.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+
+--- a/drivers/net/pcs/pcs-mtk-lynxi.c
++++ b/drivers/net/pcs/pcs-mtk-lynxi.c
+@@ -114,14 +114,23 @@ static void mtk_pcs_lynxi_get_state(stru
+ 				    struct phylink_link_state *state)
+ {
+ 	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
+-	unsigned int bm, adv;
++	unsigned int bm, bmsr, adv;
+ 
+ 	/* Read the BMSR and LPA */
+ 	regmap_read(mpcs->regmap, SGMSYS_PCS_CONTROL_1, &bm);
+-	regmap_read(mpcs->regmap, SGMSYS_PCS_ADVERTISE, &adv);
++	bmsr = FIELD_GET(SGMII_BMSR, bm);
++
++	if (state->interface == PHY_INTERFACE_MODE_2500BASEX) {
++		state->link = !!(bmsr & BMSR_LSTATUS);
++		state->an_complete = !!(bmsr & BMSR_ANEGCOMPLETE);
++		state->speed = SPEED_2500;
++		state->duplex = DUPLEX_FULL;
++
++		return;
++	}
+ 
+-	phylink_mii_c22_pcs_decode_state(state, FIELD_GET(SGMII_BMSR, bm),
+-					 FIELD_GET(SGMII_LPA, adv));
++	regmap_read(mpcs->regmap, SGMSYS_PCS_ADVERTISE, &adv);
++	phylink_mii_c22_pcs_decode_state(state, bmsr, FIELD_GET(SGMII_LPA, adv));
+ }
+ 
+ static void mtk_sgmii_reset(struct mtk_pcs_lynxi *mpcs)
+@@ -142,7 +151,7 @@ static int mtk_pcs_lynxi_config(struct p
+ {
+ 	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
+ 	bool mode_changed = false, changed;
+-	unsigned int rgc3, sgm_mode, bmcr;
++	unsigned int rgc3, sgm_mode, bmcr = 0;
+ 	int advertise, link_timer;
+ 
+ 	advertise = phylink_mii_c22_pcs_encode_advertisement(interface,
+@@ -165,9 +174,8 @@ static int mtk_pcs_lynxi_config(struct p
+ 	if (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED) {
+ 		if (interface == PHY_INTERFACE_MODE_SGMII)
+ 			sgm_mode |= SGMII_SPEED_DUPLEX_AN;
+-		bmcr = BMCR_ANENABLE;
+-	} else {
+-		bmcr = 0;
++		if (interface != PHY_INTERFACE_MODE_2500BASEX)
++			bmcr = BMCR_ANENABLE;
+ 	}
+ 
+ 	if (mpcs->interface != interface) {
diff --git a/target/linux/generic/hack-6.12/760-net-usb-r8152-add-LED-configuration-from-OF.patch b/target/linux/generic/hack-6.12/760-net-usb-r8152-add-LED-configuration-from-OF.patch
new file mode 100644
index 0000000000..3b61638cb6
--- /dev/null
+++ b/target/linux/generic/hack-6.12/760-net-usb-r8152-add-LED-configuration-from-OF.patch
@@ -0,0 +1,74 @@
+From 82985725e071f2a5735052f18e109a32aeac3a0b Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Sun, 26 Jul 2020 02:38:31 +0200
+Subject: [PATCH] net: usb: r8152: add LED configuration from OF
+
+This adds the ability to configure the LED configuration register using
+OF. This way, the correct value for board specific LED configuration can
+be determined.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ drivers/net/usb/r8152.c | 23 +++++++++++++++++++++++
+ 1 file changed, 23 insertions(+)
+
+--- a/drivers/net/usb/r8152.c
++++ b/drivers/net/usb/r8152.c
+@@ -12,6 +12,7 @@
+ #include <linux/ethtool.h>
+ #include <linux/phy.h>
+ #include <linux/usb.h>
++#include <linux/of.h>
+ #include <linux/crc32.h>
+ #include <linux/if_vlan.h>
+ #include <linux/uaccess.h>
+@@ -7047,6 +7048,22 @@ static void rtl_tally_reset(struct r8152
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY, ocp_data);
+ }
+ 
++static int r8152_led_configuration(struct r8152 *tp)
++{
++	u32 led_data;
++	int ret;
++
++	ret = of_property_read_u32(tp->udev->dev.of_node, "realtek,led-data",
++								&led_data);
++
++	if (ret)
++		return ret;
++
++	ocp_write_word(tp, MCU_TYPE_PLA, PLA_LEDSEL, led_data);
++
++	return 0;
++}
++
+ static void r8152b_init(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+@@ -7088,6 +7105,8 @@ static void r8152b_init(struct r8152 *tp
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+ 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
++
++	r8152_led_configuration(tp);
+ }
+ 
+ static void r8153_init(struct r8152 *tp)
+@@ -7228,6 +7247,8 @@ static void r8153_init(struct r8152 *tp)
+ 		tp->coalesce = COALESCE_SLOW;
+ 		break;
+ 	}
++
++	r8152_led_configuration(tp);
+ }
+ 
+ static void r8153b_init(struct r8152 *tp)
+@@ -7310,6 +7331,8 @@ static void r8153b_init(struct r8152 *tp
+ 	rtl_tally_reset(tp);
+ 
+ 	tp->coalesce = 15000;	/* 15 us */
++
++	r8152_led_configuration(tp);
+ }
+ 
+ static void r8153c_init(struct r8152 *tp)
diff --git a/target/linux/generic/hack-6.12/761-dt-bindings-net-add-RTL8152-binding-documentation.patch b/target/linux/generic/hack-6.12/761-dt-bindings-net-add-RTL8152-binding-documentation.patch
new file mode 100644
index 0000000000..be262b993c
--- /dev/null
+++ b/target/linux/generic/hack-6.12/761-dt-bindings-net-add-RTL8152-binding-documentation.patch
@@ -0,0 +1,54 @@
+From 3ee05f4aa64fc86af3be5bc176ba5808de9260a7 Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Sun, 26 Jul 2020 15:30:33 +0200
+Subject: [PATCH] dt-bindings: net: add RTL8152 binding documentation
+
+Add binding documentation for the Realtek RTL8152 / RTL8153 USB ethernet
+adapters.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ .../bindings/net/realtek,rtl8152.yaml         | 36 +++++++++++++++++++
+ 1 file changed, 36 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/net/realtek,rtl8152.yaml
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/net/realtek,rtl8152.yaml
+@@ -0,0 +1,36 @@
++# SPDX-License-Identifier: GPL-2.0
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/net/realtek,rtl8152.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Realtek RTL8152/RTL8153 series USB ethernet
++
++maintainers:
++  - David Bauer <mail@david-bauer.net>
++
++properties:
++  compatible:
++    oneOf:
++      - items:
++          - enum:
++              - realtek,rtl8152
++              - realtek,rtl8153
++
++  reg:
++    description: The device number on the USB bus
++
++  realtek,led-data:
++    description: Value to be written to the LED configuration register.
++
++required:
++  - compatible
++  - reg
++
++examples:
++  - |
++    usb-eth@2 {
++      compatible = "realtek,rtl8153";
++      reg = <2>;
++      realtek,led-data = <0x87>;
++    };
+\ No newline at end of file
diff --git a/target/linux/generic/hack-6.12/766-net-phy-mediatek-ge-add-LED-configuration-interface.patch b/target/linux/generic/hack-6.12/766-net-phy-mediatek-ge-add-LED-configuration-interface.patch
new file mode 100644
index 0000000000..2eeca8fd77
--- /dev/null
+++ b/target/linux/generic/hack-6.12/766-net-phy-mediatek-ge-add-LED-configuration-interface.patch
@@ -0,0 +1,72 @@
+From cc225d163b5a4f7a0d1968298bf7927306646a47 Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Fri, 28 Apr 2023 01:53:01 +0200
+Subject: [PATCH] net: phy: mediatek-ge: add LED configuration interface
+
+This adds a small hack similar to the one used for ar8xxx switches to
+read a reg:value map for configuring the LED configuration registers.
+
+This allows OpenWrt to write device-specific LED action as well as blink
+configurations. It is unlikely to be accepted upstream, as upstream
+plans on integrating their own framework for handling these LEDs.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ drivers/net/phy/mediatek/mtk-ge.c | 33 +++++++++++++++++++++++++++++++++
+ 1 file changed, 33 insertions(+)
+
+--- a/drivers/net/phy/mediatek/mtk-ge.c
++++ b/drivers/net/phy/mediatek/mtk-ge.c
+@@ -1,4 +1,5 @@
+ // SPDX-License-Identifier: GPL-2.0+
++#include <linux/of.h>
+ #include <linux/bitfield.h>
+ #include <linux/module.h>
+ #include <linux/phy.h>
+@@ -73,6 +74,36 @@ static int mt7530_phy_config_init(struct
+ 	return 0;
+ }
+ 
++static int mt7530_led_config_of(struct phy_device *phydev)
++{
++	struct device_node *np = phydev->mdio.dev.of_node;
++	const __be32 *paddr;
++	int len;
++	int i;
++
++	paddr = of_get_property(np, "mediatek,led-config", &len);
++	if (!paddr)
++		return 0;
++
++	if (len < (2 * sizeof(*paddr)))
++		return -EINVAL;
++
++	len /= sizeof(*paddr);
++
++	phydev_warn(phydev, "Configure LED registers (num=%d)\n", len);
++	for (i = 0; i < len - 1; i += 2) {
++		u32 reg;
++		u32 val;
++
++		reg = be32_to_cpup(paddr + i);
++		val = be32_to_cpup(paddr + i + 1);
++
++		phy_write_mmd(phydev, MDIO_MMD_VEND2, reg, val);
++	}
++
++	return 0;
++}
++
+ static int mt7531_phy_config_init(struct phy_device *phydev)
+ {
+ 	mtk_gephy_config_init(phydev);
+@@ -93,6 +124,9 @@ static int mt7531_phy_config_init(struct
+ 		       FIELD_PREP(MTK_TX_DELAY_PAIR_B_MASK, 0x4) |
+ 		       FIELD_PREP(MTK_TX_DELAY_PAIR_D_MASK, 0x4));
+ 
++	/* LED Config*/
++	mt7530_led_config_of(phydev);
++
+ 	return 0;
+ }
+ 
diff --git a/target/linux/generic/hack-6.12/773-bgmac-add-srab-switch.patch b/target/linux/generic/hack-6.12/773-bgmac-add-srab-switch.patch
new file mode 100644
index 0000000000..40634f9ed0
--- /dev/null
+++ b/target/linux/generic/hack-6.12/773-bgmac-add-srab-switch.patch
@@ -0,0 +1,98 @@
+From 3cb240533ab787899dc7f17aa7d6c5b4810e2e58 Mon Sep 17 00:00:00 2001
+From: Hauke Mehrtens <hauke@hauke-m.de>
+Date: Fri, 7 Jul 2017 17:26:01 +0200
+Subject: bcm53xx: bgmac: use srab switch driver
+
+use the srab switch driver on these SoCs.
+
+Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
+---
+ drivers/net/ethernet/broadcom/bgmac-bcma.c |  1 +
+ drivers/net/ethernet/broadcom/bgmac.c      | 24 ++++++++++++++++++++++++
+ drivers/net/ethernet/broadcom/bgmac.h      |  4 ++++
+ 3 files changed, 29 insertions(+)
+
+--- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
++++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
+@@ -280,6 +280,7 @@ static int bgmac_probe(struct bcma_devic
+ 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+ 		bgmac->feature_flags |= BGMAC_FEAT_NO_RESET;
+ 		bgmac->feature_flags |= BGMAC_FEAT_FORCE_SPEED_2500;
++		bgmac->feature_flags |= BGMAC_FEAT_SRAB;
+ 		break;
+ 	default:
+ 		bgmac->feature_flags |= BGMAC_FEAT_CLKCTLST;
+--- a/drivers/net/ethernet/broadcom/bgmac.c
++++ b/drivers/net/ethernet/broadcom/bgmac.c
+@@ -12,6 +12,7 @@
+ #include <linux/bcma/bcma.h>
+ #include <linux/etherdevice.h>
+ #include <linux/interrupt.h>
++#include <linux/platform_data/b53.h>
+ #include <linux/bcm47xx_nvram.h>
+ #include <linux/phy.h>
+ #include <linux/phy_fixed.h>
+@@ -1408,6 +1409,17 @@ static const struct ethtool_ops bgmac_et
+ 	.set_link_ksettings     = phy_ethtool_set_link_ksettings,
+ };
+ 
++static struct b53_platform_data bgmac_b53_pdata = {
++};
++
++static struct platform_device bgmac_b53_dev = {
++	.name		= "b53-srab-switch",
++	.id		= -1,
++	.dev		= {
++		.platform_data = &bgmac_b53_pdata,
++	},
++};
++
+ /**************************************************
+  * MII
+  **************************************************/
+@@ -1546,6 +1558,14 @@ int bgmac_enet_probe(struct bgmac *bgmac
+ 
+ 	bgmac->in_init = false;
+ 
++	if ((bgmac->feature_flags & BGMAC_FEAT_SRAB) && !bgmac_b53_pdata.regs) {
++		bgmac_b53_pdata.regs = ioremap(0x18007000, 0x1000);
++
++		err = platform_device_register(&bgmac_b53_dev);
++		if (!err)
++			bgmac->b53_device = &bgmac_b53_dev;
++	}
++
+ 	err = register_netdev(bgmac->net_dev);
+ 	if (err) {
+ 		dev_err(bgmac->dev, "Cannot register net device\n");
+@@ -1568,6 +1588,10 @@ EXPORT_SYMBOL_GPL(bgmac_enet_probe);
+ 
+ void bgmac_enet_remove(struct bgmac *bgmac)
+ {
++	if (bgmac->b53_device)
++		platform_device_unregister(&bgmac_b53_dev);
++	bgmac->b53_device = NULL;
++
+ 	unregister_netdev(bgmac->net_dev);
+ 	phy_disconnect(bgmac->net_dev->phydev);
+ 	netif_napi_del(&bgmac->napi);
+--- a/drivers/net/ethernet/broadcom/bgmac.h
++++ b/drivers/net/ethernet/broadcom/bgmac.h
+@@ -387,6 +387,7 @@
+ #define BGMAC_FEAT_CC4_IF_SW_TYPE_RGMII	BIT(18)
+ #define BGMAC_FEAT_CC7_IF_TYPE_RGMII	BIT(19)
+ #define BGMAC_FEAT_IDM_MASK		BIT(20)
++#define BGMAC_FEAT_SRAB			BIT(21)
+ 
+ struct bgmac_slot_info {
+ 	union {
+@@ -494,6 +495,9 @@ struct bgmac {
+ 	void (*cmn_maskset32)(struct bgmac *bgmac, u16 offset, u32 mask,
+ 			      u32 set);
+ 	int (*phy_connect)(struct bgmac *bgmac);
++
++	/* platform device for associated switch */
++	struct platform_device *b53_device;
+ };
+ 
+ struct bgmac *bgmac_alloc(struct device *dev);
diff --git a/target/linux/generic/hack-6.12/780-usb-net-MeigLink_modem_support.patch b/target/linux/generic/hack-6.12/780-usb-net-MeigLink_modem_support.patch
new file mode 100644
index 0000000000..f0b9a2f646
--- /dev/null
+++ b/target/linux/generic/hack-6.12/780-usb-net-MeigLink_modem_support.patch
@@ -0,0 +1,70 @@
+From f81700b6bb2eda3756247bce472d8eaf6f466f61 Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 13:49:26 +0200
+Subject: [PATCH] net/usb/qmi_wwan: add MeigLink modem support
+
+---
+ drivers/net/usb/qmi_wwan.c  | 1 +
+ drivers/usb/serial/option.c | 7 +++++++
+ 2 files changed, 8 insertions(+)
+
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -1076,6 +1076,11 @@ static const struct usb_device_id produc
+ 		USB_DEVICE_AND_INTERFACE_INFO(0x03f0, 0x581d, USB_CLASS_VENDOR_SPEC, 1, 7),
+ 		.driver_info = (unsigned long)&qmi_wwan_info,
+ 	},
++	{	/* Meiglink SGM828 */
++		USB_DEVICE_AND_INTERFACE_INFO(0x2dee, 0x4d49, USB_CLASS_VENDOR_SPEC, 0x10, 0x05),
++		.driver_info = (unsigned long)&qmi_wwan_info,
++	},
++
+ 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0122)},	/* Quectel RG650V */
+ 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0125)},	/* Quectel EC25, EC20 R2.0  Mini PCIe */
+ 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0306)},	/* Quectel EP06/EG06/EM06 */
+@@ -1083,6 +1088,7 @@ static const struct usb_device_id produc
+ 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0620)},	/* Quectel EM160R-GL */
+ 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0800)},	/* Quectel RM500Q-GL */
+ 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0801)},	/* Quectel RM520N */
++	{QMI_MATCH_FF_FF_FF(0x05c6, 0xf601)},	/* MeigLink SLM750 */
+ 
+ 	/* 3. Combined interface devices matching on interface number */
+ 	{QMI_FIXED_INTF(0x0408, 0xea42, 4)},	/* Yota / Megafon M100-1 */
+--- a/drivers/usb/serial/option.c
++++ b/drivers/usb/serial/option.c
+@@ -247,6 +247,11 @@ static void option_instat_callback(struc
+ #define UBLOX_PRODUCT_R410M			0x90b2
+ /* These Yuga products use Qualcomm's vendor ID */
+ #define YUGA_PRODUCT_CLM920_NC5			0x9625
++/* These MeigLink products use Qualcomm's vendor ID */
++#define MEIGLINK_PRODUCT_SLM750			0xf601
++
++#define MEIGLINK_VENDOR_ID			0x2dee
++#define MEIGLINK_PRODUCT_SLM828			0x4d49
+ 
+ #define QUECTEL_VENDOR_ID			0x2c7c
+ /* These Quectel products use Quectel's vendor ID */
+@@ -1154,6 +1159,11 @@ static const struct usb_device_id option
+ 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x0023)}, /* ONYX 3G device */
+ 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000), /* SIMCom SIM5218 */
+ 	  .driver_info = NCTRL(0) | NCTRL(1) | NCTRL(2) | NCTRL(3) | RSVD(4) },
++	/* MeiG */
++	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGLINK_VENDOR_ID, MEIGLINK_PRODUCT_SLM828, USB_CLASS_VENDOR_SPEC, 0x10, 0x01) },
++	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGLINK_VENDOR_ID, MEIGLINK_PRODUCT_SLM828, USB_CLASS_VENDOR_SPEC, 0x10, 0x02) },
++	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGLINK_VENDOR_ID, MEIGLINK_PRODUCT_SLM828, USB_CLASS_VENDOR_SPEC, 0x10, 0x03) },
++	{ USB_DEVICE_AND_INTERFACE_INFO(MEIGLINK_VENDOR_ID, MEIGLINK_PRODUCT_SLM828, USB_CLASS_VENDOR_SPEC, 0x10, 0x04) },
+ 	/* Quectel products using Qualcomm vendor ID */
+ 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, QUECTEL_PRODUCT_UC15)},
+ 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, QUECTEL_PRODUCT_UC20),
+@@ -1195,6 +1205,11 @@ static const struct usb_device_id option
+ 	  .driver_info = ZLP },
+ 	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96),
+ 	  .driver_info = RSVD(4) },
++	/* Meiglink products using Qualcomm vendor ID */
++	// Works OK. In case of some issues check macros that are used by Quectel Products
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, MEIGLINK_PRODUCT_SLM750, 0xff, 0xff, 0xff),
++	  .driver_info = NUMEP2 },
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, MEIGLINK_PRODUCT_SLM750, 0xff, 0, 0) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0xff, 0xff),
+ 	  .driver_info = RSVD(1) | RSVD(2) | RSVD(3) | RSVD(4) | NUMEP2 },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0, 0) },
diff --git a/target/linux/generic/hack-6.12/781-usb-net-rndis-support-asr.patch b/target/linux/generic/hack-6.12/781-usb-net-rndis-support-asr.patch
new file mode 100644
index 0000000000..47339b6c22
--- /dev/null
+++ b/target/linux/generic/hack-6.12/781-usb-net-rndis-support-asr.patch
@@ -0,0 +1,69 @@
+From 9fabf60187f1fa19e6f6bb5441587d485bd534b0 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Tue, 9 Apr 2024 17:06:38 +0100
+Subject: [PATCH] rndis_host: add a bunch of USB IDs
+
+Add a bunch of USB IDs found in various places online to the
+RNDIS USB network driver.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/usb/rndis_host.c | 40 ++++++++++++++++++++++
+ 1 file changed, 40 insertions(+)
+
+--- a/drivers/net/usb/rndis_host.c
++++ b/drivers/net/usb/rndis_host.c
+@@ -630,6 +630,16 @@ static const struct driver_info	zte_rndi
+ 	.tx_fixup =	rndis_tx_fixup,
+ };
+ 
++static const struct driver_info asr_rndis_info = {
++	.description =	"Asr RNDIS device",
++	.flags =	FLAG_WWAN | FLAG_POINTTOPOINT | FLAG_FRAMING_RN | FLAG_NO_SETINT | FLAG_NOARP,
++	.bind =		rndis_bind,
++	.unbind =	rndis_unbind,
++	.status =	rndis_status,
++	.rx_fixup =	rndis_rx_fixup,
++	.tx_fixup =	rndis_tx_fixup,
++};
++
+ /*-------------------------------------------------------------------------*/
+ 
+ static const struct usb_device_id	products [] = {
+@@ -666,6 +676,36 @@ static const struct usb_device_id	produc
+ 	USB_INTERFACE_INFO(USB_CLASS_WIRELESS_CONTROLLER, 1, 3),
+ 	.driver_info = (unsigned long) &rndis_info,
+ }, {
++	/* Quectel EG060V rndis device */
++	USB_DEVICE_AND_INTERFACE_INFO(0x2c7c, 0x6004,
++				      USB_CLASS_WIRELESS_CONTROLLER, 1, 3),
++	.driver_info = (unsigned long) &asr_rndis_info,
++}, {
++	/* Quectel EC200A rndis device */
++	USB_DEVICE_AND_INTERFACE_INFO(0x2c7c, 0x6005,
++				      USB_CLASS_WIRELESS_CONTROLLER, 1, 3),
++	.driver_info = (unsigned long) &asr_rndis_info,
++}, {
++	/* Quectel EC200T rndis device */
++	USB_DEVICE_AND_INTERFACE_INFO(0x2c7c, 0x6026,
++				      USB_CLASS_WIRELESS_CONTROLLER, 1, 3),
++	.driver_info = (unsigned long) &asr_rndis_info,
++}, {
++	/* Simcom A7906E rndis device */
++	USB_DEVICE_AND_INTERFACE_INFO(0x1e0e, 0x9011,
++				      USB_CLASS_WIRELESS_CONTROLLER, 1, 3),
++	.driver_info = (unsigned long) &asr_rndis_info,
++}, {
++	/* Meig SLM770A */
++	USB_DEVICE_AND_INTERFACE_INFO(0x2dee, 0x4d57,
++				      USB_CLASS_WIRELESS_CONTROLLER, 1, 3),
++	.driver_info = (unsigned long) &asr_rndis_info,
++}, {
++	/* Meig SLM828 */
++	USB_DEVICE_AND_INTERFACE_INFO(0x2dee, 0x4d49,
++				      USB_CLASS_WIRELESS_CONTROLLER, 1, 3),
++	.driver_info = (unsigned long) &asr_rndis_info,
++}, {
+ 	/* Novatel Verizon USB730L */
+ 	USB_INTERFACE_INFO(USB_CLASS_MISC, 4, 1),
+ 	.driver_info = (unsigned long) &rndis_info,
diff --git a/target/linux/generic/hack-6.12/800-GPIO-add-named-gpio-exports.patch b/target/linux/generic/hack-6.12/800-GPIO-add-named-gpio-exports.patch
new file mode 100644
index 0000000000..3bfc612c13
--- /dev/null
+++ b/target/linux/generic/hack-6.12/800-GPIO-add-named-gpio-exports.patch
@@ -0,0 +1,172 @@
+From cc809a441d8f2924f785eb863dfa6aef47a25b0b Mon Sep 17 00:00:00 2001
+From: John Crispin <blogic@openwrt.org>
+Date: Tue, 12 Aug 2014 20:49:27 +0200
+Subject: [PATCH 30/36] GPIO: add named gpio exports
+
+Signed-off-by: John Crispin <blogic@openwrt.org>
+--- a/drivers/gpio/gpiolib-of.c
++++ b/drivers/gpio/gpiolib-of.c
+@@ -21,6 +21,8 @@
+ 
+ #include <linux/gpio/consumer.h>
+ #include <linux/gpio/machine.h>
++#include <linux/init.h>
++#include <linux/platform_device.h>
+ 
+ #include "gpiolib.h"
+ #include "gpiolib-of.h"
+@@ -1189,3 +1191,73 @@ void of_gpiochip_remove(struct gpio_chip
+ {
+ 	of_node_put(dev_of_node(&chip->gpiodev->dev));
+ }
++
++#ifdef CONFIG_GPIO_SYSFS
++
++static struct of_device_id gpio_export_ids[] = {
++	{ .compatible = "gpio-export" },
++	{ /* sentinel */ }
++};
++
++static int of_gpio_export_probe(struct platform_device *pdev)
++{
++	struct device_node *np = pdev->dev.of_node;
++	struct device_node *cnp;
++	u32 val;
++	int nb = 0;
++
++	for_each_child_of_node(np, cnp) {
++		const char *name = NULL;
++		int gpio;
++		bool dmc;
++		int max_gpio = 1;
++		int i;
++
++		of_property_read_string(cnp, "gpio-export,name", &name);
++
++		if (!name)
++			max_gpio = of_gpio_named_count(cnp, "gpios");
++
++		for (i = 0; i < max_gpio; i++) {
++			struct gpio_desc *desc;
++			unsigned flags = 0;
++			enum of_gpio_flags of_flags;
++
++			desc = of_get_named_gpiod_flags(cnp, "gpios", i, &of_flags);
++			if (IS_ERR(desc))
++				return PTR_ERR(desc);
++			gpio = desc_to_gpio(desc);
++
++			if (of_flags & OF_GPIO_ACTIVE_LOW)
++				flags |= GPIOF_ACTIVE_LOW;
++
++			if (!of_property_read_u32(cnp, "gpio-export,output", &val))
++				flags |= val ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
++			else
++				flags |= GPIOF_IN;
++
++			if (devm_gpio_request_one(&pdev->dev, gpio, flags, name ? name : of_node_full_name(np)))
++				continue;
++
++			dmc = of_property_read_bool(cnp, "gpio-export,direction_may_change");
++			gpio_export_with_name(gpio_to_desc(gpio), dmc, name);
++			nb++;
++		}
++	}
++
++	dev_info(&pdev->dev, "%d gpio(s) exported\n", nb);
++
++	return 0;
++}
++
++static struct platform_driver gpio_export_driver = {
++	.driver		= {
++		.name		= "gpio-export",
++		.of_match_table	= of_match_ptr(gpio_export_ids),
++	},
++	.probe		= of_gpio_export_probe,
++};
++
++module_platform_driver(gpio_export_driver);
++
++#endif
+--- a/include/linux/gpio/consumer.h
++++ b/include/linux/gpio/consumer.h
+@@ -628,7 +628,10 @@ static inline int devm_acpi_dev_add_driv
+ 
+ #if IS_ENABLED(CONFIG_GPIOLIB) && IS_ENABLED(CONFIG_GPIO_SYSFS)
+ 
++int __gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name);
+ int gpiod_export(struct gpio_desc *desc, bool direction_may_change);
++int gpio_export_with_name(struct gpio_desc *desc, bool direction_may_change,
++			  const char *name);
+ int gpiod_export_link(struct device *dev, const char *name,
+ 		      struct gpio_desc *desc);
+ void gpiod_unexport(struct gpio_desc *desc);
+@@ -637,11 +640,25 @@ void gpiod_unexport(struct gpio_desc *de
+ 
+ #include <asm/errno.h>
+ 
++static inline int __gpiod_export(struct gpio_desc *desc,
++			       bool direction_may_change,
++			       const char *name)
++{
++	return -ENOSYS;
++}
++
+ static inline int gpiod_export(struct gpio_desc *desc,
+ 			       bool direction_may_change)
+ {
+ 	return -ENOSYS;
+ }
++
++static inline int gpio_export_with_name(struct gpio_desc *desc,
++					bool direction_may_change,
++					const char *name)
++{
++	return -ENOSYS;
++}
+ 
+ static inline int gpiod_export_link(struct device *dev, const char *name,
+ 				    struct gpio_desc *desc)
+--- a/drivers/gpio/gpiolib-sysfs.c
++++ b/drivers/gpio/gpiolib-sysfs.c
+@@ -571,7 +571,7 @@ static struct class gpio_class = {
+  * Returns:
+  * 0 on success, or negative errno on failure.
+  */
+-int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
++int __gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name)
+ {
+ 	const char *ioname = NULL;
+ 	struct gpio_device *gdev;
+@@ -629,6 +629,8 @@ int gpiod_export(struct gpio_desc *desc,
+ 	offset = gpio_chip_hwgpio(desc);
+ 	if (guard.gc->names && guard.gc->names[offset])
+ 		ioname = guard.gc->names[offset];
++	if (name)
++		ioname = name;
+ 
+ 	dev = device_create_with_groups(&gpio_class, &gdev->dev,
+ 					MKDEV(0, 0), data, gpio_groups,
+@@ -650,8 +652,21 @@ err_unlock:
+ 	gpiod_dbg(desc, "%s: status %d\n", __func__, status);
+ 	return status;
+ }
++EXPORT_SYMBOL_GPL(__gpiod_export);
++
++int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
++{
++	return __gpiod_export(desc, direction_may_change, NULL);
++}
+ EXPORT_SYMBOL_GPL(gpiod_export);
+ 
++int gpio_export_with_name(struct gpio_desc *desc, bool direction_may_change,
++			  const char *name)
++{
++	return __gpiod_export(desc, direction_may_change, name);
++}
++EXPORT_SYMBOL_GPL(gpio_export_with_name);
++
+ static int match_export(struct device *dev, const void *desc)
+ {
+ 	struct gpiod_data *data = dev_get_drvdata(dev);
diff --git a/target/linux/generic/hack-6.12/810-bcma-ssb-fallback-sprom.patch b/target/linux/generic/hack-6.12/810-bcma-ssb-fallback-sprom.patch
new file mode 100644
index 0000000000..08085d957a
--- /dev/null
+++ b/target/linux/generic/hack-6.12/810-bcma-ssb-fallback-sprom.patch
@@ -0,0 +1,182 @@
+From e4d708702e6c98f2111e33201a264d6788564cb2 Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Fri, 12 May 2023 11:08:43 +0200
+Subject: [PATCH] ssb_sprom: add generic kernel support for Broadcom  Fallback SPROMs
+
+---
+ drivers/bcma/Kconfig        |  4 ++++
+ drivers/bcma/Makefile       |  1 +
+ drivers/bcma/bcma_private.h |  1 +
+ drivers/bcma/main.c         |  8 ++++++++
+ drivers/bcma/sprom.c        | 23 ++++++++++++++---------
+ drivers/ssb/Kconfig         |  5 +++++
+ drivers/ssb/Makefile        |  1 +
+ drivers/ssb/main.c          |  8 ++++++++
+ drivers/ssb/sprom.c         | 12 +++++++++++-
+ drivers/ssb/ssb_private.h   |  2 +-
+ 10 files changed, 54 insertions(+), 11 deletions(-)
+
+--- a/drivers/bcma/Kconfig
++++ b/drivers/bcma/Kconfig
+@@ -18,6 +18,10 @@ config BCMA_BLOCKIO
+ 	bool
+ 	default y
+ 
++config BCMA_FALLBACK_SPROM
++	bool
++	default y
++
+ config BCMA_HOST_PCI_POSSIBLE
+ 	bool
+ 	depends on PCI = y
+--- a/drivers/bcma/Makefile
++++ b/drivers/bcma/Makefile
+@@ -11,6 +11,7 @@ bcma-$(CONFIG_BCMA_DRIVER_PCI_HOSTMODE)
+ bcma-$(CONFIG_BCMA_DRIVER_MIPS)		+= driver_mips.o
+ bcma-$(CONFIG_BCMA_DRIVER_GMAC_CMN)	+= driver_gmac_cmn.o
+ bcma-$(CONFIG_BCMA_DRIVER_GPIO)		+= driver_gpio.o
++bcma-$(CONFIG_BCMA_FALLBACK_SPROM)	+= fallback-sprom.o
+ bcma-$(CONFIG_BCMA_HOST_PCI)		+= host_pci.o
+ bcma-$(CONFIG_BCMA_HOST_SOC)		+= host_soc.o
+ obj-$(CONFIG_BCMA)			+= bcma.o
+--- a/drivers/bcma/bcma_private.h
++++ b/drivers/bcma/bcma_private.h
+@@ -8,6 +8,7 @@
+ 
+ #include <linux/bcma/bcma.h>
+ #include <linux/delay.h>
++#include "fallback-sprom.h"
+ 
+ #define bcma_err(bus, fmt, ...) \
+ 	dev_err((bus)->dev, "bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
+--- a/drivers/bcma/main.c
++++ b/drivers/bcma/main.c
+@@ -671,6 +671,14 @@ static int __init bcma_modinit(void)
+ {
+ 	int err;
+ 
++#ifdef CONFIG_BCMA_FALLBACK_SPROM
++	err = bcma_fbs_register();
++	if (err) {
++		pr_err("Fallback SPROM initialization failed\n");
++		err = 0;
++	}
++#endif /* CONFIG_BCMA_FALLBACK_SPROM */
++
+ 	err = bcma_init_bus_register();
+ 	if (err)
+ 		return err;
+--- a/drivers/bcma/sprom.c
++++ b/drivers/bcma/sprom.c
+@@ -51,21 +51,26 @@ static int bcma_fill_sprom_with_fallback
+ {
+ 	int err;
+ 
+-	if (!get_fallback_sprom) {
++	if (get_fallback_sprom)
++		err = get_fallback_sprom(bus, out);
++
++#ifdef CONFIG_BCMA_FALLBACK_SPROM
++	if (!get_fallback_sprom || err)
++		err = bcma_get_fallback_sprom(bus, out);
++#else
++	if (!get_fallback_sprom)
+ 		err = -ENOENT;
+-		goto fail;
+-	}
++#endif /* CONFIG_BCMA_FALLBACK_SPROM */
+ 
+-	err = get_fallback_sprom(bus, out);
+-	if (err)
+-		goto fail;
++	if (err) {
++		bcma_warn(bus, "Using fallback SPROM failed (err %d)\n", err);
++		return err;
++	}
+ 
+ 	bcma_debug(bus, "Using SPROM revision %d provided by platform.\n",
+ 		   bus->sprom.revision);
++
+ 	return 0;
+-fail:
+-	bcma_warn(bus, "Using fallback SPROM failed (err %d)\n", err);
+-	return err;
+ }
+ 
+ /**************************************************
+--- a/drivers/ssb/Kconfig
++++ b/drivers/ssb/Kconfig
+@@ -25,6 +25,11 @@ if SSB
+ config SSB_SPROM
+ 	bool
+ 
++config SSB_FALLBACK_SPROM
++	bool
++	depends on SSB_PCIHOST
++	default y
++
+ # Support for Block-I/O. SELECT this from the driver that needs it.
+ config SSB_BLOCKIO
+ 	bool
+--- a/drivers/ssb/Makefile
++++ b/drivers/ssb/Makefile
+@@ -2,6 +2,7 @@
+ # core
+ ssb-y					+= main.o scan.o
+ ssb-$(CONFIG_SSB_EMBEDDED)		+= embedded.o
++ssb-$(CONFIG_SSB_FALLBACK_SPROM)	+= fallback-sprom.o
+ ssb-$(CONFIG_SSB_SPROM)			+= sprom.o
+ 
+ # host support
+--- a/drivers/ssb/main.c
++++ b/drivers/ssb/main.c
+@@ -1289,6 +1289,14 @@ static int __init ssb_modinit(void)
+ {
+ 	int err;
+ 
++#ifdef CONFIG_SSB_FALLBACK_SPROM
++	err = ssb_fbs_register();
++	if (err) {
++		pr_err("Fallback SPROM initialization failed\n");
++		err = 0;
++	}
++#endif /* CONFIG_SSB_FALLBACK_SPROM */
++
+ 	/* See the comment at the ssb_is_early_boot definition */
+ 	ssb_is_early_boot = 0;
+ 	err = bus_register(&ssb_bustype);
+--- a/drivers/ssb/sprom.c
++++ b/drivers/ssb/sprom.c
+@@ -180,10 +180,20 @@ int ssb_arch_register_fallback_sprom(int
+ 
+ int ssb_fill_sprom_with_fallback(struct ssb_bus *bus, struct ssb_sprom *out)
+ {
++	int err;
++
++	if (get_fallback_sprom)
++		err = get_fallback_sprom(bus, out);
++
++#ifdef CONFIG_SSB_FALLBACK_SPROM
++	if (!get_fallback_sprom || err)
++		err = ssb_get_fallback_sprom(bus, out);
++#else
+ 	if (!get_fallback_sprom)
+ 		return -ENOENT;
++#endif /* CONFIG_SSB_FALLBACK_SPROM */
+ 
+-	return get_fallback_sprom(bus, out);
++	return err;
+ }
+ 
+ /* https://bcm-v4.sipsolutions.net/802.11/IsSpromAvailable */
+--- a/drivers/ssb/ssb_private.h
++++ b/drivers/ssb/ssb_private.h
+@@ -8,7 +8,7 @@
+ #include <linux/ssb/ssb.h>
+ #include <linux/types.h>
+ #include <linux/bcm47xx_wdt.h>
+-
++#include "fallback-sprom.h"
+ 
+ /* pci.c */
+ #ifdef CONFIG_SSB_PCIHOST
diff --git a/target/linux/generic/hack-6.12/901-debloat_sock_diag.patch b/target/linux/generic/hack-6.12/901-debloat_sock_diag.patch
new file mode 100644
index 0000000000..d130b82dd6
--- /dev/null
+++ b/target/linux/generic/hack-6.12/901-debloat_sock_diag.patch
@@ -0,0 +1,181 @@
+From 3b6115d6b57a263bdc8c9b1df273bd4a7955eead Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 8 Jul 2017 08:16:31 +0200
+Subject: debloat: add some debloat patches, strip down procfs and make O_DIRECT support optional, saves ~15K after lzma on MIPS
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ net/Kconfig         | 3 +++
+ net/core/Makefile   | 3 ++-
+ net/core/sock.c     | 2 ++
+ net/ipv4/Kconfig    | 1 +
+ net/netlink/Kconfig | 1 +
+ net/packet/Kconfig  | 1 +
+ net/unix/Kconfig    | 1 +
+ 7 files changed, 11 insertions(+), 1 deletion(-)
+
+--- a/net/Kconfig
++++ b/net/Kconfig
+@@ -138,6 +138,9 @@ source "net/mptcp/Kconfig"
+ 
+ endif # if INET
+ 
++config SOCK_DIAG
++	bool
++
+ config NETWORK_SECMARK
+ 	bool "Security Marking"
+ 	help
+--- a/net/core/Makefile
++++ b/net/core/Makefile
+@@ -11,12 +11,13 @@ obj-$(CONFIG_SYSCTL) += sysctl_net_core.
+ 
+ obj-y		     += dev.o dev_addr_lists.o dst.o netevent.o \
+ 			neighbour.o rtnetlink.o utils.o link_watch.o filter.o \
+-			sock_diag.o dev_ioctl.o tso.o sock_reuseport.o \
++			dev_ioctl.o tso.o sock_reuseport.o \
+ 			fib_notifier.o xdp.o flow_offload.o gro.o \
+ 			netdev-genl.o netdev-genl-gen.o gso.o
+ 
+ obj-$(CONFIG_NETDEV_ADDR_LIST_TEST) += dev_addr_lists_test.o
+ 
++obj-$(CONFIG_SOCK_DIAG) += sock_diag.o
+ obj-y += net-sysfs.o
+ obj-y += hotdata.o
+ obj-y += netdev_rx_queue.o
+--- a/net/core/sock.c
++++ b/net/core/sock.c
+@@ -118,6 +118,7 @@
+ #include <linux/mroute.h>
+ #include <linux/mroute6.h>
+ #include <linux/icmpv6.h>
++#include <linux/cookie.h>
+ 
+ #include <linux/uaccess.h>
+ 
+@@ -152,6 +153,7 @@
+ 
+ static DEFINE_MUTEX(proto_list_mutex);
+ static LIST_HEAD(proto_list);
++DEFINE_COOKIE(sock_cookie);
+ 
+ static void sock_def_write_space_wfree(struct sock *sk);
+ static void sock_def_write_space(struct sock *sk);
+@@ -587,6 +589,21 @@ discard_and_relse:
+ }
+ EXPORT_SYMBOL(__sk_receive_skb);
+ 
++u64 __sock_gen_cookie(struct sock *sk)
++{
++	u64 res = atomic64_read(&sk->sk_cookie);
++
++	if (!res) {
++		u64 new = gen_cookie_next(&sock_cookie);
++
++		atomic64_cmpxchg(&sk->sk_cookie, res, new);
++
++		/* Another thread might have changed sk_cookie before us. */
++		res = atomic64_read(&sk->sk_cookie);
++	}
++	return res;
++}
++
+ INDIRECT_CALLABLE_DECLARE(struct dst_entry *ip6_dst_check(struct dst_entry *,
+ 							  u32));
+ INDIRECT_CALLABLE_DECLARE(struct dst_entry *ipv4_dst_check(struct dst_entry *,
+@@ -2326,9 +2343,11 @@ static void __sk_free(struct sock *sk)
+ 	if (likely(sk->sk_net_refcnt))
+ 		sock_inuse_add(sock_net(sk), -1);
+ 
++#ifdef CONFIG_SOCK_DIAG
+ 	if (unlikely(sk->sk_net_refcnt && sock_diag_has_destroy_listeners(sk)))
+ 		sock_diag_broadcast_destroy(sk);
+ 	else
++#endif
+ 		sk_destruct(sk);
+ }
+ 
+--- a/net/core/sock_diag.c
++++ b/net/core/sock_diag.c
+@@ -12,7 +12,6 @@
+ #include <linux/tcp.h>
+ #include <linux/workqueue.h>
+ #include <linux/nospec.h>
+-#include <linux/cookie.h>
+ #include <linux/inet_diag.h>
+ #include <linux/sock_diag.h>
+ 
+@@ -22,23 +21,6 @@ static const struct sock_diag_inet_compa
+ 
+ static struct workqueue_struct *broadcast_wq;
+ 
+-DEFINE_COOKIE(sock_cookie);
+-
+-u64 __sock_gen_cookie(struct sock *sk)
+-{
+-	u64 res = atomic64_read(&sk->sk_cookie);
+-
+-	if (!res) {
+-		u64 new = gen_cookie_next(&sock_cookie);
+-
+-		atomic64_cmpxchg(&sk->sk_cookie, res, new);
+-
+-		/* Another thread might have changed sk_cookie before us. */
+-		res = atomic64_read(&sk->sk_cookie);
+-	}
+-	return res;
+-}
+-
+ int sock_diag_check_cookie(struct sock *sk, const __u32 *cookie)
+ {
+ 	u64 res;
+--- a/net/ipv4/Kconfig
++++ b/net/ipv4/Kconfig
+@@ -423,6 +423,7 @@ config INET_TUNNEL
+ 
+ config INET_DIAG
+ 	tristate "INET: socket monitoring interface"
++	select SOCK_DIAG
+ 	default y
+ 	help
+ 	  Support for INET (TCP, DCCP, etc) socket monitoring interface used by
+--- a/net/netlink/Kconfig
++++ b/net/netlink/Kconfig
+@@ -5,6 +5,7 @@
+ 
+ config NETLINK_DIAG
+ 	tristate "NETLINK: socket monitoring interface"
++	select SOCK_DIAG
+ 	default n
+ 	help
+ 	  Support for NETLINK socket monitoring interface used by the ss tool.
+--- a/net/packet/Kconfig
++++ b/net/packet/Kconfig
+@@ -19,6 +19,7 @@ config PACKET
+ config PACKET_DIAG
+ 	tristate "Packet: sockets monitoring interface"
+ 	depends on PACKET
++	select SOCK_DIAG
+ 	default n
+ 	help
+ 	  Support for PF_PACKET sockets monitoring interface used by the ss tool.
+--- a/net/unix/Kconfig
++++ b/net/unix/Kconfig
+@@ -24,6 +24,7 @@ config	AF_UNIX_OOB
+ config UNIX_DIAG
+ 	tristate "UNIX: socket monitoring interface"
+ 	depends on UNIX
++	select SOCK_DIAG
+ 	default n
+ 	help
+ 	  Support for UNIX socket monitoring interface used by the ss tool.
+--- a/net/xdp/Kconfig
++++ b/net/xdp/Kconfig
+@@ -10,6 +10,7 @@ config XDP_SOCKETS
+ config XDP_SOCKETS_DIAG
+ 	tristate "XDP sockets: monitoring interface"
+ 	depends on XDP_SOCKETS
++	select SOCK_DIAG
+ 	default n
+ 	help
+ 	  Support for PF_XDP sockets monitoring interface used by the ss tool.
diff --git a/target/linux/generic/hack-6.12/902-debloat_proc.patch b/target/linux/generic/hack-6.12/902-debloat_proc.patch
new file mode 100644
index 0000000000..5c8be5fe2d
--- /dev/null
+++ b/target/linux/generic/hack-6.12/902-debloat_proc.patch
@@ -0,0 +1,419 @@
+From 9e3f1d0805b2d919904dd9a4ff0d956314cc3cba Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 8 Jul 2017 08:20:09 +0200
+Subject: debloat: procfs
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ fs/locks.c               |  2 ++
+ fs/proc/Kconfig          |  5 +++++
+ fs/proc/consoles.c       |  3 +++
+ fs/proc/proc_tty.c       | 11 ++++++++++-
+ include/net/snmp.h       | 18 +++++++++++++++++-
+ ipc/msg.c                |  3 +++
+ ipc/sem.c                |  2 ++
+ ipc/shm.c                |  2 ++
+ ipc/util.c               |  3 +++
+ kernel/exec_domain.c     |  2 ++
+ kernel/irq/proc.c        |  9 +++++++++
+ kernel/time/timer_list.c |  2 ++
+ mm/vmalloc.c             |  2 ++
+ mm/vmstat.c              |  8 +++++---
+ net/8021q/vlanproc.c     |  6 ++++++
+ net/core/net-procfs.c    | 18 ++++++++++++------
+ net/core/sock.c          |  2 ++
+ net/ipv4/fib_trie.c      | 18 ++++++++++++------
+ net/ipv4/proc.c          |  3 +++
+ net/ipv4/route.c         |  3 +++
+ 20 files changed, 105 insertions(+), 17 deletions(-)
+
+--- a/fs/locks.c
++++ b/fs/locks.c
+@@ -2971,6 +2971,8 @@ static const struct seq_operations locks
+ 
+ static int __init proc_locks_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	proc_create_seq_private("locks", 0, NULL, &locks_seq_operations,
+ 			sizeof(struct locks_iterator), NULL);
+ 	return 0;
+--- a/fs/proc/Kconfig
++++ b/fs/proc/Kconfig
+@@ -101,6 +101,11 @@ config PROC_CHILDREN
+ 	  Say Y if you are running any user-space software which takes benefit from
+ 	  this interface. For example, rkt is such a piece of software.
+ 
++config PROC_STRIPPED
++	default n
++	depends on EXPERT
++	bool "Strip non-essential /proc functionality to reduce code size"
++
+ config PROC_PID_ARCH_STATUS
+ 	def_bool n
+ 	depends on PROC_FS
+--- a/fs/proc/consoles.c
++++ b/fs/proc/consoles.c
+@@ -110,6 +110,9 @@ static const struct seq_operations conso
+ 
+ static int __init proc_consoles_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	proc_create_seq("consoles", 0, NULL, &consoles_op);
+ 	return 0;
+ }
+--- a/fs/proc/proc_tty.c
++++ b/fs/proc/proc_tty.c
+@@ -131,7 +131,10 @@ static const struct seq_operations tty_d
+ void proc_tty_register_driver(struct tty_driver *driver)
+ {
+ 	struct proc_dir_entry *ent;
+-		
++
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	if (!driver->driver_name || driver->proc_entry ||
+ 	    !driver->ops->proc_show)
+ 		return;
+@@ -148,6 +151,9 @@ void proc_tty_unregister_driver(struct t
+ {
+ 	struct proc_dir_entry *ent;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	ent = driver->proc_entry;
+ 	if (!ent)
+ 		return;
+@@ -162,6 +168,9 @@ void proc_tty_unregister_driver(struct t
+  */
+ void __init proc_tty_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	if (!proc_mkdir("tty", NULL))
+ 		return;
+ 	proc_mkdir("tty/ldisc", NULL);	/* Preserved: it's userspace visible */
+--- a/include/net/snmp.h
++++ b/include/net/snmp.h
+@@ -124,6 +124,21 @@ struct linux_tls_mib {
+ #define DECLARE_SNMP_STAT(type, name)	\
+ 	extern __typeof__(type) __percpu *name
+ 
++#ifdef CONFIG_PROC_STRIPPED
++#define __SNMP_STATS_DUMMY(mib)	\
++	do { (void) mib->mibs[0]; } while(0)
++
++#define __SNMP_INC_STATS(mib, field) __SNMP_STATS_DUMMY(mib)
++#define SNMP_INC_STATS_ATOMIC_LONG(mib, field) __SNMP_STATS_DUMMY(mib)
++#define SNMP_INC_STATS(mib, field) __SNMP_STATS_DUMMY(mib)
++#define SNMP_DEC_STATS(mib, field) __SNMP_STATS_DUMMY(mib)
++#define __SNMP_ADD_STATS(mib, field, addend) __SNMP_STATS_DUMMY(mib)
++#define SNMP_ADD_STATS(mib, field, addend) __SNMP_STATS_DUMMY(mib)
++#define SNMP_UPD_PO_STATS(mib, basefield, addend) __SNMP_STATS_DUMMY(mib)
++#define __SNMP_UPD_PO_STATS(mib, basefield, addend) __SNMP_STATS_DUMMY(mib)
++
++#else
++
+ #define __SNMP_INC_STATS(mib, field)	\
+ 			__this_cpu_inc(mib->mibs[field])
+ 
+@@ -154,8 +169,9 @@ struct linux_tls_mib {
+ 		__this_cpu_add(ptr[basefield##OCTETS], addend);	\
+ 	} while (0)
+ 
++#endif
+ 
+-#if BITS_PER_LONG==32
++#if (BITS_PER_LONG==32) && !defined(CONFIG_PROC_STRIPPED)
+ 
+ #define __SNMP_ADD_STATS64(mib, field, addend) 				\
+ 	do {								\
+--- a/ipc/msg.c
++++ b/ipc/msg.c
+@@ -1370,6 +1370,9 @@ void __init msg_init(void)
+ {
+ 	msg_init_ns(&init_ipc_ns);
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	ipc_init_proc_interface("sysvipc/msg",
+ 				"       key      msqid perms      cbytes       qnum lspid lrpid   uid   gid  cuid  cgid      stime      rtime      ctime\n",
+ 				IPC_MSG_IDS, sysvipc_msg_proc_show);
+--- a/ipc/sem.c
++++ b/ipc/sem.c
+@@ -268,6 +268,8 @@ void sem_exit_ns(struct ipc_namespace *n
+ void __init sem_init(void)
+ {
+ 	sem_init_ns(&init_ipc_ns);
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
+ 	ipc_init_proc_interface("sysvipc/sem",
+ 				"       key      semid perms      nsems   uid   gid  cuid  cgid      otime      ctime\n",
+ 				IPC_SEM_IDS, sysvipc_sem_proc_show);
+--- a/ipc/shm.c
++++ b/ipc/shm.c
+@@ -155,6 +155,8 @@ pure_initcall(ipc_ns_init);
+ 
+ void __init shm_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
+ 	ipc_init_proc_interface("sysvipc/shm",
+ #if BITS_PER_LONG <= 32
+ 				"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\n",
+--- a/ipc/util.c
++++ b/ipc/util.c
+@@ -141,6 +141,9 @@ void __init ipc_init_proc_interface(cons
+ 	struct proc_dir_entry *pde;
+ 	struct ipc_proc_iface *iface;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	iface = kmalloc(sizeof(*iface), GFP_KERNEL);
+ 	if (!iface)
+ 		return;
+--- a/kernel/exec_domain.c
++++ b/kernel/exec_domain.c
+@@ -29,6 +29,8 @@ static int execdomains_proc_show(struct
+ 
+ static int __init proc_execdomains_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	proc_create_single("execdomains", 0, NULL, execdomains_proc_show);
+ 	return 0;
+ }
+--- a/kernel/irq/proc.c
++++ b/kernel/irq/proc.c
+@@ -339,6 +339,9 @@ void register_irq_proc(unsigned int irq,
+ 	void __maybe_unused *irqp = (void *)(unsigned long) irq;
+ 	char name [MAX_NAMELEN];
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
++		return;
++
+ 	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))
+ 		return;
+ 
+@@ -397,6 +400,9 @@ void unregister_irq_proc(unsigned int ir
+ {
+ 	char name [MAX_NAMELEN];
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
++		return;
++
+ 	if (!root_irq_dir || !desc->dir)
+ 		return;
+ #ifdef CONFIG_SMP
+@@ -435,6 +441,9 @@ void init_irq_proc(void)
+ 	unsigned int irq;
+ 	struct irq_desc *desc;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
++		return;
++
+ 	/* create /proc/irq */
+ 	root_irq_dir = proc_mkdir("irq", NULL);
+ 	if (!root_irq_dir)
+--- a/kernel/time/timer_list.c
++++ b/kernel/time/timer_list.c
+@@ -354,6 +354,8 @@ static int __init init_timer_list_procfs
+ {
+ 	struct proc_dir_entry *pe;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	pe = proc_create_seq_private("timer_list", 0400, NULL, &timer_list_sops,
+ 			sizeof(struct timer_list_iter), NULL);
+ 	if (!pe)
+--- a/mm/vmalloc.c
++++ b/mm/vmalloc.c
+@@ -5034,6 +5034,8 @@ static int __init proc_vmalloc_init(void
+ {
+ 	void *priv_data = NULL;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	if (IS_ENABLED(CONFIG_NUMA))
+ 		priv_data = kmalloc(nr_node_ids * sizeof(unsigned int), GFP_KERNEL);
+ 
+--- a/mm/vmstat.c
++++ b/mm/vmstat.c
+@@ -2195,10 +2195,12 @@ void __init init_mm_internals(void)
+ 	start_shepherd_timer();
+ #endif
+ #ifdef CONFIG_PROC_FS
+-	proc_create_seq("buddyinfo", 0444, NULL, &fragmentation_op);
+-	proc_create_seq("pagetypeinfo", 0400, NULL, &pagetypeinfo_op);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
++		proc_create_seq("buddyinfo", 0444, NULL, &fragmentation_op);
++		proc_create_seq("pagetypeinfo", 0400, NULL, &pagetypeinfo_op);
++		proc_create_seq("zoneinfo", 0444, NULL, &zoneinfo_op);
++	}
+ 	proc_create_seq("vmstat", 0444, NULL, &vmstat_op);
+-	proc_create_seq("zoneinfo", 0444, NULL, &zoneinfo_op);
+ #endif
+ }
+ 
+--- a/net/8021q/vlanproc.c
++++ b/net/8021q/vlanproc.c
+@@ -93,6 +93,9 @@ void vlan_proc_cleanup(struct net *net)
+ {
+ 	struct vlan_net *vn = net_generic(net, vlan_net_id);
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	if (vn->proc_vlan_conf)
+ 		remove_proc_entry(name_conf, vn->proc_vlan_dir);
+ 
+@@ -112,6 +115,9 @@ int __net_init vlan_proc_init(struct net
+ {
+ 	struct vlan_net *vn = net_generic(net, vlan_net_id);
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	vn->proc_vlan_dir = proc_net_mkdir(net, name_root, net->proc_net);
+ 	if (!vn->proc_vlan_dir)
+ 		goto err;
+--- a/net/core/net-procfs.c
++++ b/net/core/net-procfs.c
+@@ -295,10 +295,12 @@ static int __net_init dev_proc_net_init(
+ 	if (!proc_create_net("dev", 0444, net->proc_net, &dev_seq_ops,
+ 			sizeof(struct seq_net_private)))
+ 		goto out;
+-	if (!proc_create_seq("softnet_stat", 0444, net->proc_net,
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++			!proc_create_seq("softnet_stat", 0444, net->proc_net,
+ 			 &softnet_seq_ops))
+ 		goto out_dev;
+-	if (!proc_create_net("ptype", 0444, net->proc_net, &ptype_seq_ops,
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++			!proc_create_net("ptype", 0444, net->proc_net, &ptype_seq_ops,
+ 			sizeof(struct seq_net_private)))
+ 		goto out_softnet;
+ 
+@@ -308,9 +310,11 @@ static int __net_init dev_proc_net_init(
+ out:
+ 	return rc;
+ out_ptype:
+-	remove_proc_entry("ptype", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("ptype", net->proc_net);
+ out_softnet:
+-	remove_proc_entry("softnet_stat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("softnet_stat", net->proc_net);
+ out_dev:
+ 	remove_proc_entry("dev", net->proc_net);
+ 	goto out;
+@@ -320,8 +324,10 @@ static void __net_exit dev_proc_net_exit
+ {
+ 	wext_proc_exit(net);
+ 
+-	remove_proc_entry("ptype", net->proc_net);
+-	remove_proc_entry("softnet_stat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
++		remove_proc_entry("ptype", net->proc_net);
++		remove_proc_entry("softnet_stat", net->proc_net);
++	}
+ 	remove_proc_entry("dev", net->proc_net);
+ }
+ 
+--- a/net/core/sock.c
++++ b/net/core/sock.c
+@@ -4256,6 +4256,8 @@ static __net_initdata struct pernet_oper
+ 
+ static int __init proto_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 	return register_pernet_subsys(&proto_net_ops);
+ }
+ 
+--- a/net/ipv4/fib_trie.c
++++ b/net/ipv4/fib_trie.c
+@@ -3037,11 +3037,13 @@ static const struct seq_operations fib_r
+ 
+ int __net_init fib_proc_init(struct net *net)
+ {
+-	if (!proc_create_net("fib_trie", 0444, net->proc_net, &fib_trie_seq_ops,
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++			!proc_create_net("fib_trie", 0444, net->proc_net, &fib_trie_seq_ops,
+ 			sizeof(struct fib_trie_iter)))
+ 		goto out1;
+ 
+-	if (!proc_create_net_single("fib_triestat", 0444, net->proc_net,
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++			!proc_create_net_single("fib_triestat", 0444, net->proc_net,
+ 			fib_triestat_seq_show, NULL))
+ 		goto out2;
+ 
+@@ -3052,17 +3054,21 @@ int __net_init fib_proc_init(struct net
+ 	return 0;
+ 
+ out3:
+-	remove_proc_entry("fib_triestat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("fib_triestat", net->proc_net);
+ out2:
+-	remove_proc_entry("fib_trie", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("fib_trie", net->proc_net);
+ out1:
+ 	return -ENOMEM;
+ }
+ 
+ void __net_exit fib_proc_exit(struct net *net)
+ {
+-	remove_proc_entry("fib_trie", net->proc_net);
+-	remove_proc_entry("fib_triestat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
++		remove_proc_entry("fib_trie", net->proc_net);
++		remove_proc_entry("fib_triestat", net->proc_net);
++	}
+ 	remove_proc_entry("route", net->proc_net);
+ }
+ 
+--- a/net/ipv4/proc.c
++++ b/net/ipv4/proc.c
+@@ -563,5 +563,8 @@ static __net_initdata struct pernet_oper
+ 
+ int __init ip_misc_proc_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	return register_pernet_subsys(&ip_proc_ops);
+ }
+--- a/net/ipv4/route.c
++++ b/net/ipv4/route.c
+@@ -378,6 +378,9 @@ static struct pernet_operations ip_rt_pr
+ 
+ static int __init ip_rt_proc_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	return register_pernet_subsys(&ip_rt_proc_ops);
+ }
+ 
+--- a/net/ipv4/inet_timewait_sock.c
++++ b/net/ipv4/inet_timewait_sock.c
+@@ -296,7 +296,7 @@ void __inet_twsk_schedule(struct inet_ti
+ 	 */
+ 
+ 	if (!rearm) {
+-		bool kill = timeo <= 4*HZ;
++		bool __maybe_unused  kill = timeo <= 4*HZ;
+ 
+ 		__NET_INC_STATS(twsk_net(tw), kill ? LINUX_MIB_TIMEWAITKILLED :
+ 						     LINUX_MIB_TIMEWAITED);
diff --git a/target/linux/generic/hack-6.12/904-debloat_dma_buf.patch b/target/linux/generic/hack-6.12/904-debloat_dma_buf.patch
new file mode 100644
index 0000000000..2e953023c9
--- /dev/null
+++ b/target/linux/generic/hack-6.12/904-debloat_dma_buf.patch
@@ -0,0 +1,105 @@
+From e3692cb2fcd5ba1244512a0f43b8118f65f1c375 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 8 Jul 2017 08:20:43 +0200
+Subject: debloat: dmabuf
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/base/Kconfig      |  2 +-
+ drivers/dma-buf/Makefile  | 10 +++++++---
+ drivers/dma-buf/dma-buf.c |  4 +++-
+ kernel/sched/core.c       |  1 +
+ net/Kconfig               |  2 +-
+ 5 files changed, 13 insertions(+), 6 deletions(-)
+
+--- a/drivers/base/Kconfig
++++ b/drivers/base/Kconfig
+@@ -198,7 +198,7 @@ config SOC_BUS
+ source "drivers/base/regmap/Kconfig"
+ 
+ config DMA_SHARED_BUFFER
+-	bool
++	tristate
+ 	default n
+ 	select IRQ_WORK
+ 	help
+--- a/drivers/dma-buf/heaps/Makefile
++++ b/drivers/dma-buf/heaps/Makefile
+@@ -1,3 +1,3 @@
+ # SPDX-License-Identifier: GPL-2.0
+-obj-$(CONFIG_DMABUF_HEAPS_SYSTEM)	+= system_heap.o
+-obj-$(CONFIG_DMABUF_HEAPS_CMA)		+= cma_heap.o
++dma-buf-objs-$(CONFIG_DMABUF_HEAPS_SYSTEM)	+= system_heap.o
++dma-buf-objs-$(CONFIG_DMABUF_HEAPS_CMA)		+= cma_heap.o
+--- a/drivers/dma-buf/Makefile
++++ b/drivers/dma-buf/Makefile
+@@ -1,12 +1,14 @@
+ # SPDX-License-Identifier: GPL-2.0-only
+-obj-y := dma-buf.o dma-fence.o dma-fence-array.o dma-fence-chain.o \
++obj-$(CONFIG_DMA_SHARED_BUFFER) := dma-shared-buffer.o
++
++dma-buf-objs-y := dma-buf.o dma-fence.o dma-fence-array.o dma-fence-chain.o \
+ 	 dma-fence-unwrap.o dma-resv.o
+-obj-$(CONFIG_DMABUF_HEAPS)	+= dma-heap.o
+-obj-$(CONFIG_DMABUF_HEAPS)	+= heaps/
+-obj-$(CONFIG_SYNC_FILE)		+= sync_file.o
+-obj-$(CONFIG_SW_SYNC)		+= sw_sync.o sync_debug.o
+-obj-$(CONFIG_UDMABUF)		+= udmabuf.o
+-obj-$(CONFIG_DMABUF_SYSFS_STATS) += dma-buf-sysfs-stats.o
++dma-buf-objs-$(CONFIG_DMABUF_HEAPS)	+= dma-heap.o
++obj-$(CONFIG_DMABUF_HEAPS)		+= heaps/
++dma-buf-objs-$(CONFIG_SYNC_FILE)	+= sync_file.o
++dma-buf-objs-$(CONFIG_SW_SYNC)		+= sw_sync.o sync_debug.o
++dma-buf-objs-$(CONFIG_UDMABUF)		+= udmabuf.o
++dma-buf-objs-$(CONFIG_DMABUF_SYSFS_STATS) += dma-buf-sysfs-stats.o
+ 
+ dmabuf_selftests-y := \
+ 	selftest.o \
+@@ -15,4 +17,6 @@ dmabuf_selftests-y := \
+ 	st-dma-fence-unwrap.o \
+ 	st-dma-resv.o
+ 
+-obj-$(CONFIG_DMABUF_SELFTESTS)	+= dmabuf_selftests.o
++dma-buf-objs-$(CONFIG_DMABUF_SELFTESTS)	+= dmabuf_selftests.o
++
++dma-shared-buffer-objs :=  $(dma-buf-objs-y)
+--- a/drivers/dma-buf/dma-buf.c
++++ b/drivers/dma-buf/dma-buf.c
+@@ -1743,4 +1743,5 @@ static void __exit dma_buf_deinit(void)
+ 	kern_unmount(dma_buf_mnt);
+ 	dma_buf_uninit_sysfs_statistics();
+ }
+-__exitcall(dma_buf_deinit);
++module_exit(dma_buf_deinit);
++MODULE_LICENSE("GPL");
+--- a/kernel/sched/core.c
++++ b/kernel/sched/core.c
+@@ -4422,6 +4422,7 @@ int wake_up_state(struct task_struct *p,
+ {
+ 	return try_to_wake_up(p, state, 0);
+ }
++EXPORT_SYMBOL_GPL(wake_up_state);
+ 
+ /*
+  * Perform scheduler related setup for a newly forked process p.
+--- a/fs/d_path.c
++++ b/fs/d_path.c
+@@ -314,6 +314,7 @@ char *dynamic_dname(char *buffer, int bu
+ 	buffer += buflen - sz;
+ 	return memcpy(buffer, temp, sz);
+ }
++EXPORT_SYMBOL_GPL(dynamic_dname);
+ 
+ char *simple_dname(struct dentry *dentry, char *buffer, int buflen)
+ {
+--- a/net/Kconfig
++++ b/net/Kconfig
+@@ -74,7 +74,7 @@ config SKB_EXTENSIONS
+ 
+ config NET_DEVMEM
+ 	def_bool y
+-	depends on DMA_SHARED_BUFFER
++	depends on DMA_SHARED_BUFFER=y
+ 	depends on GENERIC_ALLOCATOR
+ 	depends on PAGE_POOL
+ 
diff --git a/target/linux/generic/hack-6.12/910-kobject_uevent.patch b/target/linux/generic/hack-6.12/910-kobject_uevent.patch
new file mode 100644
index 0000000000..99dd5a7053
--- /dev/null
+++ b/target/linux/generic/hack-6.12/910-kobject_uevent.patch
@@ -0,0 +1,35 @@
+From 0d37e6edc09c99e683dd91ca0e83bbc0df8477b3 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sun, 16 Jul 2017 16:56:10 +0200
+Subject: lib: add uevent_next_seqnum()
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ include/linux/kobject.h |  2 ++
+ lib/kobject_uevent.c    |  6 ++++++
+ 2 files changed, 8 insertions(+)
+
+--- a/include/linux/kobject.h
++++ b/include/linux/kobject.h
+@@ -219,4 +219,6 @@ int kobject_synth_uevent(struct kobject
+ __printf(2, 3)
+ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...);
+ 
++u64 uevent_next_seqnum(void);
++
+ #endif /* _KOBJECT_H_ */
+--- a/lib/kobject_uevent.c
++++ b/lib/kobject_uevent.c
+@@ -178,6 +178,12 @@ out:
+ 	return r;
+ }
+ 
++u64 uevent_next_seqnum(void)
++{
++	return atomic64_inc_return(&uevent_seqnum);
++}
++EXPORT_SYMBOL_GPL(uevent_next_seqnum);
++
+ /**
+  * kobject_synth_uevent - send synthetic uevent with arguments
+  *
diff --git a/target/linux/generic/hack-6.12/911-kobject_add_broadcast_uevent.patch b/target/linux/generic/hack-6.12/911-kobject_add_broadcast_uevent.patch
new file mode 100644
index 0000000000..df160baff6
--- /dev/null
+++ b/target/linux/generic/hack-6.12/911-kobject_add_broadcast_uevent.patch
@@ -0,0 +1,76 @@
+From 0d37e6edc09c99e683dd91ca0e83bbc0df8477b3 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sun, 16 Jul 2017 16:56:10 +0200
+Subject: lib: add broadcast_uevent()
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ include/linux/kobject.h |  5 +++++
+ lib/kobject_uevent.c    | 37 +++++++++++++++++++++++++++++++++++++
+ 2 files changed, 42 insertions(+)
+
+--- a/include/linux/kobject.h
++++ b/include/linux/kobject.h
+@@ -32,6 +32,8 @@
+ #define UEVENT_NUM_ENVP			64	/* number of env pointers */
+ #define UEVENT_BUFFER_SIZE		2048	/* buffer for the variables */
+ 
++struct sk_buff;
++
+ #ifdef CONFIG_UEVENT_HELPER
+ /* path to the userspace helper executed on an event */
+ extern char uevent_helper[];
+@@ -221,4 +223,7 @@ int add_uevent_var(struct kobj_uevent_en
+ 
+ u64 uevent_next_seqnum(void);
+ 
++int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
++		     gfp_t allocation);
++
+ #endif /* _KOBJECT_H_ */
+--- a/lib/kobject_uevent.c
++++ b/lib/kobject_uevent.c
+@@ -699,6 +699,43 @@ int add_uevent_var(struct kobj_uevent_en
+ EXPORT_SYMBOL_GPL(add_uevent_var);
+ 
+ #if defined(CONFIG_NET)
++int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
++		     gfp_t allocation)
++{
++	struct uevent_sock *ue_sk;
++	int err = 0;
++
++	/* send netlink message */
++	mutex_lock(&uevent_sock_mutex);
++	list_for_each_entry(ue_sk, &uevent_sock_list, list) {
++		struct sock *uevent_sock = ue_sk->sk;
++		struct sk_buff *skb2;
++
++		skb2 = skb_clone(skb, allocation);
++		if (!skb2)
++			break;
++
++		err = netlink_broadcast(uevent_sock, skb2, pid, group,
++					allocation);
++		if (err)
++			break;
++	}
++	mutex_unlock(&uevent_sock_mutex);
++
++	kfree_skb(skb);
++	return err;
++}
++#else
++int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
++		     gfp_t allocation)
++{
++	kfree_skb(skb);
++	return 0;
++}
++#endif
++EXPORT_SYMBOL_GPL(broadcast_uevent);
++
++#if defined(CONFIG_NET)
+ static int uevent_net_broadcast(struct sock *usk, struct sk_buff *skb,
+ 				struct netlink_ext_ack *extack)
+ {
diff --git a/target/linux/generic/hack-6.12/920-device_tree_cmdline.patch b/target/linux/generic/hack-6.12/920-device_tree_cmdline.patch
new file mode 100644
index 0000000000..4763e82421
--- /dev/null
+++ b/target/linux/generic/hack-6.12/920-device_tree_cmdline.patch
@@ -0,0 +1,21 @@
+From e08bcbbaa52fcc41f02743fd2e62a33255ce52da Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 13:52:28 +0200
+Subject: [PATCH] of/ftd: add device tree cmdline
+
+---
+ drivers/of/fdt.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/of/fdt.c
++++ b/drivers/of/fdt.c
+@@ -1049,6 +1049,9 @@ int __init early_init_dt_scan_chosen(cha
+ 	p = of_get_flat_dt_prop(node, "bootargs", &l);
+ 	if (p != NULL && l > 0)
+ 		strscpy(cmdline, p, min(l, COMMAND_LINE_SIZE));
++	p = of_get_flat_dt_prop(node, "bootargs-append", &l);
++	if (p != NULL && l > 0)
++		strlcat(cmdline, p, min_t(int, strlen(cmdline) + (int)l, COMMAND_LINE_SIZE));
+ 
+ handle_cmdline:
+ 	/*
diff --git a/target/linux/generic/hack-6.12/930-Revert-Revert-Revert-driver-core-Set-fw_devlink-on-b.patch b/target/linux/generic/hack-6.12/930-Revert-Revert-Revert-driver-core-Set-fw_devlink-on-b.patch
new file mode 100644
index 0000000000..a7c8a8efd2
--- /dev/null
+++ b/target/linux/generic/hack-6.12/930-Revert-Revert-Revert-driver-core-Set-fw_devlink-on-b.patch
@@ -0,0 +1,30 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 19 Jul 2022 06:17:48 +0200
+Subject: [PATCH] Revert "Revert "Revert "driver core: Set fw_devlink=on by
+ default"""
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This reverts commit ea718c699055c8566eb64432388a04974c43b2ea.
+
+With of_platform_populate() called for MTD partitions that commit breaks
+probing devices which reference MTD in device tree.
+
+Link: https://lore.kernel.org/all/696cb2da-20b9-b3dd-46d9-de4bf91a1506@gmail.com/T/#u
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+---
+ drivers/base/core.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/base/core.c
++++ b/drivers/base/core.c
+@@ -1653,7 +1653,7 @@ static void device_links_purge(struct de
+ #define FW_DEVLINK_FLAGS_RPM		(FW_DEVLINK_FLAGS_ON | \
+ 					 DL_FLAG_PM_RUNTIME)
+ 
+-static u32 fw_devlink_flags = FW_DEVLINK_FLAGS_RPM;
++static u32 fw_devlink_flags = FW_DEVLINK_FLAGS_PERMISSIVE;
+ static int __init fw_devlink_setup(char *arg)
+ {
+ 	if (!arg)
diff --git a/target/linux/mediatek/patches-6.6/735-net-phy-realtek-rtl8261n.patch b/target/linux/generic/hack-6.6/735-net-phy-realtek-rtl8261n.patch
similarity index 87%
rename from target/linux/mediatek/patches-6.6/735-net-phy-realtek-rtl8261n.patch
rename to target/linux/generic/hack-6.6/735-net-phy-realtek-rtl8261n.patch
index 676bd7c093..946869c303 100644
--- a/target/linux/mediatek/patches-6.6/735-net-phy-realtek-rtl8261n.patch
+++ b/target/linux/generic/hack-6.6/735-net-phy-realtek-rtl8261n.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -396,6 +396,8 @@ config QSEMI_PHY
+@@ -406,6 +406,8 @@ config QSEMI_PHY
  
  source "drivers/net/phy/realtek/Kconfig"
  
@@ -18,4 +18,4 @@
 +obj-y				+= rtl8261n/
  obj-$(CONFIG_RENESAS_PHY)	+= uPD60620.o
  obj-$(CONFIG_ROCKCHIP_PHY)	+= rockchip.o
- obj-$(CONFIG_RTL8367S_GSW)	+= rtk/
+ obj-$(CONFIG_SMSC_PHY)		+= smsc.o
diff --git a/target/linux/generic/kernel-6.12 b/target/linux/generic/kernel-6.12
new file mode 100644
index 0000000000..70a35aa2ae
--- /dev/null
+++ b/target/linux/generic/kernel-6.12
@@ -0,0 +1,2 @@
+LINUX_VERSION-6.12 = .28
+LINUX_KERNEL_HASH-6.12.28 = e8a099182562aecff781de72ce769461e706d97af42d740dff20eb450dd5771e
diff --git a/target/linux/generic/pending-6.12/100-compiler.h-only-include-asm-rwonce.h-for-kernel-code.patch b/target/linux/generic/pending-6.12/100-compiler.h-only-include-asm-rwonce.h-for-kernel-code.patch
new file mode 100644
index 0000000000..1a552bdc33
--- /dev/null
+++ b/target/linux/generic/pending-6.12/100-compiler.h-only-include-asm-rwonce.h-for-kernel-code.patch
@@ -0,0 +1,29 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 22 Oct 2020 22:00:03 +0200
+Subject: [PATCH] compiler.h: only include asm/rwonce.h for kernel code
+
+This header file is not in uapi, which makes any user space code that includes
+linux/compiler.h to fail with the error 'asm/rwonce.h: No such file or directory'
+
+Fixes: e506ea451254 ("compiler.h: Split {READ,WRITE}_ONCE definitions out into rwonce.h")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/linux/compiler.h
++++ b/include/linux/compiler.h
+@@ -191,6 +191,8 @@ void ftrace_likely_update(struct ftrace_
+ 	__v;								\
+ })
+ 
++#include <asm/rwonce.h>
++
+ #endif /* __KERNEL__ */
+ 
+ /**
+@@ -306,6 +308,4 @@ static inline void *offset_to_ptr(const
+  */
+ #define prevent_tail_call_optimization()	mb()
+ 
+-#include <asm/rwonce.h>
+-
+ #endif /* __LINUX_COMPILER_H */
diff --git a/target/linux/generic/pending-6.12/102-MIPS-only-process-negative-stack-offsets-on-stack-tr.patch b/target/linux/generic/pending-6.12/102-MIPS-only-process-negative-stack-offsets-on-stack-tr.patch
new file mode 100644
index 0000000000..d79d03defb
--- /dev/null
+++ b/target/linux/generic/pending-6.12/102-MIPS-only-process-negative-stack-offsets-on-stack-tr.patch
@@ -0,0 +1,57 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 18 Apr 2018 10:50:05 +0200
+Subject: [PATCH] MIPS: only process negative stack offsets on stack traces
+
+Fixes endless back traces in cases where the compiler emits a stack
+pointer increase in a branch delay slot (probably for some form of
+function return).
+
+[    3.475442] BUG: MAX_STACK_TRACE_ENTRIES too low!
+[    3.480070] turning off the locking correctness validator.
+[    3.485521] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.14.34 #0
+[    3.491475] Stack : 00000000 00000000 00000000 00000000 80e0fce2 00000034 00000000 00000000
+[    3.499764]         87c3838c 80696377 8061047c 00000000 00000001 00000001 87c2d850 6534689f
+[    3.508059]         00000000 00000000 80e10000 00000000 00000000 000000cf 0000000f 00000000
+[    3.516353]         00000000 806a0000 00076891 00000000 00000000 00000000 ffffffff 00000000
+[    3.524648]         806c0000 00000004 80e10000 806a0000 00000003 80690000 00000000 80700000
+[    3.532942]         ...
+[    3.535362] Call Trace:
+[    3.537818] [<80010a48>] show_stack+0x58/0x100
+[    3.542207] [<804c2f78>] dump_stack+0xe8/0x170
+[    3.546613] [<80079f90>] save_trace+0xf0/0x110
+[    3.551010] [<8007b1ec>] mark_lock+0x33c/0x78c
+[    3.555413] [<8007bf48>] __lock_acquire+0x2ac/0x1a08
+[    3.560337] [<8007de60>] lock_acquire+0x64/0x8c
+[    3.564846] [<804e1570>] _raw_spin_lock_irqsave+0x54/0x78
+[    3.570186] [<801b618c>] kernfs_notify+0x94/0xac
+[    3.574770] [<801b7b10>] sysfs_notify+0x74/0xa0
+[    3.579257] [<801b618c>] kernfs_notify+0x94/0xac
+[    3.583839] [<801b7b10>] sysfs_notify+0x74/0xa0
+[    3.588329] [<801b618c>] kernfs_notify+0x94/0xac
+[    3.592911] [<801b7b10>] sysfs_notify+0x74/0xa0
+[    3.597401] [<801b618c>] kernfs_notify+0x94/0xac
+[    3.601983] [<801b7b10>] sysfs_notify+0x74/0xa0
+[    3.606473] [<801b618c>] kernfs_notify+0x94/0xac
+[    3.611055] [<801b7b10>] sysfs_notify+0x74/0xa0
+[    3.615545] [<801b618c>] kernfs_notify+0x94/0xac
+[    3.620125] [<801b7b10>] sysfs_notify+0x74/0xa0
+[    3.624619] [<801b618c>] kernfs_notify+0x94/0xac
+[    3.629197] [<801b7b10>] sysfs_notify+0x74/0xa0
+[    3.633691] [<801b618c>] kernfs_notify+0x94/0xac
+[    3.638269] [<801b7b10>] sysfs_notify+0x74/0xa0
+[    3.642763] [<801b618c>] kernfs_notify+0x94/0xac
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/arch/mips/kernel/process.c
++++ b/arch/mips/kernel/process.c
+@@ -395,6 +395,8 @@ static inline int is_sp_move_ins(union m
+ 
+ 	if (ip->i_format.opcode == addiu_op ||
+ 	    ip->i_format.opcode == daddiu_op) {
++		if (ip->i_format.simmediate > 0)
++			return 0;
+ 		*frame_size = -ip->i_format.simmediate;
+ 		return 1;
+ 	}
diff --git a/target/linux/generic/pending-6.12/103-kbuild-export-SUBARCH.patch b/target/linux/generic/pending-6.12/103-kbuild-export-SUBARCH.patch
new file mode 100644
index 0000000000..0cedbeca40
--- /dev/null
+++ b/target/linux/generic/pending-6.12/103-kbuild-export-SUBARCH.patch
@@ -0,0 +1,21 @@
+From 173019b66dcc9d68ad9333aa744dad1e369b5aa8 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sun, 9 Jul 2017 00:26:53 +0200
+Subject: [PATCH 34/34] kernel: add compile fix for linux 4.9 on x86
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ Makefile | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/Makefile
++++ b/Makefile
+@@ -589,7 +589,7 @@ export RUSTC_BOOTSTRAP := 1
+ # Allows finding `.clippy.toml` in out-of-srctree builds.
+ export CLIPPY_CONF_DIR := $(srctree)
+ 
+-export ARCH SRCARCH CONFIG_SHELL BASH HOSTCC KBUILD_HOSTCFLAGS CROSS_COMPILE LD CC HOSTPKG_CONFIG
++export ARCH SRCARCH SUBARCH CONFIG_SHELL BASH HOSTCC KBUILD_HOSTCFLAGS CROSS_COMPILE LD CC HOSTPKG_CONFIG
+ export RUSTC RUSTDOC RUSTFMT RUSTC_OR_CLIPPY_QUIET RUSTC_OR_CLIPPY BINDGEN
+ export HOSTRUSTC KBUILD_HOSTRUSTFLAGS
+ export CPP AR NM STRIP OBJCOPY OBJDUMP READELF PAHOLE RESOLVE_BTFIDS LEX YACC AWK INSTALLKERNEL
diff --git a/target/linux/generic/pending-6.12/111-watchdog-max63xx_wdt-Add-support-for-specifying-WDI-.patch b/target/linux/generic/pending-6.12/111-watchdog-max63xx_wdt-Add-support-for-specifying-WDI-.patch
new file mode 100644
index 0000000000..9dd90eecdc
--- /dev/null
+++ b/target/linux/generic/pending-6.12/111-watchdog-max63xx_wdt-Add-support-for-specifying-WDI-.patch
@@ -0,0 +1,75 @@
+From bd1b9f66d5134e518419f4c4dacf1884c1616983 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 28 Apr 2022 11:13:23 +0200
+Subject: [PATCH] watchdog: max63xx_wdt: Add support for specifying WDI logic
+ via GPIO
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+On some boards is WDI logic of max6370 chip connected via GPIO.
+So extend max63xx_wdt driver to allow specifying WDI logic via GPIO.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/watchdog/max63xx_wdt.c | 24 ++++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+--- a/drivers/watchdog/max63xx_wdt.c
++++ b/drivers/watchdog/max63xx_wdt.c
+@@ -24,6 +24,7 @@
+ #include <linux/io.h>
+ #include <linux/slab.h>
+ #include <linux/property.h>
++#include <linux/gpio/consumer.h>
+ 
+ #define DEFAULT_HEARTBEAT 60
+ #define MAX_HEARTBEAT     60
+@@ -50,6 +51,9 @@ struct max63xx_wdt {
+ 	void __iomem *base;
+ 	spinlock_t lock;
+ 
++	/* GPIOs */
++	struct gpio_desc *gpio_wdi;
++
+ 	/* WDI and WSET bits write access routines */
+ 	void (*ping)(struct max63xx_wdt *wdt);
+ 	void (*set)(struct max63xx_wdt *wdt, u8 set);
+@@ -155,6 +159,17 @@ static const struct watchdog_info max63x
+ 	.identity = "max63xx Watchdog",
+ };
+ 
++static void max63xx_gpio_ping(struct max63xx_wdt *wdt)
++{
++	spin_lock(&wdt->lock);
++
++	gpiod_set_value(wdt->gpio_wdi, 1);
++	udelay(1);
++	gpiod_set_value(wdt->gpio_wdi, 0);
++
++	spin_unlock(&wdt->lock);
++}
++
+ static void max63xx_mmap_ping(struct max63xx_wdt *wdt)
+ {
+ 	u8 val;
+@@ -222,10 +237,19 @@ static int max63xx_wdt_probe(struct plat
+ 		return -EINVAL;
+ 	}
+ 
++	wdt->gpio_wdi = devm_gpiod_get(dev, NULL, GPIOD_FLAGS_BIT_DIR_OUT);
++	if (IS_ERR(wdt->gpio_wdi) && PTR_ERR(wdt->gpio_wdi) != -ENOENT)
++		return dev_err_probe(dev, PTR_ERR(wdt->gpio_wdi),
++				     "unable to request gpio: %ld\n",
++				     PTR_ERR(wdt->gpio_wdi));
++
+ 	err = max63xx_mmap_init(pdev, wdt);
+ 	if (err)
+ 		return err;
+ 
++	if (!IS_ERR(wdt->gpio_wdi))
++		wdt->ping = max63xx_gpio_ping;
++
+ 	platform_set_drvdata(pdev, &wdt->wdd);
+ 	watchdog_set_drvdata(&wdt->wdd, wdt);
+ 
diff --git a/target/linux/generic/pending-6.12/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch b/target/linux/generic/pending-6.12/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch
new file mode 100644
index 0000000000..b5cc52dc02
--- /dev/null
+++ b/target/linux/generic/pending-6.12/140-jffs2-use-.rename2-and-add-RENAME_WHITEOUT-support.patch
@@ -0,0 +1,81 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: jffs2: use .rename2 and add RENAME_WHITEOUT support
+
+It is required for renames on overlayfs
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/fs/jffs2/dir.c
++++ b/fs/jffs2/dir.c
+@@ -620,8 +620,8 @@ static int jffs2_rmdir (struct inode *di
+ 	return ret;
+ }
+ 
+-static int jffs2_mknod (struct mnt_idmap *idmap, struct inode *dir_i,
+-		        struct dentry *dentry, umode_t mode, dev_t rdev)
++static int __jffs2_mknod (struct mnt_idmap *idmap, struct inode *dir_i,
++		          struct dentry *dentry, umode_t mode, dev_t rdev, bool whiteout)
+ {
+ 	struct jffs2_inode_info *f, *dir_f;
+ 	struct jffs2_sb_info *c;
+@@ -761,7 +761,11 @@ static int jffs2_mknod (struct mnt_idmap
+ 	mutex_unlock(&dir_f->sem);
+ 	jffs2_complete_reservation(c);
+ 
+-	d_instantiate_new(dentry, inode);
++	if (!whiteout)
++		d_instantiate_new(dentry, inode);
++	else
++		unlock_new_inode(inode);
++
+ 	return 0;
+ 
+  fail:
+@@ -769,6 +773,19 @@ static int jffs2_mknod (struct mnt_idmap
+ 	return ret;
+ }
+ 
++static int jffs2_mknod (struct mnt_idmap *idmap, struct inode *dir_i,
++			struct dentry *dentry, umode_t mode, dev_t rdev)
++{
++	return __jffs2_mknod(idmap, dir_i, dentry, mode, rdev, false);
++}
++
++static int jffs2_whiteout (struct mnt_idmap *idmap, struct inode *old_dir,
++			   struct dentry *old_dentry)
++{
++	return __jffs2_mknod(idmap, old_dir, old_dentry, S_IFCHR | WHITEOUT_MODE,
++			     WHITEOUT_DEV, true);
++}
++
+ static int jffs2_rename (struct mnt_idmap *idmap,
+ 			 struct inode *old_dir_i, struct dentry *old_dentry,
+ 			 struct inode *new_dir_i, struct dentry *new_dentry,
+@@ -780,7 +797,7 @@ static int jffs2_rename (struct mnt_idma
+ 	uint8_t type;
+ 	uint32_t now;
+ 
+-	if (flags & ~RENAME_NOREPLACE)
++	if (flags & ~(RENAME_NOREPLACE|RENAME_WHITEOUT))
+ 		return -EINVAL;
+ 
+ 	/* The VFS will check for us and prevent trying to rename a
+@@ -846,9 +863,14 @@ static int jffs2_rename (struct mnt_idma
+ 	if (d_is_dir(old_dentry) && !victim_f)
+ 		inc_nlink(new_dir_i);
+ 
+-	/* Unlink the original */
+-	ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
+-			      old_dentry->d_name.name, old_dentry->d_name.len, NULL, now);
++	if (flags & RENAME_WHITEOUT)
++		/* Replace with whiteout */
++		ret = jffs2_whiteout(idmap, old_dir_i, old_dentry);
++	else
++		/* Unlink the original */
++		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
++				      old_dentry->d_name.name,
++				      old_dentry->d_name.len, NULL, now);
+ 
+ 	/* We don't touch inode->i_nlink */
+ 
diff --git a/target/linux/generic/pending-6.12/141-jffs2-add-RENAME_EXCHANGE-support.patch b/target/linux/generic/pending-6.12/141-jffs2-add-RENAME_EXCHANGE-support.patch
new file mode 100644
index 0000000000..44ba3bd959
--- /dev/null
+++ b/target/linux/generic/pending-6.12/141-jffs2-add-RENAME_EXCHANGE-support.patch
@@ -0,0 +1,73 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: jffs2: add RENAME_EXCHANGE support
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/fs/jffs2/dir.c
++++ b/fs/jffs2/dir.c
+@@ -794,18 +794,31 @@ static int jffs2_rename (struct mnt_idma
+ 	int ret;
+ 	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
+ 	struct jffs2_inode_info *victim_f = NULL;
++	struct inode *fst_inode = d_inode(old_dentry);
++	struct inode *snd_inode = d_inode(new_dentry);
+ 	uint8_t type;
+ 	uint32_t now;
+ 
+-	if (flags & ~(RENAME_NOREPLACE|RENAME_WHITEOUT))
++	if (flags & ~(RENAME_NOREPLACE|RENAME_WHITEOUT|RENAME_EXCHANGE))
+ 		return -EINVAL;
+ 
++	if ((flags & RENAME_EXCHANGE) && (old_dir_i != new_dir_i)) {
++		if (S_ISDIR(fst_inode->i_mode) && !S_ISDIR(snd_inode->i_mode)) {
++			inc_nlink(new_dir_i);
++			drop_nlink(old_dir_i);
++		}
++		else if (!S_ISDIR(fst_inode->i_mode) && S_ISDIR(snd_inode->i_mode)) {
++			drop_nlink(new_dir_i);
++			inc_nlink(old_dir_i);
++		}
++	}
++
+ 	/* The VFS will check for us and prevent trying to rename a
+ 	 * file over a directory and vice versa, but if it's a directory,
+ 	 * the VFS can't check whether the victim is empty. The filesystem
+ 	 * needs to do that for itself.
+ 	 */
+-	if (d_really_is_positive(new_dentry)) {
++	if (d_really_is_positive(new_dentry) && !(flags & RENAME_EXCHANGE)) {
+ 		victim_f = JFFS2_INODE_INFO(d_inode(new_dentry));
+ 		if (d_is_dir(new_dentry)) {
+ 			struct jffs2_full_dirent *fd;
+@@ -840,7 +853,7 @@ static int jffs2_rename (struct mnt_idma
+ 	if (ret)
+ 		return ret;
+ 
+-	if (victim_f) {
++	if (victim_f && !(flags & RENAME_EXCHANGE)) {
+ 		/* There was a victim. Kill it off nicely */
+ 		if (d_is_dir(new_dentry))
+ 			clear_nlink(d_inode(new_dentry));
+@@ -866,6 +879,12 @@ static int jffs2_rename (struct mnt_idma
+ 	if (flags & RENAME_WHITEOUT)
+ 		/* Replace with whiteout */
+ 		ret = jffs2_whiteout(idmap, old_dir_i, old_dentry);
++	else if (flags & RENAME_EXCHANGE)
++		/* Replace the original */
++		ret = jffs2_do_link(c, JFFS2_INODE_INFO(old_dir_i),
++				    d_inode(new_dentry)->i_ino, type,
++				    old_dentry->d_name.name, old_dentry->d_name.len,
++				    now);
+ 	else
+ 		/* Unlink the original */
+ 		ret = jffs2_do_unlink(c, JFFS2_INODE_INFO(old_dir_i),
+@@ -898,7 +917,7 @@ static int jffs2_rename (struct mnt_idma
+ 		return ret;
+ 	}
+ 
+-	if (d_is_dir(old_dentry))
++	if (d_is_dir(old_dentry) && !(flags & RENAME_EXCHANGE))
+ 		drop_nlink(old_dir_i);
+ 
+ 	inode_set_mtime_to_ts(old_dir_i,
diff --git a/target/linux/generic/pending-6.12/142-jffs2-add-splice-ops.patch b/target/linux/generic/pending-6.12/142-jffs2-add-splice-ops.patch
new file mode 100644
index 0000000000..ea57158cc2
--- /dev/null
+++ b/target/linux/generic/pending-6.12/142-jffs2-add-splice-ops.patch
@@ -0,0 +1,20 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: jffs2: add splice ops
+
+Add splice_read using generic_file_splice_read.
+Add splice_write using iter_file_splice_write
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/fs/jffs2/file.c
++++ b/fs/jffs2/file.c
+@@ -53,6 +53,8 @@ const struct file_operations jffs2_file_
+ 	.open =		generic_file_open,
+  	.read_iter =	generic_file_read_iter,
+  	.write_iter =	generic_file_write_iter,
++	.splice_read =	filemap_splice_read,
++	.splice_write =	iter_file_splice_write,
+ 	.unlocked_ioctl=jffs2_ioctl,
+ 	.mmap =		generic_file_readonly_mmap,
+ 	.fsync =	jffs2_fsync,
diff --git a/target/linux/generic/pending-6.12/150-bridge_allow_receiption_on_disabled_port.patch b/target/linux/generic/pending-6.12/150-bridge_allow_receiption_on_disabled_port.patch
new file mode 100644
index 0000000000..d8fd9cdf42
--- /dev/null
+++ b/target/linux/generic/pending-6.12/150-bridge_allow_receiption_on_disabled_port.patch
@@ -0,0 +1,45 @@
+From: Stephen Hemminger <stephen@networkplumber.org>
+Subject: bridge: allow receiption on disabled port
+
+When an ethernet device is enslaved to a bridge, and the bridge STP
+detects loss of carrier (or operational state down), then normally
+packet receiption is blocked.
+
+This breaks control applications like WPA which maybe expecting to
+receive packets to negotiate to bring link up. The bridge needs to
+block forwarding packets from these disabled ports, but there is no
+hard requirement to not allow local packet delivery.
+
+Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -244,6 +244,9 @@ static void __br_handle_local_finish(str
+ /* note: already called with rcu_read_lock */
+ static int br_handle_local_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
+ {
++	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
++
++	if (p->state != BR_STATE_DISABLED)
+ 	__br_handle_local_finish(skb);
+ 
+ 	/* return 1 to signal the okfn() was called so it's ok to use the skb */
+@@ -415,6 +418,17 @@ forward:
+ 		goto defer_stp_filtering;
+ 
+ 	switch (p->state) {
++	case BR_STATE_DISABLED:
++		if (ether_addr_equal(p->br->dev->dev_addr, dest))
++			skb->pkt_type = PACKET_HOST;
++
++		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
++			dev_net(skb->dev), NULL, skb, skb->dev, NULL,
++			br_handle_local_finish) == 1) {
++			return RX_HANDLER_PASS;
++		}
++		break;
++
+ 	case BR_STATE_FORWARDING:
+ 	case BR_STATE_LEARNING:
+ defer_stp_filtering:
diff --git a/target/linux/generic/pending-6.12/151-net-bridge-do-not-send-arp-replies-if-src-and-target.patch b/target/linux/generic/pending-6.12/151-net-bridge-do-not-send-arp-replies-if-src-and-target.patch
new file mode 100644
index 0000000000..3abeacaffb
--- /dev/null
+++ b/target/linux/generic/pending-6.12/151-net-bridge-do-not-send-arp-replies-if-src-and-target.patch
@@ -0,0 +1,37 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 4 Jan 2024 15:21:21 +0100
+Subject: [PATCH] net: bridge: do not send arp replies if src and target hw
+ addr is the same
+
+There are broken devices in the wild that handle duplicate IP address
+detection by sending out ARP requests for the IP that they received from a
+DHCP server and refuse the address if they get a reply.
+When proxyarp is enabled, they would go into a loop of requesting an address
+and then NAKing it again.
+
+Link: https://github.com/openwrt/openwrt/issues/14309
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/bridge/br_arp_nd_proxy.c
++++ b/net/bridge/br_arp_nd_proxy.c
+@@ -204,7 +204,10 @@ void br_do_proxy_suppress_arp(struct sk_
+ 			if ((p && (p->flags & BR_PROXYARP)) ||
+ 			    (f->dst && (f->dst->flags & BR_PROXYARP_WIFI)) ||
+ 			    br_is_neigh_suppress_enabled(f->dst, vid)) {
+-				if (!vid)
++				replied = true;
++				if (!memcmp(n->ha, sha, dev->addr_len))
++					replied = false;
++				else if (!vid)
+ 					br_arp_send(br, p, skb->dev, sip, tip,
+ 						    sha, n->ha, sha, 0, 0);
+ 				else
+@@ -212,7 +215,6 @@ void br_do_proxy_suppress_arp(struct sk_
+ 						    sha, n->ha, sha,
+ 						    skb->vlan_proto,
+ 						    skb_vlan_tag_get(skb));
+-				replied = true;
+ 			}
+ 
+ 			/* If we have replied or as long as we know the
diff --git a/target/linux/generic/pending-6.12/190-rtc-rs5c372-support_alarms_up_to_1_week.patch b/target/linux/generic/pending-6.12/190-rtc-rs5c372-support_alarms_up_to_1_week.patch
new file mode 100644
index 0000000000..2f5c2228c7
--- /dev/null
+++ b/target/linux/generic/pending-6.12/190-rtc-rs5c372-support_alarms_up_to_1_week.patch
@@ -0,0 +1,94 @@
+From: Daniel González Cabanelas <dgcbueu@gmail.com>
+Subject: [PATCH 1/2] rtc: rs5c372: support alarms up to 1 week
+
+The Ricoh R2221x, R2223x, RS5C372, RV5C387A chips can handle 1 week
+alarms.
+
+Read the "wday" alarm register and convert it to a date to support up 1
+week in our driver.
+
+Signed-off-by: Daniel González Cabanelas <dgcbueu@gmail.com>
+---
+ drivers/rtc/rtc-rs5c372.c | 48 ++++++++++++++++++++++++++++++++++-----
+ 1 file changed, 42 insertions(+), 6 deletions(-)
+
+--- a/drivers/rtc/rtc-rs5c372.c
++++ b/drivers/rtc/rtc-rs5c372.c
+@@ -399,7 +399,9 @@ static int rs5c_read_alarm(struct device
+ {
+ 	struct i2c_client	*client = to_i2c_client(dev);
+ 	struct rs5c372		*rs5c = i2c_get_clientdata(client);
+-	int			status;
++	int			status, wday_offs;
++	struct rtc_time 	rtc;
++	unsigned long 		alarm_secs;
+ 
+ 	status = rs5c_get_regs(rs5c);
+ 	if (status < 0)
+@@ -409,6 +411,30 @@ static int rs5c_read_alarm(struct device
+ 	t->time.tm_sec = 0;
+ 	t->time.tm_min = bcd2bin(rs5c->regs[RS5C_REG_ALARM_A_MIN] & 0x7f);
+ 	t->time.tm_hour = rs5c_reg2hr(rs5c, rs5c->regs[RS5C_REG_ALARM_A_HOURS]);
++	t->time.tm_wday = ffs(rs5c->regs[RS5C_REG_ALARM_A_WDAY] & 0x7f) - 1;
++
++	/* determine the day, month and year based on alarm wday, taking as a
++	 * reference the current time from the rtc
++	 */
++	status = rs5c372_rtc_read_time(dev, &rtc);
++	if (status < 0)
++		return status;
++
++	wday_offs = t->time.tm_wday - rtc.tm_wday;
++	alarm_secs = mktime64(rtc.tm_year + 1900,
++			      rtc.tm_mon + 1,
++			      rtc.tm_mday + wday_offs,
++			      t->time.tm_hour,
++			      t->time.tm_min,
++			      t->time.tm_sec);
++
++	if (wday_offs < 0 || (wday_offs == 0 &&
++			      (t->time.tm_hour < rtc.tm_hour ||
++			       (t->time.tm_hour == rtc.tm_hour &&
++				t->time.tm_min <= rtc.tm_min))))
++		alarm_secs += 7 * 86400;
++
++	rtc_time64_to_tm(alarm_secs, &t->time);
+ 
+ 	/* ... and status */
+ 	t->enabled = !!(rs5c->regs[RS5C_REG_CTRL1] & RS5C_CTRL1_AALE);
+@@ -423,12 +449,20 @@ static int rs5c_set_alarm(struct device
+ 	struct rs5c372		*rs5c = i2c_get_clientdata(client);
+ 	int			status, addr, i;
+ 	unsigned char		buf[3];
++	struct rtc_time 	rtc_tm;
++	unsigned long 		rtc_secs, alarm_secs;
+ 
+-	/* only handle up to 24 hours in the future, like RTC_ALM_SET */
+-	if (t->time.tm_mday != -1
+-			|| t->time.tm_mon != -1
+-			|| t->time.tm_year != -1)
++	/* chip only can handle alarms up to one week in the future*/
++	status = rs5c372_rtc_read_time(dev, &rtc_tm);
++	if (status)
++		return status;
++	rtc_secs = rtc_tm_to_time64(&rtc_tm);
++	alarm_secs = rtc_tm_to_time64(&t->time);
++	if (alarm_secs >= rtc_secs + 7 * 86400) {
++		dev_err(dev, "%s: alarm maximum is one week in the future (%d)\n",
++			__func__, status);
+ 		return -EINVAL;
++	}
+ 
+ 	/* REVISIT: round up tm_sec */
+ 
+@@ -449,7 +483,9 @@ static int rs5c_set_alarm(struct device
+ 	/* set alarm */
+ 	buf[0] = bin2bcd(t->time.tm_min);
+ 	buf[1] = rs5c_hr2reg(rs5c, t->time.tm_hour);
+-	buf[2] = 0x7f;	/* any/all days */
++	/* each bit is the day of the week, 0x7f means all days */
++	buf[2] = (t->time.tm_wday >= 0 && t->time.tm_wday < 7) ?
++		  BIT(t->time.tm_wday) : 0x7f;
+ 
+ 	for (i = 0; i < sizeof(buf); i++) {
+ 		addr = RS5C_ADDR(RS5C_REG_ALARM_A_MIN + i);
diff --git a/target/linux/generic/pending-6.12/191-rtc-rs5c372-let_the_alarm_to_be_used_as_wakeup_source.patch b/target/linux/generic/pending-6.12/191-rtc-rs5c372-let_the_alarm_to_be_used_as_wakeup_source.patch
new file mode 100644
index 0000000000..a29c548bbd
--- /dev/null
+++ b/target/linux/generic/pending-6.12/191-rtc-rs5c372-let_the_alarm_to_be_used_as_wakeup_source.patch
@@ -0,0 +1,71 @@
+From: Daniel González Cabanelas <dgcbueu@gmail.com>
+Subject: [PATCH 2/2] rtc: rs5c372: let the alarm to be used as wakeup source
+
+Currently there is no use for the interrupts on the rs5c372 RTC and the
+wakealarm isn't enabled. There are some devices like NASes which use this
+RTC to wake up from the power off state when the INTR pin is activated by
+the alarm clock.
+
+Enable the alarm and let to be used as a wakeup source.
+
+Tested on a Buffalo LS421DE NAS.
+
+Signed-off-by: Daniel González Cabanelas <dgcbueu@gmail.com>
+---
+ drivers/rtc/rtc-rs5c372.c | 16 ++++++++++++++++
+ 1 file changed, 16 insertions(+)
+
+--- a/drivers/rtc/rtc-rs5c372.c
++++ b/drivers/rtc/rtc-rs5c372.c
+@@ -832,6 +832,7 @@ static int rs5c372_probe(struct i2c_clie
+ 	int err = 0;
+ 	int smbus_mode = 0;
+ 	struct rs5c372 *rs5c372;
++	bool rs5c372_can_wakeup_device = false;
+ 
+ 	dev_dbg(&client->dev, "%s\n", __func__);
+ 
+@@ -868,6 +869,12 @@ static int rs5c372_probe(struct i2c_clie
+ 		rs5c372->type = id->driver_data;
+ 	}
+ 
++#ifdef CONFIG_OF
++	if(of_property_read_bool(client->dev.of_node,
++					      "wakeup-source"))
++		rs5c372_can_wakeup_device = true;
++#endif
++
+ 	/* we read registers 0x0f then 0x00-0x0f; skip the first one */
+ 	rs5c372->regs = &rs5c372->buf[1];
+ 	rs5c372->smbus = smbus_mode;
+@@ -901,6 +908,8 @@ static int rs5c372_probe(struct i2c_clie
+ 		goto exit;
+ 	}
+ 
++	rs5c372->has_irq = 1;
++
+ 	/* if the oscillator lost power and no other software (like
+ 	 * the bootloader) set it up, do it here.
+ 	 *
+@@ -927,6 +936,10 @@ static int rs5c372_probe(struct i2c_clie
+ 			);
+ 
+ 	/* REVISIT use client->irq to register alarm irq ... */
++	if (rs5c372_can_wakeup_device) {
++		device_init_wakeup(&client->dev, true);
++	}
++
+ 	rs5c372->rtc = devm_rtc_device_register(&client->dev,
+ 					rs5c372_driver.driver.name,
+ 					&rs5c372_rtc_ops, THIS_MODULE);
+@@ -940,6 +953,10 @@ static int rs5c372_probe(struct i2c_clie
+ 	if (err)
+ 		goto exit;
+ 
++	/* the rs5c372 alarm only supports a minute accuracy */
++	set_bit(RTC_FEATURE_ALARM_RES_MINUTE, rs5c372->rtc->features);
++	clear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rs5c372->rtc->features);
++
+ 	return 0;
+ 
+ exit:
diff --git a/target/linux/generic/pending-6.12/200-ARM-9404-1-arm32-fix-boot-hang-with-HAVE_LD_DEAD_COD.patch b/target/linux/generic/pending-6.12/200-ARM-9404-1-arm32-fix-boot-hang-with-HAVE_LD_DEAD_COD.patch
new file mode 100644
index 0000000000..f36b1182ed
--- /dev/null
+++ b/target/linux/generic/pending-6.12/200-ARM-9404-1-arm32-fix-boot-hang-with-HAVE_LD_DEAD_COD.patch
@@ -0,0 +1,79 @@
+From cf3d39cfd29ab7bcbd6aa79d4a2f132817969e3d Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Tue, 15 Apr 2025 23:16:40 +0200
+Subject: [PATCH] ARM: 9404/1: arm32: fix boot hang with
+ HAVE_LD_DEAD_CODE_DATA_ELIMINATION
+
+It was reported that some SoC (mvebu based for example) hang on kernel
+loading. A variant of the feature was present in OpenWrt from long ago
+and adding the additional entry with KEEP, fix the problem.
+
+Fixes: ed0f94102251 ("ARM: 9404/1: arm32: enable HAVE_LD_DEAD_CODE_DATA_ELIMINATION")
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ arch/arm/include/asm/vmlinux.lds.h | 10 +++++-----
+ arch/arm/kernel/vmlinux.lds.S      |  4 ++--
+ 2 files changed, 7 insertions(+), 7 deletions(-)
+
+--- a/arch/arm/include/asm/vmlinux.lds.h
++++ b/arch/arm/include/asm/vmlinux.lds.h
+@@ -54,7 +54,7 @@
+ #define IDMAP_TEXT							\
+ 		ALIGN_FUNCTION();					\
+ 		__idmap_text_start = .;					\
+-		*(.idmap.text)						\
++		KEEP(*(.idmap.text))					\
+ 		__idmap_text_end = .;					\
+ 
+ #define ARM_DISCARD							\
+@@ -114,12 +114,12 @@
+ 	. = ALIGN(8);							\
+ 	.ARM.unwind_idx : {						\
+ 		__start_unwind_idx = .;					\
+-		*(.ARM.exidx*)						\
++		KEEP(*(.ARM.exidx*))					\
+ 		__stop_unwind_idx = .;					\
+ 	}								\
+ 	.ARM.unwind_tab : {						\
+ 		__start_unwind_tab = .;					\
+-		*(.ARM.extab*)						\
++		KEEP(*(.ARM.extab*))					\
+ 		__stop_unwind_tab = .;					\
+ 	}
+ 
+@@ -131,7 +131,7 @@
+ 	__vectors_lma = .;						\
+ 	OVERLAY 0xffff0000 : NOCROSSREFS AT(__vectors_lma) {		\
+ 		.vectors {						\
+-			OVERLAY_KEEP(*(.vectors))			\
++			KEEP(*(.vectors))				\
+ 		}							\
+ 		.vectors.bhb.loop8 {					\
+ 			OVERLAY_KEEP(*(.vectors.bhb.loop8))		\
+@@ -149,7 +149,7 @@
+ 									\
+ 	__stubs_lma = .;						\
+ 	.stubs ADDR(.vectors) + 0x1000 : AT(__stubs_lma) {		\
+-		*(.stubs)						\
++		KEEP(*(.stubs))						\
+ 	}								\
+ 	ARM_LMA(__stubs, .stubs);					\
+ 	. = __stubs_lma + SIZEOF(.stubs);				\
+--- a/arch/arm/kernel/vmlinux.lds.S
++++ b/arch/arm/kernel/vmlinux.lds.S
+@@ -104,13 +104,13 @@ SECTIONS
+ 	}
+ 	.init.tagtable : {
+ 		__tagtable_begin = .;
+-		*(.taglist.init)
++		KEEP(*(.taglist.init))
+ 		__tagtable_end = .;
+ 	}
+ #ifdef CONFIG_SMP_ON_UP
+ 	.init.smpalt : {
+ 		__smpalt_begin = .;
+-		*(.alt.smp.init)
++		KEEP(*(.alt.smp.init))
+ 		__smpalt_end = .;
+ 	}
+ #endif
diff --git a/target/linux/generic/pending-6.12/203-kallsyms_uncompressed.patch b/target/linux/generic/pending-6.12/203-kallsyms_uncompressed.patch
new file mode 100644
index 0000000000..307acd4988
--- /dev/null
+++ b/target/linux/generic/pending-6.12/203-kallsyms_uncompressed.patch
@@ -0,0 +1,183 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: kernel: add a config option for keeping the kallsyms table uncompressed, saving ~9kb kernel size after lzma on ar71xx
+
+[john@phrozen.org: added to my upstream queue 30.12.2016]
+lede-commit: e0e3509b5ce2ccf93d4d67ea907613f5f7ec2eed
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ init/Kconfig            | 11 +++++++++++
+ kernel/kallsyms.c       |  8 ++++++++
+ kernel/vmcore_info.c    |  2 ++
+ scripts/kallsyms.c      | 12 ++++++++++++
+ scripts/link-vmlinux.sh |  4 ++++
+ 5 files changed, 37 insertions(+)
+
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -1530,6 +1530,17 @@ config SYSCTL_ARCH_UNALIGN_ALLOW
+ 	  the unaligned access emulation.
+ 	  see arch/parisc/kernel/unaligned.c for reference
+ 
++config KALLSYMS_UNCOMPRESSED
++	bool "Keep kallsyms uncompressed"
++	depends on KALLSYMS
++	help
++		Normally kallsyms contains compressed symbols (using a token table),
++		reducing the uncompressed kernel image size. Keeping the symbol table
++		uncompressed significantly improves the size of this part in compressed
++		kernel images.
++
++		Say N unless you need compressed kernel images to be small.
++
+ config HAVE_PCSPKR_PLATFORM
+ 	bool
+ 
+--- a/kernel/kallsyms.c
++++ b/kernel/kallsyms.c
+@@ -69,6 +69,11 @@ static unsigned int kallsyms_expand_symb
+ 	 * For every byte on the compressed symbol data, copy the table
+ 	 * entry for that byte.
+ 	 */
++#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
++	memcpy(result, data + 1, len - 1);
++	result += len - 1;
++	len = 0;
++#endif
+ 	while (len) {
+ 		tptr = &kallsyms_token_table[kallsyms_token_index[*data]];
+ 		data++;
+@@ -101,6 +106,9 @@ tail:
+  */
+ static char kallsyms_get_symbol_type(unsigned int off)
+ {
++#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
++	return kallsyms_names[off + 1];
++#endif
+ 	/*
+ 	 * Get just the first code, look it up in the token table,
+ 	 * and return the first char from this token.
+--- a/kernel/vmcore_info.c
++++ b/kernel/vmcore_info.c
+@@ -214,8 +214,10 @@ static int __init crash_save_vmcoreinfo_
+ #ifdef CONFIG_KALLSYMS
+ 	VMCOREINFO_SYMBOL(kallsyms_names);
+ 	VMCOREINFO_SYMBOL(kallsyms_num_syms);
++#ifndef CONFIG_KALLSYMS_UNCOMPRESSED
+ 	VMCOREINFO_SYMBOL(kallsyms_token_table);
+ 	VMCOREINFO_SYMBOL(kallsyms_token_index);
++#endif
+ 	VMCOREINFO_SYMBOL(kallsyms_offsets);
+ 	VMCOREINFO_SYMBOL(kallsyms_relative_base);
+ #endif /* CONFIG_KALLSYMS */
+--- a/scripts/kallsyms.c
++++ b/scripts/kallsyms.c
+@@ -62,6 +62,7 @@ static struct addr_range percpu_range =
+ static struct sym_entry **table;
+ static unsigned int table_size, table_cnt;
+ static int all_symbols;
++static int uncompressed;
+ static int absolute_percpu;
+ 
+ static int token_profit[0x10000];
+@@ -412,13 +413,17 @@ static void write_src(void)
+ 		for (k = 0; k < table[i]->len; k++)
+ 			printf(", 0x%02x", table[i]->sym[k]);
+ 
+-		/*
+-		 * Now that we wrote out the compressed symbol name, restore the
+-		 * original name and print it in the comment.
+-		 */
+-		expand_symbol(table[i]->sym, table[i]->len, buf);
+-		strcpy((char *)table[i]->sym, buf);
+-		printf("\t/* %s */\n", table[i]->sym);
++		if (!uncompressed) {
++			/*
++			 * Now that we wrote out the compressed symbol name, restore the
++			 * original name and print it in the comment.
++			 */
++			expand_symbol(table[i]->sym, table[i]->len, buf);
++			strcpy((char *)table[i]->sym, buf);
++			printf("\t/* %s */\n", table[i]->sym);
++		} else {
++			printf("\n");
++		}
+ 	}
+ 	printf("\n");
+ 
+@@ -429,20 +434,22 @@ static void write_src(void)
+ 
+ 	free(markers);
+ 
+-	output_label("kallsyms_token_table");
+-	off = 0;
+-	for (i = 0; i < 256; i++) {
+-		best_idx[i] = off;
+-		expand_symbol(best_table[i], best_table_len[i], buf);
+-		printf("\t.asciz\t\"%s\"\n", buf);
+-		off += strlen(buf) + 1;
++	if (!uncompressed) {
++		output_label("kallsyms_token_table");
++		off = 0;
++		for (i = 0; i < 256; i++) {
++			best_idx[i] = off;
++			expand_symbol(best_table[i], best_table_len[i], buf);
++			printf("\t.asciz\t\"%s\"\n", buf);
++			off += strlen(buf) + 1;
++		}
++		printf("\n");
++
++		output_label("kallsyms_token_index");
++		for (i = 0; i < 256; i++)
++			printf("\t.short\t%d\n", best_idx[i]);
++		printf("\n");
+ 	}
+-	printf("\n");
+-
+-	output_label("kallsyms_token_index");
+-	for (i = 0; i < 256; i++)
+-		printf("\t.short\t%d\n", best_idx[i]);
+-	printf("\n");
+ 
+ 	output_label("kallsyms_offsets");
+ 
+@@ -532,6 +539,9 @@ static unsigned char *find_token(unsigne
+ {
+ 	int i;
+ 
++	if (uncompressed)
++		return NULL;
++
+ 	for (i = 0; i < len - 1; i++) {
+ 		if (str[i] == token[0] && str[i+1] == token[1])
+ 			return &str[i];
+@@ -604,6 +614,9 @@ static void optimize_result(void)
+ {
+ 	int i, best;
+ 
++	if (uncompressed)
++		return;
++
+ 	/* using the '\0' symbol last allows compress_symbols to use standard
+ 	 * fast string functions */
+ 	for (i = 255; i >= 0; i--) {
+@@ -763,6 +776,7 @@ int main(int argc, char **argv)
+ 		static const struct option long_options[] = {
+ 			{"all-symbols",     no_argument, &all_symbols,     1},
+ 			{"absolute-percpu", no_argument, &absolute_percpu, 1},
++			{"uncompressed",   no_argument, &uncompressed,   1},
+ 			{},
+ 		};
+ 
+--- a/scripts/link-vmlinux.sh
++++ b/scripts/link-vmlinux.sh
+@@ -144,6 +144,10 @@ kallsyms()
+ 		kallsymopt="${kallsymopt} --absolute-percpu"
+ 	fi
+ 
++	if is_enabled CONFIG_KALLSYMS_UNCOMPRESSED; then
++		kallsymopt="${kallsymopt} --uncompressed"
++	fi
++
+ 	info KSYMS "${2}.S"
+ 	scripts/kallsyms ${kallsymopt} "${1}" > "${2}.S"
+ 
diff --git a/target/linux/generic/pending-6.12/205-backtrace_module_info.patch b/target/linux/generic/pending-6.12/205-backtrace_module_info.patch
new file mode 100644
index 0000000000..52d6f5c868
--- /dev/null
+++ b/target/linux/generic/pending-6.12/205-backtrace_module_info.patch
@@ -0,0 +1,41 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: kernel: when KALLSYMS is disabled, print module address + size for matching backtrace entries
+
+[john@phrozen.org: felix will add this to his upstream queue]
+
+lede-commit 53827cdc824556cda910b23ce5030c363b8f1461
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ lib/vsprintf.c | 15 +++++++++++----
+ 1 file changed, 11 insertions(+), 4 deletions(-)
+
+--- a/lib/vsprintf.c
++++ b/lib/vsprintf.c
+@@ -983,8 +983,10 @@ char *symbol_string(char *buf, char *end
+ 		    struct printf_spec spec, const char *fmt)
+ {
+ 	unsigned long value;
+-#ifdef CONFIG_KALLSYMS
+ 	char sym[KSYM_SYMBOL_LEN];
++#ifndef CONFIG_KALLSYMS
++	struct module *mod;
++	int len;
+ #endif
+ 
+ 	if (fmt[1] == 'R')
+@@ -1005,8 +1007,14 @@ char *symbol_string(char *buf, char *end
+ 
+ 	return string_nocheck(buf, end, sym, spec);
+ #else
+-	return special_hex_number(buf, end, value, sizeof(void *));
++	len = snprintf(sym, sizeof(sym), "0x%lx", value);
++	mod = __module_address(value);
++	if (mod)
++		snprintf(sym + len, sizeof(sym) - len, " [%s@%p+0x%x]",
++			 mod->name, mod->mem[MOD_TEXT].base,
++			 mod->mem[MOD_TEXT].size);
+ #endif
++	return string(buf, end, sym, spec);
+ }
+ 
+ static const struct printf_spec default_str_spec = {
diff --git a/target/linux/generic/pending-6.12/240-remove-unsane-filenames-from-deps_initramfs-list.patch b/target/linux/generic/pending-6.12/240-remove-unsane-filenames-from-deps_initramfs-list.patch
new file mode 100644
index 0000000000..9e78284ecf
--- /dev/null
+++ b/target/linux/generic/pending-6.12/240-remove-unsane-filenames-from-deps_initramfs-list.patch
@@ -0,0 +1,30 @@
+From: Gabor Juhos <juhosg@openwrt.org>
+Subject: usr: sanitize deps_initramfs list
+
+If any filename in the intramfs dependency
+list contains a colon, that causes a kernel
+build error like this:
+
+/devel/openwrt/build_dir/linux-ar71xx_generic/linux-3.6.6/usr/Makefile:58: *** multiple target patterns.  Stop.
+make[5]: *** [usr] Error 2
+
+Fix it by removing such filenames from the
+deps_initramfs list.
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ usr/Makefile | 8 +++++---
+ 1 file changed, 5 insertions(+), 3 deletions(-)
+
+--- a/usr/Makefile
++++ b/usr/Makefile
+@@ -56,6 +56,8 @@ hostprogs := gen_init_cpio
+ # The dependency list is generated by gen_initramfs.sh -l
+ -include $(obj)/.initramfs_data.cpio.d
+ 
++deps_initramfs := $(foreach v,$(deps_initramfs),$(if $(findstring :,$(v)),,$(v)))
++
+ # do not try to update files included in initramfs
+ $(deps_initramfs): ;
+ 
diff --git a/target/linux/generic/pending-6.12/270-platform-mikrotik-build-bits.patch b/target/linux/generic/pending-6.12/270-platform-mikrotik-build-bits.patch
new file mode 100644
index 0000000000..772d9feeb8
--- /dev/null
+++ b/target/linux/generic/pending-6.12/270-platform-mikrotik-build-bits.patch
@@ -0,0 +1,31 @@
+From c2deb5ef01a0ef09088832744cbace9e239a6ee0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Thibaut=20VAR=C3=88NE?= <hacks@slashdirt.org>
+Date: Sat, 28 Mar 2020 12:11:50 +0100
+Subject: [PATCH] generic: platform/mikrotik build bits (5.4)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This patch adds platform/mikrotik kernel build bits
+
+Signed-off-by: Thibaut VARÈNE <hacks@slashdirt.org>
+---
+ drivers/platform/Kconfig  | 2 ++
+ drivers/platform/Makefile | 1 +
+ 2 files changed, 3 insertions(+)
+
+--- a/drivers/platform/Kconfig
++++ b/drivers/platform/Kconfig
+@@ -18,3 +18,5 @@ source "drivers/platform/surface/Kconfig
+ source "drivers/platform/x86/Kconfig"
+ 
+ source "drivers/platform/arm64/Kconfig"
++
++source "drivers/platform/mikrotik/Kconfig"
+--- a/drivers/platform/Makefile
++++ b/drivers/platform/Makefile
+@@ -13,3 +13,4 @@ obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome
+ obj-$(CONFIG_CZNIC_PLATFORMS)	+= cznic/
+ obj-$(CONFIG_SURFACE_PLATFORMS)	+= surface/
+ obj-$(CONFIG_ARM64_PLATFORM_DEVICES)	+= arm64/
++obj-$(CONFIG_MIKROTIK)		+= mikrotik/
diff --git a/target/linux/generic/pending-6.12/300-mips_expose_boot_raw.patch b/target/linux/generic/pending-6.12/300-mips_expose_boot_raw.patch
new file mode 100644
index 0000000000..ca8d010346
--- /dev/null
+++ b/target/linux/generic/pending-6.12/300-mips_expose_boot_raw.patch
@@ -0,0 +1,40 @@
+From: Mark Miller <mark@mirell.org>
+Subject: mips: expose CONFIG_BOOT_RAW
+
+This exposes the CONFIG_BOOT_RAW symbol in Kconfig. This is needed on
+certain Broadcom chipsets running CFE in order to load the kernel.
+
+Signed-off-by: Mark Miller <mark@mirell.org>
+Acked-by: Rob Landley <rob@landley.net>
+---
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -1055,9 +1055,6 @@ config FW_ARC
+ config ARCH_MAY_HAVE_PC_FDC
+ 	bool
+ 
+-config BOOT_RAW
+-	bool
+-
+ config CEVT_BCM1480
+ 	bool
+ 
+@@ -2990,6 +2987,18 @@ choice
+ 		bool "Extend builtin kernel arguments with bootloader arguments"
+ endchoice
+ 
++config BOOT_RAW
++	bool "Enable the kernel to be executed from the load address"
++	default n
++	help
++	 Allow the kernel to be executed from the load address for
++	 bootloaders which cannot read the ELF format. This places
++	 a jump to start_kernel at the load address.
++
++	 If unsure, say N.
++
++
++
+ endmenu
+ 
+ config LOCKDEP_SUPPORT
diff --git a/target/linux/generic/pending-6.12/301-MIPS-Add-barriers-between-dcache-icache-flushes.patch b/target/linux/generic/pending-6.12/301-MIPS-Add-barriers-between-dcache-icache-flushes.patch
new file mode 100644
index 0000000000..b3cb5f0cde
--- /dev/null
+++ b/target/linux/generic/pending-6.12/301-MIPS-Add-barriers-between-dcache-icache-flushes.patch
@@ -0,0 +1,71 @@
+From e6e6ef4275978823ec3a84133fc91f4ffbef5c84 Mon Sep 17 00:00:00 2001
+From: Paul Burton <paul.burton@imgtec.com>
+Date: Mon, 22 Feb 2016 18:09:44 +0000
+Subject: [PATCH] MIPS: Add barriers between dcache & icache flushes
+
+Index-based cache operations may be arbitrarily reordered by out of
+order CPUs. Thus code which writes back the dcache & then invalidates
+the icache using indexed cache ops must include a barrier between
+operating on the 2 caches in order to prevent the scenario in which:
+
+  - icache invalidation occurs.
+
+  - icache fetch occurs, due to speculation.
+
+  - dcache writeback occurs.
+
+If the above were allowed to happen then the icache would contain stale
+data. Forcing the dcache writeback to complete before the icache
+invalidation avoids this.
+
+Signed-off-by: Paul Burton <paul.burton@imgtec.com>
+Cc: James Hogan <james.hogan@imgtec.com>
+---
+ arch/mips/mm/c-r4k.c | 13 +++++++++++--
+ 1 file changed, 11 insertions(+), 2 deletions(-)
+
+--- a/arch/mips/mm/c-r4k.c
++++ b/arch/mips/mm/c-r4k.c
+@@ -403,6 +403,7 @@ static inline void local_r4k___flush_cac
+ 
+ 	default:
+ 		r4k_blast_dcache();
++		mb(); /* cache instructions may be reordered */
+ 		r4k_blast_icache();
+ 		break;
+ 	}
+@@ -483,8 +484,10 @@ static inline void local_r4k_flush_cache
+ 	if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc))
+ 		r4k_blast_dcache();
+ 	/* If executable, blast stale lines from icache */
+-	if (exec)
++	if (exec) {
++		mb(); /* cache instructions may be reordered */
+ 		r4k_blast_icache();
++	}
+ }
+ 
+ static void r4k_flush_cache_range(struct vm_area_struct *vma,
+@@ -586,8 +589,13 @@ static inline void local_r4k_flush_cache
+ 	if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
+ 		vaddr ? r4k_blast_dcache_page(addr) :
+ 			r4k_blast_dcache_user_page(addr);
+-		if (exec && !cpu_icache_snoops_remote_store)
++		if (exec)
++			mb(); /* cache instructions may be reordered */
++
++		if (exec && !cpu_icache_snoops_remote_store) {
+ 			r4k_blast_scache_page(addr);
++			mb(); /* cache instructions may be reordered */
++		}
+ 	}
+ 	if (exec) {
+ 		if (vaddr && cpu_has_vtag_icache && mm == current->active_mm) {
+@@ -654,6 +662,7 @@ static inline void __local_r4k_flush_ica
+ 			else
+ 				blast_dcache_range(start, end);
+ 		}
++		mb(); /* cache instructions may be reordered */
+ 	}
+ 
+ 	if (type == R4K_INDEX ||
diff --git a/target/linux/generic/pending-6.12/302-mips_no_branch_likely.patch b/target/linux/generic/pending-6.12/302-mips_no_branch_likely.patch
new file mode 100644
index 0000000000..669aa8143a
--- /dev/null
+++ b/target/linux/generic/pending-6.12/302-mips_no_branch_likely.patch
@@ -0,0 +1,22 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: mips: use -mno-branch-likely for kernel and userspace
+
+saves ~11k kernel size after lzma and ~12k squashfs size in the
+
+lede-commit: 41a039f46450ffae9483d6216422098669da2900
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ arch/mips/Makefile | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -94,7 +94,7 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
+ # machines may also.  Since BFD is incredibly buggy with respect to
+ # crossformat linking we rely on the elf2ecoff tool for format conversion.
+ #
+-cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
++cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
+ cflags-y			+= -msoft-float -Wa,-msoft-float
+ LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
+ KBUILD_AFLAGS_MODULE		+= -mlong-calls
diff --git a/target/linux/generic/pending-6.12/308-mips32r2_tune.patch b/target/linux/generic/pending-6.12/308-mips32r2_tune.patch
new file mode 100644
index 0000000000..b9bd6104a4
--- /dev/null
+++ b/target/linux/generic/pending-6.12/308-mips32r2_tune.patch
@@ -0,0 +1,22 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: kernel: add -mtune=34kc to MIPS CFLAGS when building for mips32r2
+
+This provides a good tradeoff across at least 24Kc-74Kc, while also
+producing smaller code.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ arch/mips/Makefile | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -153,7 +153,7 @@ cflags-$(CONFIG_CPU_R4300)	+= $(call cc-
+ cflags-$(CONFIG_CPU_R4X00)	+= $(call cc-option,-march=r4600,-march=mips3) -Wa,--trap
+ cflags-$(CONFIG_CPU_TX49XX)	+= $(call cc-option,-march=r4600,-march=mips3) -Wa,--trap
+ cflags-$(CONFIG_CPU_MIPS32_R1)	+= -march=mips32 -Wa,--trap
+-cflags-$(CONFIG_CPU_MIPS32_R2)	+= -march=mips32r2 -Wa,--trap
++cflags-$(CONFIG_CPU_MIPS32_R2)	+= -march=mips32r2 -mtune=34kc -Wa,--trap
+ cflags-$(CONFIG_CPU_MIPS32_R5)	+= -march=mips32r5 -Wa,--trap -modd-spreg
+ cflags-$(CONFIG_CPU_MIPS32_R6)	+= -march=mips32r6 -Wa,--trap -modd-spreg
+ cflags-$(CONFIG_CPU_MIPS64_R1)	+= -march=mips64 -Wa,--trap
diff --git a/target/linux/generic/pending-6.12/310-arm_module_unresolved_weak_sym.patch b/target/linux/generic/pending-6.12/310-arm_module_unresolved_weak_sym.patch
new file mode 100644
index 0000000000..c654f6baf6
--- /dev/null
+++ b/target/linux/generic/pending-6.12/310-arm_module_unresolved_weak_sym.patch
@@ -0,0 +1,22 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: fix errors in unresolved weak symbols on arm
+
+lede-commit: 570699d4838a907c3ef9f2819bf19eb72997b32f
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ arch/arm/kernel/module.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/arch/arm/kernel/module.c
++++ b/arch/arm/kernel/module.c
+@@ -112,6 +112,10 @@ apply_relocate(Elf32_Shdr *sechdrs, cons
+ 			return -ENOEXEC;
+ 		}
+ 
++		if ((IS_ERR_VALUE(sym->st_value) || !sym->st_value) &&
++		    ELF_ST_BIND(sym->st_info) == STB_WEAK)
++			continue;
++
+ 		loc = dstsec->sh_addr + rel->r_offset;
+ 
+ 		switch (ELF32_R_TYPE(rel->r_info)) {
diff --git a/target/linux/generic/pending-6.12/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch b/target/linux/generic/pending-6.12/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch
new file mode 100644
index 0000000000..a8c6b7a5da
--- /dev/null
+++ b/target/linux/generic/pending-6.12/330-MIPS-kexec-Accept-command-line-parameters-from-users.patch
@@ -0,0 +1,282 @@
+From: Yousong Zhou <yszhou4tech@gmail.com>
+Subject: MIPS: kexec: Accept command line parameters from userspace.
+
+Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
+---
+ arch/mips/kernel/machine_kexec.c   |  153 +++++++++++++++++++++++++++++++-----
+ arch/mips/kernel/machine_kexec.h   |   20 +++++
+ arch/mips/kernel/relocate_kernel.S |   21 +++--
+ 3 files changed, 167 insertions(+), 27 deletions(-)
+ create mode 100644 arch/mips/kernel/machine_kexec.h
+
+--- a/arch/mips/kernel/machine_kexec.c
++++ b/arch/mips/kernel/machine_kexec.c
+@@ -10,14 +10,11 @@
+ #include <linux/libfdt.h>
+ #include <linux/reboot.h>
+ 
++#include <asm/bootinfo.h>
+ #include <asm/cacheflush.h>
+ #include <asm/page.h>
+-
+-extern const unsigned char relocate_new_kernel[];
+-extern const size_t relocate_new_kernel_size;
+-
+-extern unsigned long kexec_start_address;
+-extern unsigned long kexec_indirection_page;
++#include <linux/uaccess.h>
++#include "machine_kexec.h"
+ 
+ static unsigned long reboot_code_buffer;
+ 
+@@ -31,6 +28,101 @@ void (*_crash_smp_send_stop)(void) = NUL
+ void (*_machine_kexec_shutdown)(void) = NULL;
+ void (*_machine_crash_shutdown)(struct pt_regs *regs) = NULL;
+ 
++static void machine_kexec_print_args(void)
++{
++	unsigned long argc = (int)kexec_args[0];
++	int i;
++
++	pr_info("kexec_args[0] (argc): %lu\n", argc);
++	pr_info("kexec_args[1] (argv): %p\n", (void *)kexec_args[1]);
++	pr_info("kexec_args[2] (env ): %p\n", (void *)kexec_args[2]);
++	pr_info("kexec_args[3] (desc): %p\n", (void *)kexec_args[3]);
++
++	for (i = 0; i < argc; i++) {
++		pr_info("kexec_argv[%d] = %p, %s\n",
++				i, kexec_argv[i], kexec_argv[i]);
++	}
++}
++
++static void machine_kexec_init_argv(struct kimage *image)
++{
++	void __user *buf = NULL;
++	size_t bufsz;
++	size_t size;
++	int i;
++
++	bufsz = 0;
++	for (i = 0; i < image->nr_segments; i++) {
++		struct kexec_segment *seg;
++
++		seg = &image->segment[i];
++		if (seg->bufsz < 6)
++			continue;
++
++		if (strncmp((char *) seg->buf, "kexec ", 6))
++			continue;
++
++		buf = seg->buf;
++		bufsz = seg->bufsz;
++		break;
++	}
++
++	if (!buf)
++		return;
++
++	size = KEXEC_COMMAND_LINE_SIZE;
++	size = min(size, bufsz);
++	if (size < bufsz)
++		pr_warn("kexec command line truncated to %zd bytes\n", size);
++
++	/* Copy to kernel space */
++	if (copy_from_user(kexec_argv_buf, buf, size))
++		pr_warn("kexec command line copy to kernel space failed\n");
++
++	kexec_argv_buf[size - 1] = 0;
++}
++
++static void machine_kexec_parse_argv(struct kimage *image)
++{
++	char *reboot_code_buffer;
++	int reloc_delta;
++	char *ptr;
++	int argc;
++	int i;
++
++	ptr = kexec_argv_buf;
++	argc = 0;
++
++	/*
++	 * convert command line string to array of parameters
++	 * (as bootloader does).
++	 */
++	while (ptr && *ptr && (KEXEC_MAX_ARGC > argc)) {
++		if (*ptr == ' ') {
++			*ptr++ = '\0';
++			continue;
++		}
++
++		kexec_argv[argc++] = ptr;
++		ptr = strchr(ptr, ' ');
++	}
++
++	if (!argc)
++		return;
++
++	kexec_args[0] = argc;
++	kexec_args[1] = (unsigned long)kexec_argv;
++	kexec_args[2] = 0;
++	kexec_args[3] = 0;
++
++	reboot_code_buffer = page_address(image->control_code_page);
++	reloc_delta = reboot_code_buffer - (char *)kexec_relocate_new_kernel;
++
++	kexec_args[1] += reloc_delta;
++	for (i = 0; i < argc; i++)
++		kexec_argv[i] += reloc_delta;
++}
++
+ static void kexec_image_info(const struct kimage *kimage)
+ {
+ 	unsigned long i;
+@@ -100,6 +192,18 @@ machine_kexec_prepare(struct kimage *kim
+ #endif
+ 
+ 	kexec_image_info(kimage);
++	/*
++	 * Whenever arguments passed from kexec-tools, Init the arguments as
++	 * the original ones to try avoiding booting failure.
++	 */
++
++	kexec_args[0] = fw_arg0;
++	kexec_args[1] = fw_arg1;
++	kexec_args[2] = fw_arg2;
++	kexec_args[3] = fw_arg3;
++
++	machine_kexec_init_argv(kimage);
++	machine_kexec_parse_argv(kimage);
+ 
+ 	if (_machine_kexec_prepare)
+ 		return _machine_kexec_prepare(kimage);
+@@ -162,7 +266,7 @@ machine_crash_shutdown(struct pt_regs *r
+ void kexec_nonboot_cpu_jump(void)
+ {
+ 	local_flush_icache_range((unsigned long)relocated_kexec_smp_wait,
+-				 reboot_code_buffer + relocate_new_kernel_size);
++				 reboot_code_buffer + KEXEC_RELOCATE_NEW_KERNEL_SIZE);
+ 
+ 	relocated_kexec_smp_wait(NULL);
+ }
+@@ -200,7 +304,7 @@ void kexec_reboot(void)
+ 	 * machine_kexec() CPU.
+ 	 */
+ 	local_flush_icache_range(reboot_code_buffer,
+-				 reboot_code_buffer + relocate_new_kernel_size);
++				 reboot_code_buffer + KEXEC_RELOCATE_NEW_KERNEL_SIZE);
+ 
+ 	do_kexec = (void *)reboot_code_buffer;
+ 	do_kexec();
+@@ -213,10 +317,12 @@ machine_kexec(struct kimage *image)
+ 	unsigned long *ptr;
+ 
+ 	reboot_code_buffer =
+-	  (unsigned long)page_address(image->control_code_page);
++		(unsigned long)page_address(image->control_code_page);
++	pr_info("reboot_code_buffer = %p\n", (void *)reboot_code_buffer);
+ 
+ 	kexec_start_address =
+ 		(unsigned long) phys_to_virt(image->start);
++	pr_info("kexec_start_address = %p\n", (void *)kexec_start_address);
+ 
+ 	if (image->type == KEXEC_TYPE_DEFAULT) {
+ 		kexec_indirection_page =
+@@ -224,9 +330,19 @@ machine_kexec(struct kimage *image)
+ 	} else {
+ 		kexec_indirection_page = (unsigned long)&image->head;
+ 	}
++	pr_info("kexec_indirection_page = %p\n", (void *)kexec_indirection_page);
+ 
+-	memcpy((void*)reboot_code_buffer, relocate_new_kernel,
+-	       relocate_new_kernel_size);
++	pr_info("Where is memcpy: %p\n", memcpy);
++	pr_info("kexec_relocate_new_kernel = %p, kexec_relocate_new_kernel_end = %p\n",
++		(void *)kexec_relocate_new_kernel, &kexec_relocate_new_kernel_end);
++	pr_info("Copy %lu bytes from %p to %p\n", KEXEC_RELOCATE_NEW_KERNEL_SIZE,
++		(void *)kexec_relocate_new_kernel, (void *)reboot_code_buffer);
++	memcpy((void*)reboot_code_buffer, kexec_relocate_new_kernel,
++	       KEXEC_RELOCATE_NEW_KERNEL_SIZE);
++
++	pr_info("Before _print_args().\n");
++	machine_kexec_print_args();
++	pr_info("Before eval loop.\n");
+ 
+ 	/*
+ 	 * The generic kexec code builds a page list with physical
+@@ -257,7 +373,7 @@ machine_kexec(struct kimage *image)
+ #ifdef CONFIG_SMP
+ 	/* All secondary cpus now may jump to kexec_wait cycle */
+ 	relocated_kexec_smp_wait = reboot_code_buffer +
+-		(void *)(kexec_smp_wait - relocate_new_kernel);
++		(void *)(kexec_smp_wait - kexec_relocate_new_kernel);
+ 	smp_wmb();
+ 	atomic_set(&kexec_ready_to_reboot, 1);
+ #endif
+--- /dev/null
++++ b/arch/mips/kernel/machine_kexec.h
+@@ -0,0 +1,20 @@
++#ifndef _MACHINE_KEXEC_H
++#define _MACHINE_KEXEC_H
++
++#ifndef __ASSEMBLY__
++extern const unsigned char kexec_relocate_new_kernel[];
++extern unsigned long kexec_relocate_new_kernel_end;
++extern unsigned long kexec_start_address;
++extern unsigned long kexec_indirection_page;
++
++extern char kexec_argv_buf[];
++extern char *kexec_argv[];
++
++#define KEXEC_RELOCATE_NEW_KERNEL_SIZE	((unsigned long)&kexec_relocate_new_kernel_end - (unsigned long)kexec_relocate_new_kernel)
++#endif /* !__ASSEMBLY__ */
++
++#define KEXEC_COMMAND_LINE_SIZE		256
++#define KEXEC_ARGV_SIZE			(KEXEC_COMMAND_LINE_SIZE / 16)
++#define KEXEC_MAX_ARGC			(KEXEC_ARGV_SIZE / sizeof(long))
++
++#endif
+--- a/arch/mips/kernel/relocate_kernel.S
++++ b/arch/mips/kernel/relocate_kernel.S
+@@ -10,10 +10,11 @@
+ #include <asm/mipsregs.h>
+ #include <asm/stackframe.h>
+ #include <asm/addrspace.h>
++#include "machine_kexec.h"
+ 
+ #include <kernel-entry-init.h>
+ 
+-LEAF(relocate_new_kernel)
++LEAF(kexec_relocate_new_kernel)
+ 	PTR_L a0,	arg0
+ 	PTR_L a1,	arg1
+ 	PTR_L a2,	arg2
+@@ -97,7 +98,7 @@ done:
+ #endif
+ 	/* jump to kexec_start_address */
+ 	j		s1
+-	END(relocate_new_kernel)
++	END(kexec_relocate_new_kernel)
+ 
+ #ifdef CONFIG_SMP
+ /*
+@@ -176,8 +177,15 @@ EXPORT(kexec_indirection_page)
+ 	PTR_WD		0
+ 	.size		kexec_indirection_page, PTRSIZE
+ 
+-relocate_new_kernel_end:
++kexec_argv_buf:
++	EXPORT(kexec_argv_buf)
++	.skip		KEXEC_COMMAND_LINE_SIZE
++	.size		kexec_argv_buf, KEXEC_COMMAND_LINE_SIZE
++
++kexec_argv:
++	EXPORT(kexec_argv)
++	.skip		KEXEC_ARGV_SIZE
++	.size		kexec_argv, KEXEC_ARGV_SIZE
+ 
+-EXPORT(relocate_new_kernel_size)
+-	PTR_WD		relocate_new_kernel_end - relocate_new_kernel
+-	.size		relocate_new_kernel_size, PTRSIZE
++kexec_relocate_new_kernel_end:
++	EXPORT(kexec_relocate_new_kernel_end)
diff --git a/target/linux/generic/pending-6.12/332-arc-add-OWRTDTB-section.patch b/target/linux/generic/pending-6.12/332-arc-add-OWRTDTB-section.patch
new file mode 100644
index 0000000000..5b943f3734
--- /dev/null
+++ b/target/linux/generic/pending-6.12/332-arc-add-OWRTDTB-section.patch
@@ -0,0 +1,84 @@
+From bb0c3b0175240bf152fd7c644821a0cf9f77c37c Mon Sep 17 00:00:00 2001
+From: Evgeniy Didin <Evgeniy.Didin@synopsys.com>
+Date: Fri, 15 Mar 2019 18:53:38 +0300
+Subject: [PATCH] arc add OWRTDTB section
+
+This change allows OpenWRT to patch resulting kernel binary with
+external .dtb.
+
+That allows us to re-use exactky the same vmlinux on different boards
+given its ARC core configurations match (at least cache line sizes etc).
+
+""patch-dtb" searches for ASCII "OWRTDTB:" strign and copies external
+.dtb right after it, keeping the string in place.
+
+Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
+Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
+Signed-off-by: Evgeniy Didin <Evgeniy.Didin@synopsys.com>
+---
+ arch/arc/kernel/head.S        | 10 ++++++++++
+ arch/arc/kernel/setup.c       |  4 +++-
+ arch/arc/kernel/vmlinux.lds.S | 13 +++++++++++++
+ 3 files changed, 26 insertions(+), 1 deletion(-)
+
+--- a/arch/arc/kernel/head.S
++++ b/arch/arc/kernel/head.S
+@@ -88,6 +88,16 @@
+ 	DSP_EARLY_INIT
+ .endm
+ 
++	; Here "patch-dtb" will embed external .dtb
++	; Note "patch-dtb" searches for ASCII "OWRTDTB:" string
++	; and pastes .dtb right after it, hense the string precedes
++	; __image_dtb symbol.
++	.section .owrt, "aw",@progbits
++	.ascii  "OWRTDTB:"
++ENTRY(__image_dtb)
++	.fill   0x4000
++END(__image_dtb)
++
+ 	.section .init.text, "ax",@progbits
+ 
+ ;----------------------------------------------------------------
+--- a/arch/arc/kernel/setup.c
++++ b/arch/arc/kernel/setup.c
+@@ -450,6 +450,8 @@ static inline bool uboot_arg_invalid(uns
+ /* We always pass 0 as magic from U-boot */
+ #define UBOOT_MAGIC_VALUE	0
+ 
++extern struct boot_param_header __image_dtb;
++
+ void __init handle_uboot_args(void)
+ {
+ 	bool use_embedded_dtb = true;
+@@ -488,7 +490,7 @@ void __init handle_uboot_args(void)
+ ignore_uboot_args:
+ 
+ 	if (use_embedded_dtb) {
+-		machine_desc = setup_machine_fdt(__dtb_start);
++		machine_desc = setup_machine_fdt(&__image_dtb);
+ 		if (!machine_desc)
+ 			panic("Embedded DT invalid\n");
+ 	}
+--- a/arch/arc/kernel/vmlinux.lds.S
++++ b/arch/arc/kernel/vmlinux.lds.S
+@@ -27,6 +27,19 @@ SECTIONS
+ 
+ 	. = CONFIG_LINUX_LINK_BASE;
+ 
++	/*
++	* In OpenWRT we want to patch built binary embedding .dtb of choice.
++	* This is implemented with "patch-dtb" utility which searches for
++	* "OWRTDTB:" string in first 16k of image and if it is found
++	* copies .dtb right after mentioned string.
++	*
++	* Note: "OWRTDTB:" won't be overwritten with .dtb, .dtb will follow it.
++	*/
++	.owrt : {
++		*(.owrt)
++	. = ALIGN(PAGE_SIZE);
++	}
++
+ 	_int_vec_base_lds = .;
+ 	.vector : {
+ 		*(.vector)
diff --git a/target/linux/generic/pending-6.12/333-arc-enable-unaligned-access-in-kernel-mode.patch b/target/linux/generic/pending-6.12/333-arc-enable-unaligned-access-in-kernel-mode.patch
new file mode 100644
index 0000000000..2c9808de2a
--- /dev/null
+++ b/target/linux/generic/pending-6.12/333-arc-enable-unaligned-access-in-kernel-mode.patch
@@ -0,0 +1,24 @@
+From: Alexey Brodkin <abrodkin@synopsys.com>
+Subject: arc: enable unaligned access in kernel mode
+
+This enables misaligned access handling even in kernel mode.
+Some wireless drivers (ath9k-htc and mt7601u) use misaligned accesses
+here and there and to cope with that without fixing stuff in the drivers
+we're just gracefully handling it on ARC.
+
+Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
+---
+ arch/arc/kernel/unaligned.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arc/kernel/unaligned.c
++++ b/arch/arc/kernel/unaligned.c
+@@ -203,7 +203,7 @@ int misaligned_fixup(unsigned long addre
+ 	char buf[TASK_COMM_LEN];
+ 
+ 	/* handle user mode only and only if enabled by sysadmin */
+-	if (!user_mode(regs) || !unaligned_enabled)
++	if (!unaligned_enabled)
+ 		return 1;
+ 
+ 	if (no_unaligned_warning) {
diff --git a/target/linux/generic/pending-6.12/342-powerpc-Enable-kernel-XZ-compression-option-on-PPC_8.patch b/target/linux/generic/pending-6.12/342-powerpc-Enable-kernel-XZ-compression-option-on-PPC_8.patch
new file mode 100644
index 0000000000..c812a08b91
--- /dev/null
+++ b/target/linux/generic/pending-6.12/342-powerpc-Enable-kernel-XZ-compression-option-on-PPC_8.patch
@@ -0,0 +1,25 @@
+From 66770a004afe10df11d3902e16eaa0c2c39436bb Mon Sep 17 00:00:00 2001
+From: Pawel Dembicki <paweldembicki@gmail.com>
+Date: Fri, 24 May 2019 17:56:19 +0200
+Subject: [PATCH] powerpc: Enable kernel XZ compression option on PPC_85xx
+
+Enable kernel XZ compression option on PPC_85xx. Tested with
+simpleImage on TP-Link TL-WDR4900 (Freescale P1014 processor).
+
+Suggested-by: Christian Lamparter <chunkeey@gmail.com>
+Signed-off-by: Pawel Dembicki <paweldembicki@gmail.com>
+---
+ arch/powerpc/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/powerpc/Kconfig
++++ b/arch/powerpc/Kconfig
+@@ -254,7 +254,7 @@ config PPC
+ 	select HAVE_KERNEL_GZIP
+ 	select HAVE_KERNEL_LZMA			if DEFAULT_UIMAGE
+ 	select HAVE_KERNEL_LZO			if DEFAULT_UIMAGE
+-	select HAVE_KERNEL_XZ			if PPC_BOOK3S || 44x
++	select HAVE_KERNEL_XZ			if PPC_BOOK3S || 44x || PPC_85xx
+ 	select HAVE_KPROBES
+ 	select HAVE_KPROBES_ON_FTRACE
+ 	select HAVE_KRETPROBES
diff --git a/target/linux/generic/pending-6.12/350-mips-kernel-fix-detect_memory_region-function.patch b/target/linux/generic/pending-6.12/350-mips-kernel-fix-detect_memory_region-function.patch
new file mode 100644
index 0000000000..a99eed4716
--- /dev/null
+++ b/target/linux/generic/pending-6.12/350-mips-kernel-fix-detect_memory_region-function.patch
@@ -0,0 +1,74 @@
+From: Shiji Yang <yangshiji66@outlook.com>
+Date: Wed, 13 Mar 2024 20:28:37 +0800
+Subject: [PATCH] mips: kernel: fix detect_memory_region() function
+
+1. Do not use memcmp() on unallocated memory, as the new introduced
+   fortify dynamic object size check[1] will report unexpected result.
+2. Use a fixed pattern instead of a random function pointer as the
+   magic value.
+3. Flip magic value and double check it.
+4. Enable this feature only for 32-bit CPUs. Currently, only ath79 and
+   ralink CPUs are using it.
+
+[1] 439a1bcac648 ("fortify: Use __builtin_dynamic_object_size() when available")
+Signed-off-by: Shiji Yang <yangshiji66@outlook.com>
+---
+ arch/mips/include/asm/bootinfo.h |  2 ++
+ arch/mips/kernel/setup.c         | 17 ++++++++++++-----
+ 2 files changed, 14 insertions(+), 5 deletions(-)
+
+--- a/arch/mips/include/asm/bootinfo.h
++++ b/arch/mips/include/asm/bootinfo.h
+@@ -93,7 +93,9 @@ const char *get_system_type(void);
+ 
+ extern unsigned long mips_machtype;
+ 
++#ifndef CONFIG_64BIT
+ extern void detect_memory_region(phys_addr_t start, phys_addr_t sz_min,  phys_addr_t sz_max);
++#endif
+ 
+ extern void prom_init(void);
+ extern void prom_free_prom_memory(void);
+--- a/arch/mips/kernel/setup.c
++++ b/arch/mips/kernel/setup.c
+@@ -86,21 +86,27 @@ static struct resource bss_resource = {
+ unsigned long __kaslr_offset __ro_after_init;
+ EXPORT_SYMBOL(__kaslr_offset);
+ 
+-static void *detect_magic __initdata = detect_memory_region;
+-
+ #ifdef CONFIG_MIPS_AUTO_PFN_OFFSET
+ unsigned long ARCH_PFN_OFFSET;
+ EXPORT_SYMBOL(ARCH_PFN_OFFSET);
+ #endif
+ 
++#ifndef CONFIG_64BIT
++static u32 detect_magic __initdata;
++#define MIPS_MEM_TEST_PATTERN		0xaa5555aa
++
+ void __init detect_memory_region(phys_addr_t start, phys_addr_t sz_min, phys_addr_t sz_max)
+ {
+-	void *dm = &detect_magic;
++	void *dm = (void *)KSEG1ADDR(&detect_magic);
+ 	phys_addr_t size;
+ 
+ 	for (size = sz_min; size < sz_max; size <<= 1) {
+-		if (!memcmp(dm, dm + size, sizeof(detect_magic)))
+-			break;
++		__raw_writel(MIPS_MEM_TEST_PATTERN, dm);
++		if (__raw_readl(dm) == __raw_readl(dm + size)) {
++			__raw_writel(~MIPS_MEM_TEST_PATTERN, dm);
++			if (__raw_readl(dm) == __raw_readl(dm + size))
++				break;
++		}
+ 	}
+ 
+ 	pr_debug("Memory: %lluMB of RAM detected at 0x%llx (min: %lluMB, max: %lluMB)\n",
+@@ -111,6 +117,7 @@ void __init detect_memory_region(phys_ad
+ 
+ 	memblock_add(start, size);
+ }
++#endif /* CONFIG_64BIT */
+ 
+ /*
+  * Manage initrd
diff --git a/target/linux/generic/pending-6.12/400-mtd-mtdsplit-support.patch b/target/linux/generic/pending-6.12/400-mtd-mtdsplit-support.patch
new file mode 100644
index 0000000000..838f9ac990
--- /dev/null
+++ b/target/linux/generic/pending-6.12/400-mtd-mtdsplit-support.patch
@@ -0,0 +1,328 @@
+From 39717277d5c87bdb183cf2f258957b44ba99b4df Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 11:47:35 +0200
+Subject: [PATCH] mtd: mtdsplit support
+
+---
+ drivers/mtd/Kconfig            |  19 ++++
+ drivers/mtd/Makefile           |   2 +
+ drivers/mtd/mtdpart.c          | 169 ++++++++++++++++++++++++++++-----
+ include/linux/mtd/mtd.h        |  25 +++++
+ include/linux/mtd/partitions.h |   7 ++
+ 5 files changed, 197 insertions(+), 25 deletions(-)
+
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -12,6 +12,25 @@ menuconfig MTD
+ 
+ if MTD
+ 
++menu "OpenWrt specific MTD options"
++
++config MTD_ROOTFS_ROOT_DEV
++	bool "Automatically set 'rootfs' partition to be root filesystem"
++	default y
++
++config MTD_SPLIT_FIRMWARE
++	bool "Automatically split firmware partition for kernel+rootfs"
++	default y
++
++config MTD_SPLIT_FIRMWARE_NAME
++	string "Firmware partition name"
++	depends on MTD_SPLIT_FIRMWARE
++	default "firmware"
++
++source "drivers/mtd/mtdsplit/Kconfig"
++
++endmenu
++
+ config MTD_TESTS
+ 	tristate "MTD tests support (DANGEROUS)"
+ 	depends on m
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -9,6 +9,8 @@ mtd-y				:= mtdcore.o mtdsuper.o mtdconc
+ 
+ obj-y				+= parsers/
+ 
++obj-$(CONFIG_MTD_SPLIT)		+= mtdsplit/
++
+ # 'Users' - code which presents functionality to userspace.
+ obj-$(CONFIG_MTD_BLKDEVS)	+= mtd_blkdevs.o
+ obj-$(CONFIG_MTD_BLOCK)		+= mtdblock.o
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -15,11 +15,13 @@
+ #include <linux/kmod.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
++#include <linux/magic.h>
+ #include <linux/err.h>
+ #include <linux/of.h>
+ #include <linux/of_platform.h>
+ 
+ #include "mtdcore.h"
++#include "mtdsplit/mtdsplit.h"
+ 
+ /*
+  * MTD methods which simply translate the effective address and pass through
+@@ -242,6 +244,147 @@ static int mtd_add_partition_attrs(struc
+ 	return ret;
+ }
+ 
++static DEFINE_SPINLOCK(part_parser_lock);
++static LIST_HEAD(part_parsers);
++
++static struct mtd_part_parser *mtd_part_parser_get(const char *name)
++{
++	struct mtd_part_parser *p, *ret = NULL;
++
++	spin_lock(&part_parser_lock);
++
++	list_for_each_entry(p, &part_parsers, list)
++		if (!strcmp(p->name, name) && try_module_get(p->owner)) {
++			ret = p;
++			break;
++		}
++
++	spin_unlock(&part_parser_lock);
++
++	return ret;
++}
++
++static inline void mtd_part_parser_put(const struct mtd_part_parser *p)
++{
++	module_put(p->owner);
++}
++
++static struct mtd_part_parser *
++get_partition_parser_by_type(enum mtd_parser_type type,
++			     struct mtd_part_parser *start)
++{
++	struct mtd_part_parser *p, *ret = NULL;
++
++	spin_lock(&part_parser_lock);
++
++	p = list_prepare_entry(start, &part_parsers, list);
++	if (start)
++		mtd_part_parser_put(start);
++
++	list_for_each_entry_continue(p, &part_parsers, list) {
++		if (p->type == type && try_module_get(p->owner)) {
++			ret = p;
++			break;
++		}
++	}
++
++	spin_unlock(&part_parser_lock);
++
++	return ret;
++}
++
++static int parse_mtd_partitions_by_type(struct mtd_info *master,
++					enum mtd_parser_type type,
++					const struct mtd_partition **pparts,
++					struct mtd_part_parser_data *data)
++{
++	struct mtd_part_parser *prev = NULL;
++	int ret = 0;
++
++	while (1) {
++		struct mtd_part_parser *parser;
++
++		parser = get_partition_parser_by_type(type, prev);
++		if (!parser)
++			break;
++
++		ret = (*parser->parse_fn)(master, pparts, data);
++
++		if (ret > 0) {
++			mtd_part_parser_put(parser);
++			printk(KERN_NOTICE
++			       "%d %s partitions found on MTD device %s\n",
++			       ret, parser->name, master->name);
++			break;
++		}
++
++		prev = parser;
++	}
++
++	return ret;
++}
++
++static int
++run_parsers_by_type(struct mtd_info *child, enum mtd_parser_type type)
++{
++	struct mtd_partition *parts;
++	int nr_parts;
++	int i;
++
++	nr_parts = parse_mtd_partitions_by_type(child, type, (const struct mtd_partition **)&parts,
++						NULL);
++	if (nr_parts <= 0)
++		return nr_parts;
++
++	if (WARN_ON(!parts))
++		return 0;
++
++	for (i = 0; i < nr_parts; i++) {
++		/* adjust partition offsets */
++		parts[i].offset += child->part.offset;
++
++		mtd_add_partition(child->parent,
++				  parts[i].name,
++				  parts[i].offset,
++				  parts[i].size);
++	}
++
++	kfree(parts);
++
++	return nr_parts;
++}
++
++#ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
++#define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
++#else
++#define SPLIT_FIRMWARE_NAME	"unused"
++#endif
++
++static void split_firmware(struct mtd_info *master, struct mtd_info *part)
++{
++	run_parsers_by_type(part, MTD_PARSER_TYPE_FIRMWARE);
++}
++
++static void mtd_partition_split(struct mtd_info *master, struct mtd_info *part)
++{
++	static int rootfs_found = 0;
++
++	if (rootfs_found)
++		return;
++
++	if (of_find_property(mtd_get_of_node(part), "linux,rootfs", NULL) ||
++	    !strcmp(part->name, "rootfs")) {
++		run_parsers_by_type(part, MTD_PARSER_TYPE_ROOTFS);
++
++		rootfs_found = 1;
++	}
++
++	if (IS_ENABLED(CONFIG_MTD_SPLIT_FIRMWARE) &&
++	    !strcmp(part->name, SPLIT_FIRMWARE_NAME) &&
++	    !of_find_property(mtd_get_of_node(part), "compatible", NULL))
++		split_firmware(master, part);
++}
++
+ int mtd_add_partition(struct mtd_info *parent, const char *name,
+ 		      long long offset, long long length)
+ {
+@@ -280,6 +423,7 @@ int mtd_add_partition(struct mtd_info *p
+ 	if (ret)
+ 		goto err_remove_part;
+ 
++	mtd_partition_split(parent, child);
+ 	mtd_add_partition_attrs(child);
+ 
+ 	return 0;
+@@ -423,6 +567,7 @@ int add_mtd_partitions(struct mtd_info *
+ 			goto err_del_partitions;
+ 		}
+ 
++		mtd_partition_split(master, child);
+ 		mtd_add_partition_attrs(child);
+ 
+ 		/* Look for subpartitions */
+@@ -443,31 +588,6 @@ err_del_partitions:
+ 	return ret;
+ }
+ 
+-static DEFINE_SPINLOCK(part_parser_lock);
+-static LIST_HEAD(part_parsers);
+-
+-static struct mtd_part_parser *mtd_part_parser_get(const char *name)
+-{
+-	struct mtd_part_parser *p, *ret = NULL;
+-
+-	spin_lock(&part_parser_lock);
+-
+-	list_for_each_entry(p, &part_parsers, list)
+-		if (!strcmp(p->name, name) && try_module_get(p->owner)) {
+-			ret = p;
+-			break;
+-		}
+-
+-	spin_unlock(&part_parser_lock);
+-
+-	return ret;
+-}
+-
+-static inline void mtd_part_parser_put(const struct mtd_part_parser *p)
+-{
+-	module_put(p->owner);
+-}
+-
+ /*
+  * Many partition parsers just expected the core to kfree() all their data in
+  * one chunk. Do that by default.
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -615,6 +615,24 @@ static inline void mtd_align_erase_req(s
+ 		req->len += mtd->erasesize - mod;
+ }
+ 
++static inline uint64_t mtd_roundup_to_eb(uint64_t sz, struct mtd_info *mtd)
++{
++	if (mtd_mod_by_eb(sz, mtd) == 0)
++		return sz;
++
++	/* Round up to next erase block */
++	return (mtd_div_by_eb(sz, mtd) + 1) * mtd->erasesize;
++}
++
++static inline uint64_t mtd_rounddown_to_eb(uint64_t sz, struct mtd_info *mtd)
++{
++	if (mtd_mod_by_eb(sz, mtd) == 0)
++		return sz;
++
++	/* Round down to the start of the current erase block */
++	return (mtd_div_by_eb(sz, mtd)) * mtd->erasesize;
++}
++
+ static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
+ {
+ 	if (mtd->writesize_shift)
+@@ -688,6 +706,13 @@ extern struct mtd_info *of_get_mtd_devic
+ extern struct mtd_info *get_mtd_device_nm(const char *name);
+ extern void put_mtd_device(struct mtd_info *mtd);
+ 
++static inline uint64_t mtdpart_get_offset(const struct mtd_info *mtd)
++{
++	if (!mtd_is_partition(mtd))
++		return 0;
++
++	return mtd->part.offset;
++}
+ 
+ struct mtd_notifier {
+ 	void (*add)(struct mtd_info *mtd);
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -75,6 +75,12 @@ struct mtd_part_parser_data {
+  * Functions dealing with the various ways of partitioning the space
+  */
+ 
++enum mtd_parser_type {
++	MTD_PARSER_TYPE_DEVICE = 0,
++	MTD_PARSER_TYPE_ROOTFS,
++	MTD_PARSER_TYPE_FIRMWARE,
++};
++
+ struct mtd_part_parser {
+ 	struct list_head list;
+ 	struct module *owner;
+@@ -83,6 +89,7 @@ struct mtd_part_parser {
+ 	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **,
+ 			struct mtd_part_parser_data *);
+ 	void (*cleanup)(const struct mtd_partition *pparts, int nr_parts);
++	enum mtd_parser_type type;
+ };
+ 
+ /* Container for passing around a set of parsed partitions */
diff --git a/target/linux/generic/pending-6.12/401-mtd-don-t-register-NVMEM-devices-for-partitions-with.patch b/target/linux/generic/pending-6.12/401-mtd-don-t-register-NVMEM-devices-for-partitions-with.patch
new file mode 100644
index 0000000000..119f1da6dc
--- /dev/null
+++ b/target/linux/generic/pending-6.12/401-mtd-don-t-register-NVMEM-devices-for-partitions-with.patch
@@ -0,0 +1,48 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 31 Oct 2023 15:51:01 +0100
+Subject: [PATCH] mtd: don't register NVMEM devices for partitions with custom
+ drivers
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This fixes issue exposed by upstream commit f4cf4e5db331 ("Revert
+"nvmem: add new config option"").
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+---
+ drivers/mtd/mtdcore.c | 23 +++++++++++++++++++++++
+ 1 file changed, 23 insertions(+)
+
+--- a/drivers/mtd/mtdcore.c
++++ b/drivers/mtd/mtdcore.c
+@@ -549,6 +549,29 @@ static int mtd_nvmem_add(struct mtd_info
+ 	struct device_node *node = mtd_get_of_node(mtd);
+ 	struct nvmem_config config = {};
+ 
++	/*
++	 * Do NOT register NVMEM device for any partition that is meant to be
++	 * handled by a U-Boot env driver. That would result in associating two
++	 * different NVMEM devices with the same OF node.
++	 *
++	 * An example of unwanted behaviour of above (forwardtrace):
++	 * of_get_mac_addr_nvmem()
++	 * of_nvmem_cell_get()
++	 * __nvmem_device_get()
++	 *
++	 * We can't have __nvmem_device_get() return "mtdX" NVMEM device instead
++	 * of U-Boot env NVMEM device. That would result in failing to find
++	 * NVMEM cell.
++	 *
++	 * This issue seems to affect U-Boot env case only and will go away with
++	 * switch to NVMEM layouts.
++	 */
++	if (of_device_is_compatible(node, "u-boot,env") ||
++	    of_device_is_compatible(node, "u-boot,env-redundant-bool") ||
++	    of_device_is_compatible(node, "u-boot,env-redundant-count") ||
++	    of_device_is_compatible(node, "brcm,env"))
++		return 0;
++
+ 	config.id = NVMEM_DEVID_NONE;
+ 	config.dev = &mtd->dev;
+ 	config.name = dev_name(&mtd->dev);
diff --git a/target/linux/generic/pending-6.12/402-mtd-spi-nor-write-support-for-minor-aligned-partitions.patch b/target/linux/generic/pending-6.12/402-mtd-spi-nor-write-support-for-minor-aligned-partitions.patch
new file mode 100644
index 0000000000..e8ad204337
--- /dev/null
+++ b/target/linux/generic/pending-6.12/402-mtd-spi-nor-write-support-for-minor-aligned-partitions.patch
@@ -0,0 +1,245 @@
+From acacdac272927ae1d96e0bca51eb82899671eaea Mon Sep 17 00:00:00 2001
+From: John Thomson <git@johnthomson.fastmail.com.au>
+Date: Fri, 25 Dec 2020 18:50:08 +1000
+Subject: [PATCH] mtd: spi-nor: write support for minor aligned partitions
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Do not prevent writing to mtd partitions where a partition boundary sits
+on a minor erasesize boundary.
+This addresses a FIXME that has been present since the start of the
+linux git history:
+/* Doesn't start on a boundary of major erase size */
+/* FIXME: Let it be writable if it is on a boundary of
+ * _minor_ erase size though */
+
+Allow a uniform erase region spi-nor device to be configured
+to use the non-uniform erase regions code path for an erase with:
+CONFIG_MTD_SPI_NOR_USE_VARIABLE_ERASE=y
+
+On supporting hardware (SECT_4K: majority of current SPI-NOR device)
+provide the facility for an erase to use the least number
+of SPI-NOR operations, as well as access to 4K erase without
+requiring CONFIG_MTD_SPI_NOR_USE_4K_SECTORS
+
+Introduce erasesize_minor to the mtd struct,
+the smallest erasesize supported by the device
+
+On existing devices, this is useful where write support is wanted
+for data on a 4K partition, such as some u-boot-env partitions,
+or RouterBoot soft_config, while still netting the performance
+benefits of using 64K sectors
+
+Performance:
+time mtd erase firmware
+OpenWrt 5.10 ramips MT7621 w25q128jv 0xfc0000 partition length
+
+Without this patch
+MTD_SPI_NOR_USE_4K_SECTORS=y	|n
+real    2m 11.66s		|0m 50.86s
+user    0m 0.00s		|0m 0.00s
+sys     1m 56.20s		|0m 50.80s
+
+With this patch
+MTD_SPI_NOR_USE_VARIABLE_ERASE=n|y		|4K_SECTORS=y
+real    0m 51.68s		|0m 50.85s	|2m 12.89s
+user    0m 0.00s		|0m 0.00s	|0m 0.01s
+sys     0m 46.94s		|0m 50.38s	|2m 12.46s
+
+Signed-off-by: John Thomson <git@johnthomson.fastmail.com.au>
+Signed-off-by: Thibaut VARÈNE <hacks+kernel@slashdirt.org>
+
+---
+
+checkpatch does not like the printk(KERN_WARNING
+these should be changed separately beforehand?
+
+Changes v1 -> v2:
+Added mtdcore sysfs for erasesize_minor
+Removed finding minor erasesize for variable erase regions device,
+as untested and no responses regarding it.
+Moved IF_ENABLED for SPINOR variable erase to guard setting
+erasesize_minor in spi-nor/core.c
+Removed setting erasesize to minor where partition boundaries require
+minor erase to be writable
+Simplified minor boundary check by relying on minor being a factor of
+major
+
+Changes RFC -> v1:
+Fix uninitialized variable smatch warning
+Reported-by: kernel test robot <lkp@intel.com>
+Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
+---
+ drivers/mtd/mtdcore.c       | 10 ++++++++++
+ drivers/mtd/mtdpart.c       | 35 +++++++++++++++++++++++++----------
+ drivers/mtd/spi-nor/Kconfig | 10 ++++++++++
+ drivers/mtd/spi-nor/core.c  | 11 +++++++++--
+ include/linux/mtd/mtd.h     |  2 ++
+ 5 files changed, 56 insertions(+), 12 deletions(-)
+
+--- a/drivers/mtd/mtdcore.c
++++ b/drivers/mtd/mtdcore.c
+@@ -199,6 +199,15 @@ static ssize_t mtd_erasesize_show(struct
+ }
+ MTD_DEVICE_ATTR_RO(erasesize);
+ 
++static ssize_t mtd_erasesize_minor_show(struct device *dev,
++		struct device_attribute *attr, char *buf)
++{
++	struct mtd_info *mtd = dev_get_drvdata(dev);
++
++	return sysfs_emit(buf, "%lu\n", (unsigned long)mtd->erasesize_minor);
++}
++MTD_DEVICE_ATTR_RO(erasesize_minor);
++
+ static ssize_t mtd_writesize_show(struct device *dev,
+ 		struct device_attribute *attr, char *buf)
+ {
+@@ -344,6 +353,7 @@ static struct attribute *mtd_attrs[] = {
+ 	&dev_attr_flags.attr,
+ 	&dev_attr_size.attr,
+ 	&dev_attr_erasesize.attr,
++	&dev_attr_erasesize_minor.attr,
+ 	&dev_attr_writesize.attr,
+ 	&dev_attr_subpagesize.attr,
+ 	&dev_attr_oobsize.attr,
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -47,6 +47,7 @@ static struct mtd_info *allocate_partiti
+ 	struct mtd_info *master = mtd_get_master(parent);
+ 	int wr_alignment = (parent->flags & MTD_NO_ERASE) ?
+ 			   master->writesize : master->erasesize;
++	int wr_alignment_minor = 0;
+ 	u64 parent_size = mtd_is_partition(parent) ?
+ 			  parent->part.size : parent->size;
+ 	struct mtd_info *child;
+@@ -171,6 +172,7 @@ static struct mtd_info *allocate_partiti
+ 	} else {
+ 		/* Single erase size */
+ 		child->erasesize = master->erasesize;
++		child->erasesize_minor = master->erasesize_minor;
+ 	}
+ 
+ 	/*
+@@ -178,26 +180,39 @@ static struct mtd_info *allocate_partiti
+ 	 * exposes several regions with different erasesize. Adjust
+ 	 * wr_alignment accordingly.
+ 	 */
+-	if (!(child->flags & MTD_NO_ERASE))
++	if (!(child->flags & MTD_NO_ERASE)) {
+ 		wr_alignment = child->erasesize;
++		wr_alignment_minor = child->erasesize_minor;
++	}
+ 
+ 	tmp = mtd_get_master_ofs(child, 0);
+ 	remainder = do_div(tmp, wr_alignment);
+ 	if ((child->flags & MTD_WRITEABLE) && remainder) {
+-		/* Doesn't start on a boundary of major erase size */
+-		/* FIXME: Let it be writable if it is on a boundary of
+-		 * _minor_ erase size though */
+-		child->flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
+-			part->name);
++		if (wr_alignment_minor) {
++			/* rely on minor being a factor of major erasesize */
++			tmp = remainder;
++			remainder = do_div(tmp, wr_alignment_minor);
++		}
++		if (remainder) {
++			child->flags &= ~MTD_WRITEABLE;
++			printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
++				part->name);
++		}
+ 	}
+ 
+ 	tmp = mtd_get_master_ofs(child, 0) + child->part.size;
+ 	remainder = do_div(tmp, wr_alignment);
+ 	if ((child->flags & MTD_WRITEABLE) && remainder) {
+-		child->flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
+-			part->name);
++		if (wr_alignment_minor) {
++			tmp = remainder;
++			remainder = do_div(tmp, wr_alignment_minor);
++		}
++
++		if (remainder) {
++			child->flags &= ~MTD_WRITEABLE;
++			printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
++				part->name);
++		}
+ 	}
+ 
+ 	child->size = child->part.size;
+--- a/drivers/mtd/spi-nor/Kconfig
++++ b/drivers/mtd/spi-nor/Kconfig
+@@ -10,6 +10,16 @@ menuconfig MTD_SPI_NOR
+ 
+ if MTD_SPI_NOR
+ 
++config MTD_SPI_NOR_USE_VARIABLE_ERASE
++	bool "Disable uniform_erase to allow use of all hardware supported erasesizes"
++	depends on !MTD_SPI_NOR_USE_4K_SECTORS
++	default n
++	help
++	  Allow mixed use of all hardware supported erasesizes,
++	  by forcing spi_nor to use the multiple eraseregions code path.
++	  For example: A 68K erase will use one 64K erase, and one 4K erase
++	  on supporting hardware.
++
+ config MTD_SPI_NOR_USE_4K_SECTORS
+ 	bool "Use small 4096 B erase sectors"
+ 	default y
+--- a/drivers/mtd/spi-nor/core.c
++++ b/drivers/mtd/spi-nor/core.c
+@@ -1158,6 +1158,8 @@ static u8 spi_nor_convert_3to4_erase(u8
+ 
+ static bool spi_nor_has_uniform_erase(const struct spi_nor *nor)
+ {
++	if (IS_ENABLED(CONFIG_MTD_SPI_NOR_USE_VARIABLE_ERASE))
++		return false;
+ 	return !!nor->params->erase_map.uniform_region.erase_mask;
+ }
+ 
+@@ -2516,6 +2518,7 @@ static int spi_nor_select_erase(struct s
+ {
+ 	struct spi_nor_erase_map *map = &nor->params->erase_map;
+ 	const struct spi_nor_erase_type *erase = NULL;
++	const struct spi_nor_erase_type *erase_minor = NULL;
+ 	struct mtd_info *mtd = &nor->mtd;
+ 	int i;
+ 
+@@ -2542,8 +2545,9 @@ static int spi_nor_select_erase(struct s
+ 	 */
+ 	for (i = SNOR_ERASE_TYPE_MAX - 1; i >= 0; i--) {
+ 		if (map->erase_type[i].size) {
+-			erase = &map->erase_type[i];
+-			break;
++			if (!erase)
++				erase = &map->erase_type[i];
++			erase_minor = &map->erase_type[i];
+ 		}
+ 	}
+ 
+@@ -2551,6 +2555,9 @@ static int spi_nor_select_erase(struct s
+ 		return -EINVAL;
+ 
+ 	mtd->erasesize = erase->size;
++	if (IS_ENABLED(CONFIG_MTD_SPI_NOR_USE_VARIABLE_ERASE) &&
++			erase_minor && erase_minor->size < erase->size)
++		mtd->erasesize_minor = erase_minor->size;
+ 	return 0;
+ }
+ 
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -245,6 +245,8 @@ struct mtd_info {
+ 	 * information below if they desire
+ 	 */
+ 	uint32_t erasesize;
++	/* "Minor" (smallest) erase size supported by the whole device */
++	uint32_t erasesize_minor;
+ 	/* Minimal writable flash unit size. In case of NOR flash it is 1 (even
+ 	 * though individual bits can be cleared), in case of NAND flash it is
+ 	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR
diff --git a/target/linux/generic/pending-6.12/416-09-next-spi-spi-qpic-snand-validate-user-chip-specific-ECC-properties.patch b/target/linux/generic/pending-6.12/416-09-next-spi-spi-qpic-snand-validate-user-chip-specific-ECC-properties.patch
new file mode 100644
index 0000000000..c03a529963
--- /dev/null
+++ b/target/linux/generic/pending-6.12/416-09-next-spi-spi-qpic-snand-validate-user-chip-specific-ECC-properties.patch
@@ -0,0 +1,174 @@
+From: Gabor Juhos <j4g8y7@gmail.com>
+Date: Thu, 01 May 2025 18:19:16 +0200
+Subject: [PATCH next] spi: spi-qpic-snand: validate user/chip specific ECC
+ properties
+
+The driver only supports 512 bytes ECC step size and 4 bit ECC strength
+at the moment, however it does not reject unsupported step/strength
+configurations. Due to this, whenever the driver is used with a flash
+chip which needs stronger ECC protection, the following warning is shown
+in the kernel log:
+
+  [    0.574648] spi-nand spi0.0: GigaDevice SPI NAND was found.
+  [    0.635748] spi-nand spi0.0: 256 MiB, block size: 128 KiB, page size: 2048, OOB size: 128
+  [    0.649079] nand: WARNING: (null): the ECC used on your system is too weak compared to the one required by the NAND chip
+
+Although the message indicates that something is wrong, but it often gets
+unnoticed, which can cause serious problems. For example when the user
+writes something into the flash chip despite the warning, the written data
+may won't be readable by the bootloader or by the boot ROM. In the worst
+case, when the attached SPI NAND chip is the boot device, the board may not
+be able to boot anymore.
+
+Also, it is not even possible to create a backup of the flash, because
+reading its content results in bogus data. For example, dumping the first
+page of the flash gives this:
+
+  # hexdump -C -n 2048 /dev/mtd0
+  00000000  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  00000040  0f 0f 0f 0f 0f 0f 0f 0d  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  00000050  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  000001c0  0f 0f 0f 0f ff 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  000001d0  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  00000200  0f 0f 0f 0f f5 5b ff ff  0f 0f 0f 0f 0f 0f 0f 0f  |.....[..........|
+  00000210  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  000002f0  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 1f 0f 0f  |................|
+  00000300  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  000003c0  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f ff 0f 0f 0f  |................|
+  000003d0  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  00000400  0f 0f 0f 0f 0f 0f 0f 0f  e9 74 c9 06 f5 5b ff ff  |.........t...[..|
+  00000410  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  000005d0  0f 0f 0f 0f ff 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  000005e0  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  00000600  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f c6 be 0f c3  |................|
+  00000610  e9 74 c9 06 f5 5b ff ff  0f 0f 0f 0f 0f 0f 0f 0f  |.t...[..........|
+  00000620  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  00000770  0f 0f 0f 0f 8f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  00000780  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  00000800
+  #
+
+Doing the same by using the downstream kernel results in different output:
+
+  # hexdump -C -n 2048 /dev/mtd0
+  00000000  0f 0f 0f 0f 0f 0f 0f 0f  0f 0f 0f 0f 0f 0f 0f 0f  |................|
+  *
+  00000800
+  #
+
+This patch adds some sanity checks to the code to prevent using the driver
+with unsupported ECC step/strength configurations. After the change, probing
+of the driver fails in such cases:
+
+  [    0.655038] spi-nand spi0.0: GigaDevice SPI NAND was found.
+  [    0.659159] spi-nand spi0.0: 256 MiB, block size: 128 KiB, page size: 2048, OOB size: 128
+  [    0.669138] qcom_snand 79b0000.spi: only 4 bits ECC strength is supported
+  [    0.677476] nand: No suitable ECC configuration
+  [    0.689909] spi-nand spi0.0: probe with driver spi-nand failed with error -95
+
+This helps to avoid the aforementioned hassles until support for 8 bit ECC
+strength gets implemented.
+
+Fixes: 7304d1909080 ("spi: spi-qpic: add driver for QCOM SPI NAND flash Interface")
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+---
+Marked for next because it depends on commit f48d80503504 ("spi: spi-qpic-snand:
+use kmalloc() for OOB buffer allocation").
+---
+ drivers/spi/spi-qpic-snand.c | 42 +++++++++++++++++++++++++++++++++++++-----
+ 1 file changed, 37 insertions(+), 5 deletions(-)
+
+
+---
+base-commit: a7f035c2c72496cf7ac34bfaa8c289e0d4c45836
+change-id: 20250501-qpic-snand-validate-ecc-383b3e33e238
+
+Best regards,
+
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -249,9 +249,11 @@ static const struct mtd_ooblayout_ops qc
+ static int qcom_spi_ecc_init_ctx_pipelined(struct nand_device *nand)
+ {
+ 	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct nand_ecc_props *reqs = &nand->ecc.requirements;
++	struct nand_ecc_props *user = &nand->ecc.user_conf;
+ 	struct nand_ecc_props *conf = &nand->ecc.ctx.conf;
+ 	struct mtd_info *mtd = nanddev_to_mtd(nand);
+-	int cwperpage, bad_block_byte;
++	int cwperpage, bad_block_byte, ret;
+ 	struct qpic_ecc *ecc_cfg;
+ 
+ 	cwperpage = mtd->writesize / NANDC_STEP_SIZE;
+@@ -260,11 +262,39 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 	ecc_cfg = kzalloc(sizeof(*ecc_cfg), GFP_KERNEL);
+ 	if (!ecc_cfg)
+ 		return -ENOMEM;
++
++	if (user->step_size && user->strength) {
++		ecc_cfg->step_size = user->step_size;
++		ecc_cfg->strength = user->strength;
++	} else if (reqs->step_size && reqs->strength) {
++		ecc_cfg->step_size = reqs->step_size;
++		ecc_cfg->strength = reqs->strength;
++	} else {
++		/* use defaults */
++		ecc_cfg->step_size = NANDC_STEP_SIZE;
++		ecc_cfg->strength = 4;
++	}
++
++	if (ecc_cfg->step_size != NANDC_STEP_SIZE) {
++		dev_err(snandc->dev,
++			"only %u bytes ECC step size is supported\n",
++			NANDC_STEP_SIZE);
++		ret = -EOPNOTSUPP;
++		goto err_free_ecc_cfg;
++	}
++
++	if (ecc_cfg->strength != 4) {
++		dev_err(snandc->dev,
++			"only 4 bits ECC strength is supported\n");
++		ret = -EOPNOTSUPP;
++		goto err_free_ecc_cfg;
++	}
++
+ 	snandc->qspi->oob_buf = kmalloc(mtd->writesize + mtd->oobsize,
+ 					GFP_KERNEL);
+ 	if (!snandc->qspi->oob_buf) {
+-		kfree(ecc_cfg);
+-		return -ENOMEM;
++		ret = -ENOMEM;
++		goto err_free_ecc_cfg;
+ 	}
+ 
+ 	memset(snandc->qspi->oob_buf, 0xff, mtd->writesize + mtd->oobsize);
+@@ -279,8 +309,6 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 	ecc_cfg->bytes = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes + ecc_cfg->bbm_size;
+ 
+ 	ecc_cfg->steps = 4;
+-	ecc_cfg->strength = 4;
+-	ecc_cfg->step_size = 512;
+ 	ecc_cfg->cw_data = 516;
+ 	ecc_cfg->cw_size = ecc_cfg->cw_data + ecc_cfg->bytes;
+ 	bad_block_byte = mtd->writesize - ecc_cfg->cw_size * (cwperpage - 1) + 1;
+@@ -338,6 +366,10 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 		ecc_cfg->strength, ecc_cfg->step_size);
+ 
+ 	return 0;
++
++err_free_ecc_cfg:
++	kfree(ecc_cfg);
++	return ret;
+ }
+ 
+ static void qcom_spi_ecc_cleanup_ctx_pipelined(struct nand_device *nand)
diff --git a/target/linux/generic/pending-6.12/416-10-next-1-2-mtd-nand-qpic-common-add-defines-for-ECC_MODE-values.patch b/target/linux/generic/pending-6.12/416-10-next-1-2-mtd-nand-qpic-common-add-defines-for-ECC_MODE-values.patch
new file mode 100644
index 0000000000..8029e4992e
--- /dev/null
+++ b/target/linux/generic/pending-6.12/416-10-next-1-2-mtd-nand-qpic-common-add-defines-for-ECC_MODE-values.patch
@@ -0,0 +1,70 @@
+From: Gabor Juhos <j4g8y7@gmail.com>
+Date: Fri, 02 May 2025 21:31:16 +0200
+Subject: [PATCH next 1/2] mtd: nand: qpic-common: add defines for ECC_MODE
+ values
+
+Add defines for the values of the ECC_MODE field of the NAND_DEV0_ECC_CFG
+register and change both the 'qcom-nandc' and 'spi-qpic-snand' drivers to
+use those instead of magic numbers.
+
+No functional changes. This is in preparation for adding 8 bit ECC strength
+support for the 'spi-qpic-snand' driver.
+
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+---
+ drivers/mtd/nand/raw/qcom_nandc.c    | 6 +++---
+ drivers/spi/spi-qpic-snand.c         | 2 +-
+ include/linux/mtd/nand-qpic-common.h | 2 ++
+ 3 files changed, 6 insertions(+), 4 deletions(-)
+
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -1379,7 +1379,7 @@ static int qcom_nand_attach_chip(struct
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 	int cwperpage, bad_block_byte, ret;
+ 	bool wide_bus;
+-	int ecc_mode = 1;
++	int ecc_mode = ECC_MODE_8BIT;
+ 
+ 	/* controller only supports 512 bytes data steps */
+ 	ecc->size = NANDC_STEP_SIZE;
+@@ -1400,7 +1400,7 @@ static int qcom_nand_attach_chip(struct
+ 	if (ecc->strength >= 8) {
+ 		/* 8 bit ECC defaults to BCH ECC on all platforms */
+ 		host->bch_enabled = true;
+-		ecc_mode = 1;
++		ecc_mode = ECC_MODE_8BIT;
+ 
+ 		if (wide_bus) {
+ 			host->ecc_bytes_hw = 14;
+@@ -1420,7 +1420,7 @@ static int qcom_nand_attach_chip(struct
+ 		if (nandc->props->ecc_modes & ECC_BCH_4BIT) {
+ 			/* BCH */
+ 			host->bch_enabled = true;
+-			ecc_mode = 0;
++			ecc_mode = ECC_MODE_4BIT;
+ 
+ 			if (wide_bus) {
+ 				host->ecc_bytes_hw = 8;
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -349,7 +349,7 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 			       FIELD_PREP(ECC_SW_RESET, 0) |
+ 			       FIELD_PREP(ECC_NUM_DATA_BYTES_MASK, ecc_cfg->cw_data) |
+ 			       FIELD_PREP(ECC_FORCE_CLK_OPEN, 1) |
+-			       FIELD_PREP(ECC_MODE_MASK, 0) |
++			       FIELD_PREP(ECC_MODE_MASK, ECC_MODE_4BIT) |
+ 			       FIELD_PREP(ECC_PARITY_SIZE_BYTES_BCH_MASK, ecc_cfg->ecc_bytes_hw);
+ 
+ 	ecc_cfg->ecc_buf_cfg = 0x203 << NUM_STEPS;
+--- a/include/linux/mtd/nand-qpic-common.h
++++ b/include/linux/mtd/nand-qpic-common.h
+@@ -101,6 +101,8 @@
+ #define	ECC_SW_RESET			BIT(1)
+ #define	ECC_MODE			4
+ #define	ECC_MODE_MASK			GENMASK(5, 4)
++#define	ECC_MODE_4BIT			0
++#define	ECC_MODE_8BIT			1
+ #define	ECC_PARITY_SIZE_BYTES_BCH	8
+ #define	ECC_PARITY_SIZE_BYTES_BCH_MASK	GENMASK(12, 8)
+ #define	ECC_NUM_DATA_BYTES		16
diff --git a/target/linux/generic/pending-6.12/416-11-next-2-2-spi-spi-qpic-snand-add-support-for-8-bits-ECC-strength.patch b/target/linux/generic/pending-6.12/416-11-next-2-2-spi-spi-qpic-snand-add-support-for-8-bits-ECC-strength.patch
new file mode 100644
index 0000000000..5b1dee3eb1
--- /dev/null
+++ b/target/linux/generic/pending-6.12/416-11-next-2-2-spi-spi-qpic-snand-add-support-for-8-bits-ECC-strength.patch
@@ -0,0 +1,388 @@
+From: Gabor Juhos <j4g8y7@gmail.com>
+Date: Fri, 02 May 2025 21:31:17 +0200
+Subject: [PATCH next 2/2] spi: spi-qpic-snand: add support for 8 bits ECC
+ strength
+
+Even though the hardware supports 8 bits ECC strength, but that is not
+handled in the driver yet. This change adds the missing bits in order
+to allow using the driver with chips which require 8 bits ECC strength.
+
+No functional changes intended with regard to the existing 4 bits ECC
+strength support.
+
+Tested on an IPQ9574 platform using a GigaDevice GD5F2GM7REYIG chip.
+
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+---
+mtdtest results:
+
+  # dmesg | grep nand
+  [    0.678143] spi-nand spi0.0: GigaDevice SPI NAND was found.
+  [    0.687393] spi-nand spi0.0: 256 MiB, block size: 128 KiB, page size: 2048, OOB size: 128
+  # cat /proc/mtd
+  dev:    size   erasesize  name
+  mtd0: 10000000 00020000 "spi0.0"
+  # insmod mtd_test
+  # insmod mtd_speedtest dev=0
+  [   63.128425]
+  [   63.128452] =================================================
+  [   63.128979] mtd_speedtest: MTD device: 0
+  [   63.134622] mtd_speedtest: MTD device size 268435456, eraseblock size 131072, page size 2048, count of eraseblocks 2048, pages per eraseblock 64, OOB size 128
+  [   63.139561] mtd_test: scanning for bad eraseblocks
+  [   63.756447] mtd_test: scanned 2048 eraseblocks, 0 are bad
+  [   71.085514] mtd_speedtest: testing eraseblock write speed
+  [  202.745977] mtd_speedtest: eraseblock write speed is 1991 KiB/s
+  [  202.746022] mtd_speedtest: testing eraseblock read speed
+  [  284.104591] mtd_speedtest: eraseblock read speed is 3222 KiB/s
+  [  291.405533] mtd_speedtest: testing page write speed
+  [  422.516341] mtd_speedtest: page write speed is 1999 KiB/s
+  [  422.516384] mtd_speedtest: testing page read speed
+  [  504.144630] mtd_speedtest: page read speed is 3211 KiB/s
+  [  511.476726] mtd_speedtest: testing 2 page write speed
+  [  643.114443] mtd_speedtest: 2 page write speed is 1991 KiB/s
+  [  643.114485] mtd_speedtest: testing 2 page read speed
+  [  724.434752] mtd_speedtest: 2 page read speed is 3223 KiB/s
+  [  724.434796] mtd_speedtest: Testing erase speed
+  [  731.792729] mtd_speedtest: erase speed is 35648 KiB/s
+  [  731.792772] mtd_speedtest: Testing 2x multi-block erase speed
+  [  739.162513] mtd_speedtest: 2x multi-block erase speed is 35589 KiB/s
+  [  739.162558] mtd_speedtest: Testing 4x multi-block erase speed
+  [  746.486241] mtd_speedtest: 4x multi-block erase speed is 35820 KiB/s
+  [  746.486287] mtd_speedtest: Testing 8x multi-block erase speed
+  [  753.789683] mtd_speedtest: 8x multi-block erase speed is 35919 KiB/s
+  [  753.789728] mtd_speedtest: Testing 16x multi-block erase speed
+  [  761.093075] mtd_speedtest: 16x multi-block erase speed is 35920 KiB/s
+  [  761.093120] mtd_speedtest: Testing 32x multi-block erase speed
+  [  768.396145] mtd_speedtest: 32x multi-block erase speed is 35922 KiB/s
+  [  768.396222] mtd_speedtest: Testing 64x multi-block erase speed
+  [  775.699819] mtd_speedtest: 64x multi-block erase speed is 35918 KiB/s
+  [  775.699863] mtd_speedtest: finished
+  [  775.705259] =================================================
+  # insmod mtd_readtest dev=0
+  [  919.060671]
+  [  919.060699] =================================================
+  [  919.061226] mtd_readtest: MTD device: 0
+  [  919.066957] mtd_readtest: MTD device size 268435456, eraseblock size 131072, page size 2048, count of eraseblocks 2048, pages per eraseblock 64, OOB size 128
+  [  919.070556] mtd_test: scanning for bad eraseblocks
+  [  919.086016] mtd_test: scanned 2048 eraseblocks, 0 are bad
+  [  919.089465] mtd_readtest: testing page read
+  [ 1090.778227] mtd_readtest: finished
+  [ 1090.778286] =================================================
+  # insmod mtd_pagetest dev=0
+  [ 1216.297313]
+  [ 1216.297341] =================================================
+  [ 1216.297867] mtd_pagetest: MTD device: 0
+  [ 1216.303509] mtd_pagetest: MTD device size 268435456, eraseblock size 131072, page size 2048, count of eraseblocks 2048, pages per eraseblock 64, OOB size 128
+  [ 1216.307213] mtd_test: scanning for bad eraseblocks
+  [ 1216.322680] mtd_test: scanned 2048 eraseblocks, 0 are bad
+  [ 1216.326077] mtd_pagetest: erasing whole device
+  [ 1223.694968] mtd_pagetest: erased 2048 eraseblocks
+  [ 1223.695009] mtd_pagetest: writing whole device
+  [ 1223.763930] mtd_pagetest: written up to eraseblock 0
+  [ 1240.268942] mtd_pagetest: written up to eraseblock 256
+  [ 1256.641498] mtd_pagetest: written up to eraseblock 512
+  [ 1273.139048] mtd_pagetest: written up to eraseblock 768
+  [ 1289.718929] mtd_pagetest: written up to eraseblock 1024
+  [ 1306.244553] mtd_pagetest: written up to eraseblock 1280
+  [ 1322.939723] mtd_pagetest: written up to eraseblock 1536
+  [ 1339.246937] mtd_pagetest: written up to eraseblock 1792
+  [ 1355.613729] mtd_pagetest: written 2048 eraseblocks
+  [ 1355.613770] mtd_pagetest: verifying all eraseblocks
+  [ 1355.854290] mtd_pagetest: verified up to eraseblock 0
+  [ 1416.657733] mtd_pagetest: verified up to eraseblock 256
+  [ 1477.384593] mtd_pagetest: verified up to eraseblock 512
+  [ 1538.008142] mtd_pagetest: verified up to eraseblock 768
+  [ 1599.080797] mtd_pagetest: verified up to eraseblock 1024
+  [ 1660.775431] mtd_pagetest: verified up to eraseblock 1280
+  [ 1722.177149] mtd_pagetest: verified up to eraseblock 1536
+  [ 1783.090166] mtd_pagetest: verified up to eraseblock 1792
+  [ 1844.450757] mtd_pagetest: verified 2048 eraseblocks
+  [ 1844.450798] mtd_pagetest: crosstest
+  [ 1844.455676] mtd_pagetest: reading page at 0x0
+  [ 1844.458603] mtd_pagetest: reading page at 0xffff800
+  [ 1844.463047] mtd_pagetest: reading page at 0x0
+  [ 1844.467790] mtd_pagetest: verifying pages read at 0x0 match
+  [ 1844.471636] mtd_pagetest: crosstest ok
+  [ 1844.477062] mtd_pagetest: erasecrosstest
+  [ 1844.480833] mtd_pagetest: erasing block 0
+  [ 1844.488498] mtd_pagetest: writing 1st page of block 0
+  [ 1844.489821] mtd_pagetest: reading 1st page of block 0
+  [ 1844.494475] mtd_pagetest: verifying 1st page of block 0
+  [ 1844.498942] mtd_pagetest: erasing block 0
+  [ 1844.507505] mtd_pagetest: writing 1st page of block 0
+  [ 1844.509042] mtd_pagetest: erasing block 2047
+  [ 1844.516725] mtd_pagetest: reading 1st page of block 0
+  [ 1844.518087] mtd_pagetest: verifying 1st page of block 0
+  [ 1844.522415] mtd_pagetest: erasecrosstest ok
+  [ 1844.527495] mtd_pagetest: erasetest
+  [ 1844.531613] mtd_pagetest: erasing block 0
+  [ 1844.538671] mtd_pagetest: writing 1st page of block 0
+  [ 1844.540249] mtd_pagetest: erasing block 0
+  [ 1844.547869] mtd_pagetest: reading 1st page of block 0
+  [ 1844.548927] mtd_pagetest: verifying 1st page of block 0 is all 0xff
+  [ 1844.553326] mtd_pagetest: erasetest ok
+  [ 1844.559440] mtd_pagetest: finished with 0 errors
+  [ 1844.563233] =================================================
+  # insmod mtd_subpagetest dev=0
+  [ 1942.429708]
+  [ 1942.429736] =================================================
+  [ 1942.430262] mtd_subpagetest: MTD device: 0
+  [ 1942.435905] mtd_subpagetest: MTD device size 268435456, eraseblock size 131072, page size 2048, subpage size 2048, count of eraseblocks 2048, pages per eraseblock 64, OOB size 128
+  [ 1942.439994] mtd_test: scanning for bad eraseblocks
+  [ 1942.457111] mtd_test: scanned 2048 eraseblocks, 0 are bad
+  [ 1949.824564] mtd_subpagetest: writing whole device
+  [ 1949.826670] mtd_subpagetest: written up to eraseblock 0
+  [ 1950.351816] mtd_subpagetest: written up to eraseblock 256
+  [ 1950.875797] mtd_subpagetest: written up to eraseblock 512
+  [ 1951.399912] mtd_subpagetest: written up to eraseblock 768
+  [ 1951.923618] mtd_subpagetest: written up to eraseblock 1024
+  [ 1952.447361] mtd_subpagetest: written up to eraseblock 1280
+  [ 1952.970834] mtd_subpagetest: written up to eraseblock 1536
+  [ 1953.494635] mtd_subpagetest: written up to eraseblock 1792
+  [ 1954.016265] mtd_subpagetest: written 2048 eraseblocks
+  [ 1954.016294] mtd_subpagetest: verifying all eraseblocks
+  [ 1954.021617] mtd_subpagetest: verified up to eraseblock 0
+  [ 1954.347458] mtd_subpagetest: verified up to eraseblock 256
+  [ 1954.667446] mtd_subpagetest: verified up to eraseblock 512
+  [ 1954.987343] mtd_subpagetest: verified up to eraseblock 768
+  [ 1955.307385] mtd_subpagetest: verified up to eraseblock 1024
+  [ 1955.627462] mtd_subpagetest: verified up to eraseblock 1280
+  [ 1955.947277] mtd_subpagetest: verified up to eraseblock 1536
+  [ 1956.266834] mtd_subpagetest: verified up to eraseblock 1792
+  [ 1956.585581] mtd_subpagetest: verified 2048 eraseblocks
+  [ 1963.889308] mtd_subpagetest: verifying all eraseblocks for 0xff
+  [ 1963.930487] mtd_subpagetest: verified up to eraseblock 0
+  [ 1974.592567] mtd_subpagetest: verified up to eraseblock 256
+  [ 1985.180953] mtd_subpagetest: verified up to eraseblock 512
+  [ 1995.805397] mtd_subpagetest: verified up to eraseblock 768
+  [ 2006.348859] mtd_subpagetest: verified up to eraseblock 1024
+  [ 2016.900530] mtd_subpagetest: verified up to eraseblock 1280
+  [ 2027.447587] mtd_subpagetest: verified up to eraseblock 1536
+  [ 2037.962383] mtd_subpagetest: verified up to eraseblock 1792
+  [ 2048.587863] mtd_subpagetest: verified 2048 eraseblocks
+  [ 2048.587906] mtd_subpagetest: writing whole device
+  [ 2048.648174] mtd_subpagetest: written up to eraseblock 0
+  [ 2062.643145] mtd_subpagetest: written up to eraseblock 256
+  [ 2076.699015] mtd_subpagetest: written up to eraseblock 512
+  [ 2091.004910] mtd_subpagetest: written up to eraseblock 768
+  [ 2105.149879] mtd_subpagetest: written up to eraseblock 1024
+  [ 2119.470691] mtd_subpagetest: written up to eraseblock 1280
+  [ 2133.746861] mtd_subpagetest: written up to eraseblock 1536
+  [ 2147.776477] mtd_subpagetest: written up to eraseblock 1792
+  [ 2161.947734] mtd_subpagetest: written 2048 eraseblocks
+  [ 2161.947776] mtd_subpagetest: verifying all eraseblocks
+  [ 2161.986109] mtd_subpagetest: verified up to eraseblock 0
+  [ 2170.818316] mtd_subpagetest: verified up to eraseblock 256
+  [ 2179.596875] mtd_subpagetest: verified up to eraseblock 512
+  [ 2188.405116] mtd_subpagetest: verified up to eraseblock 768
+  [ 2197.188588] mtd_subpagetest: verified up to eraseblock 1024
+  [ 2206.002204] mtd_subpagetest: verified up to eraseblock 1280
+  [ 2214.784815] mtd_subpagetest: verified up to eraseblock 1536
+  [ 2223.557141] mtd_subpagetest: verified up to eraseblock 1792
+  [ 2232.472832] mtd_subpagetest: verified 2048 eraseblocks
+  [ 2239.818213] mtd_subpagetest: verifying all eraseblocks for 0xff
+  [ 2239.861404] mtd_subpagetest: verified up to eraseblock 0
+  [ 2250.439035] mtd_subpagetest: verified up to eraseblock 256
+  [ 2261.176485] mtd_subpagetest: verified up to eraseblock 512
+  [ 2271.713183] mtd_subpagetest: verified up to eraseblock 768
+  [ 2282.356892] mtd_subpagetest: verified up to eraseblock 1024
+  [ 2292.891424] mtd_subpagetest: verified up to eraseblock 1280
+  [ 2303.543110] mtd_subpagetest: verified up to eraseblock 1536
+  [ 2314.116690] mtd_subpagetest: verified up to eraseblock 1792
+  [ 2324.607804] mtd_subpagetest: verified 2048 eraseblocks
+  [ 2324.607846] mtd_subpagetest: finished with 0 errors
+  [ 2324.611859] =================================================
+  # insmod mtd_oobtest dev=0
+  [ 2336.159109]
+  [ 2336.159138] =================================================
+  [ 2336.159664] mtd_oobtest: MTD device: 0
+  [ 2336.165308] mtd_oobtest: MTD device size 268435456, eraseblock size 131072, page size 2048, count of eraseblocks 2048, pages per eraseblock 64, OOB size 128
+  [ 2336.169043] mtd_test: scanning for bad eraseblocks
+  [ 2336.184354] mtd_test: scanned 2048 eraseblocks, 0 are bad
+  [ 2336.187716] mtd_oobtest: test 1 of 5
+  [ 2343.495966] mtd_oobtest: writing OOBs of whole device
+  [ 2343.496073] mtd_oobtest: written up to eraseblock 0
+  [ 2343.516803] mtd_oobtest: written up to eraseblock 256
+  [ 2343.533527] mtd_oobtest: written up to eraseblock 512
+  [ 2343.549945] mtd_oobtest: written up to eraseblock 768
+  [ 2343.563666] mtd_oobtest: written up to eraseblock 1024
+  [ 2343.575186] mtd_oobtest: written up to eraseblock 1280
+  [ 2343.584310] mtd_oobtest: written up to eraseblock 1536
+  [ 2343.593011] mtd_oobtest: written up to eraseblock 1792
+  [ 2343.600847] mtd_oobtest: written 2048 eraseblocks
+  [ 2343.600861] mtd_oobtest: verifying all eraseblocks
+  [ 2343.604542] mtd_oobtest: verified up to eraseblock 0
+  [ 2343.616606] mtd_oobtest: verified up to eraseblock 256
+  [ 2343.623992] mtd_oobtest: verified up to eraseblock 512
+  [ 2343.631390] mtd_oobtest: verified up to eraseblock 768
+  [ 2343.638788] mtd_oobtest: verified up to eraseblock 1024
+  [ 2343.646184] mtd_oobtest: verified up to eraseblock 1280
+  [ 2343.653570] mtd_oobtest: verified up to eraseblock 1536
+  [ 2343.660970] mtd_oobtest: verified up to eraseblock 1792
+  [ 2343.668356] mtd_oobtest: verified 2048 eraseblocks
+  [ 2343.668369] mtd_oobtest: test 2 of 5
+  [ 2350.985635] mtd_oobtest: writing OOBs of whole device
+  [ 2350.985743] mtd_oobtest: written up to eraseblock 0
+  [ 2351.006445] mtd_oobtest: written up to eraseblock 256
+  [ 2351.023170] mtd_oobtest: written up to eraseblock 512
+  [ 2351.039645] mtd_oobtest: written up to eraseblock 768
+  [ 2351.053395] mtd_oobtest: written up to eraseblock 1024
+  [ 2351.064954] mtd_oobtest: written up to eraseblock 1280
+  [ 2351.074144] mtd_oobtest: written up to eraseblock 1536
+  [ 2351.082848] mtd_oobtest: written up to eraseblock 1792
+  [ 2351.090707] mtd_oobtest: written 2048 eraseblocks
+  [ 2351.090721] mtd_oobtest: verifying all eraseblocks
+  [ 2351.094373] mtd_oobtest: verified up to eraseblock 0
+  [ 2351.099353] mtd_oobtest: verified up to eraseblock 256
+  [ 2351.104460] mtd_oobtest: verified up to eraseblock 512
+  [ 2351.109437] mtd_oobtest: verified up to eraseblock 768
+  [ 2351.114528] mtd_oobtest: verified up to eraseblock 1024
+  [ 2351.119683] mtd_oobtest: verified up to eraseblock 1280
+  [ 2351.124772] mtd_oobtest: verified up to eraseblock 1536
+  [ 2351.129996] mtd_oobtest: verified up to eraseblock 1792
+  [ 2351.135187] mtd_oobtest: verified 2048 eraseblocks
+  [ 2351.140130] mtd_oobtest: test 3 of 5
+  [ 2358.448438] mtd_oobtest: writing OOBs of whole device
+  [ 2358.448546] mtd_oobtest: written up to eraseblock 0
+  [ 2358.469297] mtd_oobtest: written up to eraseblock 256
+  [ 2358.486095] mtd_oobtest: written up to eraseblock 512
+  [ 2358.501993] mtd_oobtest: written up to eraseblock 768
+  [ 2358.515473] mtd_oobtest: written up to eraseblock 1024
+  [ 2358.526708] mtd_oobtest: written up to eraseblock 1280
+  [ 2358.535426] mtd_oobtest: written up to eraseblock 1536
+  [ 2358.544152] mtd_oobtest: written up to eraseblock 1792
+  [ 2358.551732] mtd_oobtest: written 2048 eraseblocks
+  [ 2358.551744] mtd_oobtest: verifying all eraseblocks
+  [ 2358.555424] mtd_oobtest: verified up to eraseblock 0
+  [ 2358.567572] mtd_oobtest: verified up to eraseblock 256
+  [ 2358.575045] mtd_oobtest: verified up to eraseblock 512
+  [ 2358.582537] mtd_oobtest: verified up to eraseblock 768
+  [ 2358.590024] mtd_oobtest: verified up to eraseblock 1024
+  [ 2358.597511] mtd_oobtest: verified up to eraseblock 1280
+  [ 2358.604984] mtd_oobtest: verified up to eraseblock 1536
+  [ 2358.612468] mtd_oobtest: verified up to eraseblock 1792
+  [ 2358.619923] mtd_oobtest: verified 2048 eraseblocks
+  [ 2358.619936] mtd_oobtest: test 4 of 5
+  [ 2365.924669] mtd_oobtest: attempting to start write past end of OOB
+  [ 2365.924711] mtd_oobtest: an error is expected...
+  [ 2365.929795] mtd_oobtest: error occurred as expected
+  [ 2365.934520] mtd_oobtest: attempting to start read past end of OOB
+  [ 2365.939150] mtd_oobtest: an error is expected...
+  [ 2365.945371] mtd_oobtest: error occurred as expected
+  [ 2365.950087] mtd_oobtest: attempting to write past end of device
+  [ 2365.954660] mtd_oobtest: an error is expected...
+  [ 2365.960623] mtd_oobtest: error occurred as expected
+  [ 2365.965422] mtd_oobtest: attempting to read past end of device
+  [ 2365.970064] mtd_oobtest: an error is expected...
+  [ 2365.975925] mtd_oobtest: error occurred as expected
+  [ 2365.984256] mtd_oobtest: attempting to write past end of device
+  [ 2365.985300] mtd_oobtest: an error is expected...
+  [ 2365.991242] mtd_oobtest: error: wrote past end of device
+  [ 2365.996064] mtd_oobtest: attempting to read past end of device
+  [ 2366.001389] mtd_oobtest: an error is expected...
+  [ 2366.007028] mtd_oobtest: error: read past end of device
+  [ 2366.011776] mtd_oobtest: test 5 of 5
+  [ 2373.317991] mtd_oobtest: writing OOBs of whole device
+  [ 2373.318034] mtd_oobtest: written up to eraseblock 0
+  [ 2373.322028] mtd_oobtest: written up to eraseblock 0
+  [ 2373.327465] mtd_oobtest: written up to eraseblock 256
+  [ 2373.331576] mtd_oobtest: written up to eraseblock 256
+  [ 2373.337501] mtd_oobtest: written up to eraseblock 512
+  [ 2373.341820] mtd_oobtest: written up to eraseblock 512
+  [ 2373.347566] mtd_oobtest: written up to eraseblock 768
+  [ 2373.351888] mtd_oobtest: written up to eraseblock 768
+  [ 2373.357634] mtd_oobtest: written up to eraseblock 1024
+  [ 2373.361957] mtd_oobtest: written up to eraseblock 1024
+  [ 2373.367710] mtd_oobtest: written up to eraseblock 1280
+  [ 2373.372113] mtd_oobtest: written up to eraseblock 1280
+  [ 2373.377841] mtd_oobtest: written up to eraseblock 1536
+  [ 2373.382355] mtd_oobtest: written up to eraseblock 1536
+  [ 2373.387962] mtd_oobtest: written up to eraseblock 1792
+  [ 2373.392597] mtd_oobtest: written up to eraseblock 1792
+  [ 2373.398190] mtd_oobtest: written 2047 eraseblocks
+  [ 2373.402838] mtd_oobtest: verifying all eraseblocks
+  [ 2373.407629] mtd_oobtest: verified up to eraseblock 0
+  [ 2373.412483] mtd_oobtest: verified up to eraseblock 256
+  [ 2373.417625] mtd_oobtest: verified up to eraseblock 512
+  [ 2373.422518] mtd_oobtest: verified up to eraseblock 768
+  [ 2373.427650] mtd_oobtest: verified up to eraseblock 1024
+  [ 2373.432760] mtd_oobtest: verified up to eraseblock 1280
+  [ 2373.437912] mtd_oobtest: verified up to eraseblock 1536
+  [ 2373.443091] mtd_oobtest: verified up to eraseblock 1792
+  [ 2373.448337] mtd_oobtest: verified 2047 eraseblocks
+  [ 2373.453358] mtd_oobtest: finished with 2 errors
+  [ 2373.458250] =================================================
+
+Note: the two errors are present even even without this patch when testing
+the driver with a flash chip requiring 4 bits ECC strength.
+
+  # insmod mtd_stresstest dev=0
+  [ 2383.256453]
+  [ 2383.256482] =================================================
+  [ 2383.257008] mtd_stresstest: MTD device: 0
+  [ 2383.262650] mtd_stresstest: MTD device size 268435456, eraseblock size 131072, page size 2048, count of eraseblocks 2048, pages per eraseblock 64, OOB size 128
+  [ 2383.268254] mtd_test: scanning for bad eraseblocks
+  [ 2383.281992] mtd_test: scanned 2048 eraseblocks, 0 are bad
+  [ 2383.285565] mtd_stresstest: doing operations
+  [ 2383.291047] mtd_stresstest: 0 operations done
+  [ 2427.841267] mtd_stresstest: 1024 operations done
+  [ 2471.142229] mtd_stresstest: 2048 operations done
+  [ 2514.405277] mtd_stresstest: 3072 operations done
+  [ 2555.451926] mtd_stresstest: 4096 operations done
+  [ 2598.107133] mtd_stresstest: 5120 operations done
+  [ 2639.936952] mtd_stresstest: 6144 operations done
+  [ 2680.724751] mtd_stresstest: 7168 operations done
+  [ 2720.344163] mtd_stresstest: 8192 operations done
+  [ 2761.645640] mtd_stresstest: 9216 operations done
+  [ 2791.760534] mtd_stresstest: finished, 10000 operations done
+  [ 2791.760817] =================================================
+  #
+---
+ drivers/spi/spi-qpic-snand.c | 21 ++++++++++++++++-----
+ 1 file changed, 16 insertions(+), 5 deletions(-)
+
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -283,9 +283,22 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 		goto err_free_ecc_cfg;
+ 	}
+ 
+-	if (ecc_cfg->strength != 4) {
++	switch (ecc_cfg->strength) {
++	case 4:
++		ecc_cfg->ecc_mode = ECC_MODE_4BIT;
++		ecc_cfg->ecc_bytes_hw = 7;
++		ecc_cfg->spare_bytes = 4;
++		break;
++
++	case 8:
++		ecc_cfg->ecc_mode = ECC_MODE_8BIT;
++		ecc_cfg->ecc_bytes_hw = 13;
++		ecc_cfg->spare_bytes = 2;
++		break;
++
++	default:
+ 		dev_err(snandc->dev,
+-			"only 4 bits ECC strength is supported\n");
++			"only 4 or 8 bits ECC strength is supported\n");
+ 		ret = -EOPNOTSUPP;
+ 		goto err_free_ecc_cfg;
+ 	}
+@@ -302,8 +315,6 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 	nand->ecc.ctx.priv = ecc_cfg;
+ 	snandc->qspi->mtd = mtd;
+ 
+-	ecc_cfg->ecc_bytes_hw = 7;
+-	ecc_cfg->spare_bytes = 4;
+ 	ecc_cfg->bbm_size = 1;
+ 	ecc_cfg->bch_enabled = true;
+ 	ecc_cfg->bytes = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes + ecc_cfg->bbm_size;
+@@ -349,7 +360,7 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 			       FIELD_PREP(ECC_SW_RESET, 0) |
+ 			       FIELD_PREP(ECC_NUM_DATA_BYTES_MASK, ecc_cfg->cw_data) |
+ 			       FIELD_PREP(ECC_FORCE_CLK_OPEN, 1) |
+-			       FIELD_PREP(ECC_MODE_MASK, ECC_MODE_4BIT) |
++			       FIELD_PREP(ECC_MODE_MASK, ecc_cfg->ecc_mode) |
+ 			       FIELD_PREP(ECC_PARITY_SIZE_BYTES_BCH_MASK, ecc_cfg->ecc_bytes_hw);
+ 
+ 	ecc_cfg->ecc_buf_cfg = 0x203 << NUM_STEPS;
diff --git a/target/linux/generic/pending-6.12/420-mtd-redboot_space.patch b/target/linux/generic/pending-6.12/420-mtd-redboot_space.patch
new file mode 100644
index 0000000000..5518ea71dd
--- /dev/null
+++ b/target/linux/generic/pending-6.12/420-mtd-redboot_space.patch
@@ -0,0 +1,41 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: add patch for including unpartitioned space in the rootfs partition for redboot devices (if applicable)
+
+[john@phrozen.org: used by ixp and others]
+
+lede-commit: 394918851f84e4d00fa16eb900e7700e95091f00
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/mtd/redboot.c | 19 +++++++++++++------
+ 1 file changed, 13 insertions(+), 6 deletions(-)
+
+--- a/drivers/mtd/parsers/redboot.c
++++ b/drivers/mtd/parsers/redboot.c
+@@ -278,14 +278,21 @@ nogood:
+ #endif
+ 		names += strlen(names) + 1;
+ 
+-#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
+ 		if (fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {
+-			i++;
+-			parts[i].offset = parts[i - 1].size + parts[i - 1].offset;
+-			parts[i].size = fl->next->img->flash_base - parts[i].offset;
+-			parts[i].name = nullname;
+-		}
++			if (!strcmp(parts[i].name, "rootfs")) {
++				parts[i].size = fl->next->img->flash_base;
++				parts[i].size &= ~(master->erasesize - 1);
++				parts[i].size -= parts[i].offset;
++#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
++				nrparts--;
++			} else {
++				i++;
++				parts[i].offset = parts[i-1].size + parts[i-1].offset;
++				parts[i].size = fl->next->img->flash_base - parts[i].offset;
++				parts[i].name = nullname;
+ #endif
++			}
++		}
+ 		tmp_fl = fl;
+ 		fl = fl->next;
+ 		kfree(tmp_fl);
diff --git a/target/linux/generic/pending-6.12/430-mtd-add-myloader-partition-parser.patch b/target/linux/generic/pending-6.12/430-mtd-add-myloader-partition-parser.patch
new file mode 100644
index 0000000000..8ce112357a
--- /dev/null
+++ b/target/linux/generic/pending-6.12/430-mtd-add-myloader-partition-parser.patch
@@ -0,0 +1,229 @@
+From: Florian Fainelli <f.fainelli@gmail.com>
+Subject: Add myloader partition table parser
+
+[john@phozen.org: shoud be upstreamable]
+
+lede-commit: d8bf22859b51faa09d22c056fe221a45d2f7a3b8
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+[adjust for kernel 5.4, add myloader.c to patch]
+Signed-off-by: Adrian Schmutzler <freifunk@adrianschmutzler.de>
+
+--- a/drivers/mtd/parsers/Kconfig
++++ b/drivers/mtd/parsers/Kconfig
+@@ -62,6 +62,22 @@ config MTD_CMDLINE_PARTS
+ 
+ 	  If unsure, say 'N'.
+ 
++config MTD_MYLOADER_PARTS
++	tristate "MyLoader partition parsing"
++	depends on ADM5120 || ATH79
++	help
++	  MyLoader is a bootloader which allows the user to define partitions
++	  in flash devices, by putting a table in the second erase block
++	  on the device, similar to a partition table. This table gives the
++	  offsets and lengths of the user defined partitions.
++
++	  If you need code which can detect and parse these tables, and
++	  register MTD 'partitions' corresponding to each image detected,
++	  enable this option.
++
++	  You will still need the parsing functions to be called by the driver
++	  for your particular device. It won't happen automatically.
++
+ config MTD_OF_PARTS
+ 	tristate "OpenFirmware (device tree) partitioning parser"
+ 	default y
+--- a/drivers/mtd/parsers/Makefile
++++ b/drivers/mtd/parsers/Makefile
+@@ -3,6 +3,7 @@ obj-$(CONFIG_MTD_BCM47XX_PARTS)		+= bcm4
+ obj-$(CONFIG_MTD_BCM63XX_PARTS)		+= bcm63xxpart.o
+ obj-$(CONFIG_MTD_BRCM_U_BOOT)		+= brcm_u-boot.o
+ obj-$(CONFIG_MTD_CMDLINE_PARTS)		+= cmdlinepart.o
++obj-$(CONFIG_MTD_MYLOADER_PARTS)		+= myloader.o
+ obj-$(CONFIG_MTD_OF_PARTS)		+= ofpart.o
+ ofpart-y				+= ofpart_core.o
+ ofpart-$(CONFIG_MTD_OF_PARTS_BCM4908)	+= ofpart_bcm4908.o
+--- /dev/null
++++ b/drivers/mtd/parsers/myloader.c
+@@ -0,0 +1,181 @@
++/*
++ *  Parse MyLoader-style flash partition tables and produce a Linux partition
++ *  array to match.
++ *
++ *  Copyright (C) 2007-2009 Gabor Juhos <juhosg@openwrt.org>
++ *
++ *  This file was based on drivers/mtd/redboot.c
++ *  Author: Red Hat, Inc. - David Woodhouse <dwmw2@cambridge.redhat.com>
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2 as published
++ *  by the Free Software Foundation.
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/version.h>
++#include <linux/slab.h>
++#include <linux/init.h>
++#include <linux/vmalloc.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/partitions.h>
++#include <linux/byteorder/generic.h>
++#include <linux/myloader.h>
++
++#define BLOCK_LEN_MIN		0x10000
++#define PART_NAME_LEN		32
++
++struct part_data {
++	struct mylo_partition_table	tab;
++	char names[MYLO_MAX_PARTITIONS][PART_NAME_LEN];
++};
++
++static int myloader_parse_partitions(struct mtd_info *master,
++				     const struct mtd_partition **pparts,
++				     struct mtd_part_parser_data *data)
++{
++	struct part_data *buf;
++	struct mylo_partition_table *tab;
++	struct mylo_partition *part;
++	struct mtd_partition *mtd_parts;
++	struct mtd_partition *mtd_part;
++	int num_parts;
++	int ret, i;
++	size_t retlen;
++	char *names;
++	unsigned long offset;
++	unsigned long blocklen;
++
++	buf = vmalloc(sizeof(*buf));
++	if (!buf) {
++		return -ENOMEM;
++		goto out;
++	}
++	tab = &buf->tab;
++
++	blocklen = master->erasesize;
++	if (blocklen < BLOCK_LEN_MIN)
++		blocklen = BLOCK_LEN_MIN;
++
++	offset = blocklen;
++
++	/* Find the partition table */
++	for (i = 0; i < 4; i++, offset += blocklen) {
++		printk(KERN_DEBUG "%s: searching for MyLoader partition table"
++				" at offset 0x%lx\n", master->name, offset);
++
++		ret = mtd_read(master, offset, sizeof(*buf), &retlen,
++			       (void *)buf);
++		if (ret)
++			goto out_free_buf;
++
++		if (retlen != sizeof(*buf)) {
++			ret = -EIO;
++			goto out_free_buf;
++		}
++
++		/* Check for Partition Table magic number */
++		if (tab->magic == le32_to_cpu(MYLO_MAGIC_PARTITIONS))
++			break;
++
++	}
++
++	if (tab->magic != le32_to_cpu(MYLO_MAGIC_PARTITIONS)) {
++		printk(KERN_DEBUG "%s: no MyLoader partition table found\n",
++			master->name);
++		ret = 0;
++		goto out_free_buf;
++	}
++
++	/* The MyLoader and the Partition Table is always present */
++	num_parts = 2;
++
++	/* Detect number of used partitions */
++	for (i = 0; i < MYLO_MAX_PARTITIONS; i++) {
++		part = &tab->partitions[i];
++
++		if (le16_to_cpu(part->type) == PARTITION_TYPE_FREE)
++			continue;
++
++		num_parts++;
++	}
++
++	mtd_parts = kzalloc((num_parts * sizeof(*mtd_part) +
++				num_parts * PART_NAME_LEN), GFP_KERNEL);
++
++	if (!mtd_parts) {
++		ret = -ENOMEM;
++		goto out_free_buf;
++	}
++
++	mtd_part = mtd_parts;
++	names = (char *)&mtd_parts[num_parts];
++
++	strncpy(names, "myloader", PART_NAME_LEN);
++	mtd_part->name = names;
++	mtd_part->offset = 0;
++	mtd_part->size = offset;
++	mtd_part->mask_flags = MTD_WRITEABLE;
++	mtd_part++;
++	names += PART_NAME_LEN;
++
++	strncpy(names, "partition_table", PART_NAME_LEN);
++	mtd_part->name = names;
++	mtd_part->offset = offset;
++	mtd_part->size = blocklen;
++	mtd_part->mask_flags = MTD_WRITEABLE;
++	mtd_part++;
++	names += PART_NAME_LEN;
++
++	for (i = 0; i < MYLO_MAX_PARTITIONS; i++) {
++		part = &tab->partitions[i];
++
++		if (le16_to_cpu(part->type) == PARTITION_TYPE_FREE)
++			continue;
++
++		if ((buf->names[i][0]) && (buf->names[i][0] != '\xff'))
++			strncpy(names, buf->names[i], PART_NAME_LEN);
++		else
++			snprintf(names, PART_NAME_LEN, "partition%d", i);
++
++		mtd_part->offset = le32_to_cpu(part->addr);
++		mtd_part->size = le32_to_cpu(part->size);
++		mtd_part->name = names;
++		mtd_part++;
++		names += PART_NAME_LEN;
++	}
++
++	*pparts = mtd_parts;
++	ret = num_parts;
++
++ out_free_buf:
++	vfree(buf);
++ out:
++	return ret;
++}
++
++static struct mtd_part_parser myloader_mtd_parser = {
++	.owner		= THIS_MODULE,
++	.parse_fn	= myloader_parse_partitions,
++	.name		= "MyLoader",
++};
++
++static int __init myloader_mtd_parser_init(void)
++{
++	register_mtd_parser(&myloader_mtd_parser);
++
++	return 0;
++}
++
++static void __exit myloader_mtd_parser_exit(void)
++{
++	deregister_mtd_parser(&myloader_mtd_parser);
++}
++
++module_init(myloader_mtd_parser_init);
++module_exit(myloader_mtd_parser_exit);
++
++MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
++MODULE_DESCRIPTION("Parsing code for MyLoader partition tables");
++MODULE_LICENSE("GPL v2");
diff --git a/target/linux/generic/pending-6.12/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch b/target/linux/generic/pending-6.12/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch
new file mode 100644
index 0000000000..bcea45d009
--- /dev/null
+++ b/target/linux/generic/pending-6.12/431-mtd-bcm47xxpart-check-for-bad-blocks-when-calculatin.patch
@@ -0,0 +1,68 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Subject: [PATCH] mtd: bcm47xxpart: check for bad blocks when calculating offsets
+
+Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
+---
+
+--- a/drivers/mtd/parsers/parser_trx.c
++++ b/drivers/mtd/parsers/parser_trx.c
+@@ -25,6 +25,33 @@ struct trx_header {
+ 	uint32_t offset[3];
+ } __packed;
+ 
++/*
++ * Calculate real end offset (address) for a given amount of data. It checks
++ * all blocks skipping bad ones.
++ */
++static size_t parser_trx_real_offset(struct mtd_info *mtd, size_t bytes)
++{
++	size_t real_offset = 0;
++
++	if (mtd_block_isbad(mtd, real_offset))
++		pr_warn("Base offset shouldn't be at bad block");
++
++	while (bytes >= mtd->erasesize) {
++		bytes -= mtd->erasesize;
++		real_offset += mtd->erasesize;
++		while (mtd_block_isbad(mtd, real_offset)) {
++			real_offset += mtd->erasesize;
++
++			if (real_offset >= mtd->size)
++				return real_offset - mtd->erasesize;
++		}
++	}
++
++	real_offset += bytes;
++
++	return real_offset;
++}
++
+ static const char *parser_trx_data_part_name(struct mtd_info *master,
+ 					     size_t offset)
+ {
+@@ -86,21 +113,21 @@ static int parser_trx_parse(struct mtd_i
+ 	if (trx.offset[2]) {
+ 		part = &parts[curr_part++];
+ 		part->name = "loader";
+-		part->offset = trx.offset[i];
++		part->offset = parser_trx_real_offset(mtd, trx.offset[i]);
+ 		i++;
+ 	}
+ 
+ 	if (trx.offset[i]) {
+ 		part = &parts[curr_part++];
+ 		part->name = "linux";
+-		part->offset = trx.offset[i];
++		part->offset = parser_trx_real_offset(mtd, trx.offset[i]);
+ 		i++;
+ 	}
+ 
+ 	if (trx.offset[i]) {
+ 		part = &parts[curr_part++];
+-		part->name = parser_trx_data_part_name(mtd, trx.offset[i]);
+-		part->offset = trx.offset[i];
++		part->offset = parser_trx_real_offset(mtd, trx.offset[i]);
++		part->name = parser_trx_data_part_name(mtd, part->offset);
+ 		i++;
+ 	}
+ 
diff --git a/target/linux/generic/pending-6.12/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch b/target/linux/generic/pending-6.12/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch
new file mode 100644
index 0000000000..852654d924
--- /dev/null
+++ b/target/linux/generic/pending-6.12/432-mtd-bcm47xxpart-detect-T_Meter-partition.patch
@@ -0,0 +1,37 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
+Subject: mtd: bcm47xxpart: detect T_Meter partition
+
+It can be found on many Netgear devices. It consists of many 0x30 blocks
+starting with 4D 54.
+
+Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
+---
+ drivers/mtd/bcm47xxpart.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/mtd/parsers/bcm47xxpart.c
++++ b/drivers/mtd/parsers/bcm47xxpart.c
+@@ -35,6 +35,7 @@
+ #define NVRAM_HEADER			0x48534C46	/* FLSH */
+ #define POT_MAGIC1			0x54544f50	/* POTT */
+ #define POT_MAGIC2			0x504f		/* OP */
++#define T_METER_MAGIC			0x4D540000	/* MT */
+ #define ML_MAGIC1			0x39685a42
+ #define ML_MAGIC2			0x26594131
+ #define TRX_MAGIC			0x30524448
+@@ -178,6 +179,15 @@ static int bcm47xxpart_parse(struct mtd_
+ 					     MTD_WRITEABLE);
+ 			continue;
+ 		}
++
++		/* T_Meter */
++		if ((le32_to_cpu(buf[0x000 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
++		    (le32_to_cpu(buf[0x030 / 4]) & 0xFFFF0000) == T_METER_MAGIC &&
++		    (le32_to_cpu(buf[0x060 / 4]) & 0xFFFF0000) == T_METER_MAGIC) {
++			bcm47xxpart_add_part(&parts[curr_part++], "T_Meter", offset,
++					     MTD_WRITEABLE);
++			continue;
++		}
+ 
+ 		/* TRX */
+ 		if (buf[0x000 / 4] == TRX_MAGIC) {
diff --git a/target/linux/generic/pending-6.12/435-mtd-add-routerbootpart-parser-config.patch b/target/linux/generic/pending-6.12/435-mtd-add-routerbootpart-parser-config.patch
new file mode 100644
index 0000000000..d516e1dc78
--- /dev/null
+++ b/target/linux/generic/pending-6.12/435-mtd-add-routerbootpart-parser-config.patch
@@ -0,0 +1,38 @@
+From 4437e01fb6bca63fccdba5d6c44888b0935885c2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Thibaut=20VAR=C3=88NE?= <hacks@slashdirt.org>
+Date: Tue, 24 Mar 2020 11:45:07 +0100
+Subject: [PATCH] generic: routerboot partition build bits (5.4)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This patch adds routerbootpart kernel build bits
+
+Signed-off-by: Thibaut VARÈNE <hacks@slashdirt.org>
+---
+ drivers/mtd/parsers/Kconfig  | 9 +++++++++
+ drivers/mtd/parsers/Makefile | 1 +
+ 2 files changed, 10 insertions(+)
+
+--- a/drivers/mtd/parsers/Kconfig
++++ b/drivers/mtd/parsers/Kconfig
+@@ -231,3 +231,12 @@ config MTD_SERCOMM_PARTS
+ 	  partition map. This partition table contains real partition
+ 	  offsets, which may differ from device to device depending on the
+ 	  number and location of bad blocks on NAND.
++
++config MTD_ROUTERBOOT_PARTS
++	tristate "RouterBoot flash partition parser"
++	depends on MTD && OF
++	help
++	 MikroTik RouterBoot is implemented as a multi segment system on the
++	 flash, some of which are fixed and some of which are located at
++	 variable offsets. This parser handles both cases via properly
++	 formatted DTS.
+--- a/drivers/mtd/parsers/Makefile
++++ b/drivers/mtd/parsers/Makefile
+@@ -16,3 +16,4 @@ obj-$(CONFIG_MTD_SERCOMM_PARTS)		+= scpa
+ obj-$(CONFIG_MTD_SHARPSL_PARTS)		+= sharpslpart.o
+ obj-$(CONFIG_MTD_REDBOOT_PARTS)		+= redboot.o
+ obj-$(CONFIG_MTD_QCOMSMEM_PARTS)	+= qcomsmempart.o
++obj-$(CONFIG_MTD_ROUTERBOOT_PARTS)		+= routerbootpart.o
diff --git a/target/linux/generic/pending-6.12/450-block-allow-setting-partition-of_node.patch b/target/linux/generic/pending-6.12/450-block-allow-setting-partition-of_node.patch
new file mode 100644
index 0000000000..a3c8abc1d9
--- /dev/null
+++ b/target/linux/generic/pending-6.12/450-block-allow-setting-partition-of_node.patch
@@ -0,0 +1,123 @@
+From decc6959a423c8617e87244fd269129fc4e7d0e6 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Mon, 7 Oct 2024 23:36:14 +0100
+Subject: [PATCH 1/8] block: allow setting partition of_node
+
+Allow partition parsers to set the Device Tree node for a partition by
+introducing of_put_partition() and extending struct parsed_partitions
+accordingly.
+
+As the partition information is preallocated independently of the actual
+number of partitions the additional pointer takes about 2 kiB of allocated
+memory which is worth avoiding in case CONFIG_OF is not set. This is
+achieved by only adding the corresponding field to the struct in case
+CONFIG_OF is set using #ifdef'ery.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ block/partitions/check.h | 16 +++++++++++++++-
+ block/partitions/core.c  | 14 +++++++++++---
+ 2 files changed, 26 insertions(+), 4 deletions(-)
+
+--- a/block/partitions/check.h
++++ b/block/partitions/check.h
+@@ -1,6 +1,7 @@
+ /* SPDX-License-Identifier: GPL-2.0 */
+ #include <linux/pagemap.h>
+ #include <linux/blkdev.h>
++#include <linux/of.h>
+ #include "../blk.h"
+ 
+ /*
+@@ -16,6 +17,9 @@ struct parsed_partitions {
+ 		int flags;
+ 		bool has_info;
+ 		struct partition_meta_info info;
++#ifdef CONFIG_OF
++		struct device_node *np;
++#endif
+ 	} *parts;
+ 	int next;
+ 	int limit;
+@@ -34,18 +38,28 @@ static inline void put_dev_sector(Sector
+ }
+ 
+ static inline void
+-put_partition(struct parsed_partitions *p, int n, sector_t from, sector_t size)
++of_put_partition(struct parsed_partitions *p, int n, sector_t from, sector_t size,
++		 struct device_node *np)
+ {
+ 	if (n < p->limit) {
+ 		char tmp[1 + BDEVNAME_SIZE + 10 + 1];
+ 
+ 		p->parts[n].from = from;
+ 		p->parts[n].size = size;
++#ifdef CONFIG_OF
++		p->parts[n].np = np;
++#endif
+ 		snprintf(tmp, sizeof(tmp), " %s%d", p->name, n);
+ 		strlcat(p->pp_buf, tmp, PAGE_SIZE);
+ 	}
+ }
+ 
++static inline void
++put_partition(struct parsed_partitions *p, int n, sector_t from, sector_t size)
++{
++	of_put_partition(p, n, from, size, NULL);
++}
++
+ /* detection routines go here in alphabetical order: */
+ int adfspart_check_ADFS(struct parsed_partitions *state);
+ int adfspart_check_CUMANA(struct parsed_partitions *state);
+--- a/block/partitions/core.c
++++ b/block/partitions/core.c
+@@ -9,6 +9,7 @@
+ #include <linux/slab.h>
+ #include <linux/ctype.h>
+ #include <linux/vmalloc.h>
++#include <linux/device.h>
+ #include <linux/raid/detect.h>
+ #include "check.h"
+ 
+@@ -290,7 +291,8 @@ static const DEVICE_ATTR(whole_disk, 044
+  */
+ static struct block_device *add_partition(struct gendisk *disk, int partno,
+ 				sector_t start, sector_t len, int flags,
+-				struct partition_meta_info *info)
++				struct partition_meta_info *info,
++				struct device_node *np)
+ {
+ 	dev_t devt = MKDEV(0, 0);
+ 	struct device *ddev = disk_to_dev(disk);
+@@ -339,6 +341,7 @@ static struct block_device *add_partitio
+ 	pdev->class = &block_class;
+ 	pdev->type = &part_type;
+ 	pdev->parent = ddev;
++	device_set_node(pdev, of_fwnode_handle(np));
+ 
+ 	/* in consecutive minor range? */
+ 	if (bdev_partno(bdev) < disk->minors) {
+@@ -445,7 +448,7 @@ int bdev_add_partition(struct gendisk *d
+ 	}
+ 
+ 	part = add_partition(disk, partno, start, length,
+-			ADDPART_FLAG_NONE, NULL);
++			ADDPART_FLAG_NONE, NULL, NULL);
+ 	ret = PTR_ERR_OR_ZERO(part);
+ out:
+ 	mutex_unlock(&disk->open_mutex);
+@@ -559,8 +562,13 @@ static bool blk_add_partition(struct gen
+ 		size = get_capacity(disk) - from;
+ 	}
+ 
++#ifdef CONFIG_OF
+ 	part = add_partition(disk, p, from, size, state->parts[p].flags,
+-			     &state->parts[p].info);
++			     &state->parts[p].info, state->parts[p].np);
++#else
++	part = add_partition(disk, p, from, size, state->parts[p].flags,
++			     &state->parts[p].info, NULL);
++#endif
+ 	if (IS_ERR(part)) {
+ 		if (PTR_ERR(part) != -ENXIO) {
+ 			printk(KERN_ERR " %s: p%d could not be added: %pe\n",
diff --git a/target/linux/generic/pending-6.12/451-block-partitions-of-assign-Device-Tree-node-to-parti.patch b/target/linux/generic/pending-6.12/451-block-partitions-of-assign-Device-Tree-node-to-parti.patch
new file mode 100644
index 0000000000..f9e41d03c8
--- /dev/null
+++ b/target/linux/generic/pending-6.12/451-block-partitions-of-assign-Device-Tree-node-to-parti.patch
@@ -0,0 +1,25 @@
+From 5d265996597a6b0d654bbeda1bc3bae197061de7 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Mon, 7 Oct 2024 23:43:32 +0100
+Subject: [PATCH 2/8] block: partitions: of: assign Device Tree node to
+ partition
+
+Assign partition of_node so other drivers are able to identify a
+partition by its Device Tree node.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ block/partitions/of.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/block/partitions/of.c
++++ b/block/partitions/of.c
+@@ -48,7 +48,7 @@ static void add_of_partition(struct pars
+ 	u64 offset = of_read_number(reg, a_cells) / SECTOR_SIZE;
+ 	u64 size = of_read_number(reg + a_cells, s_cells) / SECTOR_SIZE;
+ 
+-	put_partition(state, slot, offset, size);
++	of_put_partition(state, slot, offset, size, np);
+ 
+ 	if (of_property_read_bool(np, "read-only"))
+ 		state->parts[slot].flags |= ADDPART_FLAG_READONLY;
diff --git a/target/linux/generic/pending-6.12/452-partitions-efi-apply-Linux-code-style.patch b/target/linux/generic/pending-6.12/452-partitions-efi-apply-Linux-code-style.patch
new file mode 100644
index 0000000000..6e996ca3f7
--- /dev/null
+++ b/target/linux/generic/pending-6.12/452-partitions-efi-apply-Linux-code-style.patch
@@ -0,0 +1,498 @@
+From d4e82837c8b86ff2c21fa923271908988bc72faa Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Mon, 7 Oct 2024 23:22:53 +0100
+Subject: [PATCH 3/8] partitions/efi: apply Linux code style
+
+Fix (mostly white space related) coding style issues in
+block/partitions/efi.c by use of clang-format.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ block/partitions/efi.c | 235 +++++++++++++++++++++--------------------
+ 1 file changed, 121 insertions(+), 114 deletions(-)
+
+--- a/block/partitions/efi.c
++++ b/block/partitions/efi.c
+@@ -95,15 +95,13 @@
+  * the partition tables happens after init too.
+  */
+ static int force_gpt;
+-static int __init
+-force_gpt_fn(char *str)
++static int __init force_gpt_fn(char *str)
+ {
+ 	force_gpt = 1;
+ 	return 1;
+ }
+ __setup("gpt", force_gpt_fn);
+ 
+-
+ /**
+  * efi_crc32() - EFI version of crc32 function
+  * @buf: buffer to calculate crc32 of
+@@ -116,8 +114,7 @@ __setup("gpt", force_gpt_fn);
+  * Note, the EFI Specification, v1.02, has a reference to
+  * Dr. Dobbs Journal, May 1994 (actually it's in May 1992).
+  */
+-static inline u32
+-efi_crc32(const void *buf, unsigned long len)
++static inline u32 efi_crc32(const void *buf, unsigned long len)
+ {
+ 	return (crc32(~0L, buf, len) ^ ~0L);
+ }
+@@ -134,7 +131,8 @@ efi_crc32(const void *buf, unsigned long
+ static u64 last_lba(struct gendisk *disk)
+ {
+ 	return div_u64(bdev_nr_bytes(disk->part0),
+-		       queue_logical_block_size(disk->queue)) - 1ULL;
++		       queue_logical_block_size(disk->queue)) -
++	       1ULL;
+ }
+ 
+ static inline int pmbr_part_valid(gpt_mbr_record *part)
+@@ -195,7 +193,7 @@ static int is_pmbr_valid(legacy_mbr *mbr
+ check_hybrid:
+ 	for (i = 0; i < 4; i++)
+ 		if ((mbr->partition_record[i].os_type !=
+-			EFI_PMBR_OSTYPE_EFI_GPT) &&
++		     EFI_PMBR_OSTYPE_EFI_GPT) &&
+ 		    (mbr->partition_record[i].os_type != 0x00))
+ 			ret = GPT_MBR_HYBRID;
+ 
+@@ -213,10 +211,11 @@ check_hybrid:
+ 	 */
+ 	if (ret == GPT_MBR_PROTECTIVE) {
+ 		sz = le32_to_cpu(mbr->partition_record[part].size_in_lba);
+-		if (sz != (uint32_t) total_sectors - 1 && sz != 0xFFFFFFFF)
+-			pr_debug("GPT: mbr size in lba (%u) different than whole disk (%u).\n",
+-				 sz, min_t(uint32_t,
+-					   total_sectors - 1, 0xFFFFFFFF));
++		if (sz != (uint32_t)total_sectors - 1 && sz != 0xFFFFFFFF)
++			pr_debug(
++				"GPT: mbr size in lba (%u) different than whole disk (%u).\n",
++				sz,
++				min_t(uint32_t, total_sectors - 1, 0xFFFFFFFF));
+ 	}
+ done:
+ 	return ret;
+@@ -232,15 +231,14 @@ done:
+  * Description: Reads @count bytes from @state->disk into @buffer.
+  * Returns number of bytes read on success, 0 on error.
+  */
+-static size_t read_lba(struct parsed_partitions *state,
+-		       u64 lba, u8 *buffer, size_t count)
++static size_t read_lba(struct parsed_partitions *state, u64 lba, u8 *buffer,
++		       size_t count)
+ {
+ 	size_t totalreadcount = 0;
+-	sector_t n = lba *
+-		(queue_logical_block_size(state->disk->queue) / 512);
++	sector_t n = lba * (queue_logical_block_size(state->disk->queue) / 512);
+ 
+ 	if (!buffer || lba > last_lba(state->disk))
+-                return 0;
++		return 0;
+ 
+ 	while (count) {
+ 		int copied = 512;
+@@ -253,7 +251,7 @@ static size_t read_lba(struct parsed_par
+ 		memcpy(buffer, data, copied);
+ 		put_dev_sector(sect);
+ 		buffer += copied;
+-		totalreadcount +=copied;
++		totalreadcount += copied;
+ 		count -= copied;
+ 	}
+ 	return totalreadcount;
+@@ -278,17 +276,17 @@ static gpt_entry *alloc_read_gpt_entries
+ 		return NULL;
+ 
+ 	count = (size_t)le32_to_cpu(gpt->num_partition_entries) *
+-                le32_to_cpu(gpt->sizeof_partition_entry);
++		le32_to_cpu(gpt->sizeof_partition_entry);
+ 	if (!count)
+ 		return NULL;
+ 	pte = kmalloc(count, GFP_KERNEL);
+ 	if (!pte)
+ 		return NULL;
+ 
+-	if (read_lba(state, le64_to_cpu(gpt->partition_entry_lba),
+-			(u8 *) pte, count) < count) {
++	if (read_lba(state, le64_to_cpu(gpt->partition_entry_lba), (u8 *)pte,
++		     count) < count) {
+ 		kfree(pte);
+-                pte=NULL;
++		pte = NULL;
+ 		return NULL;
+ 	}
+ 	return pte;
+@@ -313,9 +311,9 @@ static gpt_header *alloc_read_gpt_header
+ 	if (!gpt)
+ 		return NULL;
+ 
+-	if (read_lba(state, lba, (u8 *) gpt, ssz) < ssz) {
++	if (read_lba(state, lba, (u8 *)gpt, ssz) < ssz) {
+ 		kfree(gpt);
+-                gpt=NULL;
++		gpt = NULL;
+ 		return NULL;
+ 	}
+ 
+@@ -354,8 +352,9 @@ static int is_gpt_valid(struct parsed_pa
+ 
+ 	/* Check the GUID Partition Table header size is too big */
+ 	if (le32_to_cpu((*gpt)->header_size) >
+-			queue_logical_block_size(state->disk->queue)) {
+-		pr_debug("GUID Partition Table Header size is too large: %u > %u\n",
++	    queue_logical_block_size(state->disk->queue)) {
++		pr_debug(
++			"GUID Partition Table Header size is too large: %u > %u\n",
+ 			le32_to_cpu((*gpt)->header_size),
+ 			queue_logical_block_size(state->disk->queue));
+ 		goto fail;
+@@ -363,16 +362,17 @@ static int is_gpt_valid(struct parsed_pa
+ 
+ 	/* Check the GUID Partition Table header size is too small */
+ 	if (le32_to_cpu((*gpt)->header_size) < sizeof(gpt_header)) {
+-		pr_debug("GUID Partition Table Header size is too small: %u < %zu\n",
+-			le32_to_cpu((*gpt)->header_size),
+-			sizeof(gpt_header));
++		pr_debug(
++			"GUID Partition Table Header size is too small: %u < %zu\n",
++			le32_to_cpu((*gpt)->header_size), sizeof(gpt_header));
+ 		goto fail;
+ 	}
+ 
+ 	/* Check the GUID Partition Table CRC */
+ 	origcrc = le32_to_cpu((*gpt)->header_crc32);
+ 	(*gpt)->header_crc32 = 0;
+-	crc = efi_crc32((const unsigned char *) (*gpt), le32_to_cpu((*gpt)->header_size));
++	crc = efi_crc32((const unsigned char *)(*gpt),
++			le32_to_cpu((*gpt)->header_size));
+ 
+ 	if (crc != origcrc) {
+ 		pr_debug("GUID Partition Table Header CRC is wrong: %x != %x\n",
+@@ -396,20 +396,25 @@ static int is_gpt_valid(struct parsed_pa
+ 	lastlba = last_lba(state->disk);
+ 	if (le64_to_cpu((*gpt)->first_usable_lba) > lastlba) {
+ 		pr_debug("GPT: first_usable_lba incorrect: %lld > %lld\n",
+-			 (unsigned long long)le64_to_cpu((*gpt)->first_usable_lba),
++			 (unsigned long long)le64_to_cpu(
++				 (*gpt)->first_usable_lba),
+ 			 (unsigned long long)lastlba);
+ 		goto fail;
+ 	}
+ 	if (le64_to_cpu((*gpt)->last_usable_lba) > lastlba) {
+ 		pr_debug("GPT: last_usable_lba incorrect: %lld > %lld\n",
+-			 (unsigned long long)le64_to_cpu((*gpt)->last_usable_lba),
++			 (unsigned long long)le64_to_cpu(
++				 (*gpt)->last_usable_lba),
+ 			 (unsigned long long)lastlba);
+ 		goto fail;
+ 	}
+-	if (le64_to_cpu((*gpt)->last_usable_lba) < le64_to_cpu((*gpt)->first_usable_lba)) {
++	if (le64_to_cpu((*gpt)->last_usable_lba) <
++	    le64_to_cpu((*gpt)->first_usable_lba)) {
+ 		pr_debug("GPT: last_usable_lba incorrect: %lld > %lld\n",
+-			 (unsigned long long)le64_to_cpu((*gpt)->last_usable_lba),
+-			 (unsigned long long)le64_to_cpu((*gpt)->first_usable_lba));
++			 (unsigned long long)le64_to_cpu(
++				 (*gpt)->last_usable_lba),
++			 (unsigned long long)le64_to_cpu(
++				 (*gpt)->first_usable_lba));
+ 		goto fail;
+ 	}
+ 	/* Check that sizeof_partition_entry has the correct value */
+@@ -420,10 +425,11 @@ static int is_gpt_valid(struct parsed_pa
+ 
+ 	/* Sanity check partition table size */
+ 	pt_size = (u64)le32_to_cpu((*gpt)->num_partition_entries) *
+-		le32_to_cpu((*gpt)->sizeof_partition_entry);
++		  le32_to_cpu((*gpt)->sizeof_partition_entry);
+ 	if (pt_size > KMALLOC_MAX_SIZE) {
+-		pr_debug("GUID Partition Table is too large: %llu > %lu bytes\n",
+-			 (unsigned long long)pt_size, KMALLOC_MAX_SIZE);
++		pr_debug(
++			"GUID Partition Table is too large: %llu > %lu bytes\n",
++			(unsigned long long)pt_size, KMALLOC_MAX_SIZE);
+ 		goto fail;
+ 	}
+ 
+@@ -431,7 +437,7 @@ static int is_gpt_valid(struct parsed_pa
+ 		goto fail;
+ 
+ 	/* Check the GUID Partition Entry Array CRC */
+-	crc = efi_crc32((const unsigned char *) (*ptes), pt_size);
++	crc = efi_crc32((const unsigned char *)(*ptes), pt_size);
+ 
+ 	if (crc != le32_to_cpu((*gpt)->partition_entry_array_crc32)) {
+ 		pr_debug("GUID Partition Entry Array CRC check failed.\n");
+@@ -441,10 +447,10 @@ static int is_gpt_valid(struct parsed_pa
+ 	/* We're done, all's well */
+ 	return 1;
+ 
+- fail_ptes:
++fail_ptes:
+ 	kfree(*ptes);
+ 	*ptes = NULL;
+- fail:
++fail:
+ 	kfree(*gpt);
+ 	*gpt = NULL;
+ 	return 0;
+@@ -457,12 +463,11 @@ static int is_gpt_valid(struct parsed_pa
+  *
+  * Description: returns 1 if valid,  0 on error.
+  */
+-static inline int
+-is_pte_valid(const gpt_entry *pte, const u64 lastlba)
++static inline int is_pte_valid(const gpt_entry *pte, const u64 lastlba)
+ {
+ 	if ((!efi_guidcmp(pte->partition_type_guid, NULL_GUID)) ||
+-	    le64_to_cpu(pte->starting_lba) > lastlba         ||
+-	    le64_to_cpu(pte->ending_lba)   > lastlba)
++	    le64_to_cpu(pte->starting_lba) > lastlba ||
++	    le64_to_cpu(pte->ending_lba) > lastlba)
+ 		return 0;
+ 	return 1;
+ }
+@@ -477,8 +482,7 @@ is_pte_valid(const gpt_entry *pte, const
+  * and prints warnings on discrepancies.
+  * 
+  */
+-static void
+-compare_gpts(gpt_header *pgpt, gpt_header *agpt, u64 lastlba)
++static void compare_gpts(gpt_header *pgpt, gpt_header *agpt, u64 lastlba)
+ {
+ 	int error_found = 0;
+ 	if (!pgpt || !agpt)
+@@ -486,31 +490,32 @@ compare_gpts(gpt_header *pgpt, gpt_heade
+ 	if (le64_to_cpu(pgpt->my_lba) != le64_to_cpu(agpt->alternate_lba)) {
+ 		pr_warn("GPT:Primary header LBA != Alt. header alternate_lba\n");
+ 		pr_warn("GPT:%lld != %lld\n",
+-		       (unsigned long long)le64_to_cpu(pgpt->my_lba),
+-                       (unsigned long long)le64_to_cpu(agpt->alternate_lba));
++			(unsigned long long)le64_to_cpu(pgpt->my_lba),
++			(unsigned long long)le64_to_cpu(agpt->alternate_lba));
+ 		error_found++;
+ 	}
+ 	if (le64_to_cpu(pgpt->alternate_lba) != le64_to_cpu(agpt->my_lba)) {
+ 		pr_warn("GPT:Primary header alternate_lba != Alt. header my_lba\n");
+ 		pr_warn("GPT:%lld != %lld\n",
+-		       (unsigned long long)le64_to_cpu(pgpt->alternate_lba),
+-                       (unsigned long long)le64_to_cpu(agpt->my_lba));
++			(unsigned long long)le64_to_cpu(pgpt->alternate_lba),
++			(unsigned long long)le64_to_cpu(agpt->my_lba));
+ 		error_found++;
+ 	}
+ 	if (le64_to_cpu(pgpt->first_usable_lba) !=
+-            le64_to_cpu(agpt->first_usable_lba)) {
++	    le64_to_cpu(agpt->first_usable_lba)) {
+ 		pr_warn("GPT:first_usable_lbas don't match.\n");
+ 		pr_warn("GPT:%lld != %lld\n",
+-		       (unsigned long long)le64_to_cpu(pgpt->first_usable_lba),
+-                       (unsigned long long)le64_to_cpu(agpt->first_usable_lba));
++			(unsigned long long)le64_to_cpu(pgpt->first_usable_lba),
++			(unsigned long long)le64_to_cpu(
++				agpt->first_usable_lba));
+ 		error_found++;
+ 	}
+ 	if (le64_to_cpu(pgpt->last_usable_lba) !=
+-            le64_to_cpu(agpt->last_usable_lba)) {
++	    le64_to_cpu(agpt->last_usable_lba)) {
+ 		pr_warn("GPT:last_usable_lbas don't match.\n");
+ 		pr_warn("GPT:%lld != %lld\n",
+-		       (unsigned long long)le64_to_cpu(pgpt->last_usable_lba),
+-                       (unsigned long long)le64_to_cpu(agpt->last_usable_lba));
++			(unsigned long long)le64_to_cpu(pgpt->last_usable_lba),
++			(unsigned long long)le64_to_cpu(agpt->last_usable_lba));
+ 		error_found++;
+ 	}
+ 	if (efi_guidcmp(pgpt->disk_guid, agpt->disk_guid)) {
+@@ -518,27 +523,27 @@ compare_gpts(gpt_header *pgpt, gpt_heade
+ 		error_found++;
+ 	}
+ 	if (le32_to_cpu(pgpt->num_partition_entries) !=
+-            le32_to_cpu(agpt->num_partition_entries)) {
++	    le32_to_cpu(agpt->num_partition_entries)) {
+ 		pr_warn("GPT:num_partition_entries don't match: "
+-		       "0x%x != 0x%x\n",
+-		       le32_to_cpu(pgpt->num_partition_entries),
+-		       le32_to_cpu(agpt->num_partition_entries));
++			"0x%x != 0x%x\n",
++			le32_to_cpu(pgpt->num_partition_entries),
++			le32_to_cpu(agpt->num_partition_entries));
+ 		error_found++;
+ 	}
+ 	if (le32_to_cpu(pgpt->sizeof_partition_entry) !=
+-            le32_to_cpu(agpt->sizeof_partition_entry)) {
++	    le32_to_cpu(agpt->sizeof_partition_entry)) {
+ 		pr_warn("GPT:sizeof_partition_entry values don't match: "
+-		       "0x%x != 0x%x\n",
+-                       le32_to_cpu(pgpt->sizeof_partition_entry),
+-		       le32_to_cpu(agpt->sizeof_partition_entry));
++			"0x%x != 0x%x\n",
++			le32_to_cpu(pgpt->sizeof_partition_entry),
++			le32_to_cpu(agpt->sizeof_partition_entry));
+ 		error_found++;
+ 	}
+ 	if (le32_to_cpu(pgpt->partition_entry_array_crc32) !=
+-            le32_to_cpu(agpt->partition_entry_array_crc32)) {
++	    le32_to_cpu(agpt->partition_entry_array_crc32)) {
+ 		pr_warn("GPT:partition_entry_array_crc32 values don't match: "
+-		       "0x%x != 0x%x\n",
+-                       le32_to_cpu(pgpt->partition_entry_array_crc32),
+-		       le32_to_cpu(agpt->partition_entry_array_crc32));
++			"0x%x != 0x%x\n",
++			le32_to_cpu(pgpt->partition_entry_array_crc32),
++			le32_to_cpu(agpt->partition_entry_array_crc32));
+ 		error_found++;
+ 	}
+ 	if (le64_to_cpu(pgpt->alternate_lba) != lastlba) {
+@@ -594,7 +599,7 @@ static int find_valid_gpt(struct parsed_
+ 		return 0;
+ 
+ 	lastlba = last_lba(state->disk);
+-        if (!force_gpt) {
++	if (!force_gpt) {
+ 		/* This will be added to the EFI Spec. per Intel after v1.02. */
+ 		legacymbr = kzalloc(sizeof(*legacymbr), GFP_KERNEL);
+ 		if (!legacymbr)
+@@ -608,18 +613,17 @@ static int find_valid_gpt(struct parsed_
+ 			goto fail;
+ 
+ 		pr_debug("Device has a %s MBR\n",
+-			 good_pmbr == GPT_MBR_PROTECTIVE ?
+-						"protective" : "hybrid");
++			 good_pmbr == GPT_MBR_PROTECTIVE ? "protective" :
++							   "hybrid");
+ 	}
+ 
+-	good_pgpt = is_gpt_valid(state, GPT_PRIMARY_PARTITION_TABLE_LBA,
+-				 &pgpt, &pptes);
+-        if (good_pgpt)
+-		good_agpt = is_gpt_valid(state,
+-					 le64_to_cpu(pgpt->alternate_lba),
+-					 &agpt, &aptes);
+-        if (!good_agpt && force_gpt)
+-                good_agpt = is_gpt_valid(state, lastlba, &agpt, &aptes);
++	good_pgpt = is_gpt_valid(state, GPT_PRIMARY_PARTITION_TABLE_LBA, &pgpt,
++				 &pptes);
++	if (good_pgpt)
++		good_agpt = is_gpt_valid(
++			state, le64_to_cpu(pgpt->alternate_lba), &agpt, &aptes);
++	if (!good_agpt && force_gpt)
++		good_agpt = is_gpt_valid(state, lastlba, &agpt, &aptes);
+ 
+ 	if (!good_agpt && force_gpt && fops->alternative_gpt_sector) {
+ 		sector_t agpt_sector;
+@@ -627,43 +631,42 @@ static int find_valid_gpt(struct parsed_
+ 
+ 		err = fops->alternative_gpt_sector(disk, &agpt_sector);
+ 		if (!err)
+-			good_agpt = is_gpt_valid(state, agpt_sector,
+-						 &agpt, &aptes);
++			good_agpt =
++				is_gpt_valid(state, agpt_sector, &agpt, &aptes);
+ 	}
+ 
+-        /* The obviously unsuccessful case */
+-        if (!good_pgpt && !good_agpt)
+-                goto fail;
+-
+-        compare_gpts(pgpt, agpt, lastlba);
+-
+-        /* The good cases */
+-        if (good_pgpt) {
+-                *gpt  = pgpt;
+-                *ptes = pptes;
+-                kfree(agpt);
+-                kfree(aptes);
++	/* The obviously unsuccessful case */
++	if (!good_pgpt && !good_agpt)
++		goto fail;
++
++	compare_gpts(pgpt, agpt, lastlba);
++
++	/* The good cases */
++	if (good_pgpt) {
++		*gpt = pgpt;
++		*ptes = pptes;
++		kfree(agpt);
++		kfree(aptes);
+ 		if (!good_agpt)
+-                        pr_warn("Alternate GPT is invalid, using primary GPT.\n");
+-                return 1;
+-        }
+-        else if (good_agpt) {
+-                *gpt  = agpt;
+-                *ptes = aptes;
+-                kfree(pgpt);
+-                kfree(pptes);
++			pr_warn("Alternate GPT is invalid, using primary GPT.\n");
++		return 1;
++	} else if (good_agpt) {
++		*gpt = agpt;
++		*ptes = aptes;
++		kfree(pgpt);
++		kfree(pptes);
+ 		pr_warn("Primary GPT is invalid, using alternate GPT.\n");
+-                return 1;
+-        }
++		return 1;
++	}
+ 
+- fail:
+-        kfree(pgpt);
+-        kfree(agpt);
+-        kfree(pptes);
+-        kfree(aptes);
+-        *gpt = NULL;
+-        *ptes = NULL;
+-        return 0;
++fail:
++	kfree(pgpt);
++	kfree(agpt);
++	kfree(pptes);
++	kfree(aptes);
++	*gpt = NULL;
++	*ptes = NULL;
++	return 0;
+ }
+ 
+ /**
+@@ -725,7 +728,9 @@ int efi_partition(struct parsed_partitio
+ 
+ 	pr_debug("GUID Partition Table is valid!  Yea!\n");
+ 
+-	for (i = 0; i < le32_to_cpu(gpt->num_partition_entries) && i < state->limit-1; i++) {
++	for (i = 0; i < le32_to_cpu(gpt->num_partition_entries) &&
++		    i < state->limit - 1;
++	     i++) {
+ 		struct partition_meta_info *info;
+ 		unsigned label_max;
+ 		u64 start = le64_to_cpu(ptes[i].starting_lba);
+@@ -735,10 +740,11 @@ int efi_partition(struct parsed_partitio
+ 		if (!is_pte_valid(&ptes[i], last_lba(state->disk)))
+ 			continue;
+ 
+-		put_partition(state, i+1, start * ssz, size * ssz);
++		put_partition(state, i + 1, start * ssz, size * ssz);
+ 
+ 		/* If this is a RAID volume, tell md */
+-		if (!efi_guidcmp(ptes[i].partition_type_guid, PARTITION_LINUX_RAID_GUID))
++		if (!efi_guidcmp(ptes[i].partition_type_guid,
++				 PARTITION_LINUX_RAID_GUID))
+ 			state->parts[i + 1].flags = ADDPART_FLAG_RAID;
+ 
+ 		info = &state->parts[i + 1].info;
+@@ -747,7 +753,8 @@ int efi_partition(struct parsed_partitio
+ 		/* Naively convert UTF16-LE to 7 bits. */
+ 		label_max = min(ARRAY_SIZE(info->volname) - 1,
+ 				ARRAY_SIZE(ptes[i].partition_name));
+-		utf16_le_to_7bit(ptes[i].partition_name, label_max, info->volname);
++		utf16_le_to_7bit(ptes[i].partition_name, label_max,
++				 info->volname);
+ 		state->parts[i + 1].has_info = true;
+ 	}
+ 	kfree(ptes);
diff --git a/target/linux/generic/pending-6.12/453-partitions-efi-allow-assigning-partition-Device-Tree.patch b/target/linux/generic/pending-6.12/453-partitions-efi-allow-assigning-partition-Device-Tree.patch
new file mode 100644
index 0000000000..cc2c20338a
--- /dev/null
+++ b/target/linux/generic/pending-6.12/453-partitions-efi-allow-assigning-partition-Device-Tree.patch
@@ -0,0 +1,75 @@
+From f28e36c19b927671d93ccd2b5de3d518fccf721e Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Tue, 8 Oct 2024 00:25:12 +0100
+Subject: [PATCH 4/8] partitions/efi: allow assigning partition Device Tree
+ node
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ block/partitions/efi.c | 34 +++++++++++++++++++++++++++++++++-
+ 1 file changed, 33 insertions(+), 1 deletion(-)
+
+--- a/block/partitions/efi.c
++++ b/block/partitions/efi.c
+@@ -86,6 +86,7 @@
+ #include <linux/crc32.h>
+ #include <linux/ctype.h>
+ #include <linux/math64.h>
++#include <linux/of.h>
+ #include <linux/slab.h>
+ #include "check.h"
+ #include "efi.h"
+@@ -694,6 +695,34 @@ static void utf16_le_to_7bit(const __le1
+ 	}
+ }
+ 
++static struct device_node *find_partition_of_node(struct device_node *partitions_np,
++						  gpt_entry *ptes)
++{
++	char volname[64], partuuid[UUID_STRING_LEN + 1];
++	const char *uuid, *name;
++
++	if (!partitions_np ||
++	    !of_device_is_compatible(partitions_np, "gpt-partitions"))
++		return NULL;
++
++	efi_guid_to_str(&ptes->unique_partition_guid, partuuid);
++	utf16_le_to_7bit(ptes->partition_name, ARRAY_SIZE(volname) - 1, volname);
++
++	for_each_available_child_of_node_scoped(partitions_np, np) {
++		if (!of_property_read_string(np, "uuid", &uuid) &&
++		    strncmp(uuid, partuuid, ARRAY_SIZE(partuuid)))
++			continue;
++
++		if (!of_property_read_string(np, "partname", &name) &&
++		    strncmp(name, volname, ARRAY_SIZE(volname)))
++			continue;
++
++		return np;
++	}
++
++	return NULL;
++}
++
+ /**
+  * efi_partition - scan for GPT partitions
+  * @state: disk parsed partitions
+@@ -719,6 +748,8 @@ int efi_partition(struct parsed_partitio
+ 	gpt_entry *ptes = NULL;
+ 	u32 i;
+ 	unsigned ssz = queue_logical_block_size(state->disk->queue) / 512;
++	struct device *ddev = disk_to_dev(state->disk);
++	struct device_node *partitions_np = of_node_get(ddev->of_node);
+ 
+ 	if (!find_valid_gpt(state, &gpt, &ptes) || !gpt || !ptes) {
+ 		kfree(gpt);
+@@ -740,7 +771,8 @@ int efi_partition(struct parsed_partitio
+ 		if (!is_pte_valid(&ptes[i], last_lba(state->disk)))
+ 			continue;
+ 
+-		put_partition(state, i + 1, start * ssz, size * ssz);
++		of_put_partition(state, i + 1, start * ssz, size * ssz,
++				 find_partition_of_node(partitions_np, &ptes[i]));
+ 
+ 		/* If this is a RAID volume, tell md */
+ 		if (!efi_guidcmp(ptes[i].partition_type_guid,
diff --git a/target/linux/generic/pending-6.12/454-block-add-support-for-notifications.patch b/target/linux/generic/pending-6.12/454-block-add-support-for-notifications.patch
new file mode 100644
index 0000000000..300cbf7c7c
--- /dev/null
+++ b/target/linux/generic/pending-6.12/454-block-add-support-for-notifications.patch
@@ -0,0 +1,164 @@
+From 858df9db80c1568db255659baca7602504f823af Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Wed, 15 May 2024 08:19:51 +0100
+Subject: [PATCH 5/8] block: add support for notifications
+
+Add notifier block to notify other subsystems about the addition or
+removal of block devices.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ block/Kconfig          |   6 +++
+ block/Makefile         |   1 +
+ block/blk-notify.c     | 107 +++++++++++++++++++++++++++++++++++++++++
+ include/linux/blkdev.h |   8 +++
+ 4 files changed, 122 insertions(+)
+ create mode 100644 block/blk-notify.c
+
+--- a/block/Kconfig
++++ b/block/Kconfig
+@@ -209,6 +209,12 @@ config BLK_INLINE_ENCRYPTION_FALLBACK
+ 	  by falling back to the kernel crypto API when inline
+ 	  encryption hardware is not present.
+ 
++config BLOCK_NOTIFIERS
++	bool "Enable support for notifications in block layer"
++	help
++	  Enable this option to provide notifiers for other subsystems
++	  upon addition or removal of block devices.
++
+ source "block/partitions/Kconfig"
+ 
+ config BLK_MQ_PCI
+--- a/block/Makefile
++++ b/block/Makefile
+@@ -38,3 +38,4 @@ obj-$(CONFIG_BLK_INLINE_ENCRYPTION)	+= b
+ 					   blk-crypto-sysfs.o
+ obj-$(CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK)	+= blk-crypto-fallback.o
+ obj-$(CONFIG_BLOCK_HOLDER_DEPRECATED)	+= holder.o
++obj-$(CONFIG_BLOCK_NOTIFIERS) += blk-notify.o
+--- /dev/null
++++ b/block/blk-notify.c
+@@ -0,0 +1,107 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * Notifiers for addition and removal of block devices
++ *
++ * Copyright (c) 2024 Daniel Golle <daniel@makrotopia.org>
++ */
++
++#include <linux/list.h>
++#include <linux/mutex.h>
++#include <linux/notifier.h>
++#include <linux/workqueue.h>
++
++#include "blk.h"
++
++struct blk_device_list {
++	struct device *dev;
++	struct list_head list;
++};
++
++static RAW_NOTIFIER_HEAD(blk_notifier_list);
++static DEFINE_MUTEX(blk_notifier_lock);
++static LIST_HEAD(blk_devices);
++
++struct blk_notify_event {
++	struct delayed_work work;
++	struct device *dev;
++};
++
++void blk_register_notify(struct notifier_block *nb)
++{
++	struct blk_device_list *existing_blkdev;
++
++	mutex_lock(&blk_notifier_lock);
++	raw_notifier_chain_register(&blk_notifier_list, nb);
++
++	list_for_each_entry(existing_blkdev, &blk_devices, list)
++		nb->notifier_call(nb, BLK_DEVICE_ADD, existing_blkdev->dev);
++
++	mutex_unlock(&blk_notifier_lock);
++}
++EXPORT_SYMBOL_GPL(blk_register_notify);
++
++void blk_unregister_notify(struct notifier_block *nb)
++{
++	mutex_lock(&blk_notifier_lock);
++	raw_notifier_chain_unregister(&blk_notifier_list, nb);
++	mutex_unlock(&blk_notifier_lock);
++}
++EXPORT_SYMBOL_GPL(blk_unregister_notify);
++
++static void blk_notify_work(struct work_struct *work)
++{
++	struct blk_notify_event *ev =
++		container_of(work, struct blk_notify_event, work.work);
++
++	raw_notifier_call_chain(&blk_notifier_list, BLK_DEVICE_ADD, ev->dev);
++	kfree(ev);
++}
++
++static int blk_call_notifier_add(struct device *dev)
++{
++	struct blk_device_list *new_blkdev;
++	struct blk_notify_event *ev;
++
++	new_blkdev = kmalloc(sizeof (*new_blkdev), GFP_KERNEL);
++	if (!new_blkdev)
++		return -ENOMEM;
++
++	ev = kmalloc(sizeof(*ev), GFP_KERNEL);
++	INIT_DEFERRABLE_WORK(&ev->work, blk_notify_work);
++	ev->dev = dev;
++	new_blkdev->dev = dev;
++	mutex_lock(&blk_notifier_lock);
++	list_add_tail(&new_blkdev->list, &blk_devices);
++	schedule_delayed_work(&ev->work, msecs_to_jiffies(500));
++	mutex_unlock(&blk_notifier_lock);
++
++	return 0;
++}
++
++static void blk_call_notifier_remove(struct device *dev)
++{
++	struct blk_device_list *old_blkdev, *tmp;
++
++	mutex_lock(&blk_notifier_lock);
++	list_for_each_entry_safe(old_blkdev, tmp, &blk_devices, list) {
++		if (old_blkdev->dev != dev)
++			continue;
++
++		list_del(&old_blkdev->list);
++		kfree(old_blkdev);
++	}
++	raw_notifier_call_chain(&blk_notifier_list, BLK_DEVICE_REMOVE, dev);
++	mutex_unlock(&blk_notifier_lock);
++}
++
++static struct class_interface blk_notifications_bus_interface __refdata = {
++	.class = &block_class,
++	.add_dev = &blk_call_notifier_add,
++	.remove_dev = &blk_call_notifier_remove,
++};
++
++static int __init blk_notifications_init(void)
++{
++	return class_interface_register(&blk_notifications_bus_interface);
++}
++device_initcall(blk_notifications_init);
+--- a/include/linux/blkdev.h
++++ b/include/linux/blkdev.h
+@@ -1696,4 +1696,12 @@ static inline bool bdev_can_atomic_write
+ 
+ #define DEFINE_IO_COMP_BATCH(name)	struct io_comp_batch name = { }
+ 
++
++#ifdef CONFIG_BLOCK_NOTIFIERS
++#define BLK_DEVICE_ADD		1
++#define BLK_DEVICE_REMOVE	2
++extern void blk_register_notify(struct notifier_block *nb);
++extern void blk_unregister_notify(struct notifier_block *nb);
++#endif
++
+ #endif /* _LINUX_BLKDEV_H */
diff --git a/target/linux/generic/pending-6.12/455-block-add-new-genhd-flag-GENHD_FL_NVMEM.patch b/target/linux/generic/pending-6.12/455-block-add-new-genhd-flag-GENHD_FL_NVMEM.patch
new file mode 100644
index 0000000000..4f9a26fd16
--- /dev/null
+++ b/target/linux/generic/pending-6.12/455-block-add-new-genhd-flag-GENHD_FL_NVMEM.patch
@@ -0,0 +1,29 @@
+From 2b28bf485b283991eea9f00c5831c1c39c73991f Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 21 Mar 2024 19:33:49 +0000
+Subject: [PATCH 6/8] block: add new genhd flag GENHD_FL_NVMEM
+
+Add new flag to destinguish block devices which may act as an NVMEM
+provider.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ include/linux/blkdev.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/include/linux/blkdev.h
++++ b/include/linux/blkdev.h
+@@ -82,11 +82,13 @@ struct partition_meta_info {
+  * ``GENHD_FL_NO_PART``: partition support is disabled.  The kernel will not
+  * scan for partitions from add_disk, and users can't add partitions manually.
+  *
++ * ``GENHD_FL_NVMEM``: the block device should be considered as NVMEM provider.
+  */
+ enum {
+ 	GENHD_FL_REMOVABLE			= 1 << 0,
+ 	GENHD_FL_HIDDEN				= 1 << 1,
+ 	GENHD_FL_NO_PART			= 1 << 2,
++	GENHD_FL_NVMEM				= 1 << 3,
+ };
+ 
+ enum {
diff --git a/target/linux/generic/pending-6.12/456-nvmem-implement-block-NVMEM-provider.patch b/target/linux/generic/pending-6.12/456-nvmem-implement-block-NVMEM-provider.patch
new file mode 100644
index 0000000000..563b9f1259
--- /dev/null
+++ b/target/linux/generic/pending-6.12/456-nvmem-implement-block-NVMEM-provider.patch
@@ -0,0 +1,250 @@
+From 26ae98bf77fdbd60536fe5c2175e528469b9ac9a Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Wed, 15 May 2024 18:18:37 +0300
+Subject: [PATCH 7/8] nvmem: implement block NVMEM provider
+
+On embedded devices using an eMMC it is common that one or more partitions
+on the eMMC are used to store MAC addresses and Wi-Fi calibration EEPROM
+data. Allow referencing any block device or partition in Device Tree to
+allow e.g. Ethernet and Wi-Fi drivers accessing them via the NVMEM layer.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/nvmem/Kconfig  |  11 +++
+ drivers/nvmem/Makefile |   2 +
+ drivers/nvmem/block.c  | 198 +++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 211 insertions(+)
+ create mode 100644 drivers/nvmem/block.c
+
+--- a/drivers/nvmem/Kconfig
++++ b/drivers/nvmem/Kconfig
+@@ -40,6 +40,17 @@ config NVMEM_APPLE_EFUSES
+ 	  This driver can also be built as a module. If so, the module will
+ 	  be called nvmem-apple-efuses.
+ 
++config NVMEM_BLOCK
++	tristate "Block device NVMEM provider"
++	depends on BLOCK
++	depends on OF
++	depends on NVMEM
++	select BLOCK_NOTIFIERS
++	help
++	  Allow block devices (or partitions) to act as NVMEM prodivers,
++	  typically used with eMMC to store MAC addresses or Wi-Fi
++	  calibration data on embedded devices.
++
+ config NVMEM_BCM_OCOTP
+ 	tristate "Broadcom On-Chip OTP Controller support"
+ 	depends on ARCH_BCM_IPROC || COMPILE_TEST
+--- a/drivers/nvmem/Makefile
++++ b/drivers/nvmem/Makefile
+@@ -14,6 +14,8 @@ obj-$(CONFIG_NVMEM_APPLE_EFUSES)	+= nvme
+ nvmem-apple-efuses-y 			:= apple-efuses.o
+ obj-$(CONFIG_NVMEM_BCM_OCOTP)		+= nvmem-bcm-ocotp.o
+ nvmem-bcm-ocotp-y			:= bcm-ocotp.o
++obj-$(CONFIG_NVMEM_BLOCK)		+= nvmem-block.o
++nvmem-block-y				:= block.o
+ obj-$(CONFIG_NVMEM_BRCM_NVRAM)		+= nvmem_brcm_nvram.o
+ nvmem_brcm_nvram-y			:= brcm_nvram.o
+ obj-$(CONFIG_NVMEM_IMX_IIM)		+= nvmem-imx-iim.o
+--- /dev/null
++++ b/drivers/nvmem/block.c
+@@ -0,0 +1,198 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * block device NVMEM provider
++ *
++ * Copyright (c) 2024 Daniel Golle <daniel@makrotopia.org>
++ *
++ * Useful on devices using a partition on an eMMC for MAC addresses or
++ * Wi-Fi calibration EEPROM data.
++ */
++
++#include <linux/blkdev.h>
++#include <linux/nvmem-provider.h>
++#include <linux/of.h>
++#include <linux/pagemap.h>
++#include <linux/property.h>
++
++/* List of all NVMEM devices */
++static LIST_HEAD(nvmem_devices);
++static DEFINE_MUTEX(devices_mutex);
++
++struct blk_nvmem {
++	struct nvmem_device	*nvmem;
++	struct device		*dev;
++	struct list_head	list;
++};
++
++static int blk_nvmem_reg_read(void *priv, unsigned int from,
++			      void *val, size_t bytes)
++{
++	blk_mode_t mode = BLK_OPEN_READ | BLK_OPEN_RESTRICT_WRITES;
++	unsigned long offs = from & ~PAGE_MASK, to_read;
++	pgoff_t f_index = from >> PAGE_SHIFT;
++	struct blk_nvmem *bnv = priv;
++	size_t bytes_left = bytes;
++	struct file *bdev_file;
++	struct folio *folio;
++	void *p;
++	int ret = 0;
++
++	bdev_file = bdev_file_open_by_dev(bnv->dev->devt, mode, priv, NULL);
++	if (!bdev_file)
++		return -ENODEV;
++
++	if (IS_ERR(bdev_file))
++		return PTR_ERR(bdev_file);
++
++	while (bytes_left) {
++		folio = read_mapping_folio(bdev_file->f_mapping, f_index++, NULL);
++		if (IS_ERR(folio)) {
++			ret = PTR_ERR(folio);
++			goto err_release_bdev;
++		}
++		to_read = min_t(unsigned long, bytes_left, PAGE_SIZE - offs);
++		p = folio_address(folio) + offset_in_folio(folio, offs);
++		memcpy(val, p, to_read);
++		offs = 0;
++		bytes_left -= to_read;
++		val += to_read;
++		folio_put(folio);
++	}
++
++err_release_bdev:
++	fput(bdev_file);
++
++	return ret;
++}
++
++static int blk_nvmem_register(struct device *dev)
++{
++	struct block_device *bdev = dev_to_bdev(dev);
++	struct device_node *np = dev_of_node(dev);
++	struct nvmem_config config = {};
++	struct blk_nvmem *bnv;
++
++	/* skip devices which do not have a device tree node */
++	if (!np)
++		return 0;
++
++	/* skip devices without an nvmem layout defined */
++	if (!of_get_child_by_name(np, "nvmem-layout"))
++		return 0;
++
++	/*
++	 * skip devices which don't have GENHD_FL_NVMEM set
++	 *
++	 * This flag is used for mtdblock and ubiblock devices because
++	 * both, MTD and UBI already implement their own NVMEM provider.
++	 * To avoid registering multiple NVMEM providers for the same
++	 * device node, don't register the block NVMEM provider for them.
++	 */
++	if (!(bdev->bd_disk->flags & GENHD_FL_NVMEM))
++		return 0;
++
++	/*
++	 * skip block device too large to be represented as NVMEM devices
++	 * which are using an 'int' as address
++	 */
++	if (bdev_nr_bytes(bdev) > INT_MAX)
++		return -EFBIG;
++
++	bnv = kzalloc(sizeof(struct blk_nvmem), GFP_KERNEL);
++	if (!bnv)
++		return -ENOMEM;
++
++	config.id = NVMEM_DEVID_NONE;
++	config.dev = &bdev->bd_device;
++	config.name = dev_name(&bdev->bd_device);
++	config.owner = THIS_MODULE;
++	config.priv = bnv;
++	config.reg_read = blk_nvmem_reg_read;
++	config.size = bdev_nr_bytes(bdev);
++	config.word_size = 1;
++	config.stride = 1;
++	config.read_only = true;
++	config.root_only = true;
++	config.ignore_wp = true;
++	config.of_node = to_of_node(dev->fwnode);
++
++	bnv->dev = &bdev->bd_device;
++	bnv->nvmem = nvmem_register(&config);
++	if (IS_ERR(bnv->nvmem)) {
++		dev_err_probe(&bdev->bd_device, PTR_ERR(bnv->nvmem),
++			      "Failed to register NVMEM device\n");
++
++		kfree(bnv);
++		return PTR_ERR(bnv->nvmem);
++	}
++
++	mutex_lock(&devices_mutex);
++	list_add_tail(&bnv->list, &nvmem_devices);
++	mutex_unlock(&devices_mutex);
++
++	return 0;
++}
++
++static void blk_nvmem_unregister(struct device *dev)
++{
++	struct blk_nvmem *bnv_c, *bnv = NULL;
++
++	mutex_lock(&devices_mutex);
++	list_for_each_entry(bnv_c, &nvmem_devices, list) {
++		if (bnv_c->dev == dev) {
++			bnv = bnv_c;
++			break;
++		}
++	}
++
++	if (!bnv) {
++		mutex_unlock(&devices_mutex);
++		return;
++	}
++
++	list_del(&bnv->list);
++	mutex_unlock(&devices_mutex);
++	nvmem_unregister(bnv->nvmem);
++	kfree(bnv);
++}
++
++static int blk_nvmem_handler(struct notifier_block *this, unsigned long code, void *obj)
++{
++	struct device *dev = (struct device *)obj;
++
++	switch (code) {
++	case BLK_DEVICE_ADD:
++		return blk_nvmem_register(dev);
++		break;
++	case BLK_DEVICE_REMOVE:
++		blk_nvmem_unregister(dev);
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static struct notifier_block blk_nvmem_notifier = {
++	.notifier_call = blk_nvmem_handler,
++};
++
++static int __init blk_nvmem_init(void)
++{
++	blk_register_notify(&blk_nvmem_notifier);
++
++	return 0;
++}
++
++static void __exit blk_nvmem_exit(void)
++{
++	blk_unregister_notify(&blk_nvmem_notifier);
++}
++
++module_init(blk_nvmem_init);
++module_exit(blk_nvmem_exit);
++
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Daniel Golle <daniel@makrotopia.org>");
++MODULE_DESCRIPTION("block device NVMEM provider");
diff --git a/target/linux/generic/pending-6.12/457-mmc-block-set-GENHD_FL_NVMEM.patch b/target/linux/generic/pending-6.12/457-mmc-block-set-GENHD_FL_NVMEM.patch
new file mode 100644
index 0000000000..955fa6676e
--- /dev/null
+++ b/target/linux/generic/pending-6.12/457-mmc-block-set-GENHD_FL_NVMEM.patch
@@ -0,0 +1,22 @@
+From caac69565748349a3e532130a891e18dd5c36c5e Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 20 Jul 2023 17:36:44 +0100
+Subject: [PATCH 8/8] mmc: block: set GENHD_FL_NVMEM
+
+Set flag to consider MMC block devices as NVMEM providers.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/mmc/core/block.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/mmc/core/block.c
++++ b/drivers/mmc/core/block.c
+@@ -2644,6 +2644,7 @@ static struct mmc_blk_data *mmc_blk_allo
+ 	md->disk->major	= MMC_BLOCK_MAJOR;
+ 	md->disk->minors = perdev_minors;
+ 	md->disk->first_minor = devidx * perdev_minors;
++	md->disk->flags = GENHD_FL_NVMEM;
+ 	md->disk->fops = &mmc_bdops;
+ 	md->disk->private_data = md;
+ 	md->parent = parent;
diff --git a/target/linux/generic/pending-6.12/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch b/target/linux/generic/pending-6.12/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch
new file mode 100644
index 0000000000..2435133fa0
--- /dev/null
+++ b/target/linux/generic/pending-6.12/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch
@@ -0,0 +1,25 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: kernel: disable cfi cmdset 0002 erase suspend
+
+on some platforms, erase suspend leads to data corruption and lockups when write
+ops collide with erase ops. this has been observed on the buffalo wzr-hp-g300nh.
+rather than play whack-a-mole with a hard to reproduce issue on a variety of devices,
+simply disable erase suspend, as it will usually not produce any useful gain on
+the small filesystems used on embedded hardware.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/mtd/chips/cfi_cmdset_0002.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -906,7 +906,7 @@ static int get_chip(struct map_info *map
+ 		return 0;
+ 
+ 	case FL_ERASING:
+-		if (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
++		if (1 /* no suspend */ || !cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
+ 		    !(mode == FL_READY || mode == FL_POINT ||
+ 		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
+ 			goto sleep;
diff --git a/target/linux/generic/pending-6.12/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch b/target/linux/generic/pending-6.12/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch
new file mode 100644
index 0000000000..059d9673dc
--- /dev/null
+++ b/target/linux/generic/pending-6.12/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch
@@ -0,0 +1,17 @@
+From: George Kashperko <george@znau.edu.ua>
+Subject: Issue map read after Write Buffer Load command to ensure chip is ready to receive data.
+
+Signed-off-by: George Kashperko <george@znau.edu.ua>
+---
+ drivers/mtd/chips/cfi_cmdset_0002.c |    1 +
+ 1 file changed, 1 insertion(+)
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -2050,6 +2050,7 @@ static int __xipram do_write_buffer(stru
+ 
+ 	/* Write Buffer Load */
+ 	map_write(map, CMD(0x25), cmd_adr);
++	(void) map_read(map, cmd_adr);
+ 
+ 	chip->state = FL_WRITING_TO_BUFFER;
+ 
diff --git a/target/linux/generic/pending-6.12/465-m25p80-mx-disable-software-protection.patch b/target/linux/generic/pending-6.12/465-m25p80-mx-disable-software-protection.patch
new file mode 100644
index 0000000000..5667e273f1
--- /dev/null
+++ b/target/linux/generic/pending-6.12/465-m25p80-mx-disable-software-protection.patch
@@ -0,0 +1,18 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: Disable software protection bits for Macronix flashes.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/mtd/spi-nor/spi-nor.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/mtd/spi-nor/macronix.c
++++ b/drivers/mtd/spi-nor/macronix.c
+@@ -194,6 +194,7 @@ static int macronix_nor_late_init(struct
+ {
+ 	if (!nor->params->set_4byte_addr_mode)
+ 		nor->params->set_4byte_addr_mode = spi_nor_set_4byte_addr_mode_en4b_ex4b;
++	nor->flags |= SNOR_F_HAS_LOCK;
+ 
+ 	return 0;
+ }
diff --git a/target/linux/generic/pending-6.12/476-mtd-spi-nor-add-eon-en25q128.patch b/target/linux/generic/pending-6.12/476-mtd-spi-nor-add-eon-en25q128.patch
new file mode 100644
index 0000000000..afc5e48981
--- /dev/null
+++ b/target/linux/generic/pending-6.12/476-mtd-spi-nor-add-eon-en25q128.patch
@@ -0,0 +1,22 @@
+From: Piotr Dymacz <pepe2k@gmail.com>
+Subject: kernel/mtd: add support for EON EN25Q128
+
+Signed-off-by: Piotr Dymacz <pepe2k@gmail.com>
+---
+ drivers/mtd/spi-nor/spi-nor.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/mtd/spi-nor/eon.c
++++ b/drivers/mtd/spi-nor/eon.c
+@@ -18,6 +18,11 @@ static const struct flash_info eon_nor_p
+ 		.name = "en25p64",
+ 		.size = SZ_8M,
+ 	}, {
++		.id = SNOR_ID(0x1c, 0x30, 0x18),
++		.name = "en25q128",
++		.size = SZ_16M,
++		.no_sfdp_flags = SECT_4K,
++	}, {
+ 		.id = SNOR_ID(0x1c, 0x30, 0x14),
+ 		.name = "en25q80a",
+ 		.size = SZ_1M,
diff --git a/target/linux/generic/pending-6.12/477-mtd-spi-nor-add-eon-en25qx128a.patch b/target/linux/generic/pending-6.12/477-mtd-spi-nor-add-eon-en25qx128a.patch
new file mode 100644
index 0000000000..4dd229bde9
--- /dev/null
+++ b/target/linux/generic/pending-6.12/477-mtd-spi-nor-add-eon-en25qx128a.patch
@@ -0,0 +1,24 @@
+From: Christian Marangi <ansuelsmth@gmail.com>
+Subject: kernel/mtd: add support for EON EN25QX128A
+
+Add support for EON EN25QX128A with no flags as it does
+support SFDP parsing.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ drivers/mtd/spi-nor/spi-nor.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/mtd/spi-nor/eon.c
++++ b/drivers/mtd/spi-nor/eon.c
+@@ -23,6 +23,10 @@ static const struct flash_info eon_nor_p
+ 		.size = SZ_16M,
+ 		.no_sfdp_flags = SECT_4K,
+ 	}, {
++		.id = SNOR_ID(0x1c, 0x71, 0x18),
++		.name = "en25qx128a",
++		.size = SZ_16M,
++	}, {
+ 		.id = SNOR_ID(0x1c, 0x30, 0x14),
+ 		.name = "en25q80a",
+ 		.size = SZ_1M,
diff --git a/target/linux/generic/pending-6.12/479-mtd-spi-nor-add-xtx-xt25f128b.patch b/target/linux/generic/pending-6.12/479-mtd-spi-nor-add-xtx-xt25f128b.patch
new file mode 100644
index 0000000000..be8bafa76a
--- /dev/null
+++ b/target/linux/generic/pending-6.12/479-mtd-spi-nor-add-xtx-xt25f128b.patch
@@ -0,0 +1,84 @@
+From patchwork Thu Feb  6 17:19:41 2020
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 1234465
+Date: Thu, 6 Feb 2020 19:19:41 +0200
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-mtd@lists.infradead.org
+Subject: [PATCH v2] mtd: spi-nor: Add support for xt25f128b chip
+Message-ID: <20200206171941.GA2398@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+List-Subscribe: <http://lists.infradead.org/mailman/listinfo/linux-mtd>,
+ <mailto:linux-mtd-request@lists.infradead.org?subject=subscribe>
+Cc: Eitan Cohen <eitan@neot-semadar.com>, Piotr Dymacz <pepe2k@gmail.com>,
+ Tudor Ambarus <tudor.ambarus@microchip.com>
+Sender: "linux-mtd" <linux-mtd-bounces@lists.infradead.org>
+Errors-To: linux-mtd-bounces+incoming=patchwork.ozlabs.org@lists.infradead.org
+
+Add XT25F128B made by XTX Technology (Shenzhen) Limited.
+This chip supports dual and quad read and uniform 4K-byte erase.
+Verified on Teltonika RUT955 which comes with XT25F128B in recent
+versions of the device.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/mtd/spi-nor/spi-nor.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/mtd/spi-nor/Makefile
++++ b/drivers/mtd/spi-nor/Makefile
+@@ -14,6 +14,7 @@ spi-nor-objs			+= spansion.o
+ spi-nor-objs			+= sst.o
+ spi-nor-objs			+= winbond.o
+ spi-nor-objs			+= xmc.o
++spi-nor-objs			+= xtx.o
+ spi-nor-$(CONFIG_DEBUG_FS)	+= debugfs.o
+ obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor.o
+ 
+--- /dev/null
++++ b/drivers/mtd/spi-nor/xtx.c
+@@ -0,0 +1,20 @@
++// SPDX-License-Identifier: GPL-2.0
++#include <linux/mtd/spi-nor.h>
++
++#include "core.h"
++
++static const struct flash_info xtx_parts[] = {
++	/* XTX Technology (Shenzhen) Limited */
++	{
++		.id = SNOR_ID(0x0B, 0x40, 0x18),
++		.name = "xt25f128b",
++		.size = SZ_16M,
++		.no_sfdp_flags = SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ,
++	},
++};
++
++const struct spi_nor_manufacturer spi_nor_xtx = {
++	.name = "xtx",
++	.parts = xtx_parts,
++	.nparts = ARRAY_SIZE(xtx_parts),
++};
+--- a/drivers/mtd/spi-nor/core.c
++++ b/drivers/mtd/spi-nor/core.c
+@@ -1979,6 +1979,7 @@ static const struct spi_nor_manufacturer
+ 	&spi_nor_sst,
+ 	&spi_nor_winbond,
+ 	&spi_nor_xmc,
++	&spi_nor_xtx,
+ };
+ 
+ static const struct flash_info spi_nor_generic_flash = {
+--- a/drivers/mtd/spi-nor/core.h
++++ b/drivers/mtd/spi-nor/core.h
+@@ -593,6 +593,7 @@ extern const struct spi_nor_manufacturer
+ extern const struct spi_nor_manufacturer spi_nor_sst;
+ extern const struct spi_nor_manufacturer spi_nor_winbond;
+ extern const struct spi_nor_manufacturer spi_nor_xmc;
++extern const struct spi_nor_manufacturer spi_nor_xtx;
+ 
+ extern const struct attribute_group *spi_nor_sysfs_groups[];
+ 
diff --git a/target/linux/generic/pending-6.12/481-mtd-spi-nor-add-support-for-Gigadevice-GD25D05.patch b/target/linux/generic/pending-6.12/481-mtd-spi-nor-add-support-for-Gigadevice-GD25D05.patch
new file mode 100644
index 0000000000..c4caf732ab
--- /dev/null
+++ b/target/linux/generic/pending-6.12/481-mtd-spi-nor-add-support-for-Gigadevice-GD25D05.patch
@@ -0,0 +1,25 @@
+From d68b4aa22e8c625685bfad642dd7337948dc0ad1 Mon Sep 17 00:00:00 2001
+From: Koen Vandeputte <koen.vandeputte@ncentric.com>
+Date: Mon, 6 Jan 2020 13:07:56 +0100
+Subject: [PATCH] mtd: spi-nor: add support for Gigadevice GD25D05
+
+Signed-off-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
+---
+ drivers/mtd/spi-nor/spi-nor.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/mtd/spi-nor/gigadevice.c
++++ b/drivers/mtd/spi-nor/gigadevice.c
+@@ -35,6 +35,12 @@ static const struct spi_nor_fixups gd25q
+ 
+ static const struct flash_info gigadevice_nor_parts[] = {
+ 	{
++		.id = SNOR_ID(0xc8, 0x40, 0x10),
++		.name = "gd25q05",
++		.size = SZ_64K,
++		.flags = SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB,
++		.no_sfdp_flags = SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ,
++	}, {
+ 		.id = SNOR_ID(0xc8, 0x40, 0x15),
+ 		.name = "gd25q16",
+ 		.size = SZ_2M,
diff --git a/target/linux/generic/pending-6.12/482-mtd-spi-nor-add-gd25q512.patch b/target/linux/generic/pending-6.12/482-mtd-spi-nor-add-gd25q512.patch
new file mode 100644
index 0000000000..2b34d145ee
--- /dev/null
+++ b/target/linux/generic/pending-6.12/482-mtd-spi-nor-add-gd25q512.patch
@@ -0,0 +1,25 @@
+From f8943df3beb0d3f9754bb35320c3a378727175a8 Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Thu, 14 Jul 2022 08:38:07 +0200
+Subject: [PATCH] spi-nor/gigadevic: add gd25q512
+
+---
+ drivers/mtd/spi-nor/gigadevice.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/mtd/spi-nor/gigadevice.c
++++ b/drivers/mtd/spi-nor/gigadevice.c
+@@ -71,6 +71,13 @@ static const struct flash_info gigadevic
+ 		.fixups = &gd25q256_fixups,
+ 		.fixup_flags = SPI_NOR_4B_OPCODES,
+ 	}, {
++		.id = SNOR_ID(0xc8, 0x40, 0x20),
++		.name = "gd25q512",
++		.size = SZ_64M,
++		.flags = SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB,
++		.no_sfdp_flags = SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ,
++		.fixup_flags = SPI_NOR_4B_OPCODES,
++	}, {
+ 		.id = SNOR_ID(0xc8, 0x60, 0x16),
+ 		.name = "gd25lq32",
+ 		.size = SZ_4M,
diff --git a/target/linux/generic/pending-6.12/484-mtd-spi-nor-add-esmt-f25l16pa.patch b/target/linux/generic/pending-6.12/484-mtd-spi-nor-add-esmt-f25l16pa.patch
new file mode 100644
index 0000000000..1e296eedce
--- /dev/null
+++ b/target/linux/generic/pending-6.12/484-mtd-spi-nor-add-esmt-f25l16pa.patch
@@ -0,0 +1,27 @@
+From 87363cc0e522de3294ea6ae10fb468d2a8d6fb2f Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 12:17:21 +0200
+Subject: [PATCH] spi-nor/esmt.c: add esmt f25l16pa
+
+This fixes support for Dongwon T&I DW02-412H which uses F25L16PA(2S)
+flash.
+
+---
+ drivers/mtd/spi-nor/esmt.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/mtd/spi-nor/esmt.c
++++ b/drivers/mtd/spi-nor/esmt.c
+@@ -10,6 +10,12 @@
+ 
+ static const struct flash_info esmt_nor_parts[] = {
+ 	{
++		.id = SNOR_ID(0x8c, 0x21, 0x15),
++		.name = "f25l16pa-2s",
++		.size = SZ_2M,
++		.flags = SPI_NOR_HAS_LOCK,
++		.no_sfdp_flags = SECT_4K,
++	}, {
+ 		.id = SNOR_ID(0x8c, 0x20, 0x16),
+ 		.name = "f25l32pa",
+ 		.size = SZ_4M,
diff --git a/target/linux/generic/pending-6.12/485-mtd-spi-nor-add-xmc-xm25qh128c.patch b/target/linux/generic/pending-6.12/485-mtd-spi-nor-add-xmc-xm25qh128c.patch
new file mode 100644
index 0000000000..886d755816
--- /dev/null
+++ b/target/linux/generic/pending-6.12/485-mtd-spi-nor-add-xmc-xm25qh128c.patch
@@ -0,0 +1,27 @@
+From f6b33d850f7f12555df2fa0e3349b33427bf5890 Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 12:19:01 +0200
+Subject: [PATCH] spi-nor/xmc.c: add xm25qh128c
+
+The XMC XM25QH128C is a 16MB SPI NOR chip. The patch is verified on
+Ruijie RG-EW3200GX PRO.
+Datasheet available at https://www.xmcwh.com/uploads/435/XM25QH128C.pdf
+
+---
+ drivers/mtd/spi-nor/xmc.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/mtd/spi-nor/xmc.c
++++ b/drivers/mtd/spi-nor/xmc.c
+@@ -19,6 +19,11 @@ static const struct flash_info xmc_nor_p
+ 		.name = "XM25QH128A",
+ 		.size = SZ_16M,
+ 		.no_sfdp_flags = SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ,
++	}, {
++		.id = SNOR_ID(0x20, 0x40, 0x18),
++		.name = "XM25QH128C",
++		.size = SZ_16M,
++		.no_sfdp_flags = SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ,
+ 	},
+ };
+ 
diff --git a/target/linux/generic/pending-6.12/487-mtd-spinand-Add-support-for-Etron-EM73D044VCx.patch b/target/linux/generic/pending-6.12/487-mtd-spinand-Add-support-for-Etron-EM73D044VCx.patch
new file mode 100644
index 0000000000..0eb45822e2
--- /dev/null
+++ b/target/linux/generic/pending-6.12/487-mtd-spinand-Add-support-for-Etron-EM73D044VCx.patch
@@ -0,0 +1,170 @@
+From f32085fc0b87049491b07e198d924d738a1a2834 Mon Sep 17 00:00:00 2001
+From: Daniel Danzberger <daniel@dd-wrt.com>
+Date: Wed, 3 Aug 2022 17:31:03 +0200
+Subject: [PATCH] mtd: spinand: Add support for Etron EM73D044VCx
+
+Airoha is a new ARM platform based on Cortex-A53 which has recently been
+merged into linux-next.
+
+Due to BootROM limitations on this platform, the Cortex-A53 can't run in
+Aarch64 mode and code must be compiled for 32-Bit ARM.
+
+This support is based mostly on those linux-next commits backported
+for kernel 5.15.
+
+Patches:
+1 - platform support = linux-next
+2 - clock driver = linux-next
+3 - gpio driver = linux-next
+4 - linux,usable-memory-range dts support = linux-next
+5 - mtd spinand driver
+6 - spi driver
+7 - pci driver (kconfig only, uses mediatek PCI) = linux-next
+
+Still missing:
+- Ethernet driver
+- Sysupgrade support
+
+A.t.m there exists one subtarget EN7523 with only one evaluation
+board.
+
+The initramfs can be run with the following commands from u-boot:
+-
+u-boot> setenv bootfile \
+	openwrt-airoha-airoha_en7523-evb-initramfs-kernel.bin
+u-boot> tftpboot
+u-boot> bootm 0x81800000
+-
+
+Submitted-by: Daniel Danzberger <daniel@dd-wrt.com>
+
+--- a/drivers/mtd/nand/spi/Makefile
++++ b/drivers/mtd/nand/spi/Makefile
+@@ -1,4 +1,4 @@
+ # SPDX-License-Identifier: GPL-2.0
+-spinand-objs := core.o alliancememory.o ato.o esmt.o foresee.o gigadevice.o macronix.o
+-spinand-objs += micron.o paragon.o toshiba.o winbond.o xtx.o
++spinand-objs := core.o alliancememory.o ato.o esmt.o etron.o foresee.o gigadevice.o
++spinand-objs += macronix.o micron.o paragon.o toshiba.o winbond.o xtx.o
+ obj-$(CONFIG_MTD_SPI_NAND) += spinand.o
+--- a/drivers/mtd/nand/spi/core.c
++++ b/drivers/mtd/nand/spi/core.c
+@@ -1112,6 +1112,7 @@ static const struct spinand_manufacturer
+ 	&alliancememory_spinand_manufacturer,
+ 	&ato_spinand_manufacturer,
+ 	&esmt_c8_spinand_manufacturer,
++	&etron_spinand_manufacturer,
+ 	&foresee_spinand_manufacturer,
+ 	&gigadevice_spinand_manufacturer,
+ 	&macronix_spinand_manufacturer,
+--- /dev/null
++++ b/drivers/mtd/nand/spi/etron.c
+@@ -0,0 +1,98 @@
++// SPDX-License-Identifier: GPL-2.0
++
++#include <linux/device.h>
++#include <linux/kernel.h>
++#include <linux/mtd/spinand.h>
++
++#define SPINAND_MFR_ETRON			0xd5
++
++
++static SPINAND_OP_VARIANTS(read_cache_variants,
++		SPINAND_PAGE_READ_FROM_CACHE_QUADIO_OP(0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_X4_OP(0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_DUALIO_OP(0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_X2_OP(0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_OP(true, 0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_OP(false, 0, 1, NULL, 0));
++
++static SPINAND_OP_VARIANTS(write_cache_variants,
++		SPINAND_PROG_LOAD_X4(true, 0, NULL, 0),
++		SPINAND_PROG_LOAD(true, 0, NULL, 0));
++
++static SPINAND_OP_VARIANTS(update_cache_variants,
++		SPINAND_PROG_LOAD_X4(false, 0, NULL, 0),
++		SPINAND_PROG_LOAD(false, 0, NULL, 0));
++
++static int etron_ooblayout_ecc(struct mtd_info *mtd, int section,
++					struct mtd_oob_region *oobregion)
++{
++	if (section)
++		return -ERANGE;
++
++	oobregion->offset = 72;
++	oobregion->length = 56;
++
++	return 0;
++}
++
++static int etron_ooblayout_free(struct mtd_info *mtd, int section,
++			   struct mtd_oob_region *oobregion)
++{
++	if (section)
++		return -ERANGE;
++
++	oobregion->offset = 1;
++	oobregion->length = 71;
++
++	return 0;
++}
++
++static int etron_ecc_get_status(struct spinand_device *spinand, u8 status)
++{
++	switch (status & STATUS_ECC_MASK) {
++	case STATUS_ECC_NO_BITFLIPS:
++		return 0;
++
++	case STATUS_ECC_HAS_BITFLIPS:
++		/* Between 1-7 bitflips were corrected */
++		return 7;
++
++	case STATUS_ECC_MASK:
++		/* Maximum bitflips were corrected */
++		return 8;
++
++	case STATUS_ECC_UNCOR_ERROR:
++		return -EBADMSG;
++	}
++
++	return -EINVAL;
++}
++
++static const struct mtd_ooblayout_ops etron_ooblayout = {
++	.ecc = etron_ooblayout_ecc,
++	.free = etron_ooblayout_free,
++};
++
++static const struct spinand_info etron_spinand_table[] = {
++	SPINAND_INFO("EM73D044VCx",
++		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_ADDR, 0x1f),
++		     // bpc, pagesize, oobsize, pagesperblock, bperlun, maxbadplun, ppl, lpt, #t
++		     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 1, 1),
++		     NAND_ECCREQ(8, 512),
++		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
++					      &write_cache_variants,
++					      &update_cache_variants),
++		     SPINAND_HAS_QE_BIT,
++		     SPINAND_ECCINFO(&etron_ooblayout, etron_ecc_get_status)),
++};
++
++static const struct spinand_manufacturer_ops etron_spinand_manuf_ops = {
++};
++
++const struct spinand_manufacturer etron_spinand_manufacturer = {
++	.id = SPINAND_MFR_ETRON,
++	.name = "Etron",
++	.chips = etron_spinand_table,
++	.nchips = ARRAY_SIZE(etron_spinand_table),
++	.ops = &etron_spinand_manuf_ops,
++};
+--- a/include/linux/mtd/spinand.h
++++ b/include/linux/mtd/spinand.h
+@@ -263,6 +263,7 @@ struct spinand_manufacturer {
+ extern const struct spinand_manufacturer alliancememory_spinand_manufacturer;
+ extern const struct spinand_manufacturer ato_spinand_manufacturer;
+ extern const struct spinand_manufacturer esmt_c8_spinand_manufacturer;
++extern const struct spinand_manufacturer etron_spinand_manufacturer;
+ extern const struct spinand_manufacturer foresee_spinand_manufacturer;
+ extern const struct spinand_manufacturer gigadevice_spinand_manufacturer;
+ extern const struct spinand_manufacturer macronix_spinand_manufacturer;
diff --git a/target/linux/generic/pending-6.12/488-mtd-spi-nor-add-xmc-xm25qh64c.patch b/target/linux/generic/pending-6.12/488-mtd-spi-nor-add-xmc-xm25qh64c.patch
new file mode 100644
index 0000000000..6e65c55b21
--- /dev/null
+++ b/target/linux/generic/pending-6.12/488-mtd-spi-nor-add-xmc-xm25qh64c.patch
@@ -0,0 +1,25 @@
+From: Joe Mullally <jwmullally@gmail.com>
+Subject: mtd/spi-nor/xmc: add support for XMC XM25QH64C
+
+The XMC XM25QH64C is a 8MB SPI NOR chip. The patch is verified on TL-WPA8631P v3.
+Datasheet available at https://www.xmcwh.com/uploads/442/XM25QH64C.pdf
+
+Signed-off-by: Joe Mullally <jwmullally@gmail.com>
+---
+ drivers/mtd/spi-nor/xmc.c                             | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/mtd/spi-nor/xmc.c
++++ b/drivers/mtd/spi-nor/xmc.c
+@@ -15,6 +15,11 @@ static const struct flash_info xmc_nor_p
+ 		.size = SZ_8M,
+ 		.no_sfdp_flags = SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ,
+ 	}, {
++		.id = SNOR_ID(0x20, 0x40, 0x17),
++		.name = "XM25QH64C",
++		.size = SZ_8M,
++		.no_sfdp_flags = SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ,
++	}, {
+ 		.id = SNOR_ID(0x20, 0x70, 0x18),
+ 		.name = "XM25QH128A",
+ 		.size = SZ_16M,
diff --git a/target/linux/generic/pending-6.12/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch b/target/linux/generic/pending-6.12/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch
new file mode 100644
index 0000000000..27b8611100
--- /dev/null
+++ b/target/linux/generic/pending-6.12/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch
@@ -0,0 +1,104 @@
+From: Daniel Golle <daniel@makrotopia.org>
+Subject: ubi: auto-attach mtd device named "ubi" or "data" on boot
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/mtd/ubi/build.c | 36 ++++++++++++++++++++++++++++++++++++
+ 1 file changed, 36 insertions(+)
+
+--- a/drivers/mtd/ubi/build.c
++++ b/drivers/mtd/ubi/build.c
+@@ -1263,6 +1263,80 @@ static struct mtd_notifier ubi_mtd_notif
+ 	.remove = ubi_notify_remove,
+ };
+ 
++
++/*
++ * This function tries attaching mtd partitions named either "ubi" or "data"
++ * during boot.
++ */
++static void __init ubi_auto_attach(void)
++{
++	int err;
++	struct mtd_info *mtd;
++	struct device_node *np;
++	loff_t offset = 0;
++	size_t len;
++	char magic[4];
++
++	/* try attaching mtd device named "ubi" or "data" */
++	mtd = open_mtd_device("ubi");
++	if (IS_ERR(mtd))
++		mtd = open_mtd_device("data");
++
++	if (IS_ERR(mtd))
++		return;
++
++	/* skip "linux,ubi" mtd as it has already been attached */
++	np = mtd_get_of_node(mtd);
++	if (of_device_is_compatible(np, "linux,ubi"))
++		goto cleanup;
++
++	/* get the first not bad block */
++	if (mtd_can_have_bb(mtd))
++		while (mtd_block_isbad(mtd, offset)) {
++			offset += mtd->erasesize;
++
++			if (offset > mtd->size) {
++				pr_err("UBI error: Failed to find a non-bad "
++				       "block on mtd%d\n", mtd->index);
++				goto cleanup;
++			}
++		}
++
++	/* check if the read from flash was successful */
++	err = mtd_read(mtd, offset, 4, &len, (void *) magic);
++	if ((err && !mtd_is_bitflip(err)) || len != 4) {
++		pr_err("UBI error: unable to read from mtd%d\n", mtd->index);
++		goto cleanup;
++	}
++
++	/* check for a valid ubi magic */
++	if (strncmp(magic, "UBI#", 4)) {
++		pr_err("UBI error: no valid UBI magic found inside mtd%d\n", mtd->index);
++		goto cleanup;
++	}
++
++	/* don't auto-add media types where UBI doesn't makes sense */
++	if (mtd->type != MTD_NANDFLASH &&
++	    mtd->type != MTD_NORFLASH &&
++	    mtd->type != MTD_DATAFLASH &&
++	    mtd->type != MTD_MLCNANDFLASH)
++		goto cleanup;
++
++	mutex_lock(&ubi_devices_mutex);
++	pr_notice("UBI: auto-attach mtd%d\n", mtd->index);
++	err = ubi_attach_mtd_dev(mtd, UBI_DEV_NUM_AUTO, 0, 0, false, false);
++	mutex_unlock(&ubi_devices_mutex);
++	if (err < 0) {
++		pr_err("UBI error: cannot attach mtd%d\n", mtd->index);
++		goto cleanup;
++	}
++
++	return;
++
++cleanup:
++	put_mtd_device(mtd);
++}
++
+ static int __init ubi_init_attach(void)
+ {
+ 	int err, i, k;
+@@ -1314,6 +1388,12 @@ static int __init ubi_init_attach(void)
+ 		}
+ 	}
+ 
++	/* auto-attach mtd devices only if built-in to the kernel and no ubi.mtd
++	 * parameter was given */
++	if (IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
++	    !ubi_is_module() && !mtd_devs)
++		ubi_auto_attach();
++
+ 	return 0;
+ 
+ out_detach:
diff --git a/target/linux/generic/pending-6.12/491-ubi-auto-create-ubiblock-device-for-rootfs.patch b/target/linux/generic/pending-6.12/491-ubi-auto-create-ubiblock-device-for-rootfs.patch
new file mode 100644
index 0000000000..44c3bf36fb
--- /dev/null
+++ b/target/linux/generic/pending-6.12/491-ubi-auto-create-ubiblock-device-for-rootfs.patch
@@ -0,0 +1,77 @@
+From: Daniel Golle <daniel@makrotopia.org>
+Subject: ubi: auto-create ubiblock device for rootfs
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/mtd/ubi/block.c | 42 ++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 42 insertions(+)
+
+--- a/drivers/mtd/ubi/block.c
++++ b/drivers/mtd/ubi/block.c
+@@ -575,10 +575,47 @@ match_volume_desc(struct ubi_volume_info
+ 	return true;
+ }
+ 
++#define UBIFS_NODE_MAGIC  0x06101831
++static inline int ubi_vol_is_ubifs(struct ubi_volume_desc *desc)
++{
++	int ret;
++	uint32_t magic_of, magic;
++	ret = ubi_read(desc, 0, (char *)&magic_of, 0, 4);
++	if (ret)
++		return 0;
++	magic = le32_to_cpu(magic_of);
++	return magic == UBIFS_NODE_MAGIC;
++}
++
++static void ubiblock_create_auto_rootfs(struct ubi_volume_info *vi)
++{
++	int ret, is_ubifs;
++	struct ubi_volume_desc *desc;
++
++	if (strcmp(vi->name, "rootfs") &&
++	    strcmp(vi->name, "fit"))
++		return;
++
++	desc = ubi_open_volume(vi->ubi_num, vi->vol_id, UBI_READONLY);
++	if (IS_ERR(desc))
++		return;
++
++	is_ubifs = ubi_vol_is_ubifs(desc);
++	ubi_close_volume(desc);
++	if (is_ubifs)
++		return;
++
++	ret = ubiblock_create(vi);
++	if (ret)
++		pr_err("UBI error: block: can't add '%s' volume, err=%d\n",
++			vi->name, ret);
++}
++
+ static void
+ ubiblock_create_from_param(struct ubi_volume_info *vi)
+ {
+ 	int i, ret = 0;
++	bool got_param = false;
+ 	struct ubiblock_param *p;
+ 
+ 	/*
+@@ -591,6 +628,7 @@ ubiblock_create_from_param(struct ubi_vo
+ 		if (!match_volume_desc(vi, p->name, p->ubi_num, p->vol_id))
+ 			continue;
+ 
++		got_param = true;
+ 		ret = ubiblock_create(vi);
+ 		if (ret) {
+ 			pr_err(
+@@ -599,6 +637,10 @@ ubiblock_create_from_param(struct ubi_vo
+ 		}
+ 		break;
+ 	}
++
++	/* auto-attach "rootfs" volume if existing and non-ubifs */
++	if (!got_param && IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV))
++		ubiblock_create_auto_rootfs(vi);
+ }
+ 
+ static int ubiblock_notify(struct notifier_block *nb,
diff --git a/target/linux/generic/pending-6.12/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch b/target/linux/generic/pending-6.12/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch
new file mode 100644
index 0000000000..7a4c633438
--- /dev/null
+++ b/target/linux/generic/pending-6.12/492-try-auto-mounting-ubi0-rootfs-in-init-do_mounts.c.patch
@@ -0,0 +1,54 @@
+From: Daniel Golle <daniel@makrotopia.org>
+Subject: try auto-mounting ubi0:rootfs in init/do_mounts.c
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ init/do_mounts.c | 26 +++++++++++++++++++++++++-
+ 1 file changed, 25 insertions(+), 1 deletion(-)
+
+--- a/init/do_mounts.c
++++ b/init/do_mounts.c
+@@ -250,7 +250,30 @@ retry:
+ out:
+ 	put_page(page);
+ }
+- 
++
++#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
++static int __init mount_ubi_rootfs(void)
++{
++	int flags = MS_SILENT;
++	int err, tried = 0;
++
++	while (tried < 2) {
++		err = do_mount_root("ubi0:rootfs", "ubifs", flags, \
++					root_mount_data);
++		switch (err) {
++			case -EACCES:
++				flags |= MS_RDONLY;
++				tried++;
++				break;
++			default:
++				return err;
++		}
++	}
++
++	return -EINVAL;
++}
++#endif
++
+ #ifdef CONFIG_ROOT_NFS
+ 
+ #define NFSROOT_TIMEOUT_MIN	5
+@@ -387,6 +410,11 @@ static inline void mount_block_root(char
+ 
+ void __init mount_root(char *root_device_name)
+ {
++#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
++	if (!mount_ubi_rootfs())
++		return;
++#endif
++
+ 	switch (ROOT_DEV) {
+ 	case Root_NFS:
+ 		mount_nfs_root();
diff --git a/target/linux/generic/pending-6.12/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch b/target/linux/generic/pending-6.12/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch
new file mode 100644
index 0000000000..4007c8a8bd
--- /dev/null
+++ b/target/linux/generic/pending-6.12/493-ubi-set-ROOT_DEV-to-ubiblock-rootfs-if-unset.patch
@@ -0,0 +1,34 @@
+From: Daniel Golle <daniel@makrotopia.org>
+Subject: ubi: set ROOT_DEV to ubiblock "rootfs" if unset
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/mtd/ubi/block.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/mtd/ubi/block.c
++++ b/drivers/mtd/ubi/block.c
+@@ -41,6 +41,7 @@
+ #include <linux/scatterlist.h>
+ #include <linux/idr.h>
+ #include <asm/div64.h>
++#include <linux/root_dev.h>
+ 
+ #include "ubi-media.h"
+ #include "ubi.h"
+@@ -431,6 +432,15 @@ int ubiblock_create(struct ubi_volume_in
+ 	dev_info(disk_to_dev(dev->gd), "created from ubi%d:%d(%s)",
+ 		 dev->ubi_num, dev->vol_id, vi->name);
+ 	mutex_unlock(&devices_mutex);
++
++	if (!strcmp(vi->name, "rootfs") &&
++	    IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
++	    ROOT_DEV == 0) {
++		pr_notice("ubiblock: device ubiblock%d_%d (%s) set to be root filesystem\n",
++			  dev->ubi_num, dev->vol_id, vi->name);
++		ROOT_DEV = MKDEV(gd->major, gd->first_minor);
++	}
++
+ 	return 0;
+ 
+ out_remove_minor:
diff --git a/target/linux/generic/pending-6.12/494-mtd-ubi-add-EOF-marker-support.patch b/target/linux/generic/pending-6.12/494-mtd-ubi-add-EOF-marker-support.patch
new file mode 100644
index 0000000000..413431755f
--- /dev/null
+++ b/target/linux/generic/pending-6.12/494-mtd-ubi-add-EOF-marker-support.patch
@@ -0,0 +1,60 @@
+From: Gabor Juhos <juhosg@openwrt.org>
+Subject: mtd: add EOF marker support to the UBI layer
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+---
+ drivers/mtd/ubi/attach.c | 25 ++++++++++++++++++++++---
+ drivers/mtd/ubi/ubi.h    |  1 +
+ 2 files changed, 23 insertions(+), 3 deletions(-)
+
+--- a/drivers/mtd/ubi/attach.c
++++ b/drivers/mtd/ubi/attach.c
+@@ -926,6 +926,13 @@ static bool vol_ignored(int vol_id)
+ #endif
+ }
+ 
++static bool ec_hdr_has_eof(struct ubi_ec_hdr *ech)
++{
++	return ech->padding1[0] == 'E' &&
++	       ech->padding1[1] == 'O' &&
++	       ech->padding1[2] == 'F';
++}
++
+ /**
+  * scan_peb - scan and process UBI headers of a PEB.
+  * @ubi: UBI device description object
+@@ -958,9 +965,21 @@ static int scan_peb(struct ubi_device *u
+ 		return 0;
+ 	}
+ 
+-	err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
+-	if (err < 0)
+-		return err;
++	if (!ai->eof_found) {
++		err = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);
++		if (err < 0)
++			return err;
++
++		if (ec_hdr_has_eof(ech)) {
++			pr_notice("UBI: EOF marker found, PEBs from %d will be erased\n",
++				pnum);
++			ai->eof_found = true;
++		}
++	}
++
++	if (ai->eof_found)
++		err = UBI_IO_FF_BITFLIPS;
++
+ 	switch (err) {
+ 	case 0:
+ 		break;
+--- a/drivers/mtd/ubi/ubi.h
++++ b/drivers/mtd/ubi/ubi.h
+@@ -778,6 +778,7 @@ struct ubi_attach_info {
+ 	int mean_ec;
+ 	uint64_t ec_sum;
+ 	int ec_count;
++	bool eof_found;
+ 	struct kmem_cache *aeb_slab_cache;
+ 	struct ubi_ec_hdr *ech;
+ 	struct ubi_vid_io_buf *vidb;
diff --git a/target/linux/generic/pending-6.12/496-dt-bindings-add-bindings-for-mtd-concat-devices.patch b/target/linux/generic/pending-6.12/496-dt-bindings-add-bindings-for-mtd-concat-devices.patch
new file mode 100644
index 0000000000..01f3b9ec2d
--- /dev/null
+++ b/target/linux/generic/pending-6.12/496-dt-bindings-add-bindings-for-mtd-concat-devices.patch
@@ -0,0 +1,52 @@
+From 5734c6669fba7ddb5ef491ccff7159d15dba0b59 Mon Sep 17 00:00:00 2001
+From: Bernhard Frauendienst <kernel@nospam.obeliks.de>
+Date: Wed, 5 Sep 2018 01:32:51 +0200
+Subject: [PATCH 496/497] dt-bindings: add bindings for mtd-concat devices
+
+Document virtual mtd-concat device bindings.
+
+Signed-off-by: Bernhard Frauendienst <kernel@nospam.obeliks.de>
+---
+ .../devicetree/bindings/mtd/mtd-concat.txt    | 36 +++++++++++++++++++
+ 1 file changed, 36 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/mtd/mtd-concat.txt
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/mtd/mtd-concat.txt
+@@ -0,0 +1,36 @@
++Virtual MTD concat device
++
++Requires properties:
++- devices: list of phandles to mtd nodes that should be concatenated
++
++Example:
++
++&spi {
++	flash0: flash@0 {
++		...
++	};
++	flash1: flash@1 {
++		...
++	};
++};
++
++flash {
++	compatible = "mtd-concat";
++
++	devices = <&flash0 &flash1>;
++
++	partitions {
++		compatible = "fixed-partitions";
++
++		partition@0 {
++			label = "boot";
++			reg = <0x0000000 0x0040000>;
++			read-only;
++		};
++
++		partition@40000 {
++			label = "firmware";
++			reg = <0x0040000 0x1fc0000>;
++		};
++	}
++}
diff --git a/target/linux/generic/pending-6.12/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch b/target/linux/generic/pending-6.12/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch
new file mode 100644
index 0000000000..3d5f5768bc
--- /dev/null
+++ b/target/linux/generic/pending-6.12/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch
@@ -0,0 +1,215 @@
+From e53f712d8eac71f54399b61038ccf87d2cee99d7 Mon Sep 17 00:00:00 2001
+From: Bernhard Frauendienst <kernel@nospam.obeliks.de>
+Date: Sat, 25 Aug 2018 12:35:22 +0200
+Subject: [PATCH 497/497] mtd: mtdconcat: add dt driver for concat devices
+
+Some mtd drivers like physmap variants have support for concatenating
+multiple mtd devices, but there is no generic way to define such a
+concat device from within the device tree.
+
+This is useful for some SoC boards that use multiple flash chips as
+memory banks of a single mtd device, with partitions spanning chip
+borders.
+
+This commit adds a driver for creating virtual mtd-concat devices. They
+must have a compatible = "mtd-concat" line, and define a list of devices
+to concat in the 'devices' property, for example:
+
+flash {
+  compatible = "mtd-concat";
+
+  devices = <&flash0 &flash1>;
+
+  partitions {
+    ...
+  };
+};
+
+The driver is added to the very end of the mtd Makefile to increase the
+likelyhood of all child devices already being loaded at the time of
+probing, preventing unnecessary deferred probes.
+
+Signed-off-by: Bernhard Frauendienst <kernel@nospam.obeliks.de>
+---
+ drivers/mtd/Kconfig                 |   2 +
+ drivers/mtd/Makefile                |   3 +
+ drivers/mtd/composite/Kconfig       |  12 +++
+ drivers/mtd/composite/Makefile      |   6 ++
+ drivers/mtd/composite/virt_concat.c | 128 ++++++++++++++++++++++++++++
+ 5 files changed, 151 insertions(+)
+ create mode 100644 drivers/mtd/composite/Kconfig
+ create mode 100644 drivers/mtd/composite/Makefile
+ create mode 100644 drivers/mtd/composite/virt_concat.c
+
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -241,4 +241,6 @@ source "drivers/mtd/ubi/Kconfig"
+ 
+ source "drivers/mtd/hyperbus/Kconfig"
+ 
++source "drivers/mtd/composite/Kconfig"
++
+ endif # MTD
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -33,3 +33,6 @@ obj-y		+= chips/ lpddr/ maps/ devices/ n
+ obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor/
+ obj-$(CONFIG_MTD_UBI)		+= ubi/
+ obj-$(CONFIG_MTD_HYPERBUS)	+= hyperbus/
++
++# Composite drivers must be loaded last
++obj-y				+= composite/
+--- /dev/null
++++ b/drivers/mtd/composite/Kconfig
+@@ -0,0 +1,12 @@
++menu "Composite MTD device drivers"
++	depends on MTD!=n
++
++config MTD_VIRT_CONCAT
++	tristate "Virtual concat MTD device"
++	help
++	  This driver allows creation of a virtual MTD concat device, which
++	  concatenates multiple underlying MTD devices to a single device.
++	  This is required by some SoC boards where multiple memory banks are
++	  used as one device with partitions spanning across device boundaries.
++
++endmenu
+--- /dev/null
++++ b/drivers/mtd/composite/Makefile
+@@ -0,0 +1,6 @@
++# SPDX-License-Identifier: GPL-2.0
++#
++# linux/drivers/mtd/composite/Makefile
++#
++
++obj-$(CONFIG_MTD_VIRT_CONCAT)   += virt_concat.o
+--- /dev/null
++++ b/drivers/mtd/composite/virt_concat.c
+@@ -0,0 +1,127 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Virtual concat MTD device driver
++ *
++ * Copyright (C) 2018 Bernhard Frauendienst
++ * Author: Bernhard Frauendienst, kernel@nospam.obeliks.de
++ */
++
++#include <linux/platform_device.h>
++#include <linux/module.h>
++#include <linux/device.h>
++#include <linux/mtd/concat.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/partitions.h>
++#include <linux/of.h>
++#include <linux/of_platform.h>
++#include <linux/slab.h>
++
++/*
++ * struct of_virt_concat - platform device driver data.
++ * @cmtd the final mtd_concat device
++ * @num_devices the number of devices in @devices
++ * @devices points to an array of devices already loaded
++ */
++struct of_virt_concat {
++	struct mtd_info	*cmtd;
++	int num_devices;
++	struct mtd_info	**devices;
++};
++
++static void virt_concat_remove(struct platform_device *pdev)
++{
++	struct of_virt_concat *info;
++	int i;
++
++	info = platform_get_drvdata(pdev);
++	if (!info)
++		return;
++
++	// unset data for when this is called after a probe error
++	platform_set_drvdata(pdev, NULL);
++
++	if (info->cmtd) {
++		mtd_device_unregister(info->cmtd);
++		mtd_concat_destroy(info->cmtd);
++	}
++
++	if (info->devices) {
++		for (i = 0; i < info->num_devices; i++)
++			put_mtd_device(info->devices[i]);
++	}
++}
++
++static int virt_concat_probe(struct platform_device *pdev)
++{
++	struct device_node *node = pdev->dev.of_node;
++	struct of_phandle_iterator it;
++	struct of_virt_concat *info;
++	struct mtd_info *mtd;
++	int err = 0, count;
++
++	count = of_count_phandle_with_args(node, "devices", NULL);
++	if (count <= 0)
++		return -EINVAL;
++
++	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
++	if (!info)
++		return -ENOMEM;
++	info->devices = devm_kcalloc(&pdev->dev, count,
++				     sizeof(*(info->devices)), GFP_KERNEL);
++	if (!info->devices) {
++		err = -ENOMEM;
++		goto err_remove;
++	}
++
++	platform_set_drvdata(pdev, info);
++
++	of_for_each_phandle(&it, err, node, "devices", NULL, 0) {
++		mtd = of_get_mtd_device_by_node(it.node);
++		if (IS_ERR(mtd)) {
++			of_node_put(it.node);
++			err = -EPROBE_DEFER;
++			goto err_remove;
++		}
++
++		info->devices[info->num_devices++] = mtd;
++	}
++
++	info->cmtd = mtd_concat_create(info->devices, info->num_devices,
++				       dev_name(&pdev->dev));
++	if (!info->cmtd) {
++		err = -ENXIO;
++		goto err_remove;
++	}
++
++	info->cmtd->dev.parent = &pdev->dev;
++	mtd_set_of_node(info->cmtd, node);
++	mtd_device_register(info->cmtd, NULL, 0);
++
++	return 0;
++
++err_remove:
++	virt_concat_remove(pdev);
++
++	return err;
++}
++
++static const struct of_device_id virt_concat_of_match[] = {
++	{ .compatible = "mtd-concat", },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, virt_concat_of_match);
++
++static struct platform_driver virt_concat_driver = {
++	.probe = virt_concat_probe,
++	.remove = virt_concat_remove,
++	.driver	 = {
++		.name   = "virt-mtdconcat",
++		.of_match_table = virt_concat_of_match,
++	},
++};
++
++module_platform_driver(virt_concat_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_AUTHOR("Bernhard Frauendienst <kernel@nospam.obeliks.de>");
++MODULE_DESCRIPTION("Virtual concat MTD device driver");
diff --git a/target/linux/generic/pending-6.12/498-mtd-spi-nor-locking-support-for-MX25L6405D.patch b/target/linux/generic/pending-6.12/498-mtd-spi-nor-locking-support-for-MX25L6405D.patch
new file mode 100644
index 0000000000..0cf5b02daf
--- /dev/null
+++ b/target/linux/generic/pending-6.12/498-mtd-spi-nor-locking-support-for-MX25L6405D.patch
@@ -0,0 +1,32 @@
+From 8bf2ce6ea4ee840b70f55a27f80e1cd308051b13 Mon Sep 17 00:00:00 2001
+From: Nick Hainke <vincent@systemli.org>
+Date: Mon, 27 Dec 2021 00:38:13 +0100
+Subject: [PATCH 1/2] mtd: spi-nor: locking support for MX25L6405D
+
+Macronix MX25L6405D supports locking with four block-protection bits.
+Currently, the driver only sets three bits.  If the bootloader does not
+sustain the flash chip in an unlocked state, the flash might be
+non-writeable. Add the corresponding flag to enable locking support with
+four bits in the status register.
+
+Tested on Nanostation M2 XM.
+
+Similar to commit 7ea40b54e83b ("mtd: spi-nor: enable locking support for
+MX25L12805D")
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+Signed-off-by: Nick Hainke <vincent@systemli.org>
+---
+ drivers/mtd/spi-nor/macronix.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/mtd/spi-nor/macronix.c
++++ b/drivers/mtd/spi-nor/macronix.c
+@@ -66,6 +66,7 @@ static const struct flash_info macronix_
+ 		.id = SNOR_ID(0xc2, 0x20, 0x17),
+ 		.name = "mx25l6405d",
+ 		.size = SZ_8M,
++		.flags = SPI_NOR_HAS_LOCK | SPI_NOR_4BIT_BP,
+ 		.no_sfdp_flags = SECT_4K,
+ 	}, {
+ 		.id = SNOR_ID(0xc2, 0x20, 0x18),
diff --git a/target/linux/generic/pending-6.12/499-mtd-spi-nor-disable-16-bit-sr-for-macronix.patch b/target/linux/generic/pending-6.12/499-mtd-spi-nor-disable-16-bit-sr-for-macronix.patch
new file mode 100644
index 0000000000..5e20ef3296
--- /dev/null
+++ b/target/linux/generic/pending-6.12/499-mtd-spi-nor-disable-16-bit-sr-for-macronix.patch
@@ -0,0 +1,30 @@
+From 245224608b5368c10407da07557e546743d3c489 Mon Sep 17 00:00:00 2001
+From: Nick Hainke <vincent@systemli.org>
+Date: Mon, 27 Dec 2021 09:33:13 +0100
+Subject: [PATCH 2/2] mtd: spi-nor: disable 16-bit-sr for macronix
+
+Macronix flash chips seem to consist of only one status register.
+These chips will not work with the "16-bit Write Status (01h) Command".
+Disable SNOR_F_HAS_16BIT_SR for all Macronix chips.
+
+Tested with MX25L6405D.
+
+Fixes: 39d1e3340c73 ("mtd: spi-nor: Fix clearing of QE bit on
+lock()/unlock()")
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+Signed-off-by: Nick Hainke <vincent@systemli.org>
+---
+ drivers/mtd/spi-nor/macronix.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/mtd/spi-nor/macronix.c
++++ b/drivers/mtd/spi-nor/macronix.c
+@@ -195,6 +195,7 @@ static int macronix_nor_late_init(struct
+ {
+ 	if (!nor->params->set_4byte_addr_mode)
+ 		nor->params->set_4byte_addr_mode = spi_nor_set_4byte_addr_mode_en4b_ex4b;
++	nor->flags &= ~SNOR_F_HAS_16BIT_SR;
+ 	nor->flags |= SNOR_F_HAS_LOCK;
+ 
+ 	return 0;
diff --git a/target/linux/generic/pending-6.12/500-fs_cdrom_dependencies.patch b/target/linux/generic/pending-6.12/500-fs_cdrom_dependencies.patch
new file mode 100644
index 0000000000..7c143584a4
--- /dev/null
+++ b/target/linux/generic/pending-6.12/500-fs_cdrom_dependencies.patch
@@ -0,0 +1,52 @@
+From af7b91bcecce0eae24e90acd35d96ecee73e1407 Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 12:21:15 +0200
+Subject: [PATCH] fs: add cdrom dependency
+
+---
+ fs/hfs/Kconfig     | 1 +
+ fs/hfsplus/Kconfig | 1 +
+ fs/isofs/Kconfig   | 1 +
+ fs/udf/Kconfig     | 1 +
+ 4 files changed, 4 insertions(+)
+
+--- a/fs/hfs/Kconfig
++++ b/fs/hfs/Kconfig
+@@ -2,6 +2,7 @@
+ config HFS_FS
+ 	tristate "Apple Macintosh file system support"
+ 	depends on BLOCK
++	select CDROM
+ 	select BUFFER_HEAD
+ 	select NLS
+ 	select LEGACY_DIRECT_IO
+--- a/fs/hfsplus/Kconfig
++++ b/fs/hfsplus/Kconfig
+@@ -2,6 +2,7 @@
+ config HFSPLUS_FS
+ 	tristate "Apple Extended HFS file system support"
+ 	depends on BLOCK
++	select CDROM
+ 	select BUFFER_HEAD
+ 	select NLS
+ 	select NLS_UTF8
+--- a/fs/isofs/Kconfig
++++ b/fs/isofs/Kconfig
+@@ -1,6 +1,7 @@
+ # SPDX-License-Identifier: GPL-2.0-only
+ config ISO9660_FS
+ 	tristate "ISO 9660 CDROM file system support"
++	select CDROM
+ 	select BUFFER_HEAD
+ 	help
+ 	  This is the standard file system used on CD-ROMs.  It was previously
+--- a/fs/udf/Kconfig
++++ b/fs/udf/Kconfig
+@@ -1,6 +1,7 @@
+ # SPDX-License-Identifier: GPL-2.0-only
+ config UDF_FS
+ 	tristate "UDF file system support"
++	select CDROM
+ 	select BUFFER_HEAD
+ 	select CRC_ITU_T
+ 	select NLS
diff --git a/target/linux/generic/pending-6.12/510-block-add-uImage.FIT-subimage-block-driver.patch b/target/linux/generic/pending-6.12/510-block-add-uImage.FIT-subimage-block-driver.patch
new file mode 100644
index 0000000000..c3d246c5ee
--- /dev/null
+++ b/target/linux/generic/pending-6.12/510-block-add-uImage.FIT-subimage-block-driver.patch
@@ -0,0 +1,757 @@
+From 3a200922ac4cbf4bfffdf86c0957b1401474e839 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Wed, 16 Nov 2022 12:49:52 +0000
+Subject: [PATCH 1/2] block: add uImage.FIT subimage block driver
+
+Add a small block driver which exposes filesystem sub-images contained
+in U-Boot uImage.FIT images as block devices.
+
+The uImage.FIT image has to be stored directly on a block device or
+partition, MTD device or partition, or UBI volume.
+
+The driver is intended for systems using the U-Boot bootloader and
+uses the root device hint left by the bootloader (or the user) in
+the 'chosen' section of the device-tree.
+
+Example:
+/dts-v1/;
+/ {
+        chosen {
+                rootdisk = <&mmc0_part3>;
+        };
+};
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ MAINTAINERS                 |   6 +
+ drivers/block/Kconfig       |  12 +
+ drivers/block/Makefile      |   2 +
+ drivers/block/fitblk.c      | 660 ++++++++++++++++++++++++++++++++++++
+ drivers/block/open          |   4 +
+ include/uapi/linux/fitblk.h |  10 +
+ 6 files changed, 694 insertions(+)
+ create mode 100644 drivers/block/fitblk.c
+ create mode 100644 drivers/block/open
+ create mode 100644 include/uapi/linux/fitblk.h
+
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -23668,6 +23668,12 @@ F:	Documentation/filesystems/ubifs-authe
+ F:	Documentation/filesystems/ubifs.rst
+ F:	fs/ubifs/
+ 
++U-BOOT UIMAGE.FIT PARSER
++M:	Daniel Golle <daniel@makrotopia.org>
++L:	linux-block@vger.kernel.org
++S:	Maintained
++F:	drivers/block/fitblk.c
++
+ UBLK USERSPACE BLOCK DRIVER
+ M:	Ming Lei <ming.lei@redhat.com>
+ L:	linux-block@vger.kernel.org
+--- a/drivers/block/Kconfig
++++ b/drivers/block/Kconfig
+@@ -363,6 +363,18 @@ config BLK_DEV_RUST_NULL
+ 
+ 	  If unsure, say N.
+ 
++config UIMAGE_FIT_BLK
++	bool "uImage.FIT block driver"
++	help
++	  This driver allows using filesystems contained in uImage.FIT images
++	  by mapping them as block devices.
++
++	  It can currently not be built as a module due to libfdt symbols not
++	  being exported.
++
++	  Say Y if you want to mount filesystems sub-images of a uImage.FIT
++	  stored in a block device partition, mtdblock or ubiblock device.
++
+ config BLK_DEV_RBD
+ 	tristate "Rados block device (RBD)"
+ 	depends on INET && BLOCK
+--- a/drivers/block/Makefile
++++ b/drivers/block/Makefile
+@@ -42,4 +42,6 @@ obj-$(CONFIG_BLK_DEV_NULL_BLK)	+= null_b
+ 
+ obj-$(CONFIG_BLK_DEV_UBLK)			+= ublk_drv.o
+ 
++obj-$(CONFIG_UIMAGE_FIT_BLK)	+= fitblk.o
++
+ swim_mod-y	:= swim.o swim_asm.o
+--- /dev/null
++++ b/drivers/block/fitblk.c
+@@ -0,0 +1,660 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * uImage.FIT virtual block device driver.
++ *
++ * Copyright (C) 2023 Daniel Golle
++ * Copyright (C) 2007 Nick Piggin
++ * Copyright (C) 2007 Novell Inc.
++ *
++ * Initially derived from drivers/block/brd.c which is in parts derived from
++ * drivers/block/rd.c, and drivers/block/loop.c, copyright of their respective
++ * owners.
++ *
++ * uImage.FIT headers extracted from Das U-Boot
++ *  (C) Copyright 2008 Semihalf
++ *  (C) Copyright 2000-2005
++ *  Wolfgang Denk, DENX Software Engineering, wd@denx.de.
++ */
++
++#include <linux/init.h>
++#include <linux/initrd.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/major.h>
++#include <linux/blkdev.h>
++#include <linux/blkpg.h>
++#include <linux/blk-mq.h>
++#include <linux/ctype.h>
++#include <linux/hdreg.h>
++#include <linux/list.h>
++#include <linux/mutex.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/of_fdt.h>
++#include <linux/pagemap.h>
++#include <linux/platform_device.h>
++#include <linux/property.h>
++#include <linux/refcount.h>
++#include <linux/task_work.h>
++#include <linux/types.h>
++#include <linux/libfdt.h>
++#include <linux/mtd/mtd.h>
++#include <linux/root_dev.h>
++#include <uapi/linux/fitblk.h>
++
++#define FIT_DEVICE_PREFIX	"fit"
++
++/* maximum number of pages used for the uImage.FIT index structure */
++#define FIT_MAX_PAGES		1024
++
++/* minimum free sectors to map as read-write "remainder" volume */
++#define MIN_FREE_SECT		16
++
++/* maximum number of mapped loadables */
++#define MAX_FIT_LOADABLES	16
++
++/* constants for uImage.FIT structrure traversal */
++#define FIT_IMAGES_PATH		"/images"
++#define FIT_CONFS_PATH		"/configurations"
++
++/* hash/signature/key node */
++#define FIT_HASH_NODENAME	"hash"
++#define FIT_ALGO_PROP		"algo"
++#define FIT_VALUE_PROP		"value"
++#define FIT_IGNORE_PROP		"uboot-ignore"
++#define FIT_SIG_NODENAME	"signature"
++#define FIT_KEY_REQUIRED	"required"
++#define FIT_KEY_HINT		"key-name-hint"
++
++/* cipher node */
++#define FIT_CIPHER_NODENAME	"cipher"
++#define FIT_ALGO_PROP		"algo"
++
++/* image node */
++#define FIT_DATA_PROP		"data"
++#define FIT_DATA_POSITION_PROP	"data-position"
++#define FIT_DATA_OFFSET_PROP	"data-offset"
++#define FIT_DATA_SIZE_PROP	"data-size"
++#define FIT_TIMESTAMP_PROP	"timestamp"
++#define FIT_DESC_PROP		"description"
++#define FIT_ARCH_PROP		"arch"
++#define FIT_TYPE_PROP		"type"
++#define FIT_OS_PROP		"os"
++#define FIT_COMP_PROP		"compression"
++#define FIT_ENTRY_PROP		"entry"
++#define FIT_LOAD_PROP		"load"
++
++/* configuration node */
++#define FIT_KERNEL_PROP		"kernel"
++#define FIT_FILESYSTEM_PROP	"filesystem"
++#define FIT_RAMDISK_PROP	"ramdisk"
++#define FIT_FDT_PROP		"fdt"
++#define FIT_LOADABLE_PROP	"loadables"
++#define FIT_DEFAULT_PROP	"default"
++#define FIT_SETUP_PROP		"setup"
++#define FIT_FPGA_PROP		"fpga"
++#define FIT_FIRMWARE_PROP	"firmware"
++#define FIT_STANDALONE_PROP	"standalone"
++
++/* fitblk driver data */
++static const char *_fitblk_claim_ptr = "I belong to fitblk";
++static const char *ubootver;
++struct device_node *rootdisk;
++static struct platform_device *pdev;
++static LIST_HEAD(fitblk_devices);
++static DEFINE_MUTEX(devices_mutex);
++refcount_t num_devs;
++
++struct fitblk {
++	struct platform_device	*pdev;
++	struct file		*bdev_file;
++	sector_t		start_sect;
++	struct gendisk		*disk;
++	struct work_struct	remove_work;
++	struct list_head	list;
++	bool			dead;
++};
++
++static int fitblk_open(struct gendisk *disk, fmode_t mode)
++{
++	struct fitblk *fitblk = disk->private_data;
++
++	if (fitblk->dead)
++		return -ENOENT;
++
++	return 0;
++}
++
++static void fitblk_release(struct gendisk *disk)
++{
++	return;
++}
++
++static void fitblk_submit_bio(struct bio *orig_bio)
++{
++	struct bio *bio = orig_bio;
++	struct fitblk *fitblk = bio->bi_bdev->bd_disk->private_data;
++
++	if (fitblk->dead)
++		return;
++
++	/* mangle bio and re-submit */
++	while (bio) {
++		bio->bi_iter.bi_sector += fitblk->start_sect;
++		bio->bi_bdev = file_bdev(fitblk->bdev_file);
++		bio = bio->bi_next;
++	}
++	submit_bio(orig_bio);
++}
++
++static void fitblk_remove(struct fitblk *fitblk)
++{
++	blk_mark_disk_dead(fitblk->disk);
++	mutex_lock(&devices_mutex);
++	fitblk->dead = true;
++	list_del(&fitblk->list);
++	mutex_unlock(&devices_mutex);
++
++	schedule_work(&fitblk->remove_work);
++}
++
++static int fitblk_ioctl(struct block_device *bdev, fmode_t mode,
++			unsigned int cmd, unsigned long arg)
++{
++	struct fitblk *fitblk = bdev->bd_disk->private_data;
++
++	if (!capable(CAP_SYS_ADMIN))
++		return -EACCES;
++
++	if (fitblk->dead)
++		return -ENOENT;
++
++	switch (cmd) {
++	case FITBLK_RELEASE:
++		fitblk_remove(fitblk);
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static const struct block_device_operations fitblk_fops = {
++	.owner		= THIS_MODULE,
++	.ioctl		= fitblk_ioctl,
++	.open		= fitblk_open,
++	.release	= fitblk_release,
++	.submit_bio	= fitblk_submit_bio,
++};
++
++static void fitblk_purge(struct work_struct *work)
++{
++	struct fitblk *fitblk = container_of(work, struct fitblk, remove_work);
++
++	del_gendisk(fitblk->disk);
++	refcount_dec(&num_devs);
++	platform_device_del(fitblk->pdev);
++	platform_device_put(fitblk->pdev);
++
++	if (refcount_dec_if_one(&num_devs)) {
++		sysfs_remove_link(&pdev->dev.kobj, "lower_dev");
++		fput(fitblk->bdev_file);
++	}
++
++	kfree(fitblk);
++}
++
++static int add_fit_subimage_device(struct file *bdev_file,
++				   unsigned int slot, sector_t start_sect,
++				   sector_t nr_sect, bool readonly)
++{
++	struct block_device *bdev = file_bdev(bdev_file);
++	struct fitblk *fitblk;
++	struct gendisk *disk;
++	int err;
++
++	mutex_lock(&devices_mutex);
++	if (!refcount_inc_not_zero(&num_devs))
++		return -EBADF;
++
++	fitblk = kzalloc(sizeof(struct fitblk), GFP_KERNEL);
++	if (!fitblk) {
++		err = -ENOMEM;
++		goto out_unlock;
++	}
++
++	fitblk->bdev_file = bdev_file;
++	fitblk->start_sect = start_sect;
++	INIT_WORK(&fitblk->remove_work, fitblk_purge);
++
++	disk = blk_alloc_disk(&bdev->bd_disk->queue->limits, NUMA_NO_NODE);
++	if (!disk) {
++		err = -ENOMEM;
++		goto out_free_fitblk;
++	}
++
++	disk->first_minor = 0;
++	disk->flags = bdev->bd_disk->flags | GENHD_FL_NO_PART;
++	disk->fops = &fitblk_fops;
++	disk->private_data = fitblk;
++	if (readonly) {
++		set_disk_ro(disk, 1);
++		snprintf(disk->disk_name, sizeof(disk->disk_name), FIT_DEVICE_PREFIX "%u", slot);
++	} else {
++		strcpy(disk->disk_name, FIT_DEVICE_PREFIX "rw");
++	}
++
++	set_capacity(disk, nr_sect);
++	disk->queue->queue_flags = bdev->bd_disk->queue->queue_flags;
++
++	fitblk->disk = disk;
++	fitblk->pdev = platform_device_alloc(disk->disk_name, PLATFORM_DEVID_NONE);
++	if (!fitblk->pdev) {
++		err = -ENOMEM;
++		goto out_cleanup_disk;
++	}
++
++	fitblk->pdev->dev.parent = &pdev->dev;
++	err = platform_device_add(fitblk->pdev);
++	if (err)
++		goto out_put_pdev;
++
++	err = device_add_disk(&fitblk->pdev->dev, disk, NULL);
++	if (err)
++		goto out_del_pdev;
++
++	if (!ROOT_DEV)
++		ROOT_DEV = disk->part0->bd_dev;
++
++	list_add_tail(&fitblk->list, &fitblk_devices);
++
++	mutex_unlock(&devices_mutex);
++
++	return 0;
++
++out_del_pdev:
++	platform_device_del(fitblk->pdev);
++out_put_pdev:
++	platform_device_put(fitblk->pdev);
++out_cleanup_disk:
++	put_disk(disk);
++out_free_fitblk:
++	kfree(fitblk);
++out_unlock:
++	refcount_dec(&num_devs);
++	mutex_unlock(&devices_mutex);
++	return err;
++}
++
++static void fitblk_mark_dead(struct block_device *bdev, bool surprise)
++{
++	struct list_head *n, *tmp;
++	struct fitblk *fitblk;
++
++	mutex_lock(&devices_mutex);
++	list_for_each_safe(n, tmp, &fitblk_devices) {
++		fitblk = list_entry(n, struct fitblk, list);
++		if (file_bdev(fitblk->bdev_file) != bdev)
++			continue;
++
++		fitblk->dead = true;
++		list_del(&fitblk->list);
++		/* removal needs to be deferred to avoid deadlock */
++		schedule_work(&fitblk->remove_work);
++	}
++	mutex_unlock(&devices_mutex);
++}
++
++static const struct blk_holder_ops fitblk_hops = {
++	.mark_dead = fitblk_mark_dead,
++};
++
++static int parse_fit_on_dev(struct device *dev)
++{
++	struct file *bdev_file;
++	struct block_device *bdev;
++	struct address_space *mapping;
++	struct folio *folio;
++	pgoff_t f_index = 0;
++	size_t bytes_left, bytes_to_copy;
++	void *pre_fit, *fit, *fit_c;
++	u64 dsize, dsectors, imgmaxsect = 0;
++	u32 size, image_pos, image_len;
++	const __be32 *image_offset_be, *image_len_be, *image_pos_be;
++	int ret = 0, node, images, config;
++	const char *image_name, *image_type, *image_description,
++		*config_default, *config_description, *config_loadables;
++	u32 image_name_len, image_type_len, image_description_len,
++		bootconf_len, config_default_len, config_description_len,
++		config_loadables_len;
++	sector_t start_sect, nr_sects;
++	struct device_node *np = NULL;
++	const char *bootconf_c;
++	const char *loadable;
++	char *bootconf = NULL, *bootconf_term;
++	bool found;
++	int loadables_rem_len, loadable_len;
++	u16 loadcnt;
++	unsigned int slot = 0;
++
++	/* Exclusive open the block device to receive holder notifications */
++	bdev_file = bdev_file_open_by_dev(dev->devt,
++					  BLK_OPEN_READ | BLK_OPEN_RESTRICT_WRITES,
++					  &_fitblk_claim_ptr, &fitblk_hops);
++	if (!bdev_file)
++		return -ENODEV;
++
++	if (IS_ERR(bdev_file))
++		return PTR_ERR(bdev_file);
++
++	bdev = file_bdev(bdev_file);
++	mapping = bdev_file->f_mapping;
++
++	/* map first page */
++	folio = read_mapping_folio(mapping, f_index++, NULL);
++	if (IS_ERR(folio)) {
++		ret = PTR_ERR(folio);
++		goto out_blkdev;
++	}
++	pre_fit = folio_address(folio) + offset_in_folio(folio, 0);
++
++	/* uImage.FIT is based on flattened device tree structure */
++	if (fdt_check_header(pre_fit)) {
++		ret = -EINVAL;
++		folio_put(folio);
++		goto out_blkdev;
++	}
++
++	size = fdt_totalsize(pre_fit);
++
++	if (size > PAGE_SIZE * FIT_MAX_PAGES) {
++		ret = -EOPNOTSUPP;
++		folio_put(folio);
++		goto out_blkdev;
++	}
++
++	/* acquire disk size */
++	dsectors = bdev_nr_sectors(bdev);
++	dsize = dsectors << SECTOR_SHIFT;
++
++	/* abort if FIT structure is larger than disk or partition size */
++	if (size >= dsize) {
++		ret = -EFBIG;
++		folio_put(folio);
++		goto out_blkdev;
++	}
++
++	fit = kmalloc(size, GFP_KERNEL);
++	if (!fit) {
++		ret = -ENOMEM;
++		folio_put(folio);
++		goto out_blkdev;
++	}
++
++	bytes_left = size;
++	fit_c = fit;
++	while (bytes_left > 0) {
++		bytes_to_copy = min_t(size_t, bytes_left,
++				      folio_size(folio) - offset_in_folio(folio, 0));
++		memcpy(fit_c, pre_fit, bytes_to_copy);
++		fit_c += bytes_to_copy;
++		bytes_left -= bytes_to_copy;
++		if (bytes_left) {
++			folio_put(folio);
++			folio = read_mapping_folio(mapping, f_index++, NULL);
++			if (IS_ERR(folio)) {
++				ret = PTR_ERR(folio);
++				goto out_blkdev;
++			};
++			pre_fit = folio_address(folio) + offset_in_folio(folio, 0);
++		}
++	}
++	folio_put(folio);
++
++	/* set boot config node name U-Boot may have added to the device tree */
++	np = of_find_node_by_path("/chosen");
++	if (np) {
++		bootconf_c = of_get_property(np, "u-boot,bootconf", &bootconf_len);
++		if (bootconf_c && bootconf_len)
++			bootconf = kmemdup_nul(bootconf_c, bootconf_len, GFP_KERNEL);
++	}
++
++	if (bootconf) {
++		bootconf_term = strchr(bootconf, '#');
++		if (bootconf_term)
++			*bootconf_term = '\0';
++	}
++
++	/* find configuration path in uImage.FIT */
++	config = fdt_path_offset(fit, FIT_CONFS_PATH);
++	if (config < 0) {
++		pr_err("FIT: Cannot find %s node: %d\n",
++			FIT_CONFS_PATH, config);
++		ret = -ENOENT;
++		goto out_bootconf;
++	}
++
++	/* get default configuration node name */
++	config_default =
++		fdt_getprop(fit, config, FIT_DEFAULT_PROP, &config_default_len);
++
++	/* make sure we got either default or selected boot config node name */
++	if (!config_default && !bootconf) {
++		pr_err("FIT: Cannot find default configuration\n");
++		ret = -ENOENT;
++		goto out_bootconf;
++	}
++
++	/* find selected boot config node, fallback on default config node */
++	node = fdt_subnode_offset(fit, config, bootconf ?: config_default);
++	if (node < 0) {
++		pr_err("FIT: Cannot find %s node: %d\n",
++			bootconf ?: config_default, node);
++		ret = -ENOENT;
++		goto out_bootconf;
++	}
++
++	pr_info("FIT: Detected U-Boot %s\n", ubootver);
++
++	/* get selected configuration data */
++	config_description =
++		fdt_getprop(fit, node, FIT_DESC_PROP, &config_description_len);
++	config_loadables = fdt_getprop(fit, node, FIT_LOADABLE_PROP,
++				       &config_loadables_len);
++
++	pr_info("FIT: %s configuration: \"%.*s\"%s%.*s%s\n",
++		bootconf ? "Selected" : "Default",
++		bootconf ? bootconf_len : config_default_len,
++		bootconf ?: config_default,
++		config_description ? " (" : "",
++		config_description ? config_description_len : 0,
++		config_description ?: "",
++		config_description ? ")" : "");
++
++	if (!config_loadables || !config_loadables_len) {
++		pr_err("FIT: No loadables configured in \"%s\"\n",
++			bootconf ?: config_default);
++		ret = -ENOENT;
++		goto out_bootconf;
++	}
++
++	/* get images path in uImage.FIT */
++	images = fdt_path_offset(fit, FIT_IMAGES_PATH);
++	if (images < 0) {
++		pr_err("FIT: Cannot find %s node: %d\n", FIT_IMAGES_PATH, images);
++		ret = -EINVAL;
++		goto out_bootconf;
++	}
++
++	/* iterate over images in uImage.FIT */
++	fdt_for_each_subnode(node, fit, images) {
++		image_name = fdt_get_name(fit, node, &image_name_len);
++		image_type = fdt_getprop(fit, node, FIT_TYPE_PROP, &image_type_len);
++		image_offset_be = fdt_getprop(fit, node, FIT_DATA_OFFSET_PROP, NULL);
++		image_pos_be = fdt_getprop(fit, node, FIT_DATA_POSITION_PROP, NULL);
++		image_len_be = fdt_getprop(fit, node, FIT_DATA_SIZE_PROP, NULL);
++
++		if (!image_name || !image_type || !image_len_be ||
++		    !image_name_len || !image_type_len)
++			continue;
++
++		image_len = be32_to_cpu(*image_len_be);
++		if (!image_len)
++			continue;
++
++		if (image_offset_be)
++			image_pos = be32_to_cpu(*image_offset_be) + size;
++		else if (image_pos_be)
++			image_pos = be32_to_cpu(*image_pos_be);
++		else
++			continue;
++
++		image_description = fdt_getprop(fit, node, FIT_DESC_PROP,
++						&image_description_len);
++
++		pr_info("FIT: %16s sub-image 0x%08x..0x%08x \"%.*s\"%s%.*s%s\n",
++			image_type, image_pos, image_pos + image_len - 1,
++			image_name_len, image_name, image_description ? " (" : "",
++			image_description ? image_description_len : 0,
++			image_description ?: "", image_description ? ") " : "");
++
++		/* only 'filesystem' images should be mapped as partitions */
++		if (strncmp(image_type, FIT_FILESYSTEM_PROP, image_type_len))
++			continue;
++
++		/* check if sub-image is part of configured loadables */
++		found = false;
++		loadable = config_loadables;
++		loadables_rem_len = config_loadables_len;
++		for (loadcnt = 0; loadables_rem_len > 1 &&
++				  loadcnt < MAX_FIT_LOADABLES; ++loadcnt) {
++			loadable_len =
++				strnlen(loadable, loadables_rem_len - 1) + 1;
++			loadables_rem_len -= loadable_len;
++			if (!strncmp(image_name, loadable, loadable_len)) {
++				found = true;
++				break;
++			}
++			loadable += loadable_len;
++		}
++		if (!found)
++			continue;
++
++		if (image_pos % (1 << PAGE_SHIFT)) {
++			dev_err(dev, "FIT: image %.*s start not aligned to page boundaries, skipping\n",
++				image_name_len, image_name);
++			continue;
++		}
++
++		if (image_len % (1 << PAGE_SHIFT)) {
++			dev_err(dev, "FIT: sub-image %.*s end not aligned to page boundaries, skipping\n",
++				image_name_len, image_name);
++			continue;
++		}
++
++		start_sect = image_pos >> SECTOR_SHIFT;
++		nr_sects = image_len >> SECTOR_SHIFT;
++		imgmaxsect = max_t(sector_t, imgmaxsect, start_sect + nr_sects);
++
++		if (start_sect + nr_sects > dsectors) {
++			dev_err(dev, "FIT: sub-image %.*s disk access beyond EOD\n",
++				image_name_len, image_name);
++			continue;
++		}
++
++		if (!slot) {
++			ret = sysfs_create_link_nowarn(&pdev->dev.kobj, bdev_kobj(bdev), "lower_dev");
++			if (ret && ret != -EEXIST)
++				goto out_bootconf;
++
++			ret = 0;
++		}
++
++		add_fit_subimage_device(bdev_file, slot++, start_sect, nr_sects, true);
++	}
++
++	if (!slot)
++		goto out_bootconf;
++
++	dev_info(dev, "mapped %u uImage.FIT filesystem sub-image%s as /dev/fit%s%u%s\n",
++		 slot, (slot > 1)?"s":"", (slot > 1)?"[0...":"", slot - 1,
++		 (slot > 1)?"]":"");
++
++	/* in case uImage.FIT is stored in a partition, map the remaining space */
++	if (!bdev_read_only(bdev) && bdev_is_partition(bdev) &&
++	    (imgmaxsect + MIN_FREE_SECT) < dsectors) {
++		add_fit_subimage_device(bdev_file, slot++, imgmaxsect,
++					dsectors - imgmaxsect, false);
++		dev_info(dev, "mapped remaining space as /dev/fitrw\n");
++	}
++
++out_bootconf:
++	kfree(bootconf);
++	kfree(fit);
++out_blkdev:
++	if (!slot)
++		fput(bdev_file);
++
++	return ret;
++}
++
++static int fitblk_match_of_node(struct device *dev, const void *np)
++{
++	int ret;
++
++	ret = device_match_of_node(dev, np);
++	if (ret)
++		return ret;
++
++	/*
++	 * To match ubiblock and mtdblock devices by their parent ubi
++	 * or mtd device, also consider block device parent
++	 */
++	if (!dev->parent)
++		return 0;
++
++	return device_match_of_node(dev->parent, np);
++}
++
++static int fitblk_probe(struct platform_device *pdev)
++{
++	struct device *dev;
++
++	dev = class_find_device(&block_class, NULL, rootdisk, fitblk_match_of_node);
++	if (!dev)
++		return -EPROBE_DEFER;
++
++	return parse_fit_on_dev(dev);
++}
++
++static struct platform_driver fitblk_driver = {
++	.probe		= fitblk_probe,
++	.driver		= {
++		.name   = "fitblk",
++	},
++};
++
++static int __init fitblk_init(void)
++{
++	/* detect U-Boot firmware */
++	ubootver = of_get_property(of_chosen, "u-boot,version", NULL);
++	if (!ubootver)
++		return 0;
++
++	/* parse 'rootdisk' property phandle */
++	rootdisk = of_parse_phandle(of_chosen, "rootdisk", 0);
++	if (!rootdisk)
++		return 0;
++
++	if (platform_driver_register(&fitblk_driver))
++		return -ENODEV;
++
++	refcount_set(&num_devs, 1);
++	pdev = platform_device_register_simple("fitblk", -1, NULL, 0);
++	if (IS_ERR(pdev))
++		return PTR_ERR(pdev);
++
++	return 0;
++}
++device_initcall(fitblk_init);
+--- /dev/null
++++ b/include/uapi/linux/fitblk.h
+@@ -0,0 +1,10 @@
++/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
++#ifndef _UAPI_LINUX_FITBLK_H
++#define _UAPI_LINUX_FITBLK_H
++
++/*
++ * IOCTL commands --- we will commandeer 0x46 ('F')
++ */
++#define FITBLK_RELEASE             0x4600
++
++#endif /* _UAPI_LINUX_FITBLK_H */
diff --git a/target/linux/generic/pending-6.12/511-init-bypass-device-lookup-for-dev-fit-rootfs.patch b/target/linux/generic/pending-6.12/511-init-bypass-device-lookup-for-dev-fit-rootfs.patch
new file mode 100644
index 0000000000..b3d8d7dd0c
--- /dev/null
+++ b/target/linux/generic/pending-6.12/511-init-bypass-device-lookup-for-dev-fit-rootfs.patch
@@ -0,0 +1,25 @@
+From 5ede3f8aed9a1a579bf7304142600d1f3500add9 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Mon, 12 Jun 2023 03:58:42 +0100
+Subject: [PATCH 2/2] init: bypass device lookup for /dev/fit* rootfs
+
+Allow 'rootwait' as /dev/fit* can show up late if the underlaying
+device is probed late.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ init/do_mounts.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/init/do_mounts.c
++++ b/init/do_mounts.c
+@@ -465,7 +465,8 @@ static dev_t __init parse_root_device(ch
+ 	int error;
+ 	dev_t dev;
+ 
+-	if (!strncmp(root_device_name, "mtd", 3) ||
++	if (!strncmp(root_device_name, "fit", 3) ||
++	    !strncmp(root_device_name, "mtd", 3) ||
+ 	    !strncmp(root_device_name, "ubi", 3))
+ 		return Root_Generic;
+ 	if (strcmp(root_device_name, "/dev/nfs") == 0)
diff --git a/target/linux/generic/pending-6.12/530-jffs2_make_lzma_available.patch b/target/linux/generic/pending-6.12/530-jffs2_make_lzma_available.patch
new file mode 100644
index 0000000000..213e6f1f24
--- /dev/null
+++ b/target/linux/generic/pending-6.12/530-jffs2_make_lzma_available.patch
@@ -0,0 +1,5190 @@
+From: Alexandros C. Couloumbis <alex@ozo.com>
+Subject: fs: add jffs2/lzma support (not activated by default yet)
+
+lede-commit: c2c88d315fa0e881f8b19da07b62859b915b11b2
+Signed-off-by: Alexandros C. Couloumbis <alex@ozo.com>
+---
+ fs/jffs2/Kconfig             |    9 +
+ fs/jffs2/Makefile            |    3 +
+ fs/jffs2/compr.c             |    6 +
+ fs/jffs2/compr.h             |   10 +-
+ fs/jffs2/compr_lzma.c        |  128 +++
+ fs/jffs2/super.c             |   33 +-
+ include/linux/lzma.h         |   62 ++
+ include/linux/lzma/LzFind.h  |  115 +++
+ include/linux/lzma/LzHash.h  |   54 +
+ include/linux/lzma/LzmaDec.h |  231 +++++
+ include/linux/lzma/LzmaEnc.h |   80 ++
+ include/linux/lzma/Types.h   |  226 +++++
+ include/uapi/linux/jffs2.h   |    1 +
+ lib/Kconfig                  |    6 +
+ lib/Makefile                 |   12 +
+ lib/lzma/LzFind.c            |  761 ++++++++++++++
+ lib/lzma/LzmaDec.c           |  999 +++++++++++++++++++
+ lib/lzma/LzmaEnc.c           | 2271 ++++++++++++++++++++++++++++++++++++++++++
+ lib/lzma/Makefile            |    7 +
+ 19 files changed, 5008 insertions(+), 6 deletions(-)
+ create mode 100644 fs/jffs2/compr_lzma.c
+ create mode 100644 include/linux/lzma.h
+ create mode 100644 include/linux/lzma/LzFind.h
+ create mode 100644 include/linux/lzma/LzHash.h
+ create mode 100644 include/linux/lzma/LzmaDec.h
+ create mode 100644 include/linux/lzma/LzmaEnc.h
+ create mode 100644 include/linux/lzma/Types.h
+ create mode 100644 lib/lzma/LzFind.c
+ create mode 100644 lib/lzma/LzmaDec.c
+ create mode 100644 lib/lzma/LzmaEnc.c
+ create mode 100644 lib/lzma/Makefile
+
+--- a/fs/jffs2/Kconfig
++++ b/fs/jffs2/Kconfig
+@@ -136,6 +136,15 @@ config JFFS2_LZO
+ 	  This feature was added in July, 2007. Say 'N' if you need
+ 	  compatibility with older bootloaders or kernels.
+ 
++config JFFS2_LZMA
++	bool "JFFS2 LZMA compression support" if JFFS2_COMPRESSION_OPTIONS
++	select LZMA_COMPRESS
++	select LZMA_DECOMPRESS
++	depends on JFFS2_FS
++	default n
++	help
++	  JFFS2 wrapper to the LZMA C SDK
++
+ config JFFS2_RTIME
+ 	bool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS
+ 	depends on JFFS2_FS
+--- a/fs/jffs2/Makefile
++++ b/fs/jffs2/Makefile
+@@ -19,4 +19,7 @@ jffs2-$(CONFIG_JFFS2_RUBIN)	+= compr_rub
+ jffs2-$(CONFIG_JFFS2_RTIME)	+= compr_rtime.o
+ jffs2-$(CONFIG_JFFS2_ZLIB)	+= compr_zlib.o
+ jffs2-$(CONFIG_JFFS2_LZO)	+= compr_lzo.o
++jffs2-$(CONFIG_JFFS2_LZMA)	+= compr_lzma.o
+ jffs2-$(CONFIG_JFFS2_SUMMARY)   += summary.o
++
++CFLAGS_compr_lzma.o += -Iinclude/linux -Ilib/lzma
+--- a/fs/jffs2/compr.c
++++ b/fs/jffs2/compr.c
+@@ -381,6 +381,9 @@ int __init jffs2_compressors_init(void)
+ 	ret = jffs2_lzo_init();
+ 	if (ret)
+ 		goto exit_dynrubin;
++	ret = jffs2_lzma_init();
++	if (ret)
++		goto exit_lzo;
+ 
+ 
+ /* Setting default compression mode */
+@@ -402,6 +405,8 @@ int __init jffs2_compressors_init(void)
+ #endif
+ 	return 0;
+ 
++exit_lzo:
++	jffs2_lzo_exit();
+ exit_dynrubin:
+ 	jffs2_dynrubin_exit();
+ exit_runinmips:
+@@ -417,6 +422,7 @@ exit:
+ int jffs2_compressors_exit(void)
+ {
+ /* Unregistering compressors */
++	jffs2_lzma_exit();
+ 	jffs2_lzo_exit();
+ 	jffs2_dynrubin_exit();
+ 	jffs2_rubinmips_exit();
+--- a/fs/jffs2/compr.h
++++ b/fs/jffs2/compr.h
+@@ -29,9 +29,9 @@
+ #define JFFS2_DYNRUBIN_PRIORITY  20
+ #define JFFS2_LZARI_PRIORITY     30
+ #define JFFS2_RTIME_PRIORITY     50
+-#define JFFS2_ZLIB_PRIORITY      60
+-#define JFFS2_LZO_PRIORITY       80
+-
++#define JFFS2_LZMA_PRIORITY      70
++#define JFFS2_ZLIB_PRIORITY      80
++#define JFFS2_LZO_PRIORITY       90
+ 
+ #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
+ #define JFFS2_DYNRUBIN_DISABLED  /*	   for decompression */
+@@ -115,5 +115,12 @@ extern void jffs2_lzo_exit(void);
+ static inline int jffs2_lzo_init(void) { return 0; }
+ static inline void jffs2_lzo_exit(void) {}
+ #endif
++#ifdef CONFIG_JFFS2_LZMA
++extern int jffs2_lzma_init(void);
++extern void jffs2_lzma_exit(void);
++#else
++static inline int jffs2_lzma_init(void) { return 0; }
++static inline void jffs2_lzma_exit(void) {}
++#endif
+ 
+ #endif /* __JFFS2_COMPR_H__ */
+--- /dev/null
++++ b/fs/jffs2/compr_lzma.c
+@@ -0,0 +1,128 @@
++/*
++ * JFFS2 -- Journalling Flash File System, Version 2.
++ *
++ * For licensing information, see the file 'LICENCE' in this directory.
++ *
++ * JFFS2 wrapper to the LZMA C SDK
++ *
++ */
++
++#include <linux/lzma.h>
++#include "compr.h"
++
++#ifdef __KERNEL__
++	static DEFINE_MUTEX(deflate_mutex);
++#endif
++
++CLzmaEncHandle *p;
++Byte propsEncoded[LZMA_PROPS_SIZE];
++SizeT propsSize = sizeof(propsEncoded);
++
++STATIC void lzma_free_workspace(void)
++{
++	LzmaEnc_Destroy(p, &lzma_alloc, &lzma_alloc);
++}
++
++STATIC int INIT lzma_alloc_workspace(CLzmaEncProps *props)
++{
++	if ((p = (CLzmaEncHandle *)LzmaEnc_Create(&lzma_alloc)) == NULL)
++	{
++		PRINT_ERROR("Failed to allocate lzma deflate workspace\n");
++		return -ENOMEM;
++	}
++
++	if (LzmaEnc_SetProps(p, props) != SZ_OK)
++	{
++		lzma_free_workspace();
++		return -1;
++	}
++
++	if (LzmaEnc_WriteProperties(p, propsEncoded, &propsSize) != SZ_OK)
++	{
++		lzma_free_workspace();
++		return -1;
++	}
++
++	return 0;
++}
++
++STATIC int jffs2_lzma_compress(unsigned char *data_in, unsigned char *cpage_out,
++			      uint32_t *sourcelen, uint32_t *dstlen)
++{
++	SizeT compress_size = (SizeT)(*dstlen);
++	int ret;
++
++	#ifdef __KERNEL__
++		mutex_lock(&deflate_mutex);
++	#endif
++
++	ret = LzmaEnc_MemEncode(p, cpage_out, &compress_size, data_in, *sourcelen,
++		0, NULL, &lzma_alloc, &lzma_alloc);
++
++	#ifdef __KERNEL__
++		mutex_unlock(&deflate_mutex);
++	#endif
++
++	if (ret != SZ_OK)
++		return -1;
++
++	*dstlen = (uint32_t)compress_size;
++
++	return 0;
++}
++
++STATIC int jffs2_lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
++				 uint32_t srclen, uint32_t destlen)
++{
++	int ret;
++	SizeT dl = (SizeT)destlen;
++	SizeT sl = (SizeT)srclen;
++	ELzmaStatus status;
++
++	ret = LzmaDecode(cpage_out, &dl, data_in, &sl, propsEncoded,
++		propsSize, LZMA_FINISH_ANY, &status, &lzma_alloc);
++
++	if (ret != SZ_OK || status == LZMA_STATUS_NOT_FINISHED || dl != (SizeT)destlen)
++		return -1;
++
++	return 0;
++}
++
++static struct jffs2_compressor jffs2_lzma_comp = {
++	.priority = JFFS2_LZMA_PRIORITY,
++	.name = "lzma",
++	.compr = JFFS2_COMPR_LZMA,
++	.compress = &jffs2_lzma_compress,
++	.decompress = &jffs2_lzma_decompress,
++	.disabled = 0,
++};
++
++int INIT jffs2_lzma_init(void)
++{
++	int ret;
++	CLzmaEncProps props;
++	LzmaEncProps_Init(&props);
++
++	props.dictSize = LZMA_BEST_DICT(0x2000);
++	props.level = LZMA_BEST_LEVEL;
++	props.lc = LZMA_BEST_LC;
++	props.lp = LZMA_BEST_LP;
++	props.pb = LZMA_BEST_PB;
++	props.fb = LZMA_BEST_FB;
++
++	ret = lzma_alloc_workspace(&props);
++	if (ret < 0)
++		return ret;
++
++	ret = jffs2_register_compressor(&jffs2_lzma_comp);
++	if (ret)
++		lzma_free_workspace();
++
++	return ret;
++}
++
++void jffs2_lzma_exit(void)
++{
++	jffs2_unregister_compressor(&jffs2_lzma_comp);
++	lzma_free_workspace();
++}
+--- a/fs/jffs2/super.c
++++ b/fs/jffs2/super.c
+@@ -376,14 +376,41 @@ static int __init init_jffs2_fs(void)
+ 	BUILD_BUG_ON(sizeof(struct jffs2_raw_inode) != 68);
+ 	BUILD_BUG_ON(sizeof(struct jffs2_raw_summary) != 32);
+ 
+-	pr_info("version 2.2."
++	pr_info("version 2.2"
+ #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
+ 	       " (NAND)"
+ #endif
+ #ifdef CONFIG_JFFS2_SUMMARY
+-	       " (SUMMARY) "
++	       " (SUMMARY)"
+ #endif
+-	       " © 2001-2006 Red Hat, Inc.\n");
++#ifdef CONFIG_JFFS2_ZLIB
++	       " (ZLIB)"
++#endif
++#ifdef CONFIG_JFFS2_LZO
++	       " (LZO)"
++#endif
++#ifdef CONFIG_JFFS2_LZMA
++	       " (LZMA)"
++#endif
++#ifdef CONFIG_JFFS2_RTIME
++	       " (RTIME)"
++#endif
++#ifdef CONFIG_JFFS2_RUBIN
++	       " (RUBIN)"
++#endif
++#ifdef  CONFIG_JFFS2_CMODE_NONE
++	       " (CMODE_NONE)"
++#endif
++#ifdef CONFIG_JFFS2_CMODE_PRIORITY
++	       " (CMODE_PRIORITY)"
++#endif
++#ifdef CONFIG_JFFS2_CMODE_SIZE
++	       " (CMODE_SIZE)"
++#endif
++#ifdef CONFIG_JFFS2_CMODE_FAVOURLZO
++	       " (CMODE_FAVOURLZO)"
++#endif
++	       " (c) 2001-2006 Red Hat, Inc.\n");
+ 
+ 	jffs2_inode_cachep = kmem_cache_create("jffs2_i",
+ 					     sizeof(struct jffs2_inode_info),
+--- /dev/null
++++ b/include/linux/lzma.h
+@@ -0,0 +1,62 @@
++#ifndef __LZMA_H__
++#define __LZMA_H__
++
++#ifdef __KERNEL__
++	#include <linux/kernel.h>
++	#include <linux/sched.h>
++	#include <linux/slab.h>
++	#include <linux/vmalloc.h>
++	#include <linux/init.h>
++	#define LZMA_MALLOC vmalloc
++	#define LZMA_FREE vfree
++	#define PRINT_ERROR(msg) printk(KERN_WARNING #msg)
++	#define INIT __init
++	#define STATIC static
++#else
++	#include <stdint.h>
++	#include <stdlib.h>
++	#include <stdio.h>
++	#include <unistd.h>
++	#include <string.h>
++	#include <asm/types.h>
++	#include <errno.h>
++	#include <linux/jffs2.h>
++	#ifndef PAGE_SIZE
++		extern int page_size;
++		#define PAGE_SIZE page_size
++	#endif
++	#define LZMA_MALLOC malloc
++	#define LZMA_FREE free
++	#define PRINT_ERROR(msg) fprintf(stderr, msg)
++	#define INIT
++	#define STATIC
++#endif
++
++#include "lzma/LzmaDec.h"
++#include "lzma/LzmaEnc.h"
++
++#define LZMA_BEST_LEVEL (9)
++#define LZMA_BEST_LC    (0)
++#define LZMA_BEST_LP    (0)
++#define LZMA_BEST_PB    (0)
++#define LZMA_BEST_FB  (273)
++
++#define LZMA_BEST_DICT(n) (((int)((n) / 2)) * 2)
++
++static void *p_lzma_malloc(void *p, size_t size)
++{
++	if (size == 0)
++		return NULL;
++
++	return LZMA_MALLOC(size);
++}
++
++static void p_lzma_free(void *p, void *address)
++{
++	if (address != NULL)
++		LZMA_FREE(address);
++}
++
++static ISzAlloc lzma_alloc = { .Alloc = p_lzma_malloc, .Free = p_lzma_free };
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/LzFind.h
+@@ -0,0 +1,115 @@
++/* LzFind.h -- Match finder for LZ algorithms
++2009-04-22 : Igor Pavlov : Public domain */
++
++#ifndef __LZ_FIND_H
++#define __LZ_FIND_H
++
++#include "Types.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++typedef UInt32 CLzRef;
++
++typedef struct _CMatchFinder
++{
++  Byte *buffer;
++  UInt32 pos;
++  UInt32 posLimit;
++  UInt32 streamPos;
++  UInt32 lenLimit;
++
++  UInt32 cyclicBufferPos;
++  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
++
++  UInt32 matchMaxLen;
++  CLzRef *hash;
++  CLzRef *son;
++  UInt32 hashMask;
++  UInt32 cutValue;
++
++  Byte *bufferBase;
++  ISeqInStream *stream;
++  int streamEndWasReached;
++
++  UInt32 blockSize;
++  UInt32 keepSizeBefore;
++  UInt32 keepSizeAfter;
++
++  UInt32 numHashBytes;
++  int directInput;
++  size_t directInputRem;
++  int btMode;
++  int bigHash;
++  UInt32 historySize;
++  UInt32 fixedHashSize;
++  UInt32 hashSizeSum;
++  UInt32 numSons;
++  SRes result;
++  UInt32 crc[256];
++} CMatchFinder;
++
++#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
++#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
++
++#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
++
++int MatchFinder_NeedMove(CMatchFinder *p);
++Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
++void MatchFinder_MoveBlock(CMatchFinder *p);
++void MatchFinder_ReadIfRequired(CMatchFinder *p);
++
++void MatchFinder_Construct(CMatchFinder *p);
++
++/* Conditions:
++     historySize <= 3 GB
++     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
++*/
++int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
++    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
++    ISzAlloc *alloc);
++void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
++void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
++void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
++
++UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
++    UInt32 *distances, UInt32 maxLen);
++
++/*
++Conditions:
++  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
++  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
++*/
++
++typedef void (*Mf_Init_Func)(void *object);
++typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
++typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
++typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
++typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
++typedef void (*Mf_Skip_Func)(void *object, UInt32);
++
++typedef struct _IMatchFinder
++{
++  Mf_Init_Func Init;
++  Mf_GetIndexByte_Func GetIndexByte;
++  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
++  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
++  Mf_GetMatches_Func GetMatches;
++  Mf_Skip_Func Skip;
++} IMatchFinder;
++
++void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
++
++void MatchFinder_Init(CMatchFinder *p);
++UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
++UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
++void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
++void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/LzHash.h
+@@ -0,0 +1,54 @@
++/* LzHash.h -- HASH functions for LZ algorithms
++2009-02-07 : Igor Pavlov : Public domain */
++
++#ifndef __LZ_HASH_H
++#define __LZ_HASH_H
++
++#define kHash2Size (1 << 10)
++#define kHash3Size (1 << 16)
++#define kHash4Size (1 << 20)
++
++#define kFix3HashSize (kHash2Size)
++#define kFix4HashSize (kHash2Size + kHash3Size)
++#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
++
++#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);
++
++#define HASH3_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
++
++#define HASH4_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
++  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
++
++#define HASH5_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
++  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
++  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
++  hash4Value &= (kHash4Size - 1); }
++
++/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
++#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
++
++
++#define MT_HASH2_CALC \
++  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
++
++#define MT_HASH3_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
++
++#define MT_HASH4_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
++  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/LzmaDec.h
+@@ -0,0 +1,231 @@
++/* LzmaDec.h -- LZMA Decoder
++2009-02-07 : Igor Pavlov : Public domain */
++
++#ifndef __LZMA_DEC_H
++#define __LZMA_DEC_H
++
++#include "Types.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++/* #define _LZMA_PROB32 */
++/* _LZMA_PROB32 can increase the speed on some CPUs,
++   but memory usage for CLzmaDec::probs will be doubled in that case */
++
++#ifdef _LZMA_PROB32
++#define CLzmaProb UInt32
++#else
++#define CLzmaProb UInt16
++#endif
++
++
++/* ---------- LZMA Properties ---------- */
++
++#define LZMA_PROPS_SIZE 5
++
++typedef struct _CLzmaProps
++{
++  unsigned lc, lp, pb;
++  UInt32 dicSize;
++} CLzmaProps;
++
++/* LzmaProps_Decode - decodes properties
++Returns:
++  SZ_OK
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++*/
++
++SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
++
++
++/* ---------- LZMA Decoder state ---------- */
++
++/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
++   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
++
++#define LZMA_REQUIRED_INPUT_MAX 20
++
++typedef struct
++{
++  CLzmaProps prop;
++  CLzmaProb *probs;
++  Byte *dic;
++  const Byte *buf;
++  UInt32 range, code;
++  SizeT dicPos;
++  SizeT dicBufSize;
++  UInt32 processedPos;
++  UInt32 checkDicSize;
++  unsigned state;
++  UInt32 reps[4];
++  unsigned remainLen;
++  int needFlush;
++  int needInitState;
++  UInt32 numProbs;
++  unsigned tempBufSize;
++  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
++} CLzmaDec;
++
++#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
++
++void LzmaDec_Init(CLzmaDec *p);
++
++/* There are two types of LZMA streams:
++     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
++     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
++
++typedef enum
++{
++  LZMA_FINISH_ANY,   /* finish at any point */
++  LZMA_FINISH_END    /* block must be finished at the end */
++} ELzmaFinishMode;
++
++/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
++
++   You must use LZMA_FINISH_END, when you know that current output buffer
++   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
++
++   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
++   and output value of destLen will be less than output buffer size limit.
++   You can check status result also.
++
++   You can use multiple checks to test data integrity after full decompression:
++     1) Check Result and "status" variable.
++     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
++     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
++        You must use correct finish mode in that case. */
++
++typedef enum
++{
++  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
++  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
++  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
++  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
++  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
++} ELzmaStatus;
++
++/* ELzmaStatus is used only as output value for function call */
++
++
++/* ---------- Interfaces ---------- */
++
++/* There are 3 levels of interfaces:
++     1) Dictionary Interface
++     2) Buffer Interface
++     3) One Call Interface
++   You can select any of these interfaces, but don't mix functions from different
++   groups for same object. */
++
++
++/* There are two variants to allocate state for Dictionary Interface:
++     1) LzmaDec_Allocate / LzmaDec_Free
++     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
++   You can use variant 2, if you set dictionary buffer manually.
++   For Buffer Interface you must always use variant 1.
++
++LzmaDec_Allocate* can return:
++  SZ_OK
++  SZ_ERROR_MEM         - Memory allocation error
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++*/
++
++SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
++void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
++
++SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
++void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
++
++/* ---------- Dictionary Interface ---------- */
++
++/* You can use it, if you want to eliminate the overhead for data copying from
++   dictionary to some other external buffer.
++   You must work with CLzmaDec variables directly in this interface.
++
++   STEPS:
++     LzmaDec_Constr()
++     LzmaDec_Allocate()
++     for (each new stream)
++     {
++       LzmaDec_Init()
++       while (it needs more decompression)
++       {
++         LzmaDec_DecodeToDic()
++         use data from CLzmaDec::dic and update CLzmaDec::dicPos
++       }
++     }
++     LzmaDec_Free()
++*/
++
++/* LzmaDec_DecodeToDic
++
++   The decoding to internal dictionary buffer (CLzmaDec::dic).
++   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (dicLimit).
++  LZMA_FINISH_ANY - Decode just dicLimit bytes.
++  LZMA_FINISH_END - Stream must be finished after dicLimit.
++
++Returns:
++  SZ_OK
++    status:
++      LZMA_STATUS_FINISHED_WITH_MARK
++      LZMA_STATUS_NOT_FINISHED
++      LZMA_STATUS_NEEDS_MORE_INPUT
++      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
++  SZ_ERROR_DATA - Data error
++*/
++
++SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
++    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
++
++
++/* ---------- Buffer Interface ---------- */
++
++/* It's zlib-like interface.
++   See LzmaDec_DecodeToDic description for information about STEPS and return results,
++   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
++   to work with CLzmaDec variables manually.
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (*destLen).
++  LZMA_FINISH_ANY - Decode just destLen bytes.
++  LZMA_FINISH_END - Stream must be finished after (*destLen).
++*/
++
++SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
++    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
++
++
++/* ---------- One Call Interface ---------- */
++
++/* LzmaDecode
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (*destLen).
++  LZMA_FINISH_ANY - Decode just destLen bytes.
++  LZMA_FINISH_END - Stream must be finished after (*destLen).
++
++Returns:
++  SZ_OK
++    status:
++      LZMA_STATUS_FINISHED_WITH_MARK
++      LZMA_STATUS_NOT_FINISHED
++      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
++  SZ_ERROR_DATA - Data error
++  SZ_ERROR_MEM  - Memory allocation error
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
++*/
++
++SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
++    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
++    ELzmaStatus *status, ISzAlloc *alloc);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/LzmaEnc.h
+@@ -0,0 +1,80 @@
++/*  LzmaEnc.h -- LZMA Encoder
++2009-02-07 : Igor Pavlov : Public domain */
++
++#ifndef __LZMA_ENC_H
++#define __LZMA_ENC_H
++
++#include "Types.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++#define LZMA_PROPS_SIZE 5
++
++typedef struct _CLzmaEncProps
++{
++  int level;       /*  0 <= level <= 9 */
++  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
++                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
++                       default = (1 << 24) */
++  int lc;          /* 0 <= lc <= 8, default = 3 */
++  int lp;          /* 0 <= lp <= 4, default = 0 */
++  int pb;          /* 0 <= pb <= 4, default = 2 */
++  int algo;        /* 0 - fast, 1 - normal, default = 1 */
++  int fb;          /* 5 <= fb <= 273, default = 32 */
++  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
++  int numHashBytes; /* 2, 3 or 4, default = 4 */
++  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
++  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
++  int numThreads;  /* 1 or 2, default = 2 */
++} CLzmaEncProps;
++
++void LzmaEncProps_Init(CLzmaEncProps *p);
++void LzmaEncProps_Normalize(CLzmaEncProps *p);
++UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
++
++
++/* ---------- CLzmaEncHandle Interface ---------- */
++
++/* LzmaEnc_* functions can return the following exit codes:
++Returns:
++  SZ_OK           - OK
++  SZ_ERROR_MEM    - Memory allocation error
++  SZ_ERROR_PARAM  - Incorrect paramater in props
++  SZ_ERROR_WRITE  - Write callback error.
++  SZ_ERROR_PROGRESS - some break from progress callback
++  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
++*/
++
++typedef void * CLzmaEncHandle;
++
++CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
++void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
++SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
++SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
++SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++
++/* ---------- One Call Interface ---------- */
++
++/* LzmaEncode
++Return code:
++  SZ_OK               - OK
++  SZ_ERROR_MEM        - Memory allocation error
++  SZ_ERROR_PARAM      - Incorrect paramater
++  SZ_ERROR_OUTPUT_EOF - output buffer overflow
++  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
++*/
++
++SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+--- /dev/null
++++ b/include/linux/lzma/Types.h
+@@ -0,0 +1,226 @@
++/* Types.h -- Basic types
++2009-11-23 : Igor Pavlov : Public domain */
++
++#ifndef __7Z_TYPES_H
++#define __7Z_TYPES_H
++
++#include <stddef.h>
++
++#ifdef _WIN32
++#include <windows.h>
++#endif
++
++#ifndef EXTERN_C_BEGIN
++#ifdef __cplusplus
++#define EXTERN_C_BEGIN extern "C" {
++#define EXTERN_C_END }
++#else
++#define EXTERN_C_BEGIN
++#define EXTERN_C_END
++#endif
++#endif
++
++EXTERN_C_BEGIN
++
++#define SZ_OK 0
++
++#define SZ_ERROR_DATA 1
++#define SZ_ERROR_MEM 2
++#define SZ_ERROR_CRC 3
++#define SZ_ERROR_UNSUPPORTED 4
++#define SZ_ERROR_PARAM 5
++#define SZ_ERROR_INPUT_EOF 6
++#define SZ_ERROR_OUTPUT_EOF 7
++#define SZ_ERROR_READ 8
++#define SZ_ERROR_WRITE 9
++#define SZ_ERROR_PROGRESS 10
++#define SZ_ERROR_FAIL 11
++#define SZ_ERROR_THREAD 12
++
++#define SZ_ERROR_ARCHIVE 16
++#define SZ_ERROR_NO_ARCHIVE 17
++
++typedef int SRes;
++
++#ifdef _WIN32
++typedef DWORD WRes;
++#else
++typedef int WRes;
++#endif
++
++#ifndef RINOK
++#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
++#endif
++
++typedef unsigned char Byte;
++typedef short Int16;
++typedef unsigned short UInt16;
++
++#ifdef _LZMA_UINT32_IS_ULONG
++typedef long Int32;
++typedef unsigned long UInt32;
++#else
++typedef int Int32;
++typedef unsigned int UInt32;
++#endif
++
++#ifdef _SZ_NO_INT_64
++
++/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
++   NOTES: Some code will work incorrectly in that case! */
++
++typedef long Int64;
++typedef unsigned long UInt64;
++
++#else
++
++#if defined(_MSC_VER) || defined(__BORLANDC__)
++typedef __int64 Int64;
++typedef unsigned __int64 UInt64;
++#else
++typedef long long int Int64;
++typedef unsigned long long int UInt64;
++#endif
++
++#endif
++
++#ifdef _LZMA_NO_SYSTEM_SIZE_T
++typedef UInt32 SizeT;
++#else
++typedef size_t SizeT;
++#endif
++
++typedef int Bool;
++#define True 1
++#define False 0
++
++
++#ifdef _WIN32
++#define MY_STD_CALL __stdcall
++#else
++#define MY_STD_CALL
++#endif
++
++#ifdef _MSC_VER
++
++#if _MSC_VER >= 1300
++#define MY_NO_INLINE __declspec(noinline)
++#else
++#define MY_NO_INLINE
++#endif
++
++#define MY_CDECL __cdecl
++#define MY_FAST_CALL __fastcall
++
++#else
++
++#define MY_CDECL
++#define MY_FAST_CALL
++
++#endif
++
++
++/* The following interfaces use first parameter as pointer to structure */
++
++typedef struct
++{
++  SRes (*Read)(void *p, void *buf, size_t *size);
++    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
++       (output(*size) < input(*size)) is allowed */
++} ISeqInStream;
++
++/* it can return SZ_ERROR_INPUT_EOF */
++SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
++SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
++SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
++
++typedef struct
++{
++  size_t (*Write)(void *p, const void *buf, size_t size);
++    /* Returns: result - the number of actually written bytes.
++       (result < size) means error */
++} ISeqOutStream;
++
++typedef enum
++{
++  SZ_SEEK_SET = 0,
++  SZ_SEEK_CUR = 1,
++  SZ_SEEK_END = 2
++} ESzSeek;
++
++typedef struct
++{
++  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
++  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
++} ISeekInStream;
++
++typedef struct
++{
++  SRes (*Look)(void *p, void **buf, size_t *size);
++    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
++       (output(*size) > input(*size)) is not allowed
++       (output(*size) < input(*size)) is allowed */
++  SRes (*Skip)(void *p, size_t offset);
++    /* offset must be <= output(*size) of Look */
++
++  SRes (*Read)(void *p, void *buf, size_t *size);
++    /* reads directly (without buffer). It's same as ISeqInStream::Read */
++  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
++} ILookInStream;
++
++SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
++SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
++
++/* reads via ILookInStream::Read */
++SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
++SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
++
++#define LookToRead_BUF_SIZE (1 << 14)
++
++typedef struct
++{
++  ILookInStream s;
++  ISeekInStream *realStream;
++  size_t pos;
++  size_t size;
++  Byte buf[LookToRead_BUF_SIZE];
++} CLookToRead;
++
++void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
++void LookToRead_Init(CLookToRead *p);
++
++typedef struct
++{
++  ISeqInStream s;
++  ILookInStream *realStream;
++} CSecToLook;
++
++void SecToLook_CreateVTable(CSecToLook *p);
++
++typedef struct
++{
++  ISeqInStream s;
++  ILookInStream *realStream;
++} CSecToRead;
++
++void SecToRead_CreateVTable(CSecToRead *p);
++
++typedef struct
++{
++  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
++    /* Returns: result. (result != SZ_OK) means break.
++       Value (UInt64)(Int64)-1 for size means unknown value. */
++} ICompressProgress;
++
++typedef struct
++{
++  void *(*Alloc)(void *p, size_t size);
++  void (*Free)(void *p, void *address); /* address can be 0 */
++} ISzAlloc;
++
++#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
++#define IAlloc_Free(p, a) (p)->Free((p), a)
++
++EXTERN_C_END
++
++#endif
+--- a/include/uapi/linux/jffs2.h
++++ b/include/uapi/linux/jffs2.h
+@@ -46,6 +46,7 @@
+ #define JFFS2_COMPR_DYNRUBIN	0x05
+ #define JFFS2_COMPR_ZLIB	0x06
+ #define JFFS2_COMPR_LZO		0x07
++#define JFFS2_COMPR_LZMA	0x08
+ /* Compatibility flags. */
+ #define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
+ #define JFFS2_NODE_ACCURATE 0x2000
+--- a/lib/Kconfig
++++ b/lib/Kconfig
+@@ -353,6 +353,12 @@ config ZSTD_DECOMPRESS
+ 
+ source "lib/xz/Kconfig"
+ 
++config LZMA_COMPRESS
++    tristate
++
++config LZMA_DECOMPRESS
++    tristate
++
+ #
+ # These all provide a common interface (hence the apparent duplication with
+ # ZLIB_INFLATE; DECOMPRESS_GZIP is just a wrapper.)
+--- a/lib/Makefile
++++ b/lib/Makefile
+@@ -126,6 +126,16 @@ CFLAGS_kobject.o += -DDEBUG
+ CFLAGS_kobject_uevent.o += -DDEBUG
+ endif
+ 
++ifdef CONFIG_JFFS2_ZLIB
++  CONFIG_ZLIB_INFLATE:=y
++  CONFIG_ZLIB_DEFLATE:=y
++endif
++
++ifdef CONFIG_JFFS2_LZMA
++  CONFIG_LZMA_DECOMPRESS:=y
++  CONFIG_LZMA_COMPRESS:=y
++endif
++
+ obj-$(CONFIG_DEBUG_INFO_REDUCED) += debug_info.o
+ CFLAGS_debug_info.o += $(call cc-option, -femit-struct-debug-detailed=any)
+ 
+@@ -185,6 +195,8 @@ obj-$(CONFIG_ZSTD_COMPRESS) += zstd/
+ obj-$(CONFIG_ZSTD_DECOMPRESS) += zstd/
+ obj-$(CONFIG_XZ_DEC) += xz/
+ obj-$(CONFIG_RAID6_PQ) += raid6/
++obj-$(CONFIG_LZMA_COMPRESS) += lzma/
++obj-$(CONFIG_LZMA_DECOMPRESS) += lzma/
+ 
+ lib-$(CONFIG_DECOMPRESS_GZIP) += decompress_inflate.o
+ lib-$(CONFIG_DECOMPRESS_BZIP2) += decompress_bunzip2.o
+--- /dev/null
++++ b/lib/lzma/LzFind.c
+@@ -0,0 +1,761 @@
++/* LzFind.c -- Match finder for LZ algorithms
++2009-04-22 : Igor Pavlov : Public domain */
++
++#include <string.h>
++
++#include "LzFind.h"
++#include "LzHash.h"
++
++#define kEmptyHashValue 0
++#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
++#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
++#define kNormalizeMask (~(kNormalizeStepMin - 1))
++#define kMaxHistorySize ((UInt32)3 << 30)
++
++#define kStartMaxLen 3
++
++static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
++{
++  if (!p->directInput)
++  {
++    alloc->Free(alloc, p->bufferBase);
++    p->bufferBase = 0;
++  }
++}
++
++/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
++
++static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
++{
++  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
++  if (p->directInput)
++  {
++    p->blockSize = blockSize;
++    return 1;
++  }
++  if (p->bufferBase == 0 || p->blockSize != blockSize)
++  {
++    LzInWindow_Free(p, alloc);
++    p->blockSize = blockSize;
++    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
++  }
++  return (p->bufferBase != 0);
++}
++
++Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
++static Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
++
++static UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
++
++void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
++{
++  p->posLimit -= subValue;
++  p->pos -= subValue;
++  p->streamPos -= subValue;
++}
++
++static void MatchFinder_ReadBlock(CMatchFinder *p)
++{
++  if (p->streamEndWasReached || p->result != SZ_OK)
++    return;
++  if (p->directInput)
++  {
++    UInt32 curSize = 0xFFFFFFFF - p->streamPos;
++    if (curSize > p->directInputRem)
++      curSize = (UInt32)p->directInputRem;
++    p->directInputRem -= curSize;
++    p->streamPos += curSize;
++    if (p->directInputRem == 0)
++      p->streamEndWasReached = 1;
++    return;
++  }
++  for (;;)
++  {
++    Byte *dest = p->buffer + (p->streamPos - p->pos);
++    size_t size = (p->bufferBase + p->blockSize - dest);
++    if (size == 0)
++      return;
++    p->result = p->stream->Read(p->stream, dest, &size);
++    if (p->result != SZ_OK)
++      return;
++    if (size == 0)
++    {
++      p->streamEndWasReached = 1;
++      return;
++    }
++    p->streamPos += (UInt32)size;
++    if (p->streamPos - p->pos > p->keepSizeAfter)
++      return;
++  }
++}
++
++void MatchFinder_MoveBlock(CMatchFinder *p)
++{
++  memmove(p->bufferBase,
++    p->buffer - p->keepSizeBefore,
++    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
++  p->buffer = p->bufferBase + p->keepSizeBefore;
++}
++
++int MatchFinder_NeedMove(CMatchFinder *p)
++{
++  if (p->directInput)
++    return 0;
++  /* if (p->streamEndWasReached) return 0; */
++  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
++}
++
++void MatchFinder_ReadIfRequired(CMatchFinder *p)
++{
++  if (p->streamEndWasReached)
++    return;
++  if (p->keepSizeAfter >= p->streamPos - p->pos)
++    MatchFinder_ReadBlock(p);
++}
++
++static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
++{
++  if (MatchFinder_NeedMove(p))
++    MatchFinder_MoveBlock(p);
++  MatchFinder_ReadBlock(p);
++}
++
++static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
++{
++  p->cutValue = 32;
++  p->btMode = 1;
++  p->numHashBytes = 4;
++  p->bigHash = 0;
++}
++
++#define kCrcPoly 0xEDB88320
++
++void MatchFinder_Construct(CMatchFinder *p)
++{
++  UInt32 i;
++  p->bufferBase = 0;
++  p->directInput = 0;
++  p->hash = 0;
++  MatchFinder_SetDefaultSettings(p);
++
++  for (i = 0; i < 256; i++)
++  {
++    UInt32 r = i;
++    int j;
++    for (j = 0; j < 8; j++)
++      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
++    p->crc[i] = r;
++  }
++}
++
++static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->hash);
++  p->hash = 0;
++}
++
++void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
++{
++  MatchFinder_FreeThisClassMemory(p, alloc);
++  LzInWindow_Free(p, alloc);
++}
++
++static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
++{
++  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
++  if (sizeInBytes / sizeof(CLzRef) != num)
++    return 0;
++  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
++}
++
++int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
++    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
++    ISzAlloc *alloc)
++{
++  UInt32 sizeReserv;
++  if (historySize > kMaxHistorySize)
++  {
++    MatchFinder_Free(p, alloc);
++    return 0;
++  }
++  sizeReserv = historySize >> 1;
++  if (historySize > ((UInt32)2 << 30))
++    sizeReserv = historySize >> 2;
++  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
++
++  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
++  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
++  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
++  if (LzInWindow_Create(p, sizeReserv, alloc))
++  {
++    UInt32 newCyclicBufferSize = historySize + 1;
++    UInt32 hs;
++    p->matchMaxLen = matchMaxLen;
++    {
++      p->fixedHashSize = 0;
++      if (p->numHashBytes == 2)
++        hs = (1 << 16) - 1;
++      else
++      {
++        hs = historySize - 1;
++        hs |= (hs >> 1);
++        hs |= (hs >> 2);
++        hs |= (hs >> 4);
++        hs |= (hs >> 8);
++        hs >>= 1;
++        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
++        if (hs > (1 << 24))
++        {
++          if (p->numHashBytes == 3)
++            hs = (1 << 24) - 1;
++          else
++            hs >>= 1;
++        }
++      }
++      p->hashMask = hs;
++      hs++;
++      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
++      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
++      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
++      hs += p->fixedHashSize;
++    }
++
++    {
++      UInt32 prevSize = p->hashSizeSum + p->numSons;
++      UInt32 newSize;
++      p->historySize = historySize;
++      p->hashSizeSum = hs;
++      p->cyclicBufferSize = newCyclicBufferSize;
++      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
++      newSize = p->hashSizeSum + p->numSons;
++      if (p->hash != 0 && prevSize == newSize)
++        return 1;
++      MatchFinder_FreeThisClassMemory(p, alloc);
++      p->hash = AllocRefs(newSize, alloc);
++      if (p->hash != 0)
++      {
++        p->son = p->hash + p->hashSizeSum;
++        return 1;
++      }
++    }
++  }
++  MatchFinder_Free(p, alloc);
++  return 0;
++}
++
++static void MatchFinder_SetLimits(CMatchFinder *p)
++{
++  UInt32 limit = kMaxValForNormalize - p->pos;
++  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
++  if (limit2 < limit)
++    limit = limit2;
++  limit2 = p->streamPos - p->pos;
++  if (limit2 <= p->keepSizeAfter)
++  {
++    if (limit2 > 0)
++      limit2 = 1;
++  }
++  else
++    limit2 -= p->keepSizeAfter;
++  if (limit2 < limit)
++    limit = limit2;
++  {
++    UInt32 lenLimit = p->streamPos - p->pos;
++    if (lenLimit > p->matchMaxLen)
++      lenLimit = p->matchMaxLen;
++    p->lenLimit = lenLimit;
++  }
++  p->posLimit = p->pos + limit;
++}
++
++void MatchFinder_Init(CMatchFinder *p)
++{
++  UInt32 i;
++  for (i = 0; i < p->hashSizeSum; i++)
++    p->hash[i] = kEmptyHashValue;
++  p->cyclicBufferPos = 0;
++  p->buffer = p->bufferBase;
++  p->pos = p->streamPos = p->cyclicBufferSize;
++  p->result = SZ_OK;
++  p->streamEndWasReached = 0;
++  MatchFinder_ReadBlock(p);
++  MatchFinder_SetLimits(p);
++}
++
++static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
++{
++  return (p->pos - p->historySize - 1) & kNormalizeMask;
++}
++
++void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
++{
++  UInt32 i;
++  for (i = 0; i < numItems; i++)
++  {
++    UInt32 value = items[i];
++    if (value <= subValue)
++      value = kEmptyHashValue;
++    else
++      value -= subValue;
++    items[i] = value;
++  }
++}
++
++static void MatchFinder_Normalize(CMatchFinder *p)
++{
++  UInt32 subValue = MatchFinder_GetSubValue(p);
++  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
++  MatchFinder_ReduceOffsets(p, subValue);
++}
++
++static void MatchFinder_CheckLimits(CMatchFinder *p)
++{
++  if (p->pos == kMaxValForNormalize)
++    MatchFinder_Normalize(p);
++  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
++    MatchFinder_CheckAndMoveAndRead(p);
++  if (p->cyclicBufferPos == p->cyclicBufferSize)
++    p->cyclicBufferPos = 0;
++  MatchFinder_SetLimits(p);
++}
++
++static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
++    UInt32 *distances, UInt32 maxLen)
++{
++  son[_cyclicBufferPos] = curMatch;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++      return distances;
++    {
++      const Byte *pb = cur - delta;
++      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
++      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
++      {
++        UInt32 len = 0;
++        while (++len != lenLimit)
++          if (pb[len] != cur[len])
++            break;
++        if (maxLen < len)
++        {
++          *distances++ = maxLen = len;
++          *distances++ = delta - 1;
++          if (len == lenLimit)
++            return distances;
++        }
++      }
++    }
++  }
++}
++
++UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
++    UInt32 *distances, UInt32 maxLen)
++{
++  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
++  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
++  UInt32 len0 = 0, len1 = 0;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++    {
++      *ptr0 = *ptr1 = kEmptyHashValue;
++      return distances;
++    }
++    {
++      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
++      const Byte *pb = cur - delta;
++      UInt32 len = (len0 < len1 ? len0 : len1);
++      if (pb[len] == cur[len])
++      {
++        if (++len != lenLimit && pb[len] == cur[len])
++          while (++len != lenLimit)
++            if (pb[len] != cur[len])
++              break;
++        if (maxLen < len)
++        {
++          *distances++ = maxLen = len;
++          *distances++ = delta - 1;
++          if (len == lenLimit)
++          {
++            *ptr1 = pair[0];
++            *ptr0 = pair[1];
++            return distances;
++          }
++        }
++      }
++      if (pb[len] < cur[len])
++      {
++        *ptr1 = curMatch;
++        ptr1 = pair + 1;
++        curMatch = *ptr1;
++        len1 = len;
++      }
++      else
++      {
++        *ptr0 = curMatch;
++        ptr0 = pair;
++        curMatch = *ptr0;
++        len0 = len;
++      }
++    }
++  }
++}
++
++static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
++{
++  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
++  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
++  UInt32 len0 = 0, len1 = 0;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++    {
++      *ptr0 = *ptr1 = kEmptyHashValue;
++      return;
++    }
++    {
++      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
++      const Byte *pb = cur - delta;
++      UInt32 len = (len0 < len1 ? len0 : len1);
++      if (pb[len] == cur[len])
++      {
++        while (++len != lenLimit)
++          if (pb[len] != cur[len])
++            break;
++        {
++          if (len == lenLimit)
++          {
++            *ptr1 = pair[0];
++            *ptr0 = pair[1];
++            return;
++          }
++        }
++      }
++      if (pb[len] < cur[len])
++      {
++        *ptr1 = curMatch;
++        ptr1 = pair + 1;
++        curMatch = *ptr1;
++        len1 = len;
++      }
++      else
++      {
++        *ptr0 = curMatch;
++        ptr0 = pair;
++        curMatch = *ptr0;
++        len0 = len;
++      }
++    }
++  }
++}
++
++#define MOVE_POS \
++  ++p->cyclicBufferPos; \
++  p->buffer++; \
++  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
++
++#define MOVE_POS_RET MOVE_POS return offset;
++
++static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
++
++#define GET_MATCHES_HEADER2(minLen, ret_op) \
++  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
++  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
++  cur = p->buffer;
++
++#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
++#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
++
++#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
++
++#define GET_MATCHES_FOOTER(offset, maxLen) \
++  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
++  distances + offset, maxLen) - distances); MOVE_POS_RET;
++
++#define SKIP_FOOTER \
++  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
++
++static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(2)
++  HASH2_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = 0;
++  GET_MATCHES_FOOTER(offset, 1)
++}
++
++UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(3)
++  HASH_ZIP_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = 0;
++  GET_MATCHES_FOOTER(offset, 2)
++}
++
++static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, delta2, maxLen, offset;
++  GET_MATCHES_HEADER(3)
++
++  HASH3_CALC;
++
++  delta2 = p->pos - p->hash[hash2Value];
++  curMatch = p->hash[kFix3HashSize + hashValue];
++
++  p->hash[hash2Value] =
++  p->hash[kFix3HashSize + hashValue] = p->pos;
++
++
++  maxLen = 2;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[0] = maxLen;
++    distances[1] = delta2 - 1;
++    offset = 2;
++    if (maxLen == lenLimit)
++    {
++      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
++      MOVE_POS_RET;
++    }
++  }
++  GET_MATCHES_FOOTER(offset, maxLen)
++}
++
++static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
++  GET_MATCHES_HEADER(4)
++
++  HASH4_CALC;
++
++  delta2 = p->pos - p->hash[                hash2Value];
++  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
++  curMatch = p->hash[kFix4HashSize + hashValue];
++
++  p->hash[                hash2Value] =
++  p->hash[kFix3HashSize + hash3Value] =
++  p->hash[kFix4HashSize + hashValue] = p->pos;
++
++  maxLen = 1;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    distances[0] = maxLen = 2;
++    distances[1] = delta2 - 1;
++    offset = 2;
++  }
++  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
++  {
++    maxLen = 3;
++    distances[offset + 1] = delta3 - 1;
++    offset += 2;
++    delta2 = delta3;
++  }
++  if (offset != 0)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[offset - 2] = maxLen;
++    if (maxLen == lenLimit)
++    {
++      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
++      MOVE_POS_RET;
++    }
++  }
++  if (maxLen < 3)
++    maxLen = 3;
++  GET_MATCHES_FOOTER(offset, maxLen)
++}
++
++static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
++  GET_MATCHES_HEADER(4)
++
++  HASH4_CALC;
++
++  delta2 = p->pos - p->hash[                hash2Value];
++  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
++  curMatch = p->hash[kFix4HashSize + hashValue];
++
++  p->hash[                hash2Value] =
++  p->hash[kFix3HashSize + hash3Value] =
++  p->hash[kFix4HashSize + hashValue] = p->pos;
++
++  maxLen = 1;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    distances[0] = maxLen = 2;
++    distances[1] = delta2 - 1;
++    offset = 2;
++  }
++  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
++  {
++    maxLen = 3;
++    distances[offset + 1] = delta3 - 1;
++    offset += 2;
++    delta2 = delta3;
++  }
++  if (offset != 0)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[offset - 2] = maxLen;
++    if (maxLen == lenLimit)
++    {
++      p->son[p->cyclicBufferPos] = curMatch;
++      MOVE_POS_RET;
++    }
++  }
++  if (maxLen < 3)
++    maxLen = 3;
++  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
++    distances + offset, maxLen) - (distances));
++  MOVE_POS_RET
++}
++
++UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(3)
++  HASH_ZIP_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
++    distances, 2) - (distances));
++  MOVE_POS_RET
++}
++
++static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(2)
++    HASH2_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(3)
++    HASH_ZIP_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value;
++    SKIP_HEADER(3)
++    HASH3_CALC;
++    curMatch = p->hash[kFix3HashSize + hashValue];
++    p->hash[hash2Value] =
++    p->hash[kFix3HashSize + hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value, hash3Value;
++    SKIP_HEADER(4)
++    HASH4_CALC;
++    curMatch = p->hash[kFix4HashSize + hashValue];
++    p->hash[                hash2Value] =
++    p->hash[kFix3HashSize + hash3Value] = p->pos;
++    p->hash[kFix4HashSize + hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value, hash3Value;
++    SKIP_HEADER(4)
++    HASH4_CALC;
++    curMatch = p->hash[kFix4HashSize + hashValue];
++    p->hash[                hash2Value] =
++    p->hash[kFix3HashSize + hash3Value] =
++    p->hash[kFix4HashSize + hashValue] = p->pos;
++    p->son[p->cyclicBufferPos] = curMatch;
++    MOVE_POS
++  }
++  while (--num != 0);
++}
++
++void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(3)
++    HASH_ZIP_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    p->son[p->cyclicBufferPos] = curMatch;
++    MOVE_POS
++  }
++  while (--num != 0);
++}
++
++void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
++{
++  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
++  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
++  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
++  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
++  if (!p->btMode)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
++  }
++  else if (p->numHashBytes == 2)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
++  }
++  else if (p->numHashBytes == 3)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
++  }
++  else
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
++  }
++}
+--- /dev/null
++++ b/lib/lzma/LzmaDec.c
+@@ -0,0 +1,999 @@
++/* LzmaDec.c -- LZMA Decoder
++2009-09-20 : Igor Pavlov : Public domain */
++
++#include "LzmaDec.h"
++
++#include <string.h>
++
++#define kNumTopBits 24
++#define kTopValue ((UInt32)1 << kNumTopBits)
++
++#define kNumBitModelTotalBits 11
++#define kBitModelTotal (1 << kNumBitModelTotalBits)
++#define kNumMoveBits 5
++
++#define RC_INIT_SIZE 5
++
++#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }
++
++#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
++#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
++#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
++#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
++  { UPDATE_0(p); i = (i + i); A0; } else \
++  { UPDATE_1(p); i = (i + i) + 1; A1; }
++#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
++
++#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
++#define TREE_DECODE(probs, limit, i) \
++  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
++
++/* #define _LZMA_SIZE_OPT */
++
++#ifdef _LZMA_SIZE_OPT
++#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
++#else
++#define TREE_6_DECODE(probs, i) \
++  { i = 1; \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  i -= 0x40; }
++#endif
++
++#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }
++
++#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
++#define UPDATE_0_CHECK range = bound;
++#define UPDATE_1_CHECK range -= bound; code -= bound;
++#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
++  { UPDATE_0_CHECK; i = (i + i); A0; } else \
++  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
++#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
++#define TREE_DECODE_CHECK(probs, limit, i) \
++  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
++
++
++#define kNumPosBitsMax 4
++#define kNumPosStatesMax (1 << kNumPosBitsMax)
++
++#define kLenNumLowBits 3
++#define kLenNumLowSymbols (1 << kLenNumLowBits)
++#define kLenNumMidBits 3
++#define kLenNumMidSymbols (1 << kLenNumMidBits)
++#define kLenNumHighBits 8
++#define kLenNumHighSymbols (1 << kLenNumHighBits)
++
++#define LenChoice 0
++#define LenChoice2 (LenChoice + 1)
++#define LenLow (LenChoice2 + 1)
++#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
++#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
++#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
++
++
++#define kNumStates 12
++#define kNumLitStates 7
++
++#define kStartPosModelIndex 4
++#define kEndPosModelIndex 14
++#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
++
++#define kNumPosSlotBits 6
++#define kNumLenToPosStates 4
++
++#define kNumAlignBits 4
++#define kAlignTableSize (1 << kNumAlignBits)
++
++#define kMatchMinLen 2
++#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
++
++#define IsMatch 0
++#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
++#define IsRepG0 (IsRep + kNumStates)
++#define IsRepG1 (IsRepG0 + kNumStates)
++#define IsRepG2 (IsRepG1 + kNumStates)
++#define IsRep0Long (IsRepG2 + kNumStates)
++#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
++#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
++#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
++#define LenCoder (Align + kAlignTableSize)
++#define RepLenCoder (LenCoder + kNumLenProbs)
++#define Literal (RepLenCoder + kNumLenProbs)
++
++#define LZMA_BASE_SIZE 1846
++#define LZMA_LIT_SIZE 768
++
++#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
++
++#if Literal != LZMA_BASE_SIZE
++StopCompilingDueBUG
++#endif
++
++#define LZMA_DIC_MIN (1 << 12)
++
++/* First LZMA-symbol is always decoded.
++And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
++Out:
++  Result:
++    SZ_OK - OK
++    SZ_ERROR_DATA - Error
++  p->remainLen:
++    < kMatchSpecLenStart : normal remain
++    = kMatchSpecLenStart : finished
++    = kMatchSpecLenStart + 1 : Flush marker
++    = kMatchSpecLenStart + 2 : State Init Marker
++*/
++
++static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
++{
++  CLzmaProb *probs = p->probs;
++
++  unsigned state = p->state;
++  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
++  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
++  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
++  unsigned lc = p->prop.lc;
++
++  Byte *dic = p->dic;
++  SizeT dicBufSize = p->dicBufSize;
++  SizeT dicPos = p->dicPos;
++
++  UInt32 processedPos = p->processedPos;
++  UInt32 checkDicSize = p->checkDicSize;
++  unsigned len = 0;
++
++  const Byte *buf = p->buf;
++  UInt32 range = p->range;
++  UInt32 code = p->code;
++
++  do
++  {
++    CLzmaProb *prob;
++    UInt32 bound;
++    unsigned ttt;
++    unsigned posState = processedPos & pbMask;
++
++    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
++    IF_BIT_0(prob)
++    {
++      unsigned symbol;
++      UPDATE_0(prob);
++      prob = probs + Literal;
++      if (checkDicSize != 0 || processedPos != 0)
++        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
++        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
++
++      if (state < kNumLitStates)
++      {
++        state -= (state < 4) ? state : 3;
++        symbol = 1;
++        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
++      }
++      else
++      {
++        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
++        unsigned offs = 0x100;
++        state -= (state < 10) ? 3 : 6;
++        symbol = 1;
++        do
++        {
++          unsigned bit;
++          CLzmaProb *probLit;
++          matchByte <<= 1;
++          bit = (matchByte & offs);
++          probLit = prob + offs + bit + symbol;
++          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
++        }
++        while (symbol < 0x100);
++      }
++      dic[dicPos++] = (Byte)symbol;
++      processedPos++;
++      continue;
++    }
++    else
++    {
++      UPDATE_1(prob);
++      prob = probs + IsRep + state;
++      IF_BIT_0(prob)
++      {
++        UPDATE_0(prob);
++        state += kNumStates;
++        prob = probs + LenCoder;
++      }
++      else
++      {
++        UPDATE_1(prob);
++        if (checkDicSize == 0 && processedPos == 0)
++          return SZ_ERROR_DATA;
++        prob = probs + IsRepG0 + state;
++        IF_BIT_0(prob)
++        {
++          UPDATE_0(prob);
++          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
++          IF_BIT_0(prob)
++          {
++            UPDATE_0(prob);
++            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
++            dicPos++;
++            processedPos++;
++            state = state < kNumLitStates ? 9 : 11;
++            continue;
++          }
++          UPDATE_1(prob);
++        }
++        else
++        {
++          UInt32 distance;
++          UPDATE_1(prob);
++          prob = probs + IsRepG1 + state;
++          IF_BIT_0(prob)
++          {
++            UPDATE_0(prob);
++            distance = rep1;
++          }
++          else
++          {
++            UPDATE_1(prob);
++            prob = probs + IsRepG2 + state;
++            IF_BIT_0(prob)
++            {
++              UPDATE_0(prob);
++              distance = rep2;
++            }
++            else
++            {
++              UPDATE_1(prob);
++              distance = rep3;
++              rep3 = rep2;
++            }
++            rep2 = rep1;
++          }
++          rep1 = rep0;
++          rep0 = distance;
++        }
++        state = state < kNumLitStates ? 8 : 11;
++        prob = probs + RepLenCoder;
++      }
++      {
++        unsigned limit, offset;
++        CLzmaProb *probLen = prob + LenChoice;
++        IF_BIT_0(probLen)
++        {
++          UPDATE_0(probLen);
++          probLen = prob + LenLow + (posState << kLenNumLowBits);
++          offset = 0;
++          limit = (1 << kLenNumLowBits);
++        }
++        else
++        {
++          UPDATE_1(probLen);
++          probLen = prob + LenChoice2;
++          IF_BIT_0(probLen)
++          {
++            UPDATE_0(probLen);
++            probLen = prob + LenMid + (posState << kLenNumMidBits);
++            offset = kLenNumLowSymbols;
++            limit = (1 << kLenNumMidBits);
++          }
++          else
++          {
++            UPDATE_1(probLen);
++            probLen = prob + LenHigh;
++            offset = kLenNumLowSymbols + kLenNumMidSymbols;
++            limit = (1 << kLenNumHighBits);
++          }
++        }
++        TREE_DECODE(probLen, limit, len);
++        len += offset;
++      }
++
++      if (state >= kNumStates)
++      {
++        UInt32 distance;
++        prob = probs + PosSlot +
++            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
++        TREE_6_DECODE(prob, distance);
++        if (distance >= kStartPosModelIndex)
++        {
++          unsigned posSlot = (unsigned)distance;
++          int numDirectBits = (int)(((distance >> 1) - 1));
++          distance = (2 | (distance & 1));
++          if (posSlot < kEndPosModelIndex)
++          {
++            distance <<= numDirectBits;
++            prob = probs + SpecPos + distance - posSlot - 1;
++            {
++              UInt32 mask = 1;
++              unsigned i = 1;
++              do
++              {
++                GET_BIT2(prob + i, i, ; , distance |= mask);
++                mask <<= 1;
++              }
++              while (--numDirectBits != 0);
++            }
++          }
++          else
++          {
++            numDirectBits -= kNumAlignBits;
++            do
++            {
++              NORMALIZE
++              range >>= 1;
++
++              {
++                UInt32 t;
++                code -= range;
++                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
++                distance = (distance << 1) + (t + 1);
++                code += range & t;
++              }
++              /*
++              distance <<= 1;
++              if (code >= range)
++              {
++                code -= range;
++                distance |= 1;
++              }
++              */
++            }
++            while (--numDirectBits != 0);
++            prob = probs + Align;
++            distance <<= kNumAlignBits;
++            {
++              unsigned i = 1;
++              GET_BIT2(prob + i, i, ; , distance |= 1);
++              GET_BIT2(prob + i, i, ; , distance |= 2);
++              GET_BIT2(prob + i, i, ; , distance |= 4);
++              GET_BIT2(prob + i, i, ; , distance |= 8);
++            }
++            if (distance == (UInt32)0xFFFFFFFF)
++            {
++              len += kMatchSpecLenStart;
++              state -= kNumStates;
++              break;
++            }
++          }
++        }
++        rep3 = rep2;
++        rep2 = rep1;
++        rep1 = rep0;
++        rep0 = distance + 1;
++        if (checkDicSize == 0)
++        {
++          if (distance >= processedPos)
++            return SZ_ERROR_DATA;
++        }
++        else if (distance >= checkDicSize)
++          return SZ_ERROR_DATA;
++        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
++      }
++
++      len += kMatchMinLen;
++
++      if (limit == dicPos)
++        return SZ_ERROR_DATA;
++      {
++        SizeT rem = limit - dicPos;
++        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
++        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
++
++        processedPos += curLen;
++
++        len -= curLen;
++        if (pos + curLen <= dicBufSize)
++        {
++          Byte *dest = dic + dicPos;
++          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
++          const Byte *lim = dest + curLen;
++          dicPos += curLen;
++          do
++            *(dest) = (Byte)*(dest + src);
++          while (++dest != lim);
++        }
++        else
++        {
++          do
++          {
++            dic[dicPos++] = dic[pos];
++            if (++pos == dicBufSize)
++              pos = 0;
++          }
++          while (--curLen != 0);
++        }
++      }
++    }
++  }
++  while (dicPos < limit && buf < bufLimit);
++  NORMALIZE;
++  p->buf = buf;
++  p->range = range;
++  p->code = code;
++  p->remainLen = len;
++  p->dicPos = dicPos;
++  p->processedPos = processedPos;
++  p->reps[0] = rep0;
++  p->reps[1] = rep1;
++  p->reps[2] = rep2;
++  p->reps[3] = rep3;
++  p->state = state;
++
++  return SZ_OK;
++}
++
++static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
++{
++  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
++  {
++    Byte *dic = p->dic;
++    SizeT dicPos = p->dicPos;
++    SizeT dicBufSize = p->dicBufSize;
++    unsigned len = p->remainLen;
++    UInt32 rep0 = p->reps[0];
++    if (limit - dicPos < len)
++      len = (unsigned)(limit - dicPos);
++
++    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
++      p->checkDicSize = p->prop.dicSize;
++
++    p->processedPos += len;
++    p->remainLen -= len;
++    while (len-- != 0)
++    {
++      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
++      dicPos++;
++    }
++    p->dicPos = dicPos;
++  }
++}
++
++static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
++{
++  do
++  {
++    SizeT limit2 = limit;
++    if (p->checkDicSize == 0)
++    {
++      UInt32 rem = p->prop.dicSize - p->processedPos;
++      if (limit - p->dicPos > rem)
++        limit2 = p->dicPos + rem;
++    }
++    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
++    if (p->processedPos >= p->prop.dicSize)
++      p->checkDicSize = p->prop.dicSize;
++    LzmaDec_WriteRem(p, limit);
++  }
++  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
++
++  if (p->remainLen > kMatchSpecLenStart)
++  {
++    p->remainLen = kMatchSpecLenStart;
++  }
++  return 0;
++}
++
++typedef enum
++{
++  DUMMY_ERROR, /* unexpected end of input stream */
++  DUMMY_LIT,
++  DUMMY_MATCH,
++  DUMMY_REP
++} ELzmaDummy;
++
++static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
++{
++  UInt32 range = p->range;
++  UInt32 code = p->code;
++  const Byte *bufLimit = buf + inSize;
++  CLzmaProb *probs = p->probs;
++  unsigned state = p->state;
++  ELzmaDummy res;
++
++  {
++    CLzmaProb *prob;
++    UInt32 bound;
++    unsigned ttt;
++    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
++
++    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
++    IF_BIT_0_CHECK(prob)
++    {
++      UPDATE_0_CHECK
++
++      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
++
++      prob = probs + Literal;
++      if (p->checkDicSize != 0 || p->processedPos != 0)
++        prob += (LZMA_LIT_SIZE *
++          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
++          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
++
++      if (state < kNumLitStates)
++      {
++        unsigned symbol = 1;
++        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
++      }
++      else
++      {
++        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
++            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
++        unsigned offs = 0x100;
++        unsigned symbol = 1;
++        do
++        {
++          unsigned bit;
++          CLzmaProb *probLit;
++          matchByte <<= 1;
++          bit = (matchByte & offs);
++          probLit = prob + offs + bit + symbol;
++          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
++        }
++        while (symbol < 0x100);
++      }
++      res = DUMMY_LIT;
++    }
++    else
++    {
++      unsigned len;
++      UPDATE_1_CHECK;
++
++      prob = probs + IsRep + state;
++      IF_BIT_0_CHECK(prob)
++      {
++        UPDATE_0_CHECK;
++        state = 0;
++        prob = probs + LenCoder;
++        res = DUMMY_MATCH;
++      }
++      else
++      {
++        UPDATE_1_CHECK;
++        res = DUMMY_REP;
++        prob = probs + IsRepG0 + state;
++        IF_BIT_0_CHECK(prob)
++        {
++          UPDATE_0_CHECK;
++          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
++          IF_BIT_0_CHECK(prob)
++          {
++            UPDATE_0_CHECK;
++            NORMALIZE_CHECK;
++            return DUMMY_REP;
++          }
++          else
++          {
++            UPDATE_1_CHECK;
++          }
++        }
++        else
++        {
++          UPDATE_1_CHECK;
++          prob = probs + IsRepG1 + state;
++          IF_BIT_0_CHECK(prob)
++          {
++            UPDATE_0_CHECK;
++          }
++          else
++          {
++            UPDATE_1_CHECK;
++            prob = probs + IsRepG2 + state;
++            IF_BIT_0_CHECK(prob)
++            {
++              UPDATE_0_CHECK;
++            }
++            else
++            {
++              UPDATE_1_CHECK;
++            }
++          }
++        }
++        state = kNumStates;
++        prob = probs + RepLenCoder;
++      }
++      {
++        unsigned limit, offset;
++        CLzmaProb *probLen = prob + LenChoice;
++        IF_BIT_0_CHECK(probLen)
++        {
++          UPDATE_0_CHECK;
++          probLen = prob + LenLow + (posState << kLenNumLowBits);
++          offset = 0;
++          limit = 1 << kLenNumLowBits;
++        }
++        else
++        {
++          UPDATE_1_CHECK;
++          probLen = prob + LenChoice2;
++          IF_BIT_0_CHECK(probLen)
++          {
++            UPDATE_0_CHECK;
++            probLen = prob + LenMid + (posState << kLenNumMidBits);
++            offset = kLenNumLowSymbols;
++            limit = 1 << kLenNumMidBits;
++          }
++          else
++          {
++            UPDATE_1_CHECK;
++            probLen = prob + LenHigh;
++            offset = kLenNumLowSymbols + kLenNumMidSymbols;
++            limit = 1 << kLenNumHighBits;
++          }
++        }
++        TREE_DECODE_CHECK(probLen, limit, len);
++        len += offset;
++      }
++
++      if (state < 4)
++      {
++        unsigned posSlot;
++        prob = probs + PosSlot +
++            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
++            kNumPosSlotBits);
++        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
++        if (posSlot >= kStartPosModelIndex)
++        {
++          int numDirectBits = ((posSlot >> 1) - 1);
++
++          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
++
++          if (posSlot < kEndPosModelIndex)
++          {
++            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
++          }
++          else
++          {
++            numDirectBits -= kNumAlignBits;
++            do
++            {
++              NORMALIZE_CHECK
++              range >>= 1;
++              code -= range & (((code - range) >> 31) - 1);
++              /* if (code >= range) code -= range; */
++            }
++            while (--numDirectBits != 0);
++            prob = probs + Align;
++            numDirectBits = kNumAlignBits;
++          }
++          {
++            unsigned i = 1;
++            do
++            {
++              GET_BIT_CHECK(prob + i, i);
++            }
++            while (--numDirectBits != 0);
++          }
++        }
++      }
++    }
++  }
++  NORMALIZE_CHECK;
++  return res;
++}
++
++
++static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
++{
++  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
++  p->range = 0xFFFFFFFF;
++  p->needFlush = 0;
++}
++
++static void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
++{
++  p->needFlush = 1;
++  p->remainLen = 0;
++  p->tempBufSize = 0;
++
++  if (initDic)
++  {
++    p->processedPos = 0;
++    p->checkDicSize = 0;
++    p->needInitState = 1;
++  }
++  if (initState)
++    p->needInitState = 1;
++}
++
++void LzmaDec_Init(CLzmaDec *p)
++{
++  p->dicPos = 0;
++  LzmaDec_InitDicAndState(p, True, True);
++}
++
++static void LzmaDec_InitStateReal(CLzmaDec *p)
++{
++  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
++  UInt32 i;
++  CLzmaProb *probs = p->probs;
++  for (i = 0; i < numProbs; i++)
++    probs[i] = kBitModelTotal >> 1;
++  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
++  p->state = 0;
++  p->needInitState = 0;
++}
++
++SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
++    ELzmaFinishMode finishMode, ELzmaStatus *status)
++{
++  SizeT inSize = *srcLen;
++  (*srcLen) = 0;
++  LzmaDec_WriteRem(p, dicLimit);
++
++  *status = LZMA_STATUS_NOT_SPECIFIED;
++
++  while (p->remainLen != kMatchSpecLenStart)
++  {
++      int checkEndMarkNow;
++
++      if (p->needFlush != 0)
++      {
++        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
++          p->tempBuf[p->tempBufSize++] = *src++;
++        if (p->tempBufSize < RC_INIT_SIZE)
++        {
++          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
++          return SZ_OK;
++        }
++        if (p->tempBuf[0] != 0)
++          return SZ_ERROR_DATA;
++
++        LzmaDec_InitRc(p, p->tempBuf);
++        p->tempBufSize = 0;
++      }
++
++      checkEndMarkNow = 0;
++      if (p->dicPos >= dicLimit)
++      {
++        if (p->remainLen == 0 && p->code == 0)
++        {
++          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
++          return SZ_OK;
++        }
++        if (finishMode == LZMA_FINISH_ANY)
++        {
++          *status = LZMA_STATUS_NOT_FINISHED;
++          return SZ_OK;
++        }
++        if (p->remainLen != 0)
++        {
++          *status = LZMA_STATUS_NOT_FINISHED;
++          return SZ_ERROR_DATA;
++        }
++        checkEndMarkNow = 1;
++      }
++
++      if (p->needInitState)
++        LzmaDec_InitStateReal(p);
++
++      if (p->tempBufSize == 0)
++      {
++        SizeT processed;
++        const Byte *bufLimit;
++        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
++        {
++          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
++          if (dummyRes == DUMMY_ERROR)
++          {
++            memcpy(p->tempBuf, src, inSize);
++            p->tempBufSize = (unsigned)inSize;
++            (*srcLen) += inSize;
++            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
++            return SZ_OK;
++          }
++          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
++          {
++            *status = LZMA_STATUS_NOT_FINISHED;
++            return SZ_ERROR_DATA;
++          }
++          bufLimit = src;
++        }
++        else
++          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
++        p->buf = src;
++        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
++          return SZ_ERROR_DATA;
++        processed = (SizeT)(p->buf - src);
++        (*srcLen) += processed;
++        src += processed;
++        inSize -= processed;
++      }
++      else
++      {
++        unsigned rem = p->tempBufSize, lookAhead = 0;
++        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
++          p->tempBuf[rem++] = src[lookAhead++];
++        p->tempBufSize = rem;
++        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
++        {
++          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
++          if (dummyRes == DUMMY_ERROR)
++          {
++            (*srcLen) += lookAhead;
++            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
++            return SZ_OK;
++          }
++          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
++          {
++            *status = LZMA_STATUS_NOT_FINISHED;
++            return SZ_ERROR_DATA;
++          }
++        }
++        p->buf = p->tempBuf;
++        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
++          return SZ_ERROR_DATA;
++        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
++        (*srcLen) += lookAhead;
++        src += lookAhead;
++        inSize -= lookAhead;
++        p->tempBufSize = 0;
++      }
++  }
++  if (p->code == 0)
++    *status = LZMA_STATUS_FINISHED_WITH_MARK;
++  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
++}
++
++SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
++{
++  SizeT outSize = *destLen;
++  SizeT inSize = *srcLen;
++  *srcLen = *destLen = 0;
++  for (;;)
++  {
++    SizeT inSizeCur = inSize, outSizeCur, dicPos;
++    ELzmaFinishMode curFinishMode;
++    SRes res;
++    if (p->dicPos == p->dicBufSize)
++      p->dicPos = 0;
++    dicPos = p->dicPos;
++    if (outSize > p->dicBufSize - dicPos)
++    {
++      outSizeCur = p->dicBufSize;
++      curFinishMode = LZMA_FINISH_ANY;
++    }
++    else
++    {
++      outSizeCur = dicPos + outSize;
++      curFinishMode = finishMode;
++    }
++
++    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
++    src += inSizeCur;
++    inSize -= inSizeCur;
++    *srcLen += inSizeCur;
++    outSizeCur = p->dicPos - dicPos;
++    memcpy(dest, p->dic + dicPos, outSizeCur);
++    dest += outSizeCur;
++    outSize -= outSizeCur;
++    *destLen += outSizeCur;
++    if (res != 0)
++      return res;
++    if (outSizeCur == 0 || outSize == 0)
++      return SZ_OK;
++  }
++}
++
++void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->probs);
++  p->probs = 0;
++}
++
++static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->dic);
++  p->dic = 0;
++}
++
++void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
++{
++  LzmaDec_FreeProbs(p, alloc);
++  LzmaDec_FreeDict(p, alloc);
++}
++
++SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
++{
++  UInt32 dicSize;
++  Byte d;
++
++  if (size < LZMA_PROPS_SIZE)
++    return SZ_ERROR_UNSUPPORTED;
++  else
++    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
++
++  if (dicSize < LZMA_DIC_MIN)
++    dicSize = LZMA_DIC_MIN;
++  p->dicSize = dicSize;
++
++  d = data[0];
++  if (d >= (9 * 5 * 5))
++    return SZ_ERROR_UNSUPPORTED;
++
++  p->lc = d % 9;
++  d /= 9;
++  p->pb = d / 5;
++  p->lp = d % 5;
++
++  return SZ_OK;
++}
++
++static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
++{
++  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
++  if (p->probs == 0 || numProbs != p->numProbs)
++  {
++    LzmaDec_FreeProbs(p, alloc);
++    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
++    p->numProbs = numProbs;
++    if (p->probs == 0)
++      return SZ_ERROR_MEM;
++  }
++  return SZ_OK;
++}
++
++SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++{
++  CLzmaProps propNew;
++  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
++  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
++  p->prop = propNew;
++  return SZ_OK;
++}
++
++SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++{
++  CLzmaProps propNew;
++  SizeT dicBufSize;
++  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
++  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
++  dicBufSize = propNew.dicSize;
++  if (p->dic == 0 || dicBufSize != p->dicBufSize)
++  {
++    LzmaDec_FreeDict(p, alloc);
++    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
++    if (p->dic == 0)
++    {
++      LzmaDec_FreeProbs(p, alloc);
++      return SZ_ERROR_MEM;
++    }
++  }
++  p->dicBufSize = dicBufSize;
++  p->prop = propNew;
++  return SZ_OK;
++}
++
++SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
++    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
++    ELzmaStatus *status, ISzAlloc *alloc)
++{
++  CLzmaDec p;
++  SRes res;
++  SizeT inSize = *srcLen;
++  SizeT outSize = *destLen;
++  *srcLen = *destLen = 0;
++  if (inSize < RC_INIT_SIZE)
++    return SZ_ERROR_INPUT_EOF;
++
++  LzmaDec_Construct(&p);
++  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
++  if (res != 0)
++    return res;
++  p.dic = dest;
++  p.dicBufSize = outSize;
++
++  LzmaDec_Init(&p);
++
++  *srcLen = inSize;
++  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
++
++  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
++    res = SZ_ERROR_INPUT_EOF;
++
++  (*destLen) = p.dicPos;
++  LzmaDec_FreeProbs(&p, alloc);
++  return res;
++}
+--- /dev/null
++++ b/lib/lzma/LzmaEnc.c
+@@ -0,0 +1,2271 @@
++/* LzmaEnc.c -- LZMA Encoder
++2009-11-24 : Igor Pavlov : Public domain */
++
++#include <string.h>
++
++/* #define SHOW_STAT */
++/* #define SHOW_STAT2 */
++
++#if defined(SHOW_STAT) || defined(SHOW_STAT2)
++#include <stdio.h>
++#endif
++
++#include "LzmaEnc.h"
++
++/* disable MT */
++#define _7ZIP_ST
++
++#include "LzFind.h"
++#ifndef _7ZIP_ST
++#include "LzFindMt.h"
++#endif
++
++#ifdef SHOW_STAT
++static int ttt = 0;
++#endif
++
++#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
++
++#define kBlockSize (9 << 10)
++#define kUnpackBlockSize (1 << 18)
++#define kMatchArraySize (1 << 21)
++#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
++
++#define kNumMaxDirectBits (31)
++
++#define kNumTopBits 24
++#define kTopValue ((UInt32)1 << kNumTopBits)
++
++#define kNumBitModelTotalBits 11
++#define kBitModelTotal (1 << kNumBitModelTotalBits)
++#define kNumMoveBits 5
++#define kProbInitValue (kBitModelTotal >> 1)
++
++#define kNumMoveReducingBits 4
++#define kNumBitPriceShiftBits 4
++#define kBitPrice (1 << kNumBitPriceShiftBits)
++
++void LzmaEncProps_Init(CLzmaEncProps *p)
++{
++  p->level = 5;
++  p->dictSize = p->mc = 0;
++  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
++  p->writeEndMark = 0;
++}
++
++void LzmaEncProps_Normalize(CLzmaEncProps *p)
++{
++  int level = p->level;
++  if (level < 0) level = 5;
++  p->level = level;
++  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
++  if (p->lc < 0) p->lc = 3;
++  if (p->lp < 0) p->lp = 0;
++  if (p->pb < 0) p->pb = 2;
++  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
++  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
++  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
++  if (p->numHashBytes < 0) p->numHashBytes = 4;
++  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
++  if (p->numThreads < 0)
++    p->numThreads =
++      #ifndef _7ZIP_ST
++      ((p->btMode && p->algo) ? 2 : 1);
++      #else
++      1;
++      #endif
++}
++
++UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
++{
++  CLzmaEncProps props = *props2;
++  LzmaEncProps_Normalize(&props);
++  return props.dictSize;
++}
++
++/* #define LZMA_LOG_BSR */
++/* Define it for Intel's CPU */
++
++
++#ifdef LZMA_LOG_BSR
++
++#define kDicLogSizeMaxCompress 30
++
++#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
++
++UInt32 GetPosSlot1(UInt32 pos)
++{
++  UInt32 res;
++  BSR2_RET(pos, res);
++  return res;
++}
++#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
++#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }
++
++#else
++
++#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
++#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
++
++static void LzmaEnc_FastPosInit(Byte *g_FastPos)
++{
++  int c = 2, slotFast;
++  g_FastPos[0] = 0;
++  g_FastPos[1] = 1;
++
++  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
++  {
++    UInt32 k = (1 << ((slotFast >> 1) - 1));
++    UInt32 j;
++    for (j = 0; j < k; j++, c++)
++      g_FastPos[c] = (Byte)slotFast;
++  }
++}
++
++#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
++  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
++  res = p->g_FastPos[pos >> i] + (i * 2); }
++/*
++#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
++  p->g_FastPos[pos >> 6] + 12 : \
++  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
++*/
++
++#define GetPosSlot1(pos) p->g_FastPos[pos]
++#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
++#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
++
++#endif
++
++
++#define LZMA_NUM_REPS 4
++
++typedef unsigned CState;
++
++typedef struct
++{
++  UInt32 price;
++
++  CState state;
++  int prev1IsChar;
++  int prev2;
++
++  UInt32 posPrev2;
++  UInt32 backPrev2;
++
++  UInt32 posPrev;
++  UInt32 backPrev;
++  UInt32 backs[LZMA_NUM_REPS];
++} COptimal;
++
++#define kNumOpts (1 << 12)
++
++#define kNumLenToPosStates 4
++#define kNumPosSlotBits 6
++#define kDicLogSizeMin 0
++#define kDicLogSizeMax 32
++#define kDistTableSizeMax (kDicLogSizeMax * 2)
++
++
++#define kNumAlignBits 4
++#define kAlignTableSize (1 << kNumAlignBits)
++#define kAlignMask (kAlignTableSize - 1)
++
++#define kStartPosModelIndex 4
++#define kEndPosModelIndex 14
++#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
++
++#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
++
++#ifdef _LZMA_PROB32
++#define CLzmaProb UInt32
++#else
++#define CLzmaProb UInt16
++#endif
++
++#define LZMA_PB_MAX 4
++#define LZMA_LC_MAX 8
++#define LZMA_LP_MAX 4
++
++#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)
++
++
++#define kLenNumLowBits 3
++#define kLenNumLowSymbols (1 << kLenNumLowBits)
++#define kLenNumMidBits 3
++#define kLenNumMidSymbols (1 << kLenNumMidBits)
++#define kLenNumHighBits 8
++#define kLenNumHighSymbols (1 << kLenNumHighBits)
++
++#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
++
++#define LZMA_MATCH_LEN_MIN 2
++#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
++
++#define kNumStates 12
++
++typedef struct
++{
++  CLzmaProb choice;
++  CLzmaProb choice2;
++  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
++  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
++  CLzmaProb high[kLenNumHighSymbols];
++} CLenEnc;
++
++typedef struct
++{
++  CLenEnc p;
++  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
++  UInt32 tableSize;
++  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
++} CLenPriceEnc;
++
++typedef struct
++{
++  UInt32 range;
++  Byte cache;
++  UInt64 low;
++  UInt64 cacheSize;
++  Byte *buf;
++  Byte *bufLim;
++  Byte *bufBase;
++  ISeqOutStream *outStream;
++  UInt64 processed;
++  SRes res;
++} CRangeEnc;
++
++typedef struct
++{
++  CLzmaProb *litProbs;
++
++  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
++  CLzmaProb isRep[kNumStates];
++  CLzmaProb isRepG0[kNumStates];
++  CLzmaProb isRepG1[kNumStates];
++  CLzmaProb isRepG2[kNumStates];
++  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
++
++  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
++  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
++  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
++
++  CLenPriceEnc lenEnc;
++  CLenPriceEnc repLenEnc;
++
++  UInt32 reps[LZMA_NUM_REPS];
++  UInt32 state;
++} CSaveState;
++
++typedef struct
++{
++  IMatchFinder matchFinder;
++  void *matchFinderObj;
++
++  #ifndef _7ZIP_ST
++  Bool mtMode;
++  CMatchFinderMt matchFinderMt;
++  #endif
++
++  CMatchFinder matchFinderBase;
++
++  #ifndef _7ZIP_ST
++  Byte pad[128];
++  #endif
++
++  UInt32 optimumEndIndex;
++  UInt32 optimumCurrentIndex;
++
++  UInt32 longestMatchLength;
++  UInt32 numPairs;
++  UInt32 numAvail;
++  COptimal opt[kNumOpts];
++
++  #ifndef LZMA_LOG_BSR
++  Byte g_FastPos[1 << kNumLogBits];
++  #endif
++
++  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
++  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
++  UInt32 numFastBytes;
++  UInt32 additionalOffset;
++  UInt32 reps[LZMA_NUM_REPS];
++  UInt32 state;
++
++  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
++  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
++  UInt32 alignPrices[kAlignTableSize];
++  UInt32 alignPriceCount;
++
++  UInt32 distTableSize;
++
++  unsigned lc, lp, pb;
++  unsigned lpMask, pbMask;
++
++  CLzmaProb *litProbs;
++
++  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
++  CLzmaProb isRep[kNumStates];
++  CLzmaProb isRepG0[kNumStates];
++  CLzmaProb isRepG1[kNumStates];
++  CLzmaProb isRepG2[kNumStates];
++  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
++
++  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
++  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
++  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
++
++  CLenPriceEnc lenEnc;
++  CLenPriceEnc repLenEnc;
++
++  unsigned lclp;
++
++  Bool fastMode;
++
++  CRangeEnc rc;
++
++  Bool writeEndMark;
++  UInt64 nowPos64;
++  UInt32 matchPriceCount;
++  Bool finished;
++  Bool multiThread;
++
++  SRes result;
++  UInt32 dictSize;
++  UInt32 matchFinderCycles;
++
++  int needInit;
++
++  CSaveState saveState;
++} CLzmaEnc;
++
++/*void LzmaEnc_SaveState(CLzmaEncHandle pp)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  CSaveState *dest = &p->saveState;
++  int i;
++  dest->lenEnc = p->lenEnc;
++  dest->repLenEnc = p->repLenEnc;
++  dest->state = p->state;
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
++    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
++  }
++  for (i = 0; i < kNumLenToPosStates; i++)
++    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
++  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
++  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
++  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
++  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
++  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
++  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
++  memcpy(dest->reps, p->reps, sizeof(p->reps));
++  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
++}*/
++
++/*void LzmaEnc_RestoreState(CLzmaEncHandle pp)
++{
++  CLzmaEnc *dest = (CLzmaEnc *)pp;
++  const CSaveState *p = &dest->saveState;
++  int i;
++  dest->lenEnc = p->lenEnc;
++  dest->repLenEnc = p->repLenEnc;
++  dest->state = p->state;
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
++    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
++  }
++  for (i = 0; i < kNumLenToPosStates; i++)
++    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
++  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
++  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
++  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
++  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
++  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
++  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
++  memcpy(dest->reps, p->reps, sizeof(p->reps));
++  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
++}*/
++
++SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  CLzmaEncProps props = *props2;
++  LzmaEncProps_Normalize(&props);
++
++  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
++      props.dictSize > (1 << kDicLogSizeMaxCompress) || props.dictSize > (1 << 30))
++    return SZ_ERROR_PARAM;
++  p->dictSize = props.dictSize;
++  p->matchFinderCycles = props.mc;
++  {
++    unsigned fb = props.fb;
++    if (fb < 5)
++      fb = 5;
++    if (fb > LZMA_MATCH_LEN_MAX)
++      fb = LZMA_MATCH_LEN_MAX;
++    p->numFastBytes = fb;
++  }
++  p->lc = props.lc;
++  p->lp = props.lp;
++  p->pb = props.pb;
++  p->fastMode = (props.algo == 0);
++  p->matchFinderBase.btMode = props.btMode;
++  {
++    UInt32 numHashBytes = 4;
++    if (props.btMode)
++    {
++      if (props.numHashBytes < 2)
++        numHashBytes = 2;
++      else if (props.numHashBytes < 4)
++        numHashBytes = props.numHashBytes;
++    }
++    p->matchFinderBase.numHashBytes = numHashBytes;
++  }
++
++  p->matchFinderBase.cutValue = props.mc;
++
++  p->writeEndMark = props.writeEndMark;
++
++  #ifndef _7ZIP_ST
++  /*
++  if (newMultiThread != _multiThread)
++  {
++    ReleaseMatchFinder();
++    _multiThread = newMultiThread;
++  }
++  */
++  p->multiThread = (props.numThreads > 1);
++  #endif
++
++  return SZ_OK;
++}
++
++static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
++static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
++static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
++static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
++
++#define IsCharState(s) ((s) < 7)
++
++#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
++
++#define kInfinityPrice (1 << 30)
++
++static void RangeEnc_Construct(CRangeEnc *p)
++{
++  p->outStream = 0;
++  p->bufBase = 0;
++}
++
++#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
++
++#define RC_BUF_SIZE (1 << 16)
++static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
++{
++  if (p->bufBase == 0)
++  {
++    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
++    if (p->bufBase == 0)
++      return 0;
++    p->bufLim = p->bufBase + RC_BUF_SIZE;
++  }
++  return 1;
++}
++
++static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->bufBase);
++  p->bufBase = 0;
++}
++
++static void RangeEnc_Init(CRangeEnc *p)
++{
++  /* Stream.Init(); */
++  p->low = 0;
++  p->range = 0xFFFFFFFF;
++  p->cacheSize = 1;
++  p->cache = 0;
++
++  p->buf = p->bufBase;
++
++  p->processed = 0;
++  p->res = SZ_OK;
++}
++
++static void RangeEnc_FlushStream(CRangeEnc *p)
++{
++  size_t num;
++  if (p->res != SZ_OK)
++    return;
++  num = p->buf - p->bufBase;
++  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
++    p->res = SZ_ERROR_WRITE;
++  p->processed += num;
++  p->buf = p->bufBase;
++}
++
++static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
++{
++  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
++  {
++    Byte temp = p->cache;
++    do
++    {
++      Byte *buf = p->buf;
++      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
++      p->buf = buf;
++      if (buf == p->bufLim)
++        RangeEnc_FlushStream(p);
++      temp = 0xFF;
++    }
++    while (--p->cacheSize != 0);
++    p->cache = (Byte)((UInt32)p->low >> 24);
++  }
++  p->cacheSize++;
++  p->low = (UInt32)p->low << 8;
++}
++
++static void RangeEnc_FlushData(CRangeEnc *p)
++{
++  int i;
++  for (i = 0; i < 5; i++)
++    RangeEnc_ShiftLow(p);
++}
++
++static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
++{
++  do
++  {
++    p->range >>= 1;
++    p->low += p->range & (0 - ((value >> --numBits) & 1));
++    if (p->range < kTopValue)
++    {
++      p->range <<= 8;
++      RangeEnc_ShiftLow(p);
++    }
++  }
++  while (numBits != 0);
++}
++
++static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
++{
++  UInt32 ttt = *prob;
++  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
++  if (symbol == 0)
++  {
++    p->range = newBound;
++    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
++  }
++  else
++  {
++    p->low += newBound;
++    p->range -= newBound;
++    ttt -= ttt >> kNumMoveBits;
++  }
++  *prob = (CLzmaProb)ttt;
++  if (p->range < kTopValue)
++  {
++    p->range <<= 8;
++    RangeEnc_ShiftLow(p);
++  }
++}
++
++static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
++{
++  symbol |= 0x100;
++  do
++  {
++    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
++    symbol <<= 1;
++  }
++  while (symbol < 0x10000);
++}
++
++static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
++{
++  UInt32 offs = 0x100;
++  symbol |= 0x100;
++  do
++  {
++    matchByte <<= 1;
++    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
++    symbol <<= 1;
++    offs &= ~(matchByte ^ symbol);
++  }
++  while (symbol < 0x10000);
++}
++
++static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
++{
++  UInt32 i;
++  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
++  {
++    const int kCyclesBits = kNumBitPriceShiftBits;
++    UInt32 w = i;
++    UInt32 bitCount = 0;
++    int j;
++    for (j = 0; j < kCyclesBits; j++)
++    {
++      w = w * w;
++      bitCount <<= 1;
++      while (w >= ((UInt32)1 << 16))
++      {
++        w >>= 1;
++        bitCount++;
++      }
++    }
++    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
++  }
++}
++
++
++#define GET_PRICE(prob, symbol) \
++  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
++
++#define GET_PRICEa(prob, symbol) \
++  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
++
++#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
++#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
++
++#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
++#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
++
++static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  symbol |= 0x100;
++  do
++  {
++    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
++    symbol <<= 1;
++  }
++  while (symbol < 0x10000);
++  return price;
++}
++
++static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  UInt32 offs = 0x100;
++  symbol |= 0x100;
++  do
++  {
++    matchByte <<= 1;
++    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
++    symbol <<= 1;
++    offs &= ~(matchByte ^ symbol);
++  }
++  while (symbol < 0x10000);
++  return price;
++}
++
++
++static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
++{
++  UInt32 m = 1;
++  int i;
++  for (i = numBitLevels; i != 0;)
++  {
++    UInt32 bit;
++    i--;
++    bit = (symbol >> i) & 1;
++    RangeEnc_EncodeBit(rc, probs + m, bit);
++    m = (m << 1) | bit;
++  }
++}
++
++static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
++{
++  UInt32 m = 1;
++  int i;
++  for (i = 0; i < numBitLevels; i++)
++  {
++    UInt32 bit = symbol & 1;
++    RangeEnc_EncodeBit(rc, probs + m, bit);
++    m = (m << 1) | bit;
++    symbol >>= 1;
++  }
++}
++
++static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  symbol |= (1 << numBitLevels);
++  while (symbol != 1)
++  {
++    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
++    symbol >>= 1;
++  }
++  return price;
++}
++
++static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  UInt32 m = 1;
++  int i;
++  for (i = numBitLevels; i != 0; i--)
++  {
++    UInt32 bit = symbol & 1;
++    symbol >>= 1;
++    price += GET_PRICEa(probs[m], bit);
++    m = (m << 1) | bit;
++  }
++  return price;
++}
++
++
++static void LenEnc_Init(CLenEnc *p)
++{
++  unsigned i;
++  p->choice = p->choice2 = kProbInitValue;
++  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
++    p->low[i] = kProbInitValue;
++  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
++    p->mid[i] = kProbInitValue;
++  for (i = 0; i < kLenNumHighSymbols; i++)
++    p->high[i] = kProbInitValue;
++}
++
++static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
++{
++  if (symbol < kLenNumLowSymbols)
++  {
++    RangeEnc_EncodeBit(rc, &p->choice, 0);
++    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
++  }
++  else
++  {
++    RangeEnc_EncodeBit(rc, &p->choice, 1);
++    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
++    {
++      RangeEnc_EncodeBit(rc, &p->choice2, 0);
++      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
++    }
++    else
++    {
++      RangeEnc_EncodeBit(rc, &p->choice2, 1);
++      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
++    }
++  }
++}
++
++static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
++{
++  UInt32 a0 = GET_PRICE_0a(p->choice);
++  UInt32 a1 = GET_PRICE_1a(p->choice);
++  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
++  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
++  UInt32 i = 0;
++  for (i = 0; i < kLenNumLowSymbols; i++)
++  {
++    if (i >= numSymbols)
++      return;
++    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
++  }
++  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
++  {
++    if (i >= numSymbols)
++      return;
++    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
++  }
++  for (; i < numSymbols; i++)
++    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
++}
++
++static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
++{
++  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
++  p->counters[posState] = p->tableSize;
++}
++
++static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
++{
++  UInt32 posState;
++  for (posState = 0; posState < numPosStates; posState++)
++    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
++}
++
++static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
++{
++  LenEnc_Encode(&p->p, rc, symbol, posState);
++  if (updatePrice)
++    if (--p->counters[posState] == 0)
++      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
++}
++
++
++
++
++static void MovePos(CLzmaEnc *p, UInt32 num)
++{
++  #ifdef SHOW_STAT
++  ttt += num;
++  printf("\n MovePos %d", num);
++  #endif
++  if (num != 0)
++  {
++    p->additionalOffset += num;
++    p->matchFinder.Skip(p->matchFinderObj, num);
++  }
++}
++
++static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
++{
++  UInt32 lenRes = 0, numPairs;
++  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
++  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
++  #ifdef SHOW_STAT
++  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
++  ttt++;
++  {
++    UInt32 i;
++    for (i = 0; i < numPairs; i += 2)
++      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
++  }
++  #endif
++  if (numPairs > 0)
++  {
++    lenRes = p->matches[numPairs - 2];
++    if (lenRes == p->numFastBytes)
++    {
++      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++      UInt32 distance = p->matches[numPairs - 1] + 1;
++      UInt32 numAvail = p->numAvail;
++      if (numAvail > LZMA_MATCH_LEN_MAX)
++        numAvail = LZMA_MATCH_LEN_MAX;
++      {
++        const Byte *pby2 = pby - distance;
++        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
++      }
++    }
++  }
++  p->additionalOffset++;
++  *numDistancePairsRes = numPairs;
++  return lenRes;
++}
++
++
++#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
++#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
++#define IsShortRep(p) ((p)->backPrev == 0)
++
++static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
++{
++  return
++    GET_PRICE_0(p->isRepG0[state]) +
++    GET_PRICE_0(p->isRep0Long[state][posState]);
++}
++
++static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
++{
++  UInt32 price;
++  if (repIndex == 0)
++  {
++    price = GET_PRICE_0(p->isRepG0[state]);
++    price += GET_PRICE_1(p->isRep0Long[state][posState]);
++  }
++  else
++  {
++    price = GET_PRICE_1(p->isRepG0[state]);
++    if (repIndex == 1)
++      price += GET_PRICE_0(p->isRepG1[state]);
++    else
++    {
++      price += GET_PRICE_1(p->isRepG1[state]);
++      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
++    }
++  }
++  return price;
++}
++
++static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
++{
++  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
++    GetPureRepPrice(p, repIndex, state, posState);
++}
++
++static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
++{
++  UInt32 posMem = p->opt[cur].posPrev;
++  UInt32 backMem = p->opt[cur].backPrev;
++  p->optimumEndIndex = cur;
++  do
++  {
++    if (p->opt[cur].prev1IsChar)
++    {
++      MakeAsChar(&p->opt[posMem])
++      p->opt[posMem].posPrev = posMem - 1;
++      if (p->opt[cur].prev2)
++      {
++        p->opt[posMem - 1].prev1IsChar = False;
++        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
++        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
++      }
++    }
++    {
++      UInt32 posPrev = posMem;
++      UInt32 backCur = backMem;
++
++      backMem = p->opt[posPrev].backPrev;
++      posMem = p->opt[posPrev].posPrev;
++
++      p->opt[posPrev].backPrev = backCur;
++      p->opt[posPrev].posPrev = cur;
++      cur = posPrev;
++    }
++  }
++  while (cur != 0);
++  *backRes = p->opt[0].backPrev;
++  p->optimumCurrentIndex  = p->opt[0].posPrev;
++  return p->optimumCurrentIndex;
++}
++
++#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
++
++static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
++{
++  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
++  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
++  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
++  UInt32 *matches;
++  const Byte *data;
++  Byte curByte, matchByte;
++  if (p->optimumEndIndex != p->optimumCurrentIndex)
++  {
++    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
++    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
++    *backRes = opt->backPrev;
++    p->optimumCurrentIndex = opt->posPrev;
++    return lenRes;
++  }
++  p->optimumCurrentIndex = p->optimumEndIndex = 0;
++
++  if (p->additionalOffset == 0)
++    mainLen = ReadMatchDistances(p, &numPairs);
++  else
++  {
++    mainLen = p->longestMatchLength;
++    numPairs = p->numPairs;
++  }
++
++  numAvail = p->numAvail;
++  if (numAvail < 2)
++  {
++    *backRes = (UInt32)(-1);
++    return 1;
++  }
++  if (numAvail > LZMA_MATCH_LEN_MAX)
++    numAvail = LZMA_MATCH_LEN_MAX;
++
++  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++  repMaxIndex = 0;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 lenTest;
++    const Byte *data2;
++    reps[i] = p->reps[i];
++    data2 = data - (reps[i] + 1);
++    if (data[0] != data2[0] || data[1] != data2[1])
++    {
++      repLens[i] = 0;
++      continue;
++    }
++    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
++    repLens[i] = lenTest;
++    if (lenTest > repLens[repMaxIndex])
++      repMaxIndex = i;
++  }
++  if (repLens[repMaxIndex] >= p->numFastBytes)
++  {
++    UInt32 lenRes;
++    *backRes = repMaxIndex;
++    lenRes = repLens[repMaxIndex];
++    MovePos(p, lenRes - 1);
++    return lenRes;
++  }
++
++  matches = p->matches;
++  if (mainLen >= p->numFastBytes)
++  {
++    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
++    MovePos(p, mainLen - 1);
++    return mainLen;
++  }
++  curByte = *data;
++  matchByte = *(data - (reps[0] + 1));
++
++  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
++  {
++    *backRes = (UInt32)-1;
++    return 1;
++  }
++
++  p->opt[0].state = (CState)p->state;
++
++  posState = (position & p->pbMask);
++
++  {
++    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
++    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
++        (!IsCharState(p->state) ?
++          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
++          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
++  }
++
++  MakeAsChar(&p->opt[1]);
++
++  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
++  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
++
++  if (matchByte == curByte)
++  {
++    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
++    if (shortRepPrice < p->opt[1].price)
++    {
++      p->opt[1].price = shortRepPrice;
++      MakeAsShortRep(&p->opt[1]);
++    }
++  }
++  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
++
++  if (lenEnd < 2)
++  {
++    *backRes = p->opt[1].backPrev;
++    return 1;
++  }
++
++  p->opt[1].posPrev = 0;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++    p->opt[0].backs[i] = reps[i];
++
++  len = lenEnd;
++  do
++    p->opt[len--].price = kInfinityPrice;
++  while (len >= 2);
++
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 repLen = repLens[i];
++    UInt32 price;
++    if (repLen < 2)
++      continue;
++    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
++    do
++    {
++      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
++      COptimal *opt = &p->opt[repLen];
++      if (curAndLenPrice < opt->price)
++      {
++        opt->price = curAndLenPrice;
++        opt->posPrev = 0;
++        opt->backPrev = i;
++        opt->prev1IsChar = False;
++      }
++    }
++    while (--repLen >= 2);
++  }
++
++  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
++
++  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
++  if (len <= mainLen)
++  {
++    UInt32 offs = 0;
++    while (len > matches[offs])
++      offs += 2;
++    for (; ; len++)
++    {
++      COptimal *opt;
++      UInt32 distance = matches[offs + 1];
++
++      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
++      UInt32 lenToPosState = GetLenToPosState(len);
++      if (distance < kNumFullDistances)
++        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
++      else
++      {
++        UInt32 slot;
++        GetPosSlot2(distance, slot);
++        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
++      }
++      opt = &p->opt[len];
++      if (curAndLenPrice < opt->price)
++      {
++        opt->price = curAndLenPrice;
++        opt->posPrev = 0;
++        opt->backPrev = distance + LZMA_NUM_REPS;
++        opt->prev1IsChar = False;
++      }
++      if (len == matches[offs])
++      {
++        offs += 2;
++        if (offs == numPairs)
++          break;
++      }
++    }
++  }
++
++  cur = 0;
++
++    #ifdef SHOW_STAT2
++    if (position >= 0)
++    {
++      unsigned i;
++      printf("\n pos = %4X", position);
++      for (i = cur; i <= lenEnd; i++)
++      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
++    }
++    #endif
++
++  for (;;)
++  {
++    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
++    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
++    Bool nextIsChar;
++    Byte curByte, matchByte;
++    const Byte *data;
++    COptimal *curOpt;
++    COptimal *nextOpt;
++
++    cur++;
++    if (cur == lenEnd)
++      return Backward(p, backRes, cur);
++
++    newLen = ReadMatchDistances(p, &numPairs);
++    if (newLen >= p->numFastBytes)
++    {
++      p->numPairs = numPairs;
++      p->longestMatchLength = newLen;
++      return Backward(p, backRes, cur);
++    }
++    position++;
++    curOpt = &p->opt[cur];
++    posPrev = curOpt->posPrev;
++    if (curOpt->prev1IsChar)
++    {
++      posPrev--;
++      if (curOpt->prev2)
++      {
++        state = p->opt[curOpt->posPrev2].state;
++        if (curOpt->backPrev2 < LZMA_NUM_REPS)
++          state = kRepNextStates[state];
++        else
++          state = kMatchNextStates[state];
++      }
++      else
++        state = p->opt[posPrev].state;
++      state = kLiteralNextStates[state];
++    }
++    else
++      state = p->opt[posPrev].state;
++    if (posPrev == cur - 1)
++    {
++      if (IsShortRep(curOpt))
++        state = kShortRepNextStates[state];
++      else
++        state = kLiteralNextStates[state];
++    }
++    else
++    {
++      UInt32 pos;
++      const COptimal *prevOpt;
++      if (curOpt->prev1IsChar && curOpt->prev2)
++      {
++        posPrev = curOpt->posPrev2;
++        pos = curOpt->backPrev2;
++        state = kRepNextStates[state];
++      }
++      else
++      {
++        pos = curOpt->backPrev;
++        if (pos < LZMA_NUM_REPS)
++          state = kRepNextStates[state];
++        else
++          state = kMatchNextStates[state];
++      }
++      prevOpt = &p->opt[posPrev];
++      if (pos < LZMA_NUM_REPS)
++      {
++        UInt32 i;
++        reps[0] = prevOpt->backs[pos];
++        for (i = 1; i <= pos; i++)
++          reps[i] = prevOpt->backs[i - 1];
++        for (; i < LZMA_NUM_REPS; i++)
++          reps[i] = prevOpt->backs[i];
++      }
++      else
++      {
++        UInt32 i;
++        reps[0] = (pos - LZMA_NUM_REPS);
++        for (i = 1; i < LZMA_NUM_REPS; i++)
++          reps[i] = prevOpt->backs[i - 1];
++      }
++    }
++    curOpt->state = (CState)state;
++
++    curOpt->backs[0] = reps[0];
++    curOpt->backs[1] = reps[1];
++    curOpt->backs[2] = reps[2];
++    curOpt->backs[3] = reps[3];
++
++    curPrice = curOpt->price;
++    nextIsChar = False;
++    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++    curByte = *data;
++    matchByte = *(data - (reps[0] + 1));
++
++    posState = (position & p->pbMask);
++
++    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
++    {
++      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
++      curAnd1Price +=
++        (!IsCharState(state) ?
++          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
++          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
++    }
++
++    nextOpt = &p->opt[cur + 1];
++
++    if (curAnd1Price < nextOpt->price)
++    {
++      nextOpt->price = curAnd1Price;
++      nextOpt->posPrev = cur;
++      MakeAsChar(nextOpt);
++      nextIsChar = True;
++    }
++
++    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
++    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
++
++    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
++    {
++      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
++      if (shortRepPrice <= nextOpt->price)
++      {
++        nextOpt->price = shortRepPrice;
++        nextOpt->posPrev = cur;
++        MakeAsShortRep(nextOpt);
++        nextIsChar = True;
++      }
++    }
++    numAvailFull = p->numAvail;
++    {
++      UInt32 temp = kNumOpts - 1 - cur;
++      if (temp < numAvailFull)
++        numAvailFull = temp;
++    }
++
++    if (numAvailFull < 2)
++      continue;
++    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
++
++    if (!nextIsChar && matchByte != curByte) /* speed optimization */
++    {
++      /* try Literal + rep0 */
++      UInt32 temp;
++      UInt32 lenTest2;
++      const Byte *data2 = data - (reps[0] + 1);
++      UInt32 limit = p->numFastBytes + 1;
++      if (limit > numAvailFull)
++        limit = numAvailFull;
++
++      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
++      lenTest2 = temp - 1;
++      if (lenTest2 >= 2)
++      {
++        UInt32 state2 = kLiteralNextStates[state];
++        UInt32 posStateNext = (position + 1) & p->pbMask;
++        UInt32 nextRepMatchPrice = curAnd1Price +
++            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
++            GET_PRICE_1(p->isRep[state2]);
++        /* for (; lenTest2 >= 2; lenTest2--) */
++        {
++          UInt32 curAndLenPrice;
++          COptimal *opt;
++          UInt32 offset = cur + 1 + lenTest2;
++          while (lenEnd < offset)
++            p->opt[++lenEnd].price = kInfinityPrice;
++          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
++          opt = &p->opt[offset];
++          if (curAndLenPrice < opt->price)
++          {
++            opt->price = curAndLenPrice;
++            opt->posPrev = cur + 1;
++            opt->backPrev = 0;
++            opt->prev1IsChar = True;
++            opt->prev2 = False;
++          }
++        }
++      }
++    }
++
++    startLen = 2; /* speed optimization */
++    {
++    UInt32 repIndex;
++    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
++    {
++      UInt32 lenTest;
++      UInt32 lenTestTemp;
++      UInt32 price;
++      const Byte *data2 = data - (reps[repIndex] + 1);
++      if (data[0] != data2[0] || data[1] != data2[1])
++        continue;
++      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
++      while (lenEnd < cur + lenTest)
++        p->opt[++lenEnd].price = kInfinityPrice;
++      lenTestTemp = lenTest;
++      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
++      do
++      {
++        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
++        COptimal *opt = &p->opt[cur + lenTest];
++        if (curAndLenPrice < opt->price)
++        {
++          opt->price = curAndLenPrice;
++          opt->posPrev = cur;
++          opt->backPrev = repIndex;
++          opt->prev1IsChar = False;
++        }
++      }
++      while (--lenTest >= 2);
++      lenTest = lenTestTemp;
++
++      if (repIndex == 0)
++        startLen = lenTest + 1;
++
++      /* if (_maxMode) */
++        {
++          UInt32 lenTest2 = lenTest + 1;
++          UInt32 limit = lenTest2 + p->numFastBytes;
++          UInt32 nextRepMatchPrice;
++          if (limit > numAvailFull)
++            limit = numAvailFull;
++          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
++          lenTest2 -= lenTest + 1;
++          if (lenTest2 >= 2)
++          {
++            UInt32 state2 = kRepNextStates[state];
++            UInt32 posStateNext = (position + lenTest) & p->pbMask;
++            UInt32 curAndLenCharPrice =
++                price + p->repLenEnc.prices[posState][lenTest - 2] +
++                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
++                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
++                    data[lenTest], data2[lenTest], p->ProbPrices);
++            state2 = kLiteralNextStates[state2];
++            posStateNext = (position + lenTest + 1) & p->pbMask;
++            nextRepMatchPrice = curAndLenCharPrice +
++                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
++                GET_PRICE_1(p->isRep[state2]);
++
++            /* for (; lenTest2 >= 2; lenTest2--) */
++            {
++              UInt32 curAndLenPrice;
++              COptimal *opt;
++              UInt32 offset = cur + lenTest + 1 + lenTest2;
++              while (lenEnd < offset)
++                p->opt[++lenEnd].price = kInfinityPrice;
++              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
++              opt = &p->opt[offset];
++              if (curAndLenPrice < opt->price)
++              {
++                opt->price = curAndLenPrice;
++                opt->posPrev = cur + lenTest + 1;
++                opt->backPrev = 0;
++                opt->prev1IsChar = True;
++                opt->prev2 = True;
++                opt->posPrev2 = cur;
++                opt->backPrev2 = repIndex;
++              }
++            }
++          }
++        }
++    }
++    }
++    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
++    if (newLen > numAvail)
++    {
++      newLen = numAvail;
++      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
++      matches[numPairs] = newLen;
++      numPairs += 2;
++    }
++    if (newLen >= startLen)
++    {
++      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
++      UInt32 offs, curBack, posSlot;
++      UInt32 lenTest;
++      while (lenEnd < cur + newLen)
++        p->opt[++lenEnd].price = kInfinityPrice;
++
++      offs = 0;
++      while (startLen > matches[offs])
++        offs += 2;
++      curBack = matches[offs + 1];
++      GetPosSlot2(curBack, posSlot);
++      for (lenTest = /*2*/ startLen; ; lenTest++)
++      {
++        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
++        UInt32 lenToPosState = GetLenToPosState(lenTest);
++        COptimal *opt;
++        if (curBack < kNumFullDistances)
++          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
++        else
++          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
++
++        opt = &p->opt[cur + lenTest];
++        if (curAndLenPrice < opt->price)
++        {
++          opt->price = curAndLenPrice;
++          opt->posPrev = cur;
++          opt->backPrev = curBack + LZMA_NUM_REPS;
++          opt->prev1IsChar = False;
++        }
++
++        if (/*_maxMode && */lenTest == matches[offs])
++        {
++          /* Try Match + Literal + Rep0 */
++          const Byte *data2 = data - (curBack + 1);
++          UInt32 lenTest2 = lenTest + 1;
++          UInt32 limit = lenTest2 + p->numFastBytes;
++          UInt32 nextRepMatchPrice;
++          if (limit > numAvailFull)
++            limit = numAvailFull;
++          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
++          lenTest2 -= lenTest + 1;
++          if (lenTest2 >= 2)
++          {
++            UInt32 state2 = kMatchNextStates[state];
++            UInt32 posStateNext = (position + lenTest) & p->pbMask;
++            UInt32 curAndLenCharPrice = curAndLenPrice +
++                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
++                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
++                    data[lenTest], data2[lenTest], p->ProbPrices);
++            state2 = kLiteralNextStates[state2];
++            posStateNext = (posStateNext + 1) & p->pbMask;
++            nextRepMatchPrice = curAndLenCharPrice +
++                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
++                GET_PRICE_1(p->isRep[state2]);
++
++            /* for (; lenTest2 >= 2; lenTest2--) */
++            {
++              UInt32 offset = cur + lenTest + 1 + lenTest2;
++              UInt32 curAndLenPrice;
++              COptimal *opt;
++              while (lenEnd < offset)
++                p->opt[++lenEnd].price = kInfinityPrice;
++              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
++              opt = &p->opt[offset];
++              if (curAndLenPrice < opt->price)
++              {
++                opt->price = curAndLenPrice;
++                opt->posPrev = cur + lenTest + 1;
++                opt->backPrev = 0;
++                opt->prev1IsChar = True;
++                opt->prev2 = True;
++                opt->posPrev2 = cur;
++                opt->backPrev2 = curBack + LZMA_NUM_REPS;
++              }
++            }
++          }
++          offs += 2;
++          if (offs == numPairs)
++            break;
++          curBack = matches[offs + 1];
++          if (curBack >= kNumFullDistances)
++            GetPosSlot2(curBack, posSlot);
++        }
++      }
++    }
++  }
++}
++
++#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
++
++static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
++{
++  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
++  const Byte *data;
++  const UInt32 *matches;
++
++  if (p->additionalOffset == 0)
++    mainLen = ReadMatchDistances(p, &numPairs);
++  else
++  {
++    mainLen = p->longestMatchLength;
++    numPairs = p->numPairs;
++  }
++
++  numAvail = p->numAvail;
++  *backRes = (UInt32)-1;
++  if (numAvail < 2)
++    return 1;
++  if (numAvail > LZMA_MATCH_LEN_MAX)
++    numAvail = LZMA_MATCH_LEN_MAX;
++  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++
++  repLen = repIndex = 0;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 len;
++    const Byte *data2 = data - (p->reps[i] + 1);
++    if (data[0] != data2[0] || data[1] != data2[1])
++      continue;
++    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
++    if (len >= p->numFastBytes)
++    {
++      *backRes = i;
++      MovePos(p, len - 1);
++      return len;
++    }
++    if (len > repLen)
++    {
++      repIndex = i;
++      repLen = len;
++    }
++  }
++
++  matches = p->matches;
++  if (mainLen >= p->numFastBytes)
++  {
++    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
++    MovePos(p, mainLen - 1);
++    return mainLen;
++  }
++
++  mainDist = 0; /* for GCC */
++  if (mainLen >= 2)
++  {
++    mainDist = matches[numPairs - 1];
++    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
++    {
++      if (!ChangePair(matches[numPairs - 3], mainDist))
++        break;
++      numPairs -= 2;
++      mainLen = matches[numPairs - 2];
++      mainDist = matches[numPairs - 1];
++    }
++    if (mainLen == 2 && mainDist >= 0x80)
++      mainLen = 1;
++  }
++
++  if (repLen >= 2 && (
++        (repLen + 1 >= mainLen) ||
++        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
++        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
++  {
++    *backRes = repIndex;
++    MovePos(p, repLen - 1);
++    return repLen;
++  }
++
++  if (mainLen < 2 || numAvail <= 2)
++    return 1;
++
++  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
++  if (p->longestMatchLength >= 2)
++  {
++    UInt32 newDistance = matches[p->numPairs - 1];
++    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
++        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
++        (p->longestMatchLength > mainLen + 1) ||
++        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
++      return 1;
++  }
++
++  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 len, limit;
++    const Byte *data2 = data - (p->reps[i] + 1);
++    if (data[0] != data2[0] || data[1] != data2[1])
++      continue;
++    limit = mainLen - 1;
++    for (len = 2; len < limit && data[len] == data2[len]; len++);
++    if (len >= limit)
++      return 1;
++  }
++  *backRes = mainDist + LZMA_NUM_REPS;
++  MovePos(p, mainLen - 2);
++  return mainLen;
++}
++
++static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
++{
++  UInt32 len;
++  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
++  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
++  p->state = kMatchNextStates[p->state];
++  len = LZMA_MATCH_LEN_MIN;
++  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
++  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
++  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
++  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
++}
++
++static SRes CheckErrors(CLzmaEnc *p)
++{
++  if (p->result != SZ_OK)
++    return p->result;
++  if (p->rc.res != SZ_OK)
++    p->result = SZ_ERROR_WRITE;
++  if (p->matchFinderBase.result != SZ_OK)
++    p->result = SZ_ERROR_READ;
++  if (p->result != SZ_OK)
++    p->finished = True;
++  return p->result;
++}
++
++static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
++{
++  /* ReleaseMFStream(); */
++  p->finished = True;
++  if (p->writeEndMark)
++    WriteEndMarker(p, nowPos & p->pbMask);
++  RangeEnc_FlushData(&p->rc);
++  RangeEnc_FlushStream(&p->rc);
++  return CheckErrors(p);
++}
++
++static void FillAlignPrices(CLzmaEnc *p)
++{
++  UInt32 i;
++  for (i = 0; i < kAlignTableSize; i++)
++    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
++  p->alignPriceCount = 0;
++}
++
++static void FillDistancesPrices(CLzmaEnc *p)
++{
++  UInt32 tempPrices[kNumFullDistances];
++  UInt32 i, lenToPosState;
++  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
++  {
++    UInt32 posSlot = GetPosSlot1(i);
++    UInt32 footerBits = ((posSlot >> 1) - 1);
++    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
++    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
++  }
++
++  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
++  {
++    UInt32 posSlot;
++    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
++    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
++    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
++      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
++    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
++      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
++
++    {
++      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
++      UInt32 i;
++      for (i = 0; i < kStartPosModelIndex; i++)
++        distancesPrices[i] = posSlotPrices[i];
++      for (; i < kNumFullDistances; i++)
++        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
++    }
++  }
++  p->matchPriceCount = 0;
++}
++
++static void LzmaEnc_Construct(CLzmaEnc *p)
++{
++  RangeEnc_Construct(&p->rc);
++  MatchFinder_Construct(&p->matchFinderBase);
++  #ifndef _7ZIP_ST
++  MatchFinderMt_Construct(&p->matchFinderMt);
++  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
++  #endif
++
++  {
++    CLzmaEncProps props;
++    LzmaEncProps_Init(&props);
++    LzmaEnc_SetProps(p, &props);
++  }
++
++  #ifndef LZMA_LOG_BSR
++  LzmaEnc_FastPosInit(p->g_FastPos);
++  #endif
++
++  LzmaEnc_InitPriceTables(p->ProbPrices);
++  p->litProbs = 0;
++  p->saveState.litProbs = 0;
++}
++
++CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
++{
++  void *p;
++  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
++  if (p != 0)
++    LzmaEnc_Construct((CLzmaEnc *)p);
++  return p;
++}
++
++static void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->litProbs);
++  alloc->Free(alloc, p->saveState.litProbs);
++  p->litProbs = 0;
++  p->saveState.litProbs = 0;
++}
++
++static void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  #ifndef _7ZIP_ST
++  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
++  #endif
++  MatchFinder_Free(&p->matchFinderBase, allocBig);
++  LzmaEnc_FreeLits(p, alloc);
++  RangeEnc_Free(&p->rc, alloc);
++}
++
++void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
++  alloc->Free(alloc, p);
++}
++
++static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
++{
++  UInt32 nowPos32, startPos32;
++  if (p->needInit)
++  {
++    p->matchFinder.Init(p->matchFinderObj);
++    p->needInit = 0;
++  }
++
++  if (p->finished)
++    return p->result;
++  RINOK(CheckErrors(p));
++
++  nowPos32 = (UInt32)p->nowPos64;
++  startPos32 = nowPos32;
++
++  if (p->nowPos64 == 0)
++  {
++    UInt32 numPairs;
++    Byte curByte;
++    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
++      return Flush(p, nowPos32);
++    ReadMatchDistances(p, &numPairs);
++    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
++    p->state = kLiteralNextStates[p->state];
++    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
++    LitEnc_Encode(&p->rc, p->litProbs, curByte);
++    p->additionalOffset--;
++    nowPos32++;
++  }
++
++  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
++  for (;;)
++  {
++    UInt32 pos, len, posState;
++
++    if (p->fastMode)
++      len = GetOptimumFast(p, &pos);
++    else
++      len = GetOptimum(p, nowPos32, &pos);
++
++    #ifdef SHOW_STAT2
++    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
++    #endif
++
++    posState = nowPos32 & p->pbMask;
++    if (len == 1 && pos == (UInt32)-1)
++    {
++      Byte curByte;
++      CLzmaProb *probs;
++      const Byte *data;
++
++      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
++      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
++      curByte = *data;
++      probs = LIT_PROBS(nowPos32, *(data - 1));
++      if (IsCharState(p->state))
++        LitEnc_Encode(&p->rc, probs, curByte);
++      else
++        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
++      p->state = kLiteralNextStates[p->state];
++    }
++    else
++    {
++      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
++      if (pos < LZMA_NUM_REPS)
++      {
++        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
++        if (pos == 0)
++        {
++          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
++          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
++        }
++        else
++        {
++          UInt32 distance = p->reps[pos];
++          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
++          if (pos == 1)
++            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
++          else
++          {
++            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
++            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
++            if (pos == 3)
++              p->reps[3] = p->reps[2];
++            p->reps[2] = p->reps[1];
++          }
++          p->reps[1] = p->reps[0];
++          p->reps[0] = distance;
++        }
++        if (len == 1)
++          p->state = kShortRepNextStates[p->state];
++        else
++        {
++          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
++          p->state = kRepNextStates[p->state];
++        }
++      }
++      else
++      {
++        UInt32 posSlot;
++        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
++        p->state = kMatchNextStates[p->state];
++        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
++        pos -= LZMA_NUM_REPS;
++        GetPosSlot(pos, posSlot);
++        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
++
++        if (posSlot >= kStartPosModelIndex)
++        {
++          UInt32 footerBits = ((posSlot >> 1) - 1);
++          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
++          UInt32 posReduced = pos - base;
++
++          if (posSlot < kEndPosModelIndex)
++            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
++          else
++          {
++            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
++            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
++            p->alignPriceCount++;
++          }
++        }
++        p->reps[3] = p->reps[2];
++        p->reps[2] = p->reps[1];
++        p->reps[1] = p->reps[0];
++        p->reps[0] = pos;
++        p->matchPriceCount++;
++      }
++    }
++    p->additionalOffset -= len;
++    nowPos32 += len;
++    if (p->additionalOffset == 0)
++    {
++      UInt32 processed;
++      if (!p->fastMode)
++      {
++        if (p->matchPriceCount >= (1 << 7))
++          FillDistancesPrices(p);
++        if (p->alignPriceCount >= kAlignTableSize)
++          FillAlignPrices(p);
++      }
++      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
++        break;
++      processed = nowPos32 - startPos32;
++      if (useLimits)
++      {
++        if (processed + kNumOpts + 300 >= maxUnpackSize ||
++            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
++          break;
++      }
++      else if (processed >= (1 << 15))
++      {
++        p->nowPos64 += nowPos32 - startPos32;
++        return CheckErrors(p);
++      }
++    }
++  }
++  p->nowPos64 += nowPos32 - startPos32;
++  return Flush(p, nowPos32);
++}
++
++#define kBigHashDicLimit ((UInt32)1 << 24)
++
++static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  UInt32 beforeSize = kNumOpts;
++  Bool btMode;
++  if (!RangeEnc_Alloc(&p->rc, alloc))
++    return SZ_ERROR_MEM;
++  btMode = (p->matchFinderBase.btMode != 0);
++  #ifndef _7ZIP_ST
++  p->mtMode = (p->multiThread && !p->fastMode && btMode);
++  #endif
++
++  {
++    unsigned lclp = p->lc + p->lp;
++    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
++    {
++      LzmaEnc_FreeLits(p, alloc);
++      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
++      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
++      if (p->litProbs == 0 || p->saveState.litProbs == 0)
++      {
++        LzmaEnc_FreeLits(p, alloc);
++        return SZ_ERROR_MEM;
++      }
++      p->lclp = lclp;
++    }
++  }
++
++  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
++
++  if (beforeSize + p->dictSize < keepWindowSize)
++    beforeSize = keepWindowSize - p->dictSize;
++
++  #ifndef _7ZIP_ST
++  if (p->mtMode)
++  {
++    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
++    p->matchFinderObj = &p->matchFinderMt;
++    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
++  }
++  else
++  #endif
++  {
++    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
++      return SZ_ERROR_MEM;
++    p->matchFinderObj = &p->matchFinderBase;
++    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
++  }
++  return SZ_OK;
++}
++
++static void LzmaEnc_Init(CLzmaEnc *p)
++{
++  UInt32 i;
++  p->state = 0;
++  for (i = 0 ; i < LZMA_NUM_REPS; i++)
++    p->reps[i] = 0;
++
++  RangeEnc_Init(&p->rc);
++
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    UInt32 j;
++    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
++    {
++      p->isMatch[i][j] = kProbInitValue;
++      p->isRep0Long[i][j] = kProbInitValue;
++    }
++    p->isRep[i] = kProbInitValue;
++    p->isRepG0[i] = kProbInitValue;
++    p->isRepG1[i] = kProbInitValue;
++    p->isRepG2[i] = kProbInitValue;
++  }
++
++  {
++    UInt32 num = 0x300 << (p->lp + p->lc);
++    for (i = 0; i < num; i++)
++      p->litProbs[i] = kProbInitValue;
++  }
++
++  {
++    for (i = 0; i < kNumLenToPosStates; i++)
++    {
++      CLzmaProb *probs = p->posSlotEncoder[i];
++      UInt32 j;
++      for (j = 0; j < (1 << kNumPosSlotBits); j++)
++        probs[j] = kProbInitValue;
++    }
++  }
++  {
++    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
++      p->posEncoders[i] = kProbInitValue;
++  }
++
++  LenEnc_Init(&p->lenEnc.p);
++  LenEnc_Init(&p->repLenEnc.p);
++
++  for (i = 0; i < (1 << kNumAlignBits); i++)
++    p->posAlignEncoder[i] = kProbInitValue;
++
++  p->optimumEndIndex = 0;
++  p->optimumCurrentIndex = 0;
++  p->additionalOffset = 0;
++
++  p->pbMask = (1 << p->pb) - 1;
++  p->lpMask = (1 << p->lp) - 1;
++}
++
++static void LzmaEnc_InitPrices(CLzmaEnc *p)
++{
++  if (!p->fastMode)
++  {
++    FillDistancesPrices(p);
++    FillAlignPrices(p);
++  }
++
++  p->lenEnc.tableSize =
++  p->repLenEnc.tableSize =
++      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
++  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
++  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
++}
++
++static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  UInt32 i;
++  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
++    if (p->dictSize <= ((UInt32)1 << i))
++      break;
++  p->distTableSize = i * 2;
++
++  p->finished = False;
++  p->result = SZ_OK;
++  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
++  LzmaEnc_Init(p);
++  LzmaEnc_InitPrices(p);
++  p->nowPos64 = 0;
++  return SZ_OK;
++}
++
++static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  p->matchFinderBase.stream = inStream;
++  p->needInit = 1;
++  p->rc.outStream = outStream;
++  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
++}
++
++/*SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
++    ISeqInStream *inStream, UInt32 keepWindowSize,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  p->matchFinderBase.stream = inStream;
++  p->needInit = 1;
++  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
++}*/
++
++static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
++{
++  p->matchFinderBase.directInput = 1;
++  p->matchFinderBase.bufferBase = (Byte *)src;
++  p->matchFinderBase.directInputRem = srcLen;
++}
++
++static SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
++    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  LzmaEnc_SetInputBuf(p, src, srcLen);
++  p->needInit = 1;
++
++  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
++}
++
++static void LzmaEnc_Finish(CLzmaEncHandle pp)
++{
++  #ifndef _7ZIP_ST
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  if (p->mtMode)
++    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
++  #else
++  pp = pp;
++  #endif
++}
++
++typedef struct
++{
++  ISeqOutStream funcTable;
++  Byte *data;
++  SizeT rem;
++  Bool overflow;
++} CSeqOutStreamBuf;
++
++static size_t MyWrite(void *pp, const void *data, size_t size)
++{
++  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
++  if (p->rem < size)
++  {
++    size = p->rem;
++    p->overflow = True;
++  }
++  memcpy(p->data, data, size);
++  p->rem -= size;
++  p->data += size;
++  return size;
++}
++
++
++/*UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
++{
++  const CLzmaEnc *p = (CLzmaEnc *)pp;
++  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
++}*/
++
++/*const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
++{
++  const CLzmaEnc *p = (CLzmaEnc *)pp;
++  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
++}*/
++
++/* SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
++    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  UInt64 nowPos64;
++  SRes res;
++  CSeqOutStreamBuf outStream;
++
++  outStream.funcTable.Write = MyWrite;
++  outStream.data = dest;
++  outStream.rem = *destLen;
++  outStream.overflow = False;
++
++  p->writeEndMark = False;
++  p->finished = False;
++  p->result = SZ_OK;
++
++  if (reInit)
++    LzmaEnc_Init(p);
++  LzmaEnc_InitPrices(p);
++  nowPos64 = p->nowPos64;
++  RangeEnc_Init(&p->rc);
++  p->rc.outStream = &outStream.funcTable;
++
++  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
++
++  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
++  *destLen -= outStream.rem;
++  if (outStream.overflow)
++    return SZ_ERROR_OUTPUT_EOF;
++
++  return res;
++}*/
++
++static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
++{
++  SRes res = SZ_OK;
++
++  #ifndef _7ZIP_ST
++  Byte allocaDummy[0x300];
++  int i = 0;
++  for (i = 0; i < 16; i++)
++    allocaDummy[i] = (Byte)i;
++  #endif
++
++  for (;;)
++  {
++    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
++    if (res != SZ_OK || p->finished != 0)
++      break;
++    if (progress != 0)
++    {
++      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
++      if (res != SZ_OK)
++      {
++        res = SZ_ERROR_PROGRESS;
++        break;
++      }
++    }
++  }
++  LzmaEnc_Finish(p);
++  return res;
++}
++
++SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
++  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
++}
++
++SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  int i;
++  UInt32 dictSize = p->dictSize;
++  if (*size < LZMA_PROPS_SIZE)
++    return SZ_ERROR_PARAM;
++  *size = LZMA_PROPS_SIZE;
++  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
++
++  for (i = 11; i <= 30; i++)
++  {
++    if (dictSize <= ((UInt32)2 << i))
++    {
++      dictSize = (2 << i);
++      break;
++    }
++    if (dictSize <= ((UInt32)3 << i))
++    {
++      dictSize = (3 << i);
++      break;
++    }
++  }
++
++  for (i = 0; i < 4; i++)
++    props[1 + i] = (Byte)(dictSize >> (8 * i));
++  return SZ_OK;
++}
++
++SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  SRes res;
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++
++  CSeqOutStreamBuf outStream;
++
++  LzmaEnc_SetInputBuf(p, src, srcLen);
++
++  outStream.funcTable.Write = MyWrite;
++  outStream.data = dest;
++  outStream.rem = *destLen;
++  outStream.overflow = False;
++
++  p->writeEndMark = writeEndMark;
++
++  p->rc.outStream = &outStream.funcTable;
++  res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);
++  if (res == SZ_OK)
++    res = LzmaEnc_Encode2(p, progress);
++
++  *destLen -= outStream.rem;
++  if (outStream.overflow)
++    return SZ_ERROR_OUTPUT_EOF;
++  return res;
++}
++
++SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
++  SRes res;
++  if (p == 0)
++    return SZ_ERROR_MEM;
++
++  res = LzmaEnc_SetProps(p, props);
++  if (res == SZ_OK)
++  {
++    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
++    if (res == SZ_OK)
++      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
++          writeEndMark, progress, alloc, allocBig);
++  }
++
++  LzmaEnc_Destroy(p, alloc, allocBig);
++  return res;
++}
+--- /dev/null
++++ b/lib/lzma/Makefile
+@@ -0,0 +1,7 @@
++lzma_compress-objs := LzFind.o LzmaEnc.o
++lzma_decompress-objs := LzmaDec.o
++
++obj-$(CONFIG_LZMA_COMPRESS) += lzma_compress.o
++obj-$(CONFIG_LZMA_DECOMPRESS) += lzma_decompress.o
++
++EXTRA_CFLAGS += -Iinclude/linux -Iinclude/linux/lzma -include types.h
diff --git a/target/linux/generic/pending-6.12/532-jffs2_eofdetect.patch b/target/linux/generic/pending-6.12/532-jffs2_eofdetect.patch
new file mode 100644
index 0000000000..744fbd0e21
--- /dev/null
+++ b/target/linux/generic/pending-6.12/532-jffs2_eofdetect.patch
@@ -0,0 +1,65 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: fs: jffs2: EOF marker
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ fs/jffs2/build.c | 10 ++++++++++
+ fs/jffs2/scan.c  | 21 +++++++++++++++++++--
+ 2 files changed, 29 insertions(+), 2 deletions(-)
+
+--- a/fs/jffs2/build.c
++++ b/fs/jffs2/build.c
+@@ -117,6 +117,16 @@ static int jffs2_build_filesystem(struct
+ 	dbg_fsbuild("scanned flash completely\n");
+ 	jffs2_dbg_dump_block_lists_nolock(c);
+ 
++	if (c->flags & (1 << 7)) {
++		printk("%s(): unlocking the mtd device... ", __func__);
++		mtd_unlock(c->mtd, 0, c->mtd->size);
++		printk("done.\n");
++
++		printk("%s(): erasing all blocks after the end marker... ", __func__);
++		jffs2_erase_pending_blocks(c, -1);
++		printk("done.\n");
++	}
++
+ 	dbg_fsbuild("pass 1 starting\n");
+ 	c->flags |= JFFS2_SB_FLAG_BUILDING;
+ 	/* Now scan the directory tree, increasing nlink according to every dirent found. */
+--- a/fs/jffs2/scan.c
++++ b/fs/jffs2/scan.c
+@@ -148,8 +148,14 @@ int jffs2_scan_medium(struct jffs2_sb_in
+ 		/* reset summary info for next eraseblock scan */
+ 		jffs2_sum_reset_collected(s);
+ 
+-		ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
+-						buf_size, s);
++		if (c->flags & (1 << 7)) {
++			if (mtd_block_isbad(c->mtd, jeb->offset))
++				ret = BLK_STATE_BADBLOCK;
++			else
++				ret = BLK_STATE_ALLFF;
++		} else
++			ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
++							buf_size, s);
+ 
+ 		if (ret < 0)
+ 			goto out;
+@@ -567,6 +573,17 @@ full_scan:
+ 			return err;
+ 	}
+ 
++	if ((buf[0] == 0xde) &&
++		(buf[1] == 0xad) &&
++		(buf[2] == 0xc0) &&
++		(buf[3] == 0xde)) {
++		/* end of filesystem. erase everything after this point */
++		printk("%s(): End of filesystem marker found at 0x%x\n", __func__, jeb->offset);
++		c->flags |= (1 << 7);
++
++		return BLK_STATE_ALLFF;
++	}
++
+ 	/* We temporarily use 'ofs' as a pointer into the buffer/jeb */
+ 	ofs = 0;
+ 	max_ofs = EMPTY_SCAN_SIZE(c->sector_size);
diff --git a/target/linux/generic/pending-6.12/600-netfilter_conntrack_flush.patch b/target/linux/generic/pending-6.12/600-netfilter_conntrack_flush.patch
new file mode 100644
index 0000000000..52e97e46ef
--- /dev/null
+++ b/target/linux/generic/pending-6.12/600-netfilter_conntrack_flush.patch
@@ -0,0 +1,90 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: netfilter: add support for flushing conntrack via /proc
+
+lede-commit 8193bbe59a74d34d6a26d4a8cb857b1952905314
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ net/netfilter/nf_conntrack_standalone.c | 59 ++++++++++++++++++++++++++++++++-
+ 1 file changed, 58 insertions(+), 1 deletion(-)
+
+--- a/net/netfilter/nf_conntrack_standalone.c
++++ b/net/netfilter/nf_conntrack_standalone.c
+@@ -9,6 +9,7 @@
+ #include <linux/percpu.h>
+ #include <linux/netdevice.h>
+ #include <linux/security.h>
++#include <linux/inet.h>
+ #include <net/net_namespace.h>
+ #ifdef CONFIG_SYSCTL
+ #include <linux/sysctl.h>
+@@ -458,6 +459,58 @@ static int ct_cpu_seq_show(struct seq_fi
+ 	return 0;
+ }
+ 
++struct kill_request {
++	u16 family;
++	union nf_inet_addr addr;
++};
++
++static int kill_matching(struct nf_conn *i, void *data)
++{
++	struct kill_request *kr = data;
++	struct nf_conntrack_tuple *t1 = &i->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
++	struct nf_conntrack_tuple *t2 = &i->tuplehash[IP_CT_DIR_REPLY].tuple;
++
++	if (!kr->family)
++		return 1;
++
++	if (t1->src.l3num != kr->family)
++		return 0;
++
++	return (nf_inet_addr_cmp(&kr->addr, &t1->src.u3) ||
++	        nf_inet_addr_cmp(&kr->addr, &t1->dst.u3) ||
++	        nf_inet_addr_cmp(&kr->addr, &t2->src.u3) ||
++	        nf_inet_addr_cmp(&kr->addr, &t2->dst.u3));
++}
++
++static int ct_file_write(struct file *file, char *buf, size_t count)
++{
++	struct seq_file *seq = file->private_data;
++	struct nf_ct_iter_data iter_data;
++	struct kill_request kr = { };
++
++	if (count == 0)
++		return 0;
++
++	if (count >= INET6_ADDRSTRLEN)
++		count = INET6_ADDRSTRLEN - 1;
++
++	if (strnchr(buf, count, ':')) {
++		kr.family = AF_INET6;
++		if (!in6_pton(buf, count, (void *)&kr.addr, '\n', NULL))
++			return -EINVAL;
++	} else if (strnchr(buf, count, '.')) {
++		kr.family = AF_INET;
++		if (!in4_pton(buf, count, (void *)&kr.addr, '\n', NULL))
++			return -EINVAL;
++	}
++
++	iter_data.net = seq_file_net(seq);
++	iter_data.data = &kr;
++	nf_ct_iterate_cleanup_net(kill_matching, &iter_data);
++
++	return 0;
++}
++
+ static const struct seq_operations ct_cpu_seq_ops = {
+ 	.start	= ct_cpu_seq_start,
+ 	.next	= ct_cpu_seq_next,
+@@ -471,8 +524,9 @@ static int nf_conntrack_standalone_init_
+ 	kuid_t root_uid;
+ 	kgid_t root_gid;
+ 
+-	pde = proc_create_net("nf_conntrack", 0440, net->proc_net, &ct_seq_ops,
+-			sizeof(struct ct_iter_state));
++	pde = proc_create_net_data_write("nf_conntrack", 0440, net->proc_net,
++					 &ct_seq_ops, &ct_file_write,
++					 sizeof(struct ct_iter_state), NULL);
+ 	if (!pde)
+ 		goto out_nf_conntrack;
+ 
diff --git a/target/linux/generic/pending-6.12/610-netfilter_match_bypass_default_checks.patch b/target/linux/generic/pending-6.12/610-netfilter_match_bypass_default_checks.patch
new file mode 100644
index 0000000000..fd22200a84
--- /dev/null
+++ b/target/linux/generic/pending-6.12/610-netfilter_match_bypass_default_checks.patch
@@ -0,0 +1,110 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: kernel: add a new version of my netfilter speedup patches for linux 2.6.39 and 3.0
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ include/uapi/linux/netfilter_ipv4/ip_tables.h |  1 +
+ net/ipv4/netfilter/ip_tables.c                | 37 +++++++++++++++++++++++++++
+ 2 files changed, 38 insertions(+)
+
+--- a/include/uapi/linux/netfilter_ipv4/ip_tables.h
++++ b/include/uapi/linux/netfilter_ipv4/ip_tables.h
+@@ -89,6 +89,7 @@ struct ipt_ip {
+ #define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
+ #define IPT_F_GOTO		0x02	/* Set if jump is a goto */
+ #define IPT_F_MASK		0x03	/* All possible flag bits mask. */
++#define IPT_F_NO_DEF_MATCH	0x80	/* Internal: no default match rules present */
+ 
+ /* Values for "inv" field in struct ipt_ip. */
+ #define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -48,6 +48,9 @@ ip_packet_match(const struct iphdr *ip,
+ {
+ 	unsigned long ret;
+ 
++	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
++		return true;
++
+ 	if (NF_INVF(ipinfo, IPT_INV_SRCIP,
+ 		    (ip->saddr & ipinfo->smsk.s_addr) != ipinfo->src.s_addr) ||
+ 	    NF_INVF(ipinfo, IPT_INV_DSTIP,
+@@ -78,6 +81,29 @@ ip_packet_match(const struct iphdr *ip,
+ 	return true;
+ }
+ 
++static void
++ip_checkdefault(struct ipt_ip *ip)
++{
++	static const char iface_mask[IFNAMSIZ] = {};
++
++	if (ip->invflags || ip->flags & IPT_F_FRAG)
++		return;
++
++	if (memcmp(ip->iniface_mask, iface_mask, IFNAMSIZ) != 0)
++		return;
++
++	if (memcmp(ip->outiface_mask, iface_mask, IFNAMSIZ) != 0)
++		return;
++
++	if (ip->smsk.s_addr || ip->dmsk.s_addr)
++		return;
++
++	if (ip->proto)
++		return;
++
++	ip->flags |= IPT_F_NO_DEF_MATCH;
++}
++
+ static bool
+ ip_checkentry(const struct ipt_ip *ip)
+ {
+@@ -523,6 +549,8 @@ find_check_entry(struct ipt_entry *e, st
+ 	struct xt_mtchk_param mtpar;
+ 	struct xt_entry_match *ematch;
+ 
++	ip_checkdefault(&e->ip);
++
+ 	if (!xt_percpu_counter_alloc(alloc_state, &e->counters))
+ 		return -ENOMEM;
+ 
+@@ -817,6 +845,7 @@ copy_entries_to_user(unsigned int total_
+ 	const struct xt_table_info *private = table->private;
+ 	int ret = 0;
+ 	const void *loc_cpu_entry;
++	u8 flags;
+ 
+ 	counters = alloc_counters(table);
+ 	if (IS_ERR(counters))
+@@ -844,6 +873,14 @@ copy_entries_to_user(unsigned int total_
+ 			goto free_counters;
+ 		}
+ 
++		flags = e->ip.flags & IPT_F_MASK;
++		if (copy_to_user(userptr + off
++				 + offsetof(struct ipt_entry, ip.flags),
++				 &flags, sizeof(flags)) != 0) {
++			ret = -EFAULT;
++			goto free_counters;
++		}
++
+ 		for (i = sizeof(struct ipt_entry);
+ 		     i < e->target_offset;
+ 		     i += m->u.match_size) {
+@@ -1225,12 +1262,15 @@ compat_copy_entry_to_user(struct ipt_ent
+ 	compat_uint_t origsize;
+ 	const struct xt_entry_match *ematch;
+ 	int ret = 0;
++	u8 flags = e->ip.flags & IPT_F_MASK;
+ 
+ 	origsize = *size;
+ 	ce = *dstptr;
+ 	if (copy_to_user(ce, e, sizeof(struct ipt_entry)) != 0 ||
+ 	    copy_to_user(&ce->counters, &counters[i],
+-	    sizeof(counters[i])) != 0)
++	    sizeof(counters[i])) != 0 ||
++	    copy_to_user(&ce->ip.flags, &flags,
++	    sizeof(flags)) != 0)
+ 		return -EFAULT;
+ 
+ 	*dstptr += sizeof(struct compat_ipt_entry);
diff --git a/target/linux/generic/pending-6.12/611-netfilter_match_bypass_default_table.patch b/target/linux/generic/pending-6.12/611-netfilter_match_bypass_default_table.patch
new file mode 100644
index 0000000000..9f0efe4ec4
--- /dev/null
+++ b/target/linux/generic/pending-6.12/611-netfilter_match_bypass_default_table.patch
@@ -0,0 +1,106 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: netfilter: match bypass default table
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ net/ipv4/netfilter/ip_tables.c | 79 +++++++++++++++++++++++++++++++-----------
+ 1 file changed, 58 insertions(+), 21 deletions(-)
+
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -244,6 +244,33 @@ struct ipt_entry *ipt_next_entry(const s
+ 	return (void *)entry + entry->next_offset;
+ }
+ 
++static bool
++ipt_handle_default_rule(struct ipt_entry *e, unsigned int *verdict)
++{
++	struct xt_entry_target *t;
++	struct xt_standard_target *st;
++
++	if (e->target_offset != sizeof(struct ipt_entry))
++		return false;
++
++	if (!(e->ip.flags & IPT_F_NO_DEF_MATCH))
++		return false;
++
++	t = ipt_get_target(e);
++	if (t->u.kernel.target->target)
++		return false;
++
++	st = (struct xt_standard_target *) t;
++	if (st->verdict == XT_RETURN)
++		return false;
++
++	if (st->verdict >= 0)
++		return false;
++
++	*verdict = (unsigned)(-st->verdict) - 1;
++	return true;
++}
++
+ /* Returns one of the generic firewall policies, like NF_ACCEPT. */
+ unsigned int
+ ipt_do_table(void *priv,
+@@ -265,27 +292,28 @@ ipt_do_table(void *priv,
+ 	unsigned int addend;
+ 
+ 	/* Initialization */
++	WARN_ON(!(table->valid_hooks & (1 << hook)));
++	local_bh_disable();
++	private = READ_ONCE(table->private); /* Address dependency. */
++	cpu        = smp_processor_id();
++	table_base = private->entries;
++
++	e = get_entry(table_base, private->hook_entry[hook]);
++	if (ipt_handle_default_rule(e, &verdict)) {
++		struct xt_counters *counter;
++
++		counter = xt_get_this_cpu_counter(&e->counters);
++		ADD_COUNTER(*counter, skb->len, 1);
++		local_bh_enable();
++		return verdict;
++	}
++
+ 	stackidx = 0;
+ 	ip = ip_hdr(skb);
+ 	indev = state->in ? state->in->name : nulldevname;
+ 	outdev = state->out ? state->out->name : nulldevname;
+-	/* We handle fragments by dealing with the first fragment as
+-	 * if it was a normal packet.  All other fragments are treated
+-	 * normally, except that they will NEVER match rules that ask
+-	 * things we don't know, ie. tcp syn flag or ports).  If the
+-	 * rule is also a fragment-specific rule, non-fragments won't
+-	 * match it. */
+-	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
+-	acpar.thoff   = ip_hdrlen(skb);
+-	acpar.hotdrop = false;
+-	acpar.state   = state;
+ 
+-	WARN_ON(!(table->valid_hooks & (1 << hook)));
+-	local_bh_disable();
+ 	addend = xt_write_recseq_begin();
+-	private = READ_ONCE(table->private); /* Address dependency. */
+-	cpu        = smp_processor_id();
+-	table_base = private->entries;
+ 	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];
+ 
+ 	/* Switch to alternate jumpstack if we're being invoked via TEE.
+@@ -298,7 +326,16 @@ ipt_do_table(void *priv,
+ 	if (static_key_false(&xt_tee_enabled))
+ 		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);
+ 
+-	e = get_entry(table_base, private->hook_entry[hook]);
++	/* We handle fragments by dealing with the first fragment as
++	 * if it was a normal packet.  All other fragments are treated
++	 * normally, except that they will NEVER match rules that ask
++	 * things we don't know, ie. tcp syn flag or ports).  If the
++	 * rule is also a fragment-specific rule, non-fragments won't
++	 * match it. */
++	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
++	acpar.thoff   = ip_hdrlen(skb);
++	acpar.hotdrop = false;
++	acpar.state   = state;
+ 
+ 	do {
+ 		const struct xt_entry_target *t;
diff --git a/target/linux/generic/pending-6.12/612-netfilter_match_reduce_memory_access.patch b/target/linux/generic/pending-6.12/612-netfilter_match_reduce_memory_access.patch
new file mode 100644
index 0000000000..7f291fc008
--- /dev/null
+++ b/target/linux/generic/pending-6.12/612-netfilter_match_reduce_memory_access.patch
@@ -0,0 +1,22 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: netfilter: reduce match memory access
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ net/ipv4/netfilter/ip_tables.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -51,9 +51,9 @@ ip_packet_match(const struct iphdr *ip,
+ 	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
+ 		return true;
+ 
+-	if (NF_INVF(ipinfo, IPT_INV_SRCIP,
++	if (NF_INVF(ipinfo, IPT_INV_SRCIP, ipinfo->smsk.s_addr &&
+ 		    (ip->saddr & ipinfo->smsk.s_addr) != ipinfo->src.s_addr) ||
+-	    NF_INVF(ipinfo, IPT_INV_DSTIP,
++	    NF_INVF(ipinfo, IPT_INV_DSTIP, ipinfo->dmsk.s_addr &&
+ 		    (ip->daddr & ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr))
+ 		return false;
+ 
diff --git a/target/linux/generic/pending-6.12/630-packet_socket_type.patch b/target/linux/generic/pending-6.12/630-packet_socket_type.patch
new file mode 100644
index 0000000000..fff421bd3c
--- /dev/null
+++ b/target/linux/generic/pending-6.12/630-packet_socket_type.patch
@@ -0,0 +1,138 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: net: add an optimization for dealing with raw sockets
+
+lede-commit: 4898039703d7315f0f3431c860123338ec3be0f6
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ include/uapi/linux/if_packet.h |  3 +++
+ net/packet/af_packet.c         | 34 +++++++++++++++++++++++++++-------
+ net/packet/internal.h          |  1 +
+ 3 files changed, 31 insertions(+), 7 deletions(-)
+
+--- a/include/uapi/linux/if_packet.h
++++ b/include/uapi/linux/if_packet.h
+@@ -33,6 +33,8 @@ struct sockaddr_ll {
+ #define PACKET_KERNEL		7		/* To kernel space	*/
+ /* Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space */
+ #define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
++#define PACKET_MASK_ANY		0xffffffff	/* mask for packet type bits */
++
+ 
+ /* Packet socket options */
+ 
+@@ -60,6 +62,7 @@ struct sockaddr_ll {
+ #define PACKET_FANOUT_DATA		22
+ #define PACKET_IGNORE_OUTGOING		23
+ #define PACKET_VNET_HDR_SZ		24
++#define PACKET_RECV_TYPE		25
+ 
+ #define PACKET_FANOUT_HASH		0
+ #define PACKET_FANOUT_LB		1
+--- a/net/packet/af_packet.c
++++ b/net/packet/af_packet.c
+@@ -1911,6 +1911,7 @@ static int packet_rcv_spkt(struct sk_buf
+ {
+ 	struct sock *sk;
+ 	struct sockaddr_pkt *spkt;
++	struct packet_sock *po;
+ 
+ 	/*
+ 	 *	When we registered the protocol we saved the socket in the data
+@@ -1918,6 +1919,7 @@ static int packet_rcv_spkt(struct sk_buf
+ 	 */
+ 
+ 	sk = pt->af_packet_priv;
++	po = pkt_sk(sk);
+ 
+ 	/*
+ 	 *	Yank back the headers [hope the device set this
+@@ -1930,7 +1932,7 @@ static int packet_rcv_spkt(struct sk_buf
+ 	 *	so that this procedure is noop.
+ 	 */
+ 
+-	if (skb->pkt_type == PACKET_LOOPBACK)
++	if (!(po->pkt_type & (1 << skb->pkt_type)))
+ 		goto out;
+ 
+ 	if (!net_eq(dev_net(dev), sock_net(sk)))
+@@ -2175,12 +2177,12 @@ static int packet_rcv(struct sk_buff *sk
+ 	int skb_len = skb->len;
+ 	unsigned int snaplen, res;
+ 
+-	if (skb->pkt_type == PACKET_LOOPBACK)
+-		goto drop;
+-
+ 	sk = pt->af_packet_priv;
+ 	po = pkt_sk(sk);
+ 
++	if (!(po->pkt_type & (1 << skb->pkt_type)))
++		goto drop;
++
+ 	if (!net_eq(dev_net(dev), sock_net(sk)))
+ 		goto drop;
+ 
+@@ -2304,12 +2306,12 @@ static int tpacket_rcv(struct sk_buff *s
+ 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);
+ 	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);
+ 
+-	if (skb->pkt_type == PACKET_LOOPBACK)
+-		goto drop;
+-
+ 	sk = pt->af_packet_priv;
+ 	po = pkt_sk(sk);
+ 
++	if (!(po->pkt_type & (1 << skb->pkt_type)))
++		goto drop;
++
+ 	if (!net_eq(dev_net(dev), sock_net(sk)))
+ 		goto drop;
+ 
+@@ -3430,6 +3432,7 @@ static int packet_create(struct net *net
+ 	mutex_init(&po->pg_vec_lock);
+ 	po->rollover = NULL;
+ 	po->prot_hook.func = packet_rcv;
++	po->pkt_type = PACKET_MASK_ANY & ~(1 << PACKET_LOOPBACK);
+ 
+ 	if (sock->type == SOCK_PACKET)
+ 		po->prot_hook.func = packet_rcv_spkt;
+@@ -4097,6 +4100,16 @@ packet_setsockopt(struct socket *sock, i
+ 		packet_sock_flag_set(po, PACKET_SOCK_QDISC_BYPASS, val);
+ 		return 0;
+ 	}
++	case PACKET_RECV_TYPE:
++	{
++		unsigned int val;
++		if (optlen != sizeof(val))
++			return -EINVAL;
++		if (copy_from_sockptr(&val, optval, sizeof(val)))
++			return -EFAULT;
++		po->pkt_type = val & ~BIT(PACKET_LOOPBACK);
++		return 0;
++	}
+ 	default:
+ 		return -ENOPROTOOPT;
+ 	}
+@@ -4159,6 +4172,13 @@ static int packet_getsockopt(struct sock
+ 	case PACKET_COPY_THRESH:
+ 		val = READ_ONCE(pkt_sk(sk)->copy_thresh);
+ 		break;
++	case PACKET_RECV_TYPE:
++		if (len > sizeof(unsigned int))
++			len = sizeof(unsigned int);
++		val = po->pkt_type;
++
++		data = &val;
++		break;
+ 	case PACKET_VERSION:
+ 		val = po->tp_version;
+ 		break;
+--- a/net/packet/internal.h
++++ b/net/packet/internal.h
+@@ -131,6 +131,7 @@ struct packet_sock {
+ 	struct net_device __rcu	*cached_dev;
+ 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
+ 	atomic_t		tp_drops ____cacheline_aligned_in_smp;
++	unsigned int		pkt_type;
+ };
+ 
+ #define pkt_sk(ptr) container_of_const(ptr, struct packet_sock, sk)
diff --git a/target/linux/generic/pending-6.12/640-net-bridge-fix-switchdev-host-mdb-entry-updates.patch b/target/linux/generic/pending-6.12/640-net-bridge-fix-switchdev-host-mdb-entry-updates.patch
new file mode 100644
index 0000000000..cf55c6a3fb
--- /dev/null
+++ b/target/linux/generic/pending-6.12/640-net-bridge-fix-switchdev-host-mdb-entry-updates.patch
@@ -0,0 +1,42 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 22 Aug 2024 18:02:17 +0200
+Subject: [PATCH] net: bridge: fix switchdev host mdb entry updates
+
+When a mdb entry is removed, the bridge switchdev code can issue a
+switchdev_port_obj_del call for a port that was not offloaded.
+
+This leads to an imbalance in switchdev_port_obj_add/del calls, since
+br_switchdev_mdb_replay has not been called for the port before.
+
+This can lead to potential multicast forwarding issues and messages such as:
+mt7915e 0000:01:00.0 wl1-ap0: Failed to del Host Multicast Database entry
+	(object id=3) with error: -ENOENT (-2).
+
+Fix this issue by checking the port offload status when iterating over
+lower devs.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/bridge/br_switchdev.c
++++ b/net/bridge/br_switchdev.c
+@@ -568,10 +568,18 @@ static void br_switchdev_host_mdb(struct
+ 				  struct net_bridge_mdb_entry *mp, int type)
+ {
+ 	struct net_device *lower_dev;
++	struct net_bridge_port *port;
+ 	struct list_head *iter;
+ 
+-	netdev_for_each_lower_dev(dev, lower_dev, iter)
++	rcu_read_lock();
++	netdev_for_each_lower_dev(dev, lower_dev, iter) {
++		port = br_port_get_rcu(lower_dev);
++		if (!port || !port->offload_count)
++			continue;
++
+ 		br_switchdev_host_mdb_one(dev, lower_dev, mp, type);
++	}
++	rcu_read_unlock();
+ }
+ 
+ static int
diff --git a/target/linux/generic/pending-6.12/641-net-bridge-switchdev-Don-t-drop-packets-between-port.patch b/target/linux/generic/pending-6.12/641-net-bridge-switchdev-Don-t-drop-packets-between-port.patch
new file mode 100644
index 0000000000..1c4ec61b50
--- /dev/null
+++ b/target/linux/generic/pending-6.12/641-net-bridge-switchdev-Don-t-drop-packets-between-port.patch
@@ -0,0 +1,38 @@
+From: "Leon M. Busch-George" <leon@georgemail.eu>
+Date: Sun, 20 Oct 2024 18:20:14 +0200
+Subject: [PATCH] net: bridge: switchdev: Don't drop packets between ports with
+ no hwdom
+
+nbp_switchdev_allowed_egress uses hwdom to determine whether or not a
+packet has already been forwarded to a hardware domain. For
+net_bridge_ports that aren't set up to use forward offloading, hwdom is
+set to 0. When both ingress and egress port have no hwdom,
+'cb->src_hwdom != p->hwdom' indicates that the packet is already known in
+the target domain - which it isn't - and the packet is wrongly dropped.
+
+The error was found on a bridge containing a wifi device and a VLAN
+tagging device (e.g. eth0.12). With VLAN filtering, this shouldn't happen.
+
+This patch adds a check for p->hwdom != 0 before comparing hardware
+domains to restore forwarding between ports with hwdom = 0.
+
+fwd_hwdoms are only set for ports with offloading enabled, which also
+implies a valid hwdom, so the check '!test_bit(p->hwdom, &cb->fwd_hwdoms)'
+doesn't fail in this way (yet - fingers crossed..) and it is left in place.
+
+Co-developed-by: Felix Fietkau <nbd@nbd.name>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+Signed-off-by: Leon M. Busch-George <leon@georgemail.eu>
+---
+
+--- a/net/bridge/br_switchdev.c
++++ b/net/bridge/br_switchdev.c
+@@ -67,7 +67,7 @@ bool nbp_switchdev_allowed_egress(const
+ 	struct br_input_skb_cb *cb = BR_INPUT_SKB_CB(skb);
+ 
+ 	return !test_bit(p->hwdom, &cb->fwd_hwdoms) &&
+-		(!skb->offload_fwd_mark || cb->src_hwdom != p->hwdom);
++		(!skb->offload_fwd_mark || !p->hwdom || cb->src_hwdom != p->hwdom);
+ }
+ 
+ /* Flags that can be offloaded to hardware */
diff --git a/target/linux/generic/pending-6.12/642-net-bridge-locally-receive-all-multicast-packets-if-.patch b/target/linux/generic/pending-6.12/642-net-bridge-locally-receive-all-multicast-packets-if-.patch
new file mode 100644
index 0000000000..98edb315b1
--- /dev/null
+++ b/target/linux/generic/pending-6.12/642-net-bridge-locally-receive-all-multicast-packets-if-.patch
@@ -0,0 +1,24 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 17 Feb 2025 12:21:08 +0100
+Subject: [PATCH] net: bridge: locally receive all multicast packets if
+ IFF_ALLMULTI is set
+
+If multicast snooping is enabled, multicast packets may not always end up on
+the local bridge interface, if the host is not a member of the multicast
+group. Similar to how IFF_PROMISC allows all packets to be received locally,
+let IFF_ALLMULTI allow all multicast packets to be received.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -152,6 +152,8 @@ int br_handle_frame_finish(struct net *n
+ 			pkt_type = BR_PKT_MULTICAST;
+ 			if (br_multicast_rcv(&brmctx, &pmctx, vlan, skb, vid))
+ 				goto drop;
++			if (br->dev->flags & IFF_ALLMULTI)
++				local_rcv = true;
+ 		}
+ 	}
+ 
diff --git a/target/linux/generic/pending-6.12/655-increase_skb_pad.patch b/target/linux/generic/pending-6.12/655-increase_skb_pad.patch
new file mode 100644
index 0000000000..6fa3358218
--- /dev/null
+++ b/target/linux/generic/pending-6.12/655-increase_skb_pad.patch
@@ -0,0 +1,20 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: kernel: add a few patches for avoiding unnecessary skb reallocations - significantly improves ethernet<->wireless performance
+
+lede-commit: 6f89cffc9add6939d44a6b54cf9a5e77849aa7fd
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ include/linux/skbuff.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -3180,7 +3180,7 @@ static inline int pskb_network_may_pull(
+  * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
+  */
+ #ifndef NET_SKB_PAD
+-#define NET_SKB_PAD	max(32, L1_CACHE_BYTES)
++#define NET_SKB_PAD	max(64, L1_CACHE_BYTES)
+ #endif
+ 
+ int ___pskb_trim(struct sk_buff *skb, unsigned int len);
diff --git a/target/linux/generic/pending-6.12/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch b/target/linux/generic/pending-6.12/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch
new file mode 100644
index 0000000000..f0e8a63a99
--- /dev/null
+++ b/target/linux/generic/pending-6.12/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch
@@ -0,0 +1,511 @@
+From: Steven Barth <steven@midlink.org>
+Subject: Add support for MAP-E FMRs (mesh mode)
+
+MAP-E FMRs (draft-ietf-softwire-map-10) are rules for IPv4-communication
+between MAP CEs (mesh mode) without the need to forward such data to a
+border relay. This is similar to how 6rd works but for IPv4 over IPv6.
+
+Signed-off-by: Steven Barth <cyrus@openwrt.org>
+---
+ include/net/ip6_tunnel.h       |  13 ++
+ include/uapi/linux/if_tunnel.h |  13 ++
+ net/ipv6/ip6_tunnel.c          | 276 +++++++++++++++++++++++++++++++++++++++--
+ 3 files changed, 291 insertions(+), 11 deletions(-)
+
+--- a/include/net/ip6_tunnel.h
++++ b/include/net/ip6_tunnel.h
+@@ -18,6 +18,18 @@
+ /* determine capability on a per-packet basis */
+ #define IP6_TNL_F_CAP_PER_PACKET 0x40000
+ 
++/* IPv6 tunnel FMR */
++struct __ip6_tnl_fmr {
++	struct __ip6_tnl_fmr *next; /* next fmr in list */
++	struct in6_addr ip6_prefix;
++	struct in_addr ip4_prefix;
++
++	__u8 ip6_prefix_len;
++	__u8 ip4_prefix_len;
++	__u8 ea_len;
++	__u8 offset;
++};
++
+ struct __ip6_tnl_parm {
+ 	char name[IFNAMSIZ];	/* name of tunnel device */
+ 	int link;		/* ifindex of underlying L2 interface */
+@@ -29,6 +41,7 @@ struct __ip6_tnl_parm {
+ 	__u32 flags;		/* tunnel flags */
+ 	struct in6_addr laddr;	/* local tunnel end-point address */
+ 	struct in6_addr raddr;	/* remote tunnel end-point address */
++	struct __ip6_tnl_fmr *fmrs;	/* FMRs */
+ 
+ 	IP_TUNNEL_DECLARE_FLAGS(i_flags);
+ 	IP_TUNNEL_DECLARE_FLAGS(o_flags);
+--- a/include/uapi/linux/if_tunnel.h
++++ b/include/uapi/linux/if_tunnel.h
+@@ -77,10 +77,23 @@ enum {
+ 	IFLA_IPTUN_ENCAP_DPORT,
+ 	IFLA_IPTUN_COLLECT_METADATA,
+ 	IFLA_IPTUN_FWMARK,
++	IFLA_IPTUN_FMRS,
+ 	__IFLA_IPTUN_MAX,
+ };
+ #define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
+ 
++enum {
++	IFLA_IPTUN_FMR_UNSPEC,
++	IFLA_IPTUN_FMR_IP6_PREFIX,
++	IFLA_IPTUN_FMR_IP4_PREFIX,
++	IFLA_IPTUN_FMR_IP6_PREFIX_LEN,
++	IFLA_IPTUN_FMR_IP4_PREFIX_LEN,
++	IFLA_IPTUN_FMR_EA_LEN,
++	IFLA_IPTUN_FMR_OFFSET,
++	__IFLA_IPTUN_FMR_MAX,
++};
++#define IFLA_IPTUN_FMR_MAX (__IFLA_IPTUN_FMR_MAX - 1)
++
+ enum tunnel_encap_types {
+ 	TUNNEL_ENCAP_NONE,
+ 	TUNNEL_ENCAP_FOU,
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -11,6 +11,9 @@
+  *      linux/net/ipv6/sit.c and linux/net/ipv4/ipip.c
+  *
+  *      RFC 2473
++ *
++ *      Changes:
++ *      Steven Barth <cyrus@openwrt.org>:           MAP-E FMR support
+  */
+ 
+ #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+@@ -68,9 +71,9 @@ static bool log_ecn_error = true;
+ module_param(log_ecn_error, bool, 0644);
+ MODULE_PARM_DESC(log_ecn_error, "Log packets received with corrupted ECN");
+ 
+-static u32 HASH(const struct in6_addr *addr1, const struct in6_addr *addr2)
++static u32 HASH(const struct in6_addr *addr)
+ {
+-	u32 hash = ipv6_addr_hash(addr1) ^ ipv6_addr_hash(addr2);
++	u32 hash = ipv6_addr_hash(addr);
+ 
+ 	return hash_32(hash, IP6_TUNNEL_HASH_SIZE_SHIFT);
+ }
+@@ -115,17 +118,33 @@ static struct ip6_tnl *
+ ip6_tnl_lookup(struct net *net, int link,
+ 	       const struct in6_addr *remote, const struct in6_addr *local)
+ {
+-	unsigned int hash = HASH(remote, local);
++	unsigned int hash = HASH(local);
+ 	struct ip6_tnl *t, *cand = NULL;
+ 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
+ 	struct in6_addr any;
+ 
+ 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
+ 		if (!ipv6_addr_equal(local, &t->parms.laddr) ||
+-		    !ipv6_addr_equal(remote, &t->parms.raddr) ||
+ 		    !(t->dev->flags & IFF_UP))
+ 			continue;
+ 
++		if (!ipv6_addr_equal(remote, &t->parms.raddr)) {
++			struct __ip6_tnl_fmr *fmr;
++			bool found = false;
++
++			for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
++				if (!ipv6_prefix_equal(remote, &fmr->ip6_prefix,
++						       fmr->ip6_prefix_len))
++					continue;
++
++				found = true;
++				break;
++			}
++
++			if (!found)
++				continue;
++		}
++
+ 		if (link == t->parms.link)
+ 			return t;
+ 		else
+@@ -133,7 +152,7 @@ ip6_tnl_lookup(struct net *net, int link
+ 	}
+ 
+ 	memset(&any, 0, sizeof(any));
+-	hash = HASH(&any, local);
++	hash = HASH(local);
+ 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
+ 		if (!ipv6_addr_equal(local, &t->parms.laddr) ||
+ 		    !ipv6_addr_any(&t->parms.raddr) ||
+@@ -146,7 +165,7 @@ ip6_tnl_lookup(struct net *net, int link
+ 			cand = t;
+ 	}
+ 
+-	hash = HASH(remote, &any);
++	hash = HASH(&any);
+ 	for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {
+ 		if (!ipv6_addr_equal(remote, &t->parms.raddr) ||
+ 		    !ipv6_addr_any(&t->parms.laddr) ||
+@@ -195,7 +214,7 @@ ip6_tnl_bucket(struct ip6_tnl_net *ip6n,
+ 
+ 	if (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {
+ 		prio = 1;
+-		h = HASH(remote, local);
++		h = HASH(local);
+ 	}
+ 	return &ip6n->tnls[prio][h];
+ }
+@@ -376,6 +395,12 @@ ip6_tnl_dev_uninit(struct net_device *de
+ 	struct net *net = t->net;
+ 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
+ 
++	while (t->parms.fmrs) {
++		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
++		kfree(t->parms.fmrs);
++		t->parms.fmrs = next;
++	}
++
+ 	if (dev == ip6n->fb_tnl_dev)
+ 		RCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);
+ 	else
+@@ -790,6 +815,107 @@ int ip6_tnl_rcv_ctl(struct ip6_tnl *t,
+ }
+ EXPORT_SYMBOL_GPL(ip6_tnl_rcv_ctl);
+ 
++/**
++ * ip4ip6_fmr_calc - calculate target / source IPv6-address based on FMR
++ *   @dest: destination IPv6 address buffer
++ *   @skb: received socket buffer
++ *   @fmr: MAP FMR
++ *   @xmit: Calculate for xmit or rcv
++ **/
++static void ip4ip6_fmr_calc(struct in6_addr *dest,
++		const struct iphdr *iph, const uint8_t *end,
++		const struct __ip6_tnl_fmr *fmr, bool xmit)
++{
++	int psidlen = fmr->ea_len - (32 - fmr->ip4_prefix_len);
++	u8 *portp = NULL;
++	bool use_dest_addr;
++	const struct iphdr *dsth = iph;
++
++	if ((u8*)dsth >= end)
++		return;
++
++	/* find significant IP header */
++	if (iph->protocol == IPPROTO_ICMP) {
++		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
++		if (ih && ((u8*)&ih[1]) <= end && (
++			ih->type == ICMP_DEST_UNREACH ||
++			ih->type == ICMP_SOURCE_QUENCH ||
++			ih->type == ICMP_TIME_EXCEEDED ||
++			ih->type == ICMP_PARAMETERPROB ||
++			ih->type == ICMP_REDIRECT))
++				dsth = (const struct iphdr*)&ih[1];
++	}
++
++	/* in xmit-path use dest port by default and source port only if
++		this is an ICMP reply to something else; vice versa in rcv-path */
++	use_dest_addr = (xmit && dsth == iph) || (!xmit && dsth != iph);
++
++	/* get dst port */
++	if (((u8*)&dsth[1]) <= end && (
++		dsth->protocol == IPPROTO_UDP ||
++		dsth->protocol == IPPROTO_TCP ||
++		dsth->protocol == IPPROTO_SCTP ||
++		dsth->protocol == IPPROTO_DCCP)) {
++			/* for UDP, TCP, SCTP and DCCP source and dest port
++			follow IPv4 header directly */
++			portp = ((u8*)dsth) + dsth->ihl * 4;
++
++			if (use_dest_addr)
++				portp += sizeof(u16);
++	} else if (iph->protocol == IPPROTO_ICMP) {
++		struct icmphdr *ih = (struct icmphdr*)(((u8*)dsth) + dsth->ihl * 4);
++
++		/* use icmp identifier as port */
++		if (((u8*)&ih) <= end && (
++		    (use_dest_addr && (
++		    ih->type == ICMP_ECHOREPLY ||
++			ih->type == ICMP_TIMESTAMPREPLY ||
++			ih->type == ICMP_INFO_REPLY ||
++			ih->type == ICMP_ADDRESSREPLY)) ||
++			(!use_dest_addr && (
++			ih->type == ICMP_ECHO ||
++			ih->type == ICMP_TIMESTAMP ||
++			ih->type == ICMP_INFO_REQUEST ||
++			ih->type == ICMP_ADDRESS)
++			)))
++				portp = (u8*)&ih->un.echo.id;
++	}
++
++	if ((portp && &portp[2] <= end) || psidlen == 0) {
++		int frombyte = fmr->ip6_prefix_len / 8;
++		int fromrem = fmr->ip6_prefix_len % 8;
++		int bytes = sizeof(struct in6_addr) - frombyte;
++		const u32 *addr = (use_dest_addr) ? &iph->daddr : &iph->saddr;
++		u64 eabits = ((u64)ntohl(*addr)) << (32 + fmr->ip4_prefix_len);
++		u64 t = 0;
++
++		/* extract PSID from port and add it to eabits */
++		u16 psidbits = 0;
++		if (psidlen > 0) {
++			psidbits = ((u16)portp[0]) << 8 | ((u16)portp[1]);
++			psidbits >>= 16 - psidlen - fmr->offset;
++			psidbits = (u16)(psidbits << (16 - psidlen));
++			eabits |= ((u64)psidbits) << (48 - (fmr->ea_len - psidlen));
++		}
++
++		/* rewrite destination address */
++		*dest = fmr->ip6_prefix;
++		memcpy(&dest->s6_addr[10], addr, sizeof(*addr));
++		dest->s6_addr16[7] = htons(psidbits >> (16 - psidlen));
++
++		if (bytes > sizeof(u64))
++			bytes = sizeof(u64);
++
++		/* insert eabits */
++		memcpy(&t, &dest->s6_addr[frombyte], bytes);
++		t = be64_to_cpu(t) & ~(((((u64)1) << fmr->ea_len) - 1)
++			<< (64 - fmr->ea_len - fromrem));
++		t = cpu_to_be64(t | (eabits >> fromrem));
++		memcpy(&dest->s6_addr[frombyte], &t, bytes);
++	}
++}
++
++
+ static int __ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,
+ 			 const struct tnl_ptk_info *tpi,
+ 			 struct metadata_dst *tun_dst,
+@@ -855,6 +981,27 @@ static int __ip6_tnl_rcv(struct ip6_tnl
+ 
+ 	memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
+ 
++	if (tpi->proto == htons(ETH_P_IP) && tunnel->parms.fmrs &&
++		!ipv6_addr_equal(&ipv6h->saddr, &tunnel->parms.raddr)) {
++			/* Packet didn't come from BR, so lookup FMR */
++			struct __ip6_tnl_fmr *fmr;
++			struct in6_addr expected = tunnel->parms.raddr;
++			for (fmr = tunnel->parms.fmrs; fmr; fmr = fmr->next)
++				if (ipv6_prefix_equal(&ipv6h->saddr,
++					&fmr->ip6_prefix, fmr->ip6_prefix_len))
++						break;
++
++			/* Check that IPv6 matches IPv4 source to prevent spoofing */
++			if (fmr)
++				ip4ip6_fmr_calc(&expected, ip_hdr(skb),
++						skb_tail_pointer(skb), fmr, false);
++
++			if (!ipv6_addr_equal(&ipv6h->saddr, &expected)) {
++				rcu_read_unlock();
++				goto drop;
++			}
++	}
++
+ 	__skb_tunnel_rx(skb, tunnel->dev, tunnel->net);
+ 
+ 	err = dscp_ecn_decapsulate(tunnel, ipv6h, skb);
+@@ -1004,6 +1151,7 @@ static void init_tel_txopt(struct ipv6_t
+ 	opt->ops.opt_nflen = 8;
+ }
+ 
++
+ /**
+  * ip6_tnl_addr_conflict - compare packet addresses to tunnel's own
+  *   @t: the outgoing tunnel device
+@@ -1294,6 +1442,7 @@ ipxip6_tnl_xmit(struct sk_buff *skb, str
+ 		u8 protocol)
+ {
+ 	struct ip6_tnl *t = netdev_priv(dev);
++	struct __ip6_tnl_fmr *fmr;
+ 	struct ipv6hdr *ipv6h;
+ 	const struct iphdr  *iph;
+ 	int encap_limit = -1;
+@@ -1393,6 +1542,18 @@ ipxip6_tnl_xmit(struct sk_buff *skb, str
+ 	fl6.flowi6_uid = sock_net_uid(dev_net(dev), NULL);
+ 	dsfield = INET_ECN_encapsulate(dsfield, orig_dsfield);
+ 
++	/* try to find matching FMR */
++	for (fmr = t->parms.fmrs; fmr; fmr = fmr->next) {
++		unsigned mshift = 32 - fmr->ip4_prefix_len;
++		if (ntohl(fmr->ip4_prefix.s_addr) >> mshift ==
++				ntohl(ip_hdr(skb)->daddr) >> mshift)
++			break;
++	}
++
++	/* change dstaddr according to FMR */
++	if (fmr)
++		ip4ip6_fmr_calc(&fl6.daddr, ip_hdr(skb), skb_tail_pointer(skb), fmr, true);
++
+ 	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
+ 		return -1;
+ 
+@@ -1546,6 +1707,14 @@ ip6_tnl_change(struct ip6_tnl *t, const
+ 	t->parms.link = p->link;
+ 	t->parms.proto = p->proto;
+ 	t->parms.fwmark = p->fwmark;
++
++	while (t->parms.fmrs) {
++		struct __ip6_tnl_fmr *next = t->parms.fmrs->next;
++		kfree(t->parms.fmrs);
++		t->parms.fmrs = next;
++	}
++	t->parms.fmrs = p->fmrs;
++
+ 	dst_cache_reset(&t->dst_cache);
+ 	ip6_tnl_link_config(t);
+ }
+@@ -1580,6 +1749,7 @@ ip6_tnl_parm_from_user(struct __ip6_tnl_
+ 	p->flowinfo = u->flowinfo;
+ 	p->link = u->link;
+ 	p->proto = u->proto;
++	p->fmrs = NULL;
+ 	memcpy(p->name, u->name, sizeof(u->name));
+ }
+ 
+@@ -1963,6 +2133,15 @@ static int ip6_tnl_validate(struct nlatt
+ 	return 0;
+ }
+ 
++static const struct nla_policy ip6_tnl_fmr_policy[IFLA_IPTUN_FMR_MAX + 1] = {
++	[IFLA_IPTUN_FMR_IP6_PREFIX] = { .len = sizeof(struct in6_addr) },
++	[IFLA_IPTUN_FMR_IP4_PREFIX] = { .len = sizeof(struct in_addr) },
++	[IFLA_IPTUN_FMR_IP6_PREFIX_LEN] = { .type = NLA_U8 },
++	[IFLA_IPTUN_FMR_IP4_PREFIX_LEN] = { .type = NLA_U8 },
++	[IFLA_IPTUN_FMR_EA_LEN] = { .type = NLA_U8 },
++	[IFLA_IPTUN_FMR_OFFSET] = { .type = NLA_U8 }
++};
++
+ static void ip6_tnl_netlink_parms(struct nlattr *data[],
+ 				  struct __ip6_tnl_parm *parms)
+ {
+@@ -2000,6 +2179,46 @@ static void ip6_tnl_netlink_parms(struct
+ 
+ 	if (data[IFLA_IPTUN_FWMARK])
+ 		parms->fwmark = nla_get_u32(data[IFLA_IPTUN_FWMARK]);
++
++	if (data[IFLA_IPTUN_FMRS]) {
++		unsigned rem;
++		struct nlattr *fmr;
++		nla_for_each_nested(fmr, data[IFLA_IPTUN_FMRS], rem) {
++			struct nlattr *fmrd[IFLA_IPTUN_FMR_MAX + 1], *c;
++			struct __ip6_tnl_fmr *nfmr;
++
++			nla_parse_nested(fmrd, IFLA_IPTUN_FMR_MAX,
++				fmr, ip6_tnl_fmr_policy, NULL);
++
++			if (!(nfmr = kzalloc(sizeof(*nfmr), GFP_KERNEL)))
++				continue;
++
++			nfmr->offset = 6;
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX]))
++				nla_memcpy(&nfmr->ip6_prefix, fmrd[IFLA_IPTUN_FMR_IP6_PREFIX],
++					sizeof(nfmr->ip6_prefix));
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX]))
++				nla_memcpy(&nfmr->ip4_prefix, fmrd[IFLA_IPTUN_FMR_IP4_PREFIX],
++					sizeof(nfmr->ip4_prefix));
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_IP6_PREFIX_LEN]))
++				nfmr->ip6_prefix_len = nla_get_u8(c);
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_IP4_PREFIX_LEN]))
++				nfmr->ip4_prefix_len = nla_get_u8(c);
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_EA_LEN]))
++				nfmr->ea_len = nla_get_u8(c);
++
++			if ((c = fmrd[IFLA_IPTUN_FMR_OFFSET]))
++				nfmr->offset = nla_get_u8(c);
++
++			nfmr->next = parms->fmrs;
++			parms->fmrs = nfmr;
++		}
++	}
+ }
+ 
+ static int ip6_tnl_newlink(struct net *src_net, struct net_device *dev,
+@@ -2083,6 +2302,12 @@ static void ip6_tnl_dellink(struct net_d
+ 
+ static size_t ip6_tnl_get_size(const struct net_device *dev)
+ {
++	const struct ip6_tnl *t = netdev_priv(dev);
++	struct __ip6_tnl_fmr *c;
++	int fmrs = 0;
++	for (c = t->parms.fmrs; c; c = c->next)
++		++fmrs;
++
+ 	return
+ 		/* IFLA_IPTUN_LINK */
+ 		nla_total_size(4) +
+@@ -2112,6 +2337,24 @@ static size_t ip6_tnl_get_size(const str
+ 		nla_total_size(0) +
+ 		/* IFLA_IPTUN_FWMARK */
+ 		nla_total_size(4) +
++		/* IFLA_IPTUN_FMRS */
++		nla_total_size(0) +
++		(
++			/* nest */
++			nla_total_size(0) +
++			/* IFLA_IPTUN_FMR_IP6_PREFIX */
++			nla_total_size(sizeof(struct in6_addr)) +
++			/* IFLA_IPTUN_FMR_IP4_PREFIX */
++			nla_total_size(sizeof(struct in_addr)) +
++			/* IFLA_IPTUN_FMR_EA_LEN */
++			nla_total_size(1) +
++			/* IFLA_IPTUN_FMR_IP6_PREFIX_LEN */
++			nla_total_size(1) +
++			/* IFLA_IPTUN_FMR_IP4_PREFIX_LEN */
++			nla_total_size(1) +
++			/* IFLA_IPTUN_FMR_OFFSET */
++			nla_total_size(1)
++		) * fmrs +
+ 		0;
+ }
+ 
+@@ -2119,6 +2362,9 @@ static int ip6_tnl_fill_info(struct sk_b
+ {
+ 	struct ip6_tnl *tunnel = netdev_priv(dev);
+ 	struct __ip6_tnl_parm *parm = &tunnel->parms;
++	struct __ip6_tnl_fmr *c;
++	int fmrcnt = 0;
++	struct nlattr *fmrs;
+ 
+ 	if (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||
+ 	    nla_put_in6_addr(skb, IFLA_IPTUN_LOCAL, &parm->laddr) ||
+@@ -2128,9 +2374,27 @@ static int ip6_tnl_fill_info(struct sk_b
+ 	    nla_put_be32(skb, IFLA_IPTUN_FLOWINFO, parm->flowinfo) ||
+ 	    nla_put_u32(skb, IFLA_IPTUN_FLAGS, parm->flags) ||
+ 	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto) ||
+-	    nla_put_u32(skb, IFLA_IPTUN_FWMARK, parm->fwmark))
++	    nla_put_u32(skb, IFLA_IPTUN_FWMARK, parm->fwmark) ||
++	    !(fmrs = nla_nest_start(skb, IFLA_IPTUN_FMRS)))
+ 		goto nla_put_failure;
+ 
++	for (c = parm->fmrs; c; c = c->next) {
++		struct nlattr *fmr = nla_nest_start(skb, ++fmrcnt);
++		if (!fmr ||
++			nla_put(skb, IFLA_IPTUN_FMR_IP6_PREFIX,
++				sizeof(c->ip6_prefix), &c->ip6_prefix) ||
++			nla_put(skb, IFLA_IPTUN_FMR_IP4_PREFIX,
++				sizeof(c->ip4_prefix), &c->ip4_prefix) ||
++			nla_put_u8(skb, IFLA_IPTUN_FMR_IP6_PREFIX_LEN, c->ip6_prefix_len) ||
++			nla_put_u8(skb, IFLA_IPTUN_FMR_IP4_PREFIX_LEN, c->ip4_prefix_len) ||
++			nla_put_u8(skb, IFLA_IPTUN_FMR_EA_LEN, c->ea_len) ||
++			nla_put_u8(skb, IFLA_IPTUN_FMR_OFFSET, c->offset))
++				goto nla_put_failure;
++
++		nla_nest_end(skb, fmr);
++	}
++	nla_nest_end(skb, fmrs);
++
+ 	if (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE, tunnel->encap.type) ||
+ 	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT, tunnel->encap.sport) ||
+ 	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT, tunnel->encap.dport) ||
+@@ -2170,6 +2434,7 @@ static const struct nla_policy ip6_tnl_p
+ 	[IFLA_IPTUN_ENCAP_DPORT]	= { .type = NLA_U16 },
+ 	[IFLA_IPTUN_COLLECT_METADATA]	= { .type = NLA_FLAG },
+ 	[IFLA_IPTUN_FWMARK]		= { .type = NLA_U32 },
++	[IFLA_IPTUN_FMRS]		= { .type = NLA_NESTED },
+ };
+ 
+ static struct rtnl_link_ops ip6_link_ops __read_mostly = {
diff --git a/target/linux/generic/pending-6.12/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch b/target/linux/generic/pending-6.12/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
new file mode 100644
index 0000000000..a9aa7a3beb
--- /dev/null
+++ b/target/linux/generic/pending-6.12/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
@@ -0,0 +1,263 @@
+From: Jonas Gorski <jogo@openwrt.org>
+Subject: ipv6: allow rejecting with "source address failed policy"
+
+RFC6204 L-14 requires rejecting traffic from invalid addresses with
+ICMPv6 Destination Unreachable, Code 5 (Source address failed ingress/
+egress policy) on the LAN side, so add an appropriate rule for that.
+
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+---
+ include/net/netns/ipv6.h       |  1 +
+ include/uapi/linux/fib_rules.h |  4 +++
+ include/uapi/linux/rtnetlink.h |  1 +
+ net/ipv4/fib_semantics.c       |  4 +++
+ net/ipv4/fib_trie.c            |  1 +
+ net/ipv4/ipmr.c                |  1 +
+ net/ipv6/fib6_rules.c          |  4 +++
+ net/ipv6/ip6mr.c               |  2 ++
+ net/ipv6/route.c               | 58 +++++++++++++++++++++++++++++++++++++++++-
+ 9 files changed, 75 insertions(+), 1 deletion(-)
+
+--- a/include/net/netns/ipv6.h
++++ b/include/net/netns/ipv6.h
+@@ -86,6 +86,7 @@ struct netns_ipv6 {
+ 	unsigned int		fib6_routes_require_src;
+ #endif
+ 	struct rt6_info         *ip6_prohibit_entry;
++	struct rt6_info		*ip6_policy_failed_entry;
+ 	struct rt6_info         *ip6_blk_hole_entry;
+ 	struct fib6_table       *fib6_local_tbl;
+ 	struct fib_rules_ops    *fib6_rules_ops;
+--- a/include/uapi/linux/fib_rules.h
++++ b/include/uapi/linux/fib_rules.h
+@@ -83,6 +83,10 @@ enum {
+ 	FR_ACT_BLACKHOLE,	/* Drop without notification */
+ 	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
+ 	FR_ACT_PROHIBIT,	/* Drop with EACCES */
++	FR_ACT_RES9,
++	FR_ACT_RES10,
++	FR_ACT_RES11,
++	FR_ACT_POLICY_FAILED,	/* Drop with EACCES */
+ 	__FR_ACT_MAX,
+ };
+ 
+--- a/include/uapi/linux/rtnetlink.h
++++ b/include/uapi/linux/rtnetlink.h
+@@ -265,6 +265,7 @@ enum {
+ 	RTN_THROW,		/* Not in this table		*/
+ 	RTN_NAT,		/* Translate this address	*/
+ 	RTN_XRESOLVE,		/* Use external resolver	*/
++	RTN_POLICY_FAILED,	/* Failed ingress/egress policy */
+ 	__RTN_MAX
+ };
+ 
+--- a/net/ipv4/fib_semantics.c
++++ b/net/ipv4/fib_semantics.c
+@@ -145,6 +145,10 @@ const struct fib_prop fib_props[RTN_MAX
+ 		.error	= -EINVAL,
+ 		.scope	= RT_SCOPE_NOWHERE,
+ 	},
++	[RTN_POLICY_FAILED] = {
++		.error	= -EACCES,
++		.scope	= RT_SCOPE_UNIVERSE,
++	},
+ };
+ 
+ static void rt_fibinfo_free(struct rtable __rcu **rtp)
+--- a/net/ipv4/fib_trie.c
++++ b/net/ipv4/fib_trie.c
+@@ -2784,6 +2784,7 @@ static const char *const rtn_type_names[
+ 	[RTN_THROW] = "THROW",
+ 	[RTN_NAT] = "NAT",
+ 	[RTN_XRESOLVE] = "XRESOLVE",
++	[RTN_POLICY_FAILED] = "POLICY_FAILED",
+ };
+ 
+ static inline const char *rtn_type(char *buf, size_t len, unsigned int t)
+--- a/net/ipv4/ipmr.c
++++ b/net/ipv4/ipmr.c
+@@ -191,6 +191,7 @@ static int ipmr_rule_action(struct fib_r
+ 	case FR_ACT_UNREACHABLE:
+ 		return -ENETUNREACH;
+ 	case FR_ACT_PROHIBIT:
++	case FR_ACT_POLICY_FAILED:
+ 		return -EACCES;
+ 	case FR_ACT_BLACKHOLE:
+ 	default:
+--- a/net/ipv6/fib6_rules.c
++++ b/net/ipv6/fib6_rules.c
+@@ -222,6 +222,10 @@ static int __fib6_rule_action(struct fib
+ 		err = -EACCES;
+ 		rt = net->ipv6.ip6_prohibit_entry;
+ 		goto discard_pkt;
++	case FR_ACT_POLICY_FAILED:
++		err = -EACCES;
++		rt = net->ipv6.ip6_policy_failed_entry;
++		goto discard_pkt;
+ 	}
+ 
+ 	tb_id = fib_rule_get_table(rule, arg);
+--- a/net/ipv6/ip6mr.c
++++ b/net/ipv6/ip6mr.c
+@@ -180,6 +180,8 @@ static int ip6mr_rule_action(struct fib_
+ 		return -ENETUNREACH;
+ 	case FR_ACT_PROHIBIT:
+ 		return -EACCES;
++	case FR_ACT_POLICY_FAILED:
++		return -EACCES;
+ 	case FR_ACT_BLACKHOLE:
+ 	default:
+ 		return -EINVAL;
+--- a/net/ipv6/route.c
++++ b/net/ipv6/route.c
+@@ -98,6 +98,8 @@ static int		ip6_pkt_discard(struct sk_bu
+ static int		ip6_pkt_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb);
+ static int		ip6_pkt_prohibit(struct sk_buff *skb);
+ static int		ip6_pkt_prohibit_out(struct net *net, struct sock *sk, struct sk_buff *skb);
++static int		ip6_pkt_policy_failed(struct sk_buff *skb);
++static int		ip6_pkt_policy_failed_out(struct net *net, struct sock *sk, struct sk_buff *skb);
+ static void		ip6_link_failure(struct sk_buff *skb);
+ static void		ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
+ 					   struct sk_buff *skb, u32 mtu,
+@@ -316,6 +318,18 @@ static const struct rt6_info ip6_prohibi
+ 	.rt6i_flags	= (RTF_REJECT | RTF_NONEXTHOP),
+ };
+ 
++static const struct rt6_info ip6_policy_failed_entry_template = {
++	.dst = {
++		.__rcuref	= RCUREF_INIT(1),
++		.__use		= 1,
++		.obsolete	= DST_OBSOLETE_FORCE_CHK,
++		.error		= -EACCES,
++		.input		= ip6_pkt_policy_failed,
++		.output		= ip6_pkt_policy_failed_out,
++	},
++	.rt6i_flags	= (RTF_REJECT | RTF_NONEXTHOP),
++};
++
+ static const struct rt6_info ip6_blk_hole_entry_template = {
+ 	.dst = {
+ 		.__rcuref	= RCUREF_INIT(1),
+@@ -1085,6 +1099,7 @@ static const int fib6_prop[RTN_MAX + 1]
+ 	[RTN_BLACKHOLE]	= -EINVAL,
+ 	[RTN_UNREACHABLE] = -EHOSTUNREACH,
+ 	[RTN_PROHIBIT]	= -EACCES,
++	[RTN_POLICY_FAILED] = -EACCES,
+ 	[RTN_THROW]	= -EAGAIN,
+ 	[RTN_NAT]	= -EINVAL,
+ 	[RTN_XRESOLVE]	= -EINVAL,
+@@ -1120,6 +1135,10 @@ static void ip6_rt_init_dst_reject(struc
+ 		rt->dst.output = ip6_pkt_prohibit_out;
+ 		rt->dst.input = ip6_pkt_prohibit;
+ 		break;
++	case RTN_POLICY_FAILED:
++		rt->dst.output = ip6_pkt_policy_failed_out;
++		rt->dst.input = ip6_pkt_policy_failed;
++		break;
+ 	case RTN_THROW:
+ 	case RTN_UNREACHABLE:
+ 	default:
+@@ -4598,6 +4617,17 @@ static int ip6_pkt_prohibit_out(struct n
+ 	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);
+ }
+ 
++static int ip6_pkt_policy_failed(struct sk_buff *skb)
++{
++	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_INNOROUTES);
++}
++
++static int ip6_pkt_policy_failed_out(struct net *net, struct sock *sk, struct sk_buff *skb)
++{
++	skb->dev = skb_dst(skb)->dev;
++	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_OUTNOROUTES);
++}
++
+ /*
+  *	Allocate a dst for local (unicast / anycast) address.
+  */
+@@ -5089,7 +5119,8 @@ static int rtm_to_fib6_config(struct sk_
+ 	if (rtm->rtm_type == RTN_UNREACHABLE ||
+ 	    rtm->rtm_type == RTN_BLACKHOLE ||
+ 	    rtm->rtm_type == RTN_PROHIBIT ||
+-	    rtm->rtm_type == RTN_THROW)
++	    rtm->rtm_type == RTN_THROW ||
++	    rtm->rtm_type == RTN_POLICY_FAILED)
+ 		cfg->fc_flags |= RTF_REJECT;
+ 
+ 	if (rtm->rtm_type == RTN_LOCAL)
+@@ -6349,6 +6380,8 @@ static int ip6_route_dev_notify(struct n
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 		net->ipv6.ip6_prohibit_entry->dst.dev = dev;
+ 		net->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);
++		net->ipv6.ip6_policy_failed_entry->dst.dev = dev;
++		net->ipv6.ip6_policy_failed_entry->rt6i_idev = in6_dev_get(dev);
+ 		net->ipv6.ip6_blk_hole_entry->dst.dev = dev;
+ 		net->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);
+ #endif
+@@ -6360,6 +6393,7 @@ static int ip6_route_dev_notify(struct n
+ 		in6_dev_put_clear(&net->ipv6.ip6_null_entry->rt6i_idev);
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 		in6_dev_put_clear(&net->ipv6.ip6_prohibit_entry->rt6i_idev);
++		in6_dev_put_clear(&net->ipv6.ip6_policy_failed_entry->rt6i_idev);
+ 		in6_dev_put_clear(&net->ipv6.ip6_blk_hole_entry->rt6i_idev);
+ #endif
+ 	}
+@@ -6555,6 +6589,8 @@ static int __net_init ip6_route_net_init
+ 
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 	net->ipv6.fib6_has_custom_rules = false;
++
++
+ 	net->ipv6.ip6_prohibit_entry = kmemdup(&ip6_prohibit_entry_template,
+ 					       sizeof(*net->ipv6.ip6_prohibit_entry),
+ 					       GFP_KERNEL);
+@@ -6565,11 +6601,21 @@ static int __net_init ip6_route_net_init
+ 			 ip6_template_metrics, true);
+ 	INIT_LIST_HEAD(&net->ipv6.ip6_prohibit_entry->dst.rt_uncached);
+ 
++	net->ipv6.ip6_policy_failed_entry =
++				kmemdup(&ip6_policy_failed_entry_template,
++				sizeof(*net->ipv6.ip6_policy_failed_entry), GFP_KERNEL);
++	if (!net->ipv6.ip6_policy_failed_entry)
++		goto out_ip6_prohibit_entry;
++	net->ipv6.ip6_policy_failed_entry->dst.ops = &net->ipv6.ip6_dst_ops;
++	dst_init_metrics(&net->ipv6.ip6_policy_failed_entry->dst,
++			 ip6_template_metrics, true);
++	INIT_LIST_HEAD(&net->ipv6.ip6_policy_failed_entry->dst.rt_uncached);
++
+ 	net->ipv6.ip6_blk_hole_entry = kmemdup(&ip6_blk_hole_entry_template,
+ 					       sizeof(*net->ipv6.ip6_blk_hole_entry),
+ 					       GFP_KERNEL);
+ 	if (!net->ipv6.ip6_blk_hole_entry)
+-		goto out_ip6_prohibit_entry;
++		goto out_ip6_policy_failed_entry;
+ 	net->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;
+ 	dst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,
+ 			 ip6_template_metrics, true);
+@@ -6596,6 +6642,8 @@ out:
+ 	return ret;
+ 
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
++out_ip6_policy_failed_entry:
++	kfree(net->ipv6.ip6_policy_failed_entry);
+ out_ip6_prohibit_entry:
+ 	kfree(net->ipv6.ip6_prohibit_entry);
+ out_ip6_null_entry:
+@@ -6615,6 +6663,7 @@ static void __net_exit ip6_route_net_exi
+ 	kfree(net->ipv6.ip6_null_entry);
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 	kfree(net->ipv6.ip6_prohibit_entry);
++	kfree(net->ipv6.ip6_policy_failed_entry);
+ 	kfree(net->ipv6.ip6_blk_hole_entry);
+ #endif
+ 	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
+@@ -6698,6 +6747,9 @@ void __init ip6_route_init_special_entri
+ 	init_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
+ 	init_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;
+ 	init_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
++	init_net.ipv6.ip6_policy_failed_entry->dst.dev = init_net.loopback_dev;
++	init_net.ipv6.ip6_policy_failed_entry->rt6i_idev =
++		in6_dev_get(init_net.loopback_dev);
+   #endif
+ }
+ 
diff --git a/target/linux/generic/pending-6.12/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch b/target/linux/generic/pending-6.12/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch
new file mode 100644
index 0000000000..7057d364db
--- /dev/null
+++ b/target/linux/generic/pending-6.12/671-net-provide-defines-for-_POLICY_FAILED-until-all-cod.patch
@@ -0,0 +1,50 @@
+From: Jonas Gorski <jogo@openwrt.org>
+Subject: net: provide defines for _POLICY_FAILED until all code is updated
+
+Upstream introduced ICMPV6_POLICY_FAIL for code 5 of destination
+unreachable, conflicting with our name.
+
+Add appropriate defines to allow our code to build with the new
+name until we have updated our local patches for older kernels
+and userspace packages.
+
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+---
+ include/uapi/linux/fib_rules.h | 2 ++
+ include/uapi/linux/icmpv6.h    | 2 ++
+ include/uapi/linux/rtnetlink.h | 2 ++
+ 3 files changed, 6 insertions(+)
+
+--- a/include/uapi/linux/fib_rules.h
++++ b/include/uapi/linux/fib_rules.h
+@@ -90,6 +90,8 @@ enum {
+ 	__FR_ACT_MAX,
+ };
+ 
++#define FR_ACT_FAILED_POLICY FR_ACT_POLICY_FAILED
++
+ #define FR_ACT_MAX (__FR_ACT_MAX - 1)
+ 
+ #endif
+--- a/include/uapi/linux/icmpv6.h
++++ b/include/uapi/linux/icmpv6.h
+@@ -127,6 +127,8 @@ struct icmp6hdr {
+ #define ICMPV6_POLICY_FAIL		5
+ #define ICMPV6_REJECT_ROUTE		6
+ 
++#define ICMPV6_FAILED_POLICY		ICMPV6_POLICY_FAIL
++
+ /*
+  *	Codes for Time Exceeded
+  */
+--- a/include/uapi/linux/rtnetlink.h
++++ b/include/uapi/linux/rtnetlink.h
+@@ -269,6 +269,8 @@ enum {
+ 	__RTN_MAX
+ };
+ 
++#define RTN_FAILED_POLICY RTN_POLICY_FAILED
++
+ #define RTN_MAX (__RTN_MAX - 1)
+ 
+ 
diff --git a/target/linux/generic/pending-6.12/681-net-remove-NETIF_F_GSO_FRAGLIST-from-NETIF_F_GSO_SOF.patch b/target/linux/generic/pending-6.12/681-net-remove-NETIF_F_GSO_FRAGLIST-from-NETIF_F_GSO_SOF.patch
new file mode 100644
index 0000000000..9788ded24c
--- /dev/null
+++ b/target/linux/generic/pending-6.12/681-net-remove-NETIF_F_GSO_FRAGLIST-from-NETIF_F_GSO_SOF.patch
@@ -0,0 +1,129 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 15 Aug 2024 21:15:13 +0200
+Subject: [PATCH] net: remove NETIF_F_GSO_FRAGLIST from NETIF_F_GSO_SOFTWARE
+
+Several drivers set NETIF_F_GSO_SOFTWARE, but mangle fraglist GRO packets
+in a way that they can't be properly segmented anymore.
+In order to properly deal with this, remove fraglist GSO from
+NETIF_F_GSO_SOFTWARE and switch to NETIF_F_GSO_SOFTWARE_ALL (which includes
+fraglist GSO) in places where it's safe to add.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/dummy.c
++++ b/drivers/net/dummy.c
+@@ -111,7 +111,7 @@ static void dummy_setup(struct net_devic
+ 	dev->priv_flags |= IFF_LIVE_ADDR_CHANGE | IFF_NO_QUEUE;
+ 	dev->lltx = true;
+ 	dev->features	|= NETIF_F_SG | NETIF_F_FRAGLIST;
+-	dev->features	|= NETIF_F_GSO_SOFTWARE;
++	dev->features	|= NETIF_F_GSO_SOFTWARE_ALL;
+ 	dev->features	|= NETIF_F_HW_CSUM | NETIF_F_HIGHDMA;
+ 	dev->features	|= NETIF_F_GSO_ENCAP_ALL;
+ 	dev->hw_features |= dev->features;
+--- a/drivers/net/loopback.c
++++ b/drivers/net/loopback.c
+@@ -174,7 +174,7 @@ static void gen_lo_setup(struct net_devi
+ 	dev->lltx		= true;
+ 	dev->netns_local	= true;
+ 	netif_keep_dst(dev);
+-	dev->hw_features	= NETIF_F_GSO_SOFTWARE;
++	dev->hw_features	= NETIF_F_GSO_SOFTWARE_ALL;
+ 	dev->features		= NETIF_F_SG | NETIF_F_FRAGLIST
+ 		| NETIF_F_GSO_SOFTWARE
+ 		| NETIF_F_HW_CSUM
+--- a/drivers/net/macvlan.c
++++ b/drivers/net/macvlan.c
+@@ -897,7 +897,7 @@ static int macvlan_hwtstamp_set(struct n
+ static struct lock_class_key macvlan_netdev_addr_lock_key;
+ 
+ #define ALWAYS_ON_OFFLOADS \
+-	(NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_GSO_SOFTWARE | \
++	(NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_GSO_SOFTWARE_ALL | \
+ 	 NETIF_F_GSO_ROBUST | NETIF_F_GSO_ENCAP_ALL)
+ 
+ #define ALWAYS_ON_FEATURES ALWAYS_ON_OFFLOADS
+--- a/include/linux/netdev_features.h
++++ b/include/linux/netdev_features.h
+@@ -211,13 +211,14 @@ static inline int find_next_netdev_featu
+ 
+ /* List of features with software fallbacks. */
+ #define NETIF_F_GSO_SOFTWARE	(NETIF_F_ALL_TSO | NETIF_F_GSO_SCTP |	     \
+-				 NETIF_F_GSO_UDP_L4 | NETIF_F_GSO_FRAGLIST)
++				 NETIF_F_GSO_UDP_L4)
++#define NETIF_F_GSO_SOFTWARE_ALL (NETIF_F_GSO_SOFTWARE | NETIF_F_GSO_FRAGLIST)
+ 
+ /*
+  * If one device supports one of these features, then enable them
+  * for all in netdev_increment_features.
+  */
+-#define NETIF_F_ONE_FOR_ALL	(NETIF_F_GSO_SOFTWARE | NETIF_F_GSO_ROBUST | \
++#define NETIF_F_ONE_FOR_ALL	(NETIF_F_GSO_SOFTWARE_ALL | NETIF_F_GSO_ROBUST | \
+ 				 NETIF_F_SG | NETIF_F_HIGHDMA |		\
+ 				 NETIF_F_FRAGLIST | NETIF_F_VLAN_CHALLENGED)
+ 
+--- a/net/8021q/vlan.h
++++ b/net/8021q/vlan.h
+@@ -108,7 +108,7 @@ static inline netdev_features_t vlan_tnl
+ 	netdev_features_t ret;
+ 
+ 	ret = real_dev->hw_enc_features &
+-	      (NETIF_F_CSUM_MASK | NETIF_F_GSO_SOFTWARE |
++	      (NETIF_F_CSUM_MASK | NETIF_F_GSO_SOFTWARE_ALL |
+ 	       NETIF_F_GSO_ENCAP_ALL);
+ 
+ 	if ((ret & NETIF_F_GSO_ENCAP_ALL) && (ret & NETIF_F_CSUM_MASK))
+--- a/net/8021q/vlan_dev.c
++++ b/net/8021q/vlan_dev.c
+@@ -538,7 +538,7 @@ static int vlan_dev_init(struct net_devi
+ 		dev->state |= (1 << __LINK_STATE_NOCARRIER);
+ 
+ 	dev->hw_features = NETIF_F_HW_CSUM | NETIF_F_SG |
+-			   NETIF_F_FRAGLIST | NETIF_F_GSO_SOFTWARE |
++			   NETIF_F_FRAGLIST | NETIF_F_GSO_SOFTWARE_ALL |
+ 			   NETIF_F_GSO_ENCAP_ALL |
+ 			   NETIF_F_HIGHDMA | NETIF_F_SCTP_CRC |
+ 			   NETIF_F_FCOE_CRC | NETIF_F_FSO;
+@@ -634,7 +634,7 @@ static netdev_features_t vlan_dev_fix_fe
+ 	if (lower_features & (NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM))
+ 		lower_features |= NETIF_F_HW_CSUM;
+ 	features = netdev_intersect_features(features, lower_features);
+-	features |= old_features & (NETIF_F_SOFT_FEATURES | NETIF_F_GSO_SOFTWARE);
++	features |= old_features & (NETIF_F_SOFT_FEATURES | NETIF_F_GSO_SOFTWARE_ALL);
+ 
+ 	return features;
+ }
+--- a/net/core/sock.c
++++ b/net/core/sock.c
+@@ -2533,7 +2533,7 @@ void sk_setup_caps(struct sock *sk, stru
+ 	if (sk_is_tcp(sk))
+ 		sk->sk_route_caps |= NETIF_F_GSO;
+ 	if (sk->sk_route_caps & NETIF_F_GSO)
+-		sk->sk_route_caps |= NETIF_F_GSO_SOFTWARE;
++		sk->sk_route_caps |= NETIF_F_GSO_SOFTWARE_ALL;
+ 	if (unlikely(sk->sk_gso_disabled))
+ 		sk->sk_route_caps &= ~NETIF_F_GSO_MASK;
+ 	if (sk_can_gso(sk)) {
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -2012,7 +2012,7 @@ void ieee80211_color_collision_detection
+ /* interface handling */
+ #define MAC80211_SUPPORTED_FEATURES_TX	(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | \
+ 					 NETIF_F_HW_CSUM | NETIF_F_SG | \
+-					 NETIF_F_HIGHDMA | NETIF_F_GSO_SOFTWARE | \
++					 NETIF_F_HIGHDMA | NETIF_F_GSO_SOFTWARE_ALL | \
+ 					 NETIF_F_HW_TC)
+ #define MAC80211_SUPPORTED_FEATURES_RX	(NETIF_F_RXCSUM)
+ #define MAC80211_SUPPORTED_FEATURES	(MAC80211_SUPPORTED_FEATURES_TX | \
+--- a/net/openvswitch/vport-internal_dev.c
++++ b/net/openvswitch/vport-internal_dev.c
+@@ -109,7 +109,7 @@ static void do_setup(struct net_device *
+ 	netdev->rtnl_link_ops = &internal_dev_link_ops;
+ 
+ 	netdev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
+-			   NETIF_F_HW_CSUM | NETIF_F_GSO_SOFTWARE |
++			   NETIF_F_HW_CSUM | NETIF_F_GSO_SOFTWARE_ALL |
+ 			   NETIF_F_GSO_ENCAP_ALL;
+ 
+ 	netdev->vlan_features = netdev->features;
diff --git a/target/linux/generic/pending-6.12/683-of_net-add-mac-address-to-of-tree.patch b/target/linux/generic/pending-6.12/683-of_net-add-mac-address-to-of-tree.patch
new file mode 100644
index 0000000000..0fb02dbb67
--- /dev/null
+++ b/target/linux/generic/pending-6.12/683-of_net-add-mac-address-to-of-tree.patch
@@ -0,0 +1,75 @@
+From 8585756342caa6d27008d1ad0c18023e4211a40a Mon Sep 17 00:00:00 2001
+From: OpenWrt community <openwrt-devel@lists.openwrt.org>
+Date: Wed, 13 Jul 2022 12:22:48 +0200
+Subject: [PATCH] of/of_net: write back netdev MAC-address to device-tree
+
+The label-mac logic relies on the mac-address property of a netdev
+devices of-node. However, the mac address can also be stored as a
+different property or read from e.g. an mtd device.
+
+Create this node when reading a mac-address from OF if it does not
+already exist and copy the mac-address used for the device to this
+property. This way, the MAC address can be accessed using procfs.
+
+---
+ net/core/of_net.c | 22 ++++++++++++++++++++++
+ 1 file changed, 22 insertions(+)
+
+--- a/net/core/of_net.c
++++ b/net/core/of_net.c
+@@ -97,6 +97,27 @@ int of_get_mac_address_nvmem(struct devi
+ }
+ EXPORT_SYMBOL(of_get_mac_address_nvmem);
+ 
++static int of_add_mac_address(struct device_node *np, u8* addr)
++{
++	struct property *prop;
++
++	prop = kzalloc(sizeof(*prop), GFP_KERNEL);
++	if (!prop)
++		return -ENOMEM;
++
++	prop->name = "mac-address";
++	prop->length = ETH_ALEN;
++	prop->value = kmemdup(addr, ETH_ALEN, GFP_KERNEL);
++	if (!prop->value || of_update_property(np, prop))
++		goto free;
++
++	return 0;
++free:
++	kfree(prop->value);
++	kfree(prop);
++	return -ENOMEM;
++}
++
+ /**
+  * of_get_mac_address()
+  * @np:		Caller's Device Node
+@@ -132,17 +153,23 @@ int of_get_mac_address(struct device_nod
+ 
+ 	ret = of_get_mac_addr(np, "mac-address", addr);
+ 	if (!ret)
+-		return 0;
++		goto found;
+ 
+ 	ret = of_get_mac_addr(np, "local-mac-address", addr);
+ 	if (!ret)
+-		return 0;
++		goto found;
+ 
+ 	ret = of_get_mac_addr(np, "address", addr);
+ 	if (!ret)
+-		return 0;
++		goto found;
+ 
+-	return of_get_mac_address_nvmem(np, addr);
++	ret = of_get_mac_address_nvmem(np, addr);
++	if (ret)
++		return ret;
++
++found:
++	ret = of_add_mac_address(np, addr);
++	return ret;
+ }
+ EXPORT_SYMBOL(of_get_mac_address);
+ 
diff --git a/target/linux/generic/pending-6.12/690-net-add-missing-check-for-TCP-fraglist-GRO.patch b/target/linux/generic/pending-6.12/690-net-add-missing-check-for-TCP-fraglist-GRO.patch
new file mode 100644
index 0000000000..b404037915
--- /dev/null
+++ b/target/linux/generic/pending-6.12/690-net-add-missing-check-for-TCP-fraglist-GRO.patch
@@ -0,0 +1,26 @@
+From 4498f0aa561092bc656bfabe7c4bdae41bc4a5b4 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 7 May 2024 11:24:50 +0200
+Subject: [PATCH] net: add missing check for TCP fraglist GRO
+
+It turns out that the existing checks do not guarantee that the skb can be
+pulled up to the GRO offset. When using the usb r8152 network driver with
+GRO fraglist, the BUG() in __skb_pull is often triggered.
+Fix the crash by adding the missing check.
+
+Fixes: 8d95dc474f85 ("net: add code for TCP fraglist GRO")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ net/ipv4/tcp_offload.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/net/ipv4/tcp_offload.c
++++ b/net/ipv4/tcp_offload.c
+@@ -354,6 +354,7 @@ struct sk_buff *tcp_gro_receive(struct l
+ 		flush |= (__force int)(flags ^ tcp_flag_word(th2));
+ 		flush |= skb->ip_summed != p->ip_summed;
+ 		flush |= skb->csum_level != p->csum_level;
++		flush |= !pskb_may_pull(skb, skb_gro_offset(skb));
+ 		flush |= NAPI_GRO_CB(p)->count >= 64;
+ 
+ 		if (flush || skb_gro_receive_list(p, skb))
diff --git a/target/linux/generic/pending-6.12/700-netfilter-nft_flow_offload-handle-netdevice-events-f.patch b/target/linux/generic/pending-6.12/700-netfilter-nft_flow_offload-handle-netdevice-events-f.patch
new file mode 100644
index 0000000000..301defb49a
--- /dev/null
+++ b/target/linux/generic/pending-6.12/700-netfilter-nft_flow_offload-handle-netdevice-events-f.patch
@@ -0,0 +1,106 @@
+From: Pablo Neira Ayuso <pablo@netfilter.org>
+Date: Thu, 25 Jan 2018 12:58:55 +0100
+Subject: [PATCH] netfilter: nft_flow_offload: handle netdevice events from
+ nf_flow_table
+
+Move the code that deals with device events to the core.
+
+Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
+---
+
+--- a/net/netfilter/nf_flow_table_core.c
++++ b/net/netfilter/nf_flow_table_core.c
+@@ -658,6 +658,23 @@ static struct pernet_operations nf_flow_
+ 	.exit_batch = nf_flow_table_pernet_exit,
+ };
+ 
++static int nf_flow_table_netdev_event(struct notifier_block *this,
++				      unsigned long event, void *ptr)
++{
++	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
++
++	if (event != NETDEV_DOWN)
++		return NOTIFY_DONE;
++
++	nf_flow_table_cleanup(dev);
++
++	return NOTIFY_DONE;
++}
++
++static struct notifier_block flow_offload_netdev_notifier = {
++	.notifier_call	= nf_flow_table_netdev_event,
++};
++
+ static int __init nf_flow_table_module_init(void)
+ {
+ 	int ret;
+@@ -674,6 +691,10 @@ static int __init nf_flow_table_module_i
+ 	if (ret)
+ 		goto out_bpf;
+ 
++	ret = register_netdevice_notifier(&flow_offload_netdev_notifier);
++	if (ret)
++		goto out_bpf;
++
+ 	return 0;
+ 
+ out_bpf:
+@@ -685,6 +706,7 @@ out_offload:
+ 
+ static void __exit nf_flow_table_module_exit(void)
+ {
++	unregister_netdevice_notifier(&flow_offload_netdev_notifier);
+ 	nf_flow_table_offload_exit();
+ 	unregister_pernet_subsys(&nf_flow_table_net_ops);
+ }
+--- a/net/netfilter/nft_flow_offload.c
++++ b/net/netfilter/nft_flow_offload.c
+@@ -487,47 +487,14 @@ static struct nft_expr_type nft_flow_off
+ 	.owner		= THIS_MODULE,
+ };
+ 
+-static int flow_offload_netdev_event(struct notifier_block *this,
+-				     unsigned long event, void *ptr)
+-{
+-	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+-
+-	if (event != NETDEV_DOWN)
+-		return NOTIFY_DONE;
+-
+-	nf_flow_table_cleanup(dev);
+-
+-	return NOTIFY_DONE;
+-}
+-
+-static struct notifier_block flow_offload_netdev_notifier = {
+-	.notifier_call	= flow_offload_netdev_event,
+-};
+-
+ static int __init nft_flow_offload_module_init(void)
+ {
+-	int err;
+-
+-	err = register_netdevice_notifier(&flow_offload_netdev_notifier);
+-	if (err)
+-		goto err;
+-
+-	err = nft_register_expr(&nft_flow_offload_type);
+-	if (err < 0)
+-		goto register_expr;
+-
+-	return 0;
+-
+-register_expr:
+-	unregister_netdevice_notifier(&flow_offload_netdev_notifier);
+-err:
+-	return err;
++	return nft_register_expr(&nft_flow_offload_type);
+ }
+ 
+ static void __exit nft_flow_offload_module_exit(void)
+ {
+ 	nft_unregister_expr(&nft_flow_offload_type);
+-	unregister_netdevice_notifier(&flow_offload_netdev_notifier);
+ }
+ 
+ module_init(nft_flow_offload_module_init);
diff --git a/target/linux/generic/pending-6.12/701-netfilter-nf_tables-ignore-EOPNOTSUPP-on-flowtable-d.patch b/target/linux/generic/pending-6.12/701-netfilter-nf_tables-ignore-EOPNOTSUPP-on-flowtable-d.patch
new file mode 100644
index 0000000000..ceb191e5c5
--- /dev/null
+++ b/target/linux/generic/pending-6.12/701-netfilter-nf_tables-ignore-EOPNOTSUPP-on-flowtable-d.patch
@@ -0,0 +1,29 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 31 Aug 2023 21:48:38 +0200
+Subject: [PATCH] netfilter: nf_tables: ignore -EOPNOTSUPP on flowtable device
+ offload setup
+
+On many embedded devices, it is common to configure flowtable offloading for
+a mix of different devices, some of which have hardware offload support and
+some of which don't.
+The current code limits the ability of user space to properly set up such a
+configuration by only allowing adding devices with hardware offload support to
+a offload-enabled flowtable.
+Given that offload-enabled flowtables also imply fallback to pure software
+offloading, this limitation makes little sense.
+Fix it by not bailing out when the offload setup returns -EOPNOTSUPP
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/netfilter/nf_tables_api.c
++++ b/net/netfilter/nf_tables_api.c
+@@ -8658,7 +8658,7 @@ static int nft_register_flowtable_net_ho
+ 		err = flowtable->data.type->setup(&flowtable->data,
+ 						  hook->ops.dev,
+ 						  FLOW_BLOCK_BIND);
+-		if (err < 0)
++		if (err < 0 && err != -EOPNOTSUPP)
+ 			goto err_unregister_net_hooks;
+ 
+ 		err = nf_register_net_hook(net, &hook->ops);
diff --git a/target/linux/generic/pending-6.12/702-net-ethernet-mtk_eth_soc-enable-threaded-NAPI.patch b/target/linux/generic/pending-6.12/702-net-ethernet-mtk_eth_soc-enable-threaded-NAPI.patch
new file mode 100644
index 0000000000..0b3be626d7
--- /dev/null
+++ b/target/linux/generic/pending-6.12/702-net-ethernet-mtk_eth_soc-enable-threaded-NAPI.patch
@@ -0,0 +1,21 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 21 Mar 2022 20:39:59 +0100
+Subject: [PATCH] net: ethernet: mtk_eth_soc: enable threaded NAPI
+
+This can improve performance under load by ensuring that NAPI processing is
+not pinned on CPU 0.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -5135,6 +5135,8 @@ static int mtk_probe(struct platform_dev
+ 		dev_err(eth->dev, "failed to allocated dummy device\n");
+ 		goto err_unreg_netdev;
+ 	}
++	eth->dummy_dev->threaded = 1;
++	strcpy(eth->dummy_dev->name, "mtk_eth");
+ 	netif_napi_add(eth->dummy_dev, &eth->tx_napi, mtk_napi_tx);
+ 	netif_napi_add(eth->dummy_dev, &eth->rx_napi, mtk_napi_rx);
+ 
diff --git a/target/linux/generic/pending-6.12/703-phy-add-detach-callback-to-struct-phy_driver.patch b/target/linux/generic/pending-6.12/703-phy-add-detach-callback-to-struct-phy_driver.patch
new file mode 100644
index 0000000000..d41d4e224e
--- /dev/null
+++ b/target/linux/generic/pending-6.12/703-phy-add-detach-callback-to-struct-phy_driver.patch
@@ -0,0 +1,38 @@
+From: Gabor Juhos <juhosg@openwrt.org>
+Subject: generic: add detach callback to struct phy_driver
+
+lede-commit: fe61fc2d7d0b3fb348b502f68f98243b3ddf5867
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+---
+ drivers/net/phy/phy_device.c | 3 +++
+ include/linux/phy.h          | 6 ++++++
+ 2 files changed, 9 insertions(+)
+
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -2013,6 +2013,9 @@ void phy_detach(struct phy_device *phyde
+ 	if (phydev->devlink)
+ 		device_link_del(phydev->devlink);
+ 
++	if (phydev->drv && phydev->drv->detach)
++		phydev->drv->detach(phydev);
++
+ 	if (phydev->sysfs_links) {
+ 		if (dev)
+ 			sysfs_remove_link(&dev->dev.kobj, "phydev");
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -999,6 +999,12 @@ struct phy_driver {
+ 	/** @handle_interrupt: Override default interrupt handling */
+ 	irqreturn_t (*handle_interrupt)(struct phy_device *phydev);
+ 
++	/*
++	 * Called before an ethernet device is detached
++	 * from the PHY.
++	 */
++	void (*detach)(struct phy_device *phydev);
++
+ 	/** @remove: Clears up any memory if needed */
+ 	void (*remove)(struct phy_device *phydev);
+ 
diff --git a/target/linux/generic/pending-6.12/705-net-dsa-tag_mtk-add-padding-for-tx-packets.patch b/target/linux/generic/pending-6.12/705-net-dsa-tag_mtk-add-padding-for-tx-packets.patch
new file mode 100644
index 0000000000..f7e4e77773
--- /dev/null
+++ b/target/linux/generic/pending-6.12/705-net-dsa-tag_mtk-add-padding-for-tx-packets.patch
@@ -0,0 +1,28 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 6 May 2022 21:38:42 +0200
+Subject: [PATCH] net: dsa: tag_mtk: add padding for tx packets
+
+Padding for transmitted packets needs to account for the special tag.
+With not enough padding, garbage bytes are inserted by the switch at the
+end of small packets.
+
+Fixes: 5cd8985a1909 ("net-next: dsa: add Mediatek tag RX/TX handler")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/dsa/tag_mtk.c
++++ b/net/dsa/tag_mtk.c
+@@ -29,6 +29,13 @@ static struct sk_buff *mtk_tag_xmit(stru
+ 
+ 	skb_set_queue_mapping(skb, dp->index);
+ 
++	/* The Ethernet switch we are interfaced with needs packets to be at
++	 * least 64 bytes (including FCS) otherwise their padding might be
++	 * corrupted. With tags enabled, we need to make sure that packets are
++	 * at least 68 bytes (including FCS and tag).
++	 */
++	eth_skb_pad(skb);
++
+ 	/* Build the special tag after the MAC Source Address. If VLAN header
+ 	 * is present, it's required that VLAN header and special tag is
+ 	 * being combined. Only in this way we can allow the switch can parse
diff --git a/target/linux/generic/pending-6.12/706-net-phy-populate-host_interfaces-when-attaching-PHY.patch b/target/linux/generic/pending-6.12/706-net-phy-populate-host_interfaces-when-attaching-PHY.patch
new file mode 100644
index 0000000000..6b2b016881
--- /dev/null
+++ b/target/linux/generic/pending-6.12/706-net-phy-populate-host_interfaces-when-attaching-PHY.patch
@@ -0,0 +1,57 @@
+From 4e432e530db0056450fbc4a3cee793f16adc39a7 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Tue, 8 Oct 2024 23:58:41 +0100
+Subject: [PATCH] net: phy: populate host_interfaces when attaching PHY
+
+Use bitmask of interfaces supported by the MAC for the PHY to choose
+from if the declared interface mode is among those using a single pair
+of SerDes lanes.
+This will allow 2500Base-T PHYs to switch to SGMII on most hosts, which
+results in half-duplex being supported in case the MAC supports them.
+Without this change, 2500Base-T PHYs will always operate in 2500Base-X
+mode with rate-matching, which is not only wasteful in terms of energy
+consumption, but also limits the supported interface modes to
+full-duplex only.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/phy/phylink.c | 21 ++++++++++++++++++++-
+ 1 file changed, 20 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -2086,7 +2086,7 @@ int phylink_fwnode_phy_connect(struct ph
+ {
+ 	struct fwnode_handle *phy_fwnode;
+ 	struct phy_device *phy_dev;
+-	int ret;
++	int i, ret;
+ 
+ 	/* Fixed links and 802.3z are handled without needing a PHY */
+ 	if (pl->cfg_link_an_mode == MLO_AN_FIXED ||
+@@ -2116,6 +2116,25 @@ int phylink_fwnode_phy_connect(struct ph
+ 	if (pl->config->mac_requires_rxc)
+ 		flags |= PHY_F_RXC_ALWAYS_ON;
+ 
++	/* Assume single-lane SerDes interface modes share the same
++	 * lanes and allow the PHY to switch to slower also supported modes
++	 */
++	for (i = ARRAY_SIZE(phylink_sfp_interface_preference) - 1; i >= 0; i--) {
++		/* skip unsupported modes */
++		if (!test_bit(phylink_sfp_interface_preference[i], pl->config->supported_interfaces))
++			continue;
++
++		__set_bit(phylink_sfp_interface_preference[i], phy_dev->host_interfaces);
++
++		/* skip all faster modes */
++		if (phylink_sfp_interface_preference[i] == pl->link_interface)
++			break;
++	}
++
++	if (test_bit(pl->link_interface, phylink_sfp_interfaces))
++		phy_interface_and(phy_dev->host_interfaces, phylink_sfp_interfaces,
++				  pl->config->supported_interfaces);
++
+ 	ret = phy_attach_direct(pl->netdev, phy_dev, flags,
+ 				pl->link_interface);
+ 	phy_device_free(phy_dev);
diff --git a/target/linux/generic/pending-6.12/710-bridge-add-knob-for-filtering-rx-tx-BPDU-pack.patch b/target/linux/generic/pending-6.12/710-bridge-add-knob-for-filtering-rx-tx-BPDU-pack.patch
new file mode 100644
index 0000000000..c44d2cf736
--- /dev/null
+++ b/target/linux/generic/pending-6.12/710-bridge-add-knob-for-filtering-rx-tx-BPDU-pack.patch
@@ -0,0 +1,174 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 27 Aug 2021 12:22:32 +0200
+Subject: [PATCH] bridge: add knob for filtering rx/tx BPDU packets on a port
+
+Some devices (e.g. wireless APs) can't have devices behind them be part of
+a bridge topology with redundant links, due to address limitations.
+Additionally, broadcast traffic on these devices is somewhat expensive, due to
+the low data rate and wakeups of clients in powersave mode.
+This knob can be used to ensure that BPDU packets are never sent or forwarded
+to/from these devices
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -61,6 +61,7 @@ struct br_ip_list {
+ #define BR_PORT_LOCKED		BIT(21)
+ #define BR_PORT_MAB		BIT(22)
+ #define BR_NEIGH_VLAN_SUPPRESS	BIT(23)
++#define BR_BPDU_FILTER		BIT(24)
+ 
+ #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
+ 
+--- a/net/bridge/br_forward.c
++++ b/net/bridge/br_forward.c
+@@ -201,6 +201,7 @@ void br_flood(struct net_bridge *br, str
+ 	      enum br_pkt_type pkt_type, bool local_rcv, bool local_orig,
+ 	      u16 vid)
+ {
++	const unsigned char *dest = eth_hdr(skb)->h_dest;
+ 	struct net_bridge_port *prev = NULL;
+ 	struct net_bridge_port *p;
+ 
+@@ -218,6 +219,10 @@ void br_flood(struct net_bridge *br, str
+ 		case BR_PKT_MULTICAST:
+ 			if (!(p->flags & BR_MCAST_FLOOD) && skb->dev != br->dev)
+ 				continue;
++			if ((p->flags & BR_BPDU_FILTER) &&
++			    unlikely(is_link_local_ether_addr(dest) &&
++				     dest[5] == 0))
++				continue;
+ 			break;
+ 		case BR_PKT_BROADCAST:
+ 			if (!(p->flags & BR_BCAST_FLOOD) && skb->dev != br->dev)
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -369,6 +369,8 @@ static rx_handler_result_t br_handle_fra
+ 		fwd_mask |= p->group_fwd_mask;
+ 		switch (dest[5]) {
+ 		case 0x00:	/* Bridge Group Address */
++			if (p->flags & BR_BPDU_FILTER)
++				goto drop;
+ 			/* If STP is turned off,
+ 			   then must forward to keep loop detection */
+ 			if (p->br->stp_enabled == BR_NO_STP ||
+--- a/net/bridge/br_sysfs_if.c
++++ b/net/bridge/br_sysfs_if.c
+@@ -240,6 +240,7 @@ BRPORT_ATTR_FLAG(multicast_flood, BR_MCA
+ BRPORT_ATTR_FLAG(broadcast_flood, BR_BCAST_FLOOD);
+ BRPORT_ATTR_FLAG(neigh_suppress, BR_NEIGH_SUPPRESS);
+ BRPORT_ATTR_FLAG(isolated, BR_ISOLATED);
++BRPORT_ATTR_FLAG(bpdu_filter, BR_BPDU_FILTER);
+ 
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
+@@ -292,6 +293,7 @@ static const struct brport_attribute *br
+ 	&brport_attr_group_fwd_mask,
+ 	&brport_attr_neigh_suppress,
+ 	&brport_attr_isolated,
++	&brport_attr_bpdu_filter,
+ 	&brport_attr_backup_port,
+ 	NULL
+ };
+--- a/net/bridge/br_stp_bpdu.c
++++ b/net/bridge/br_stp_bpdu.c
+@@ -80,7 +80,8 @@ void br_send_config_bpdu(struct net_brid
+ {
+ 	unsigned char buf[35];
+ 
+-	if (p->br->stp_enabled != BR_KERNEL_STP)
++	if (p->br->stp_enabled != BR_KERNEL_STP ||
++	    (p->flags & BR_BPDU_FILTER))
+ 		return;
+ 
+ 	buf[0] = 0;
+@@ -127,7 +128,8 @@ void br_send_tcn_bpdu(struct net_bridge_
+ {
+ 	unsigned char buf[4];
+ 
+-	if (p->br->stp_enabled != BR_KERNEL_STP)
++	if (p->br->stp_enabled != BR_KERNEL_STP ||
++	    (p->flags & BR_BPDU_FILTER))
+ 		return;
+ 
+ 	buf[0] = 0;
+@@ -172,6 +174,9 @@ void br_stp_rcv(const struct stp_proto *
+ 	if (!(br->dev->flags & IFF_UP))
+ 		goto out;
+ 
++	if (p->flags & BR_BPDU_FILTER)
++		goto out;
++
+ 	if (p->state == BR_STATE_DISABLED)
+ 		goto out;
+ 
+--- a/include/uapi/linux/if_link.h
++++ b/include/uapi/linux/if_link.h
+@@ -1094,6 +1094,7 @@ enum {
+ 	IFLA_BRPORT_MCAST_MAX_GROUPS,
+ 	IFLA_BRPORT_NEIGH_VLAN_SUPPRESS,
+ 	IFLA_BRPORT_BACKUP_NHID,
++	IFLA_BRPORT_BPDU_FILTER,
+ 	__IFLA_BRPORT_MAX
+ };
+ #define IFLA_BRPORT_MAX (__IFLA_BRPORT_MAX - 1)
+--- a/net/bridge/br_netlink.c
++++ b/net/bridge/br_netlink.c
+@@ -190,6 +190,7 @@ static inline size_t br_port_info_size(v
+ 		+ nla_total_size(1)	/* IFLA_BRPORT_LOCKED */
+ 		+ nla_total_size(1)	/* IFLA_BRPORT_MAB */
+ 		+ nla_total_size(1)	/* IFLA_BRPORT_NEIGH_VLAN_SUPPRESS */
++		+ nla_total_size(1)	/* IFLA_BRPORT_BPDU_FILTER */
+ 		+ nla_total_size(sizeof(struct ifla_bridge_id))	/* IFLA_BRPORT_ROOT_ID */
+ 		+ nla_total_size(sizeof(struct ifla_bridge_id))	/* IFLA_BRPORT_BRIDGE_ID */
+ 		+ nla_total_size(sizeof(u16))	/* IFLA_BRPORT_DESIGNATED_PORT */
+@@ -282,7 +283,8 @@ static int br_port_fill_attrs(struct sk_
+ 	    nla_put_u8(skb, IFLA_BRPORT_LOCKED, !!(p->flags & BR_PORT_LOCKED)) ||
+ 	    nla_put_u8(skb, IFLA_BRPORT_MAB, !!(p->flags & BR_PORT_MAB)) ||
+ 	    nla_put_u8(skb, IFLA_BRPORT_NEIGH_VLAN_SUPPRESS,
+-		       !!(p->flags & BR_NEIGH_VLAN_SUPPRESS)))
++		       !!(p->flags & BR_NEIGH_VLAN_SUPPRESS)) ||
++	    nla_put_u8(skb, IFLA_BRPORT_BPDU_FILTER, !!(p->flags & BR_BPDU_FILTER)))
+ 		return -EMSGSIZE;
+ 
+ 	timerval = br_timer_value(&p->message_age_timer);
+@@ -902,6 +904,7 @@ static const struct nla_policy br_port_p
+ 	[IFLA_BRPORT_MCAST_MAX_GROUPS] = { .type = NLA_U32 },
+ 	[IFLA_BRPORT_NEIGH_VLAN_SUPPRESS] = NLA_POLICY_MAX(NLA_U8, 1),
+ 	[IFLA_BRPORT_BACKUP_NHID] = { .type = NLA_U32 },
++	[IFLA_BRPORT_BPDU_FILTER] = { .type = NLA_U8 },
+ };
+ 
+ /* Change the state of the port and notify spanning tree */
+@@ -970,6 +973,7 @@ static int br_setport(struct net_bridge_
+ 	br_set_port_flag(p, tb, IFLA_BRPORT_MAB, BR_PORT_MAB);
+ 	br_set_port_flag(p, tb, IFLA_BRPORT_NEIGH_VLAN_SUPPRESS,
+ 			 BR_NEIGH_VLAN_SUPPRESS);
++	br_set_port_flag(p, tb, IFLA_BRPORT_BPDU_FILTER, BR_BPDU_FILTER);
+ 
+ 	if ((p->flags & BR_PORT_MAB) &&
+ 	    (!(p->flags & BR_PORT_LOCKED) || !(p->flags & BR_LEARNING))) {
+--- a/net/core/rtnetlink.c
++++ b/net/core/rtnetlink.c
+@@ -62,7 +62,7 @@
+ #include "dev.h"
+ 
+ #define RTNL_MAX_TYPE		50
+-#define RTNL_SLAVE_MAX_TYPE	44
++#define RTNL_SLAVE_MAX_TYPE	45
+ 
+ struct rtnl_link {
+ 	rtnl_doit_func		doit;
+@@ -5012,7 +5012,9 @@ int ndo_dflt_bridge_getlink(struct sk_bu
+ 	    brport_nla_put_flag(skb, flags, mask,
+ 				IFLA_BRPORT_MCAST_FLOOD, BR_MCAST_FLOOD) ||
+ 	    brport_nla_put_flag(skb, flags, mask,
+-				IFLA_BRPORT_BCAST_FLOOD, BR_BCAST_FLOOD)) {
++				IFLA_BRPORT_BCAST_FLOOD, BR_BCAST_FLOOD) ||
++	    brport_nla_put_flag(skb, flags, mask,
++				IFLA_BRPORT_BPDU_FILTER, BR_BPDU_FILTER)) {
+ 		nla_nest_cancel(skb, protinfo);
+ 		goto nla_put_failure;
+ 	}
diff --git a/target/linux/generic/pending-6.12/711-01-net-dsa-qca8k-implement-lag_fdb_add-del-ops.patch b/target/linux/generic/pending-6.12/711-01-net-dsa-qca8k-implement-lag_fdb_add-del-ops.patch
new file mode 100644
index 0000000000..0e8915903f
--- /dev/null
+++ b/target/linux/generic/pending-6.12/711-01-net-dsa-qca8k-implement-lag_fdb_add-del-ops.patch
@@ -0,0 +1,86 @@
+From 3b4329230db8750bea7a56ef07f07cbbf5fc6c5a Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Tue, 4 Jul 2023 22:50:12 +0200
+Subject: [PATCH 19/20] net: dsa: qca8k: implement lag_fdb_add/del ops
+
+Implement lag_fdb_add/del ops to correctly support using LAG interface.
+Qca8k switch supports declaring fdb entry for link aggregation by simply
+setting the DES_PORT bits to all the LAG member.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ drivers/net/dsa/qca/qca8k-8xxx.c   |  2 ++
+ drivers/net/dsa/qca/qca8k-common.c | 48 ++++++++++++++++++++++++++++++
+ drivers/net/dsa/qca/qca8k.h        |  6 ++++
+ 3 files changed, 56 insertions(+)
+
+--- a/drivers/net/dsa/qca/qca8k-8xxx.c
++++ b/drivers/net/dsa/qca/qca8k-8xxx.c
+@@ -2031,6 +2031,8 @@ static const struct dsa_switch_ops qca8k
+ 	.port_fdb_add		= qca8k_port_fdb_add,
+ 	.port_fdb_del		= qca8k_port_fdb_del,
+ 	.port_fdb_dump		= qca8k_port_fdb_dump,
++	.lag_fdb_add		= qca8k_lag_fdb_add,
++	.lag_fdb_del		= qca8k_lag_fdb_del,
+ 	.port_mdb_add		= qca8k_port_mdb_add,
+ 	.port_mdb_del		= qca8k_port_mdb_del,
+ 	.port_mirror_add	= qca8k_port_mirror_add,
+--- a/drivers/net/dsa/qca/qca8k-common.c
++++ b/drivers/net/dsa/qca/qca8k-common.c
+@@ -1234,6 +1234,42 @@ int qca8k_port_lag_leave(struct dsa_swit
+ 	return qca8k_lag_refresh_portmap(ds, port, lag, true);
+ }
+ 
++int qca8k_lag_fdb_add(struct dsa_switch *ds, struct dsa_lag lag,
++		      const unsigned char *addr, u16 vid,
++		      struct dsa_db db)
++{
++	struct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;
++	struct dsa_port *dp;
++	u16 port_mask = 0;
++
++	/* Set the vid to the port vlan id if no vid is set */
++	if (!vid)
++		vid = QCA8K_PORT_VID_DEF;
++
++	dsa_lag_foreach_port(dp, ds->dst, &lag)
++		port_mask |= BIT(dp->index);
++
++	return qca8k_port_fdb_insert(priv, addr, port_mask, vid);
++}
++
++int qca8k_lag_fdb_del(struct dsa_switch *ds, struct dsa_lag lag,
++		      const unsigned char *addr, u16 vid,
++		      struct dsa_db db)
++{
++	struct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;
++	struct dsa_port *dp;
++	u16 port_mask = 0;
++
++	/* Set the vid to the port vlan id if no vid is set */
++	if (!vid)
++		vid = QCA8K_PORT_VID_DEF;
++
++	dsa_lag_foreach_port(dp, ds->dst, &lag)
++	port_mask |= BIT(dp->index);
++
++	return qca8k_fdb_del(priv, addr, port_mask, vid);
++}
++
+ int qca8k_read_switch_id(struct qca8k_priv *priv)
+ {
+ 	u32 val;
+--- a/drivers/net/dsa/qca/qca8k.h
++++ b/drivers/net/dsa/qca/qca8k.h
+@@ -592,5 +592,11 @@ int qca8k_port_lag_join(struct dsa_switc
+ 			struct netlink_ext_ack *extack);
+ int qca8k_port_lag_leave(struct dsa_switch *ds, int port,
+ 			 struct dsa_lag lag);
++int qca8k_lag_fdb_add(struct dsa_switch *ds, struct dsa_lag lag,
++		      const unsigned char *addr, u16 vid,
++		      struct dsa_db db);
++int qca8k_lag_fdb_del(struct dsa_switch *ds, struct dsa_lag lag,
++		      const unsigned char *addr, u16 vid,
++		      struct dsa_db db);
+ 
+ #endif /* __QCA8K_H */
diff --git a/target/linux/generic/pending-6.12/711-02-net-dsa-qca8k-enable-flooding-to-both-CPU-port.patch b/target/linux/generic/pending-6.12/711-02-net-dsa-qca8k-enable-flooding-to-both-CPU-port.patch
new file mode 100644
index 0000000000..d10bbcf802
--- /dev/null
+++ b/target/linux/generic/pending-6.12/711-02-net-dsa-qca8k-enable-flooding-to-both-CPU-port.patch
@@ -0,0 +1,37 @@
+From b954d61d9ecfa64450fc178586719dc2a95b92a7 Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Tue, 20 Jun 2023 21:48:24 +0200
+Subject: [PATCH 3/4] net: dsa: qca8k: enable flooding to both CPU port
+
+To permit a multi-CPU setup, flood all unknown frames to all CPU ports.
+Each CPU port should have correct LOOKUP MEMBER configuration to
+prevent receiving duplicate packets from user ports.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ drivers/net/dsa/qca/qca8k-8xxx.c | 13 +++++--------
+ 1 file changed, 5 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/dsa/qca/qca8k-8xxx.c
++++ b/drivers/net/dsa/qca/qca8k-8xxx.c
+@@ -1913,15 +1913,12 @@ qca8k_setup(struct dsa_switch *ds)
+ 		}
+ 	}
+ 
+-	/* Forward all unknown frames to CPU port for Linux processing
+-	 * Notice that in multi-cpu config only one port should be set
+-	 * for igmp, unknown, multicast and broadcast packet
+-	 */
++	/* Forward all unknown frames to CPU port for Linux processing */
+ 	ret = qca8k_write(priv, QCA8K_REG_GLOBAL_FW_CTRL1,
+-			  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_IGMP_DP_MASK, BIT(cpu_port)) |
+-			  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_BC_DP_MASK, BIT(cpu_port)) |
+-			  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_MC_DP_MASK, BIT(cpu_port)) |
+-			  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_UC_DP_MASK, BIT(cpu_port)));
++			  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_IGMP_DP_MASK, dsa_cpu_ports(ds)) |
++			  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_BC_DP_MASK, dsa_cpu_ports(ds)) |
++			  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_MC_DP_MASK, dsa_cpu_ports(ds)) |
++			  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_UC_DP_MASK, dsa_cpu_ports(ds)));
+ 	if (ret)
+ 		return ret;
+ 
diff --git a/target/linux/generic/pending-6.12/711-03-net-dsa-qca8k-add-support-for-port_change_master.patch b/target/linux/generic/pending-6.12/711-03-net-dsa-qca8k-add-support-for-port_change_master.patch
new file mode 100644
index 0000000000..25c6ae3f78
--- /dev/null
+++ b/target/linux/generic/pending-6.12/711-03-net-dsa-qca8k-add-support-for-port_change_master.patch
@@ -0,0 +1,158 @@
+From b2d6ebf2f92f8695c83fa6979f4ab579c588df76 Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Tue, 20 Jun 2023 07:57:38 +0200
+Subject: [PATCH 4/4] net: dsa: qca8k: add support for port_change_master
+
+Add support for port_change_master to permit assigning an alternative
+CPU port if the switch have both CPU port connected or create a LAG on
+both CPU port and assign the LAG as DSA master.
+
+On port change master request, we check if the master is a LAG.
+With LAG we compose the cpu_port_mask with the CPU port in the LAG, if
+master is a simple dsa_port, we derive the index.
+
+Finally we apply the new cpu_port_mask to the LOOKUP MEMBER to permit
+the port to receive packet by the new CPU port setup for the port and we
+refresh the CPU ports LOOKUP MEMBER configuration to reflect the new
+user port state.
+
+port_lag_join/leave is updated to refresh the user ports if we detect
+that the LAG is a DSA master and we have user port using it as a master.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ drivers/net/dsa/qca/qca8k-8xxx.c | 116 ++++++++++++++++++++++++++++++-
+ 1 file changed, 114 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/dsa/qca/qca8k-8xxx.c
++++ b/drivers/net/dsa/qca/qca8k-8xxx.c
+@@ -1750,6 +1750,117 @@ qca8k_get_tag_protocol(struct dsa_switch
+ 	return DSA_TAG_PROTO_QCA;
+ }
+ 
++static int qca8k_port_change_master(struct dsa_switch *ds, int port,
++				    struct net_device *master,
++				    struct netlink_ext_ack *extack)
++{
++	struct dsa_switch_tree *dst = ds->dst;
++	struct qca8k_priv *priv = ds->priv;
++	u8 cpu_port_mask = 0;
++	struct dsa_port *dp;
++	u32 val;
++	int ret;
++
++	/* With LAG of CPU port, compose the mask for port LOOKUP MEMBER */
++	if (netif_is_lag_master(master)) {
++		struct dsa_lag *lag;
++		int id;
++
++		id = dsa_lag_id(dst, master);
++		lag = dsa_lag_by_id(dst, id);
++
++		dsa_lag_foreach_port(dp, dst, lag)
++			if (dsa_port_is_cpu(dp))
++				cpu_port_mask |= BIT(dp->index);
++	} else {
++		dp = master->dsa_ptr;
++		cpu_port_mask |= BIT(dp->index);
++	}
++
++	/* Connect port to new cpu port */
++	ret = regmap_read(priv->regmap, QCA8K_PORT_LOOKUP_CTRL(port), &val);
++	if (ret)
++		return ret;
++
++	/* Reset connected CPU port in port LOOKUP MEMBER */
++	val &=  ~dsa_cpu_ports(ds);
++	/* Assign the new CPU port in port LOOKUP MEMBER */
++	val |= cpu_port_mask;
++
++	ret = regmap_update_bits(priv->regmap, QCA8K_PORT_LOOKUP_CTRL(port),
++				 QCA8K_PORT_LOOKUP_MEMBER,
++				 val);
++	if (ret)
++		return ret;
++
++	/* Refresh CPU port LOOKUP MEMBER with new port */
++	dsa_tree_for_each_cpu_port(dp, ds->dst) {
++		u32 reg = QCA8K_PORT_LOOKUP_CTRL(dp->index);
++
++		/* If CPU port in mask assign port, else remove port */
++		if (BIT(dp->index) & cpu_port_mask)
++			ret = regmap_set_bits(priv->regmap, reg, BIT(port));
++		else
++			ret = regmap_clear_bits(priv->regmap, reg, BIT(port));
++
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++static int qca8k_port_lag_refresh_user_ports(struct dsa_switch *ds,
++					     struct dsa_lag lag)
++{
++	struct net_device *lag_dev = lag.dev;
++	struct dsa_port *dp;
++	int ret;
++
++	/* Ignore if LAG is not a DSA master */
++	if (!netif_is_lag_master(lag_dev))
++		return 0;
++
++	dsa_switch_for_each_user_port(dp, ds) {
++		/* Skip if assigned master is not the LAG */
++		if (dsa_port_to_conduit(dp) != lag_dev)
++			continue;
++
++		ret = qca8k_port_change_master(ds, dp->index,
++					       lag_dev, NULL);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++static int qca8xxx_port_lag_join(struct dsa_switch *ds, int port,
++				 struct dsa_lag lag,
++				 struct netdev_lag_upper_info *info,
++				 struct netlink_ext_ack *extack)
++{
++	int ret;
++
++	ret = qca8k_port_lag_join(ds, port, lag, info, extack);
++	if (ret)
++		return ret;
++
++	return qca8k_port_lag_refresh_user_ports(ds, lag);
++}
++
++static int qca8xxx_port_lag_leave(struct dsa_switch *ds, int port,
++				  struct dsa_lag lag)
++{
++	int ret;
++
++	ret = qca8k_port_lag_leave(ds, port, lag);
++	if (ret)
++		return ret;
++
++	return qca8k_port_lag_refresh_user_ports(ds, lag);
++}
++
+ static void
+ qca8k_conduit_change(struct dsa_switch *ds, const struct net_device *conduit,
+ 		     bool operational)
+@@ -2039,8 +2150,9 @@ static const struct dsa_switch_ops qca8k
+ 	.port_vlan_del		= qca8k_port_vlan_del,
+ 	.phylink_get_caps	= qca8k_phylink_get_caps,
+ 	.get_phy_flags		= qca8k_get_phy_flags,
+-	.port_lag_join		= qca8k_port_lag_join,
+-	.port_lag_leave		= qca8k_port_lag_leave,
++	.port_lag_join		= qca8xxx_port_lag_join,
++	.port_lag_leave		= qca8xxx_port_lag_leave,
++	.port_change_conduit	= qca8k_port_change_master,
+ 	.conduit_state_change	= qca8k_conduit_change,
+ 	.connect_tag_protocol	= qca8k_connect_tag_protocol,
+ };
diff --git a/target/linux/generic/pending-6.12/712-net-dsa-qca8k-enable-assisted-learning-on-CPU-port.patch b/target/linux/generic/pending-6.12/712-net-dsa-qca8k-enable-assisted-learning-on-CPU-port.patch
new file mode 100644
index 0000000000..03cf2db6b6
--- /dev/null
+++ b/target/linux/generic/pending-6.12/712-net-dsa-qca8k-enable-assisted-learning-on-CPU-port.patch
@@ -0,0 +1,57 @@
+From 0f6599167c126ce32c85d4f8a1f3d1775a268572 Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Fri, 6 Oct 2023 12:44:00 +0200
+Subject: [PATCH] net: dsa: qca8k: enable assisted learning on CPU port
+
+Enable assisted learning on CPU port.
+
+It has been verified that there is a problem in packet roaming
+from one BSS to another in the same security settings from one
+physical R7800 to another physical R7800 where they are in the
+same L2 broadcast domain backhauled/linked together via one
+of the ethernet ports.
+DHCP will fail to complete and traffic cannot flow for around 300
+seconds.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ drivers/net/dsa/qca/qca8k-8xxx.c | 14 +++++++++-----
+ 1 file changed, 9 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/dsa/qca/qca8k-8xxx.c
++++ b/drivers/net/dsa/qca/qca8k-8xxx.c
+@@ -2022,6 +2022,12 @@ qca8k_setup(struct dsa_switch *ds)
+ 			dev_err(priv->dev, "failed enabling QCA header mode on port %d", dp->index);
+ 			return ret;
+ 		}
++
++		/* Disable learning by default on all ports */
++		ret = regmap_clear_bits(priv->regmap, QCA8K_PORT_LOOKUP_CTRL(dp->index),
++								QCA8K_PORT_LOOKUP_LEARN);
++		if (ret)
++			return ret;
+ 	}
+ 
+ 	/* Forward all unknown frames to CPU port for Linux processing */
+@@ -2051,11 +2057,6 @@ qca8k_setup(struct dsa_switch *ds)
+ 		if (ret)
+ 			return ret;
+ 
+-		ret = regmap_clear_bits(priv->regmap, QCA8K_PORT_LOOKUP_CTRL(port),
+-					QCA8K_PORT_LOOKUP_LEARN);
+-		if (ret)
+-			return ret;
+-
+ 		/* For port based vlans to work we need to set the
+ 		 * default egress vid
+ 		 */
+@@ -2107,6 +2108,9 @@ qca8k_setup(struct dsa_switch *ds)
+ 	/* Set max number of LAGs supported */
+ 	ds->num_lag_ids = QCA8K_NUM_LAGS;
+ 
++	/* HW learn on CPU port is limited and require manual setting */
++	ds->assisted_learning_on_cpu_port = true;
++
+ 	return 0;
+ }
+ 
diff --git a/target/linux/generic/pending-6.12/720-01-net-phy-realtek-use-genphy_soft_reset-for-2.5G-PHYs.patch b/target/linux/generic/pending-6.12/720-01-net-phy-realtek-use-genphy_soft_reset-for-2.5G-PHYs.patch
new file mode 100644
index 0000000000..6a68ae428c
--- /dev/null
+++ b/target/linux/generic/pending-6.12/720-01-net-phy-realtek-use-genphy_soft_reset-for-2.5G-PHYs.patch
@@ -0,0 +1,81 @@
+From 85cd45580f5e3b26068cccb7d6173f200e754dc0 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Sun, 2 Apr 2023 23:56:16 +0100
+Subject: [PATCH 1/2] net: phy: realtek: use genphy_soft_reset for 2.5G PHYs
+
+Some vendor bootloaders do weird things with those PHYs which result in
+link modes being reported wrongly. Start from a clean sheet by resetting
+the PHY.
+
+Reported-by: Yevhen Kolomeiko <jarvis2709@gmail.com>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/phy/realtek/realtek_main.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -1434,6 +1434,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.name		= "RTL8226 2.5Gbps PHY",
+ 		.match_phy_device = rtl8226_match_phy_device,
++		.soft_reset     = genphy_soft_reset,
+ 		.get_features	= rtl822x_get_features,
+ 		.config_aneg	= rtl822x_config_aneg,
+ 		.read_status	= rtl822x_read_status,
+@@ -1444,6 +1445,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_match_phy_device,
+ 		.name		= "RTL8226B_RTL8221B 2.5Gbps PHY",
++		.soft_reset     = genphy_soft_reset,
+ 		.get_features	= rtl822x_get_features,
+ 		.config_aneg	= rtl822x_config_aneg,
+ 		.config_init    = rtl822xb_config_init,
+@@ -1456,6 +1458,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		PHY_ID_MATCH_EXACT(0x001cc838),
+ 		.name           = "RTL8226-CG 2.5Gbps PHY",
++		.soft_reset     = genphy_soft_reset,
+ 		.get_features   = rtl822x_get_features,
+ 		.config_aneg    = rtl822x_config_aneg,
+ 		.read_status    = rtl822x_read_status,
+@@ -1466,6 +1469,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		PHY_ID_MATCH_EXACT(0x001cc848),
+ 		.name           = "RTL8226B-CG_RTL8221B-CG 2.5Gbps PHY",
++		.soft_reset     = genphy_soft_reset,
+ 		.get_features   = rtl822x_get_features,
+ 		.config_aneg    = rtl822x_config_aneg,
+ 		.config_init    = rtl822xb_config_init,
+@@ -1478,6 +1482,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vb_cg_c22_match_phy_device,
+ 		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C22)",
++		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+ 		.get_features   = rtl822x_get_features,
+ 		.config_aneg    = rtl822x_config_aneg,
+@@ -1491,6 +1496,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vb_cg_c45_match_phy_device,
+ 		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C45)",
++		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+ 		.config_init    = rtl822xb_config_init,
+ 		.get_rate_matching = rtl822xb_get_rate_matching,
+@@ -1502,6 +1508,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vn_cg_c22_match_phy_device,
+ 		.name           = "RTL8221B-VM-CG 2.5Gbps PHY (C22)",
++		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+ 		.get_features   = rtl822x_get_features,
+ 		.config_aneg    = rtl822x_config_aneg,
+@@ -1515,6 +1522,7 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vn_cg_c45_match_phy_device,
+ 		.name           = "RTL8221B-VN-CG 2.5Gbps PHY (C45)",
++		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+ 		.config_init    = rtl822xb_config_init,
+ 		.get_rate_matching = rtl822xb_get_rate_matching,
diff --git a/target/linux/generic/pending-6.12/720-02-net-phy-realtek-disable-SGMII-in-band-AN-for-2-5G-PHYs.patch b/target/linux/generic/pending-6.12/720-02-net-phy-realtek-disable-SGMII-in-band-AN-for-2-5G-PHYs.patch
new file mode 100644
index 0000000000..6ecd7235b4
--- /dev/null
+++ b/target/linux/generic/pending-6.12/720-02-net-phy-realtek-disable-SGMII-in-band-AN-for-2-5G-PHYs.patch
@@ -0,0 +1,63 @@
+From d54ef6aea00e7a6ace439baade6ad0aa38ee4b04 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Mon, 3 Apr 2023 01:21:57 +0300
+Subject: [PATCH 287/326] net: phy: realtek: disable SGMII in-band AN for 2.5G
+ PHYs
+
+MAC drivers don't use SGMII in-band autonegotiation unless told to do so
+in device tree using 'managed = "in-band-status"'. When using MDIO to
+access a PHY, in-band-status is unneeded as we have link-status via
+MDIO. Switch off SGMII in-band autonegotiation using magic values.
+
+Reported-by: Chen Minqiang <ptpt52@gmail.com>
+Reported-by: Chukun Pan <amadeus@jmu.edu.cn>
+Reported-by: Yevhen Kolomeiko <jarvis2709@gmail.com>
+Tested-by: Yevhen Kolomeiko <jarvis2709@gmail.com>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/phy/realtek/realtek_main.c | 27 +++++++++++++++++++++++++--
+ 1 file changed, 25 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -837,8 +837,8 @@ static int rtl822x_probe(struct phy_devi
+ static int rtl822xb_config_init(struct phy_device *phydev)
+ {
+ 	bool has_2500, has_sgmii;
++	int ret, val;
+ 	u16 mode;
+-	int ret;
+ 
+ 	has_2500 = test_bit(PHY_INTERFACE_MODE_2500BASEX,
+ 			    phydev->host_interfaces) ||
+@@ -888,7 +888,29 @@ static int rtl822xb_config_init(struct p
+ 	if (ret < 0)
+ 		return ret;
+ 
+-	return phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x6f11, 0x8020);
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x6f11, 0x8020);
++	if (ret < 0)
++		return ret;
++
++	/* Disable SGMII AN */
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x7588, 0x2);
++	if (ret < 0)
++		return ret;
++
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x7589, 0x71d0);
++	if (ret < 0)
++		return ret;
++
++	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x7587, 0x3);
++	if (ret < 0)
++		return ret;
++
++	ret = phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1, 0x7587,
++					val, !(val & BIT(0)), 500, 100000, false);
++	if (ret < 0)
++		return ret;
++
++	return 0;
+ }
+ 
+ static int rtl822xb_get_rate_matching(struct phy_device *phydev,
diff --git a/target/linux/generic/pending-6.12/720-03-net-phy-realtek-make-sure-paged-read-is-protected-by.patch b/target/linux/generic/pending-6.12/720-03-net-phy-realtek-make-sure-paged-read-is-protected-by.patch
new file mode 100644
index 0000000000..86ba13370a
--- /dev/null
+++ b/target/linux/generic/pending-6.12/720-03-net-phy-realtek-make-sure-paged-read-is-protected-by.patch
@@ -0,0 +1,35 @@
+From 4dd2cc9b91ecb25f278a2c55e07e6455e9000e6b Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Sat, 22 Apr 2023 01:21:14 +0100
+Subject: [PATCH] net: phy: realtek: make sure paged read is protected by mutex
+
+As we cannot rely on phy_read_paged function before the PHY is
+identified, the paged read in rtlgen_supports_2_5gbps needs to be open
+coded as it is being called by the match_phy_device function, ie. before
+.read_page and .write_page have been populated.
+
+Make sure it is also protected by the MDIO bus mutex and use
+rtl821x_write_page instead of 3 individually locked MDIO bus operations.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/phy/realtek/realtek_main.c | 8 +++++---
+ 1 file changed, 5 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -1115,9 +1115,11 @@ static bool rtlgen_supports_2_5gbps(stru
+ {
+ 	int val;
+ 
+-	phy_write(phydev, RTL821x_PAGE_SELECT, 0xa61);
+-	val = phy_read(phydev, 0x13);
+-	phy_write(phydev, RTL821x_PAGE_SELECT, 0);
++	mutex_lock(&phydev->mdio.bus->mdio_lock);
++	rtl821x_write_page(phydev, 0xa61);
++	val = __phy_read(phydev, 0x13);
++	rtl821x_write_page(phydev, 0);
++	mutex_unlock(&phydev->mdio.bus->mdio_lock);
+ 
+ 	return val >= 0 && val & MDIO_PMA_SPEED_2_5G;
+ }
diff --git a/target/linux/generic/pending-6.12/720-04-net-phy-realtek-setup-aldps.patch b/target/linux/generic/pending-6.12/720-04-net-phy-realtek-setup-aldps.patch
new file mode 100644
index 0000000000..fb9944e8e5
--- /dev/null
+++ b/target/linux/generic/pending-6.12/720-04-net-phy-realtek-setup-aldps.patch
@@ -0,0 +1,42 @@
+From 9155098547fb1172d4fa536f3f6bc9d42f59d08c Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Sat, 22 Apr 2023 03:26:01 +0100
+Subject: [PATCH] net: phy: realtek: setup ALDPS on RTL822x
+
+Setup Link Down Power Saving Mode according the DTS property
+just like for RTL821x 1GE PHYs.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/phy/realtek/realtek_main.c | 11 +++++++++++
+ 1 file changed, 11 insertions(+)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -82,6 +82,10 @@
+  */
+ #define RTL822X_VND2_C22_REG(reg)		(0xa400 + 2 * (reg))
+ 
++#define RTL8221B_PHYCR1				0xa430
++#define RTL8221B_PHYCR1_ALDPS_EN		BIT(2)
++#define RTL8221B_PHYCR1_ALDPS_XTAL_OFF_EN	BIT(12)
++
+ #define RTL8366RB_POWER_SAVE			0x15
+ #define RTL8366RB_POWER_SAVE_ON			BIT(12)
+ 
+@@ -892,6 +896,15 @@ static int rtl822xb_config_init(struct p
+ 	if (ret < 0)
+ 		return ret;
+ 
++	if (of_property_read_bool(phydev->mdio.dev.of_node, "realtek,aldps-enable"))
++		ret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, RTL8221B_PHYCR1,
++				 RTL8221B_PHYCR1_ALDPS_EN | RTL8221B_PHYCR1_ALDPS_XTAL_OFF_EN);
++	else
++		ret = phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, RTL8221B_PHYCR1,
++				   RTL8221B_PHYCR1_ALDPS_EN | RTL8221B_PHYCR1_ALDPS_XTAL_OFF_EN);
++	if (ret < 0)
++		return ret;
++
+ 	/* Disable SGMII AN */
+ 	ret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x7588, 0x2);
+ 	if (ret < 0)
diff --git a/target/linux/generic/pending-6.12/720-05-net-phy-realtek-detect-early-version-of-RTL8221B.patch b/target/linux/generic/pending-6.12/720-05-net-phy-realtek-detect-early-version-of-RTL8221B.patch
new file mode 100644
index 0000000000..ca08dcafdf
--- /dev/null
+++ b/target/linux/generic/pending-6.12/720-05-net-phy-realtek-detect-early-version-of-RTL8221B.patch
@@ -0,0 +1,52 @@
+From 0de82310d2b32e78ff79d42c08b1122a6ede3778 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Sun, 30 Apr 2023 00:15:41 +0100
+Subject: [PATCH] net: phy: realtek: detect early version of RTL8221B
+
+Early versions (?) of the RTL8221B PHY cannot be identified in a regular
+Clause-45 bus scan as the PHY doesn't report the implemented MMDs
+correctly but returns 0 instead.
+Implement custom identify function using the PKGID instead of iterating
+over the implemented MMDs.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+[forward-port by @namiltd]
+Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -1170,10 +1170,32 @@ static int rtl8226_match_phy_device(stru
+ static int rtlgen_is_c45_match(struct phy_device *phydev, unsigned int id,
+ 			       bool is_c45)
+ {
+-	if (phydev->is_c45)
+-		return is_c45 && (id == phydev->c45_ids.device_ids[1]);
+-	else
++	if (phydev->is_c45) {
++		u32 rid;
++
++		if (!is_c45)
++			return 0;
++
++		rid = phydev->c45_ids.device_ids[1];
++		if ((rid == 0xffffffff) && phydev->mdio.bus->read_c45) {
++			int val;
++
++			val = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_PKGID1);
++			if (val < 0)
++				return 0;
++
++			rid = val << 16;
++			val = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_PKGID2);
++			if (val < 0)
++				return 0;
++
++			rid |= val;
++		}
++
++		return (id == rid);
++	} else {
+ 		return !is_c45 && (id == phydev->phy_id);
++	}
+ }
+ 
+ static int rtl8221b_match_phy_device(struct phy_device *phydev)
diff --git a/target/linux/generic/pending-6.12/720-06-net-phy-realtek-support-interrupt-of-RTL8221B.patch b/target/linux/generic/pending-6.12/720-06-net-phy-realtek-support-interrupt-of-RTL8221B.patch
new file mode 100644
index 0000000000..24109d8d54
--- /dev/null
+++ b/target/linux/generic/pending-6.12/720-06-net-phy-realtek-support-interrupt-of-RTL8221B.patch
@@ -0,0 +1,102 @@
+From d7943c31d57c11e1a517aa3ce2006fca44866870 Mon Sep 17 00:00:00 2001
+From: Jianhui Zhao <zhaojh329@gmail.com>
+Date: Sun, 24 Sep 2023 22:15:00 +0800
+Subject: [PATCH] net: phy: realtek: add interrupt support for RTL8221B
+
+This commit introduces interrupt support for RTL8221B.
+
+Signed-off-by: Jianhui Zhao <zhaojh329@gmail.com>
+---
+ drivers/net/phy/realtek/realtek_main.c | 47 +++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 47 insertions(+)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -1381,6 +1381,51 @@ static irqreturn_t rtl9000a_handle_inter
+ 	return IRQ_HANDLED;
+ }
+ 
++static int rtl8221b_ack_interrupt(struct phy_device *phydev)
++{
++	int err;
++
++	err = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xa4d4);
++
++	return (err < 0) ? err : 0;
++}
++
++static int rtl8221b_config_intr(struct phy_device *phydev)
++{
++	int err;
++
++	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
++		err = rtl8221b_ack_interrupt(phydev);
++		if (err)
++			return err;
++
++		err = phy_write_mmd(phydev, MDIO_MMD_VEND2, 0xa4d2, 0x7ff);
++	} else {
++		err = phy_write_mmd(phydev, MDIO_MMD_VEND2, 0xa4d2, 0x0);
++		if (err)
++			return err;
++
++		err = rtl8221b_ack_interrupt(phydev);
++	}
++
++	return err;
++}
++
++static irqreturn_t rtl8221b_handle_interrupt(struct phy_device *phydev)
++{
++	int err;
++
++	err = rtl8221b_ack_interrupt(phydev);
++	if (err) {
++		phy_error(phydev);
++		return IRQ_NONE;
++	}
++
++	phy_trigger_machine(phydev);
++
++	return IRQ_HANDLED;
++}
++
+ static struct phy_driver realtek_drvs[] = {
+ 	{
+ 		PHY_ID_MATCH_EXACT(0x00008201),
+@@ -1541,6 +1586,8 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vb_cg_c22_match_phy_device,
+ 		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C22)",
++		.config_intr	= rtl8221b_config_intr,
++		.handle_interrupt = rtl8221b_handle_interrupt,
+ 		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+ 		.get_features   = rtl822x_get_features,
+@@ -1555,6 +1602,8 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vb_cg_c45_match_phy_device,
+ 		.name           = "RTL8221B-VB-CG 2.5Gbps PHY (C45)",
++		.config_intr	= rtl8221b_config_intr,
++		.handle_interrupt = rtl8221b_handle_interrupt,
+ 		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+ 		.config_init    = rtl822xb_config_init,
+@@ -1567,6 +1616,8 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vn_cg_c22_match_phy_device,
+ 		.name           = "RTL8221B-VM-CG 2.5Gbps PHY (C22)",
++		.config_intr	= rtl8221b_config_intr,
++		.handle_interrupt = rtl8221b_handle_interrupt,
+ 		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+ 		.get_features   = rtl822x_get_features,
+@@ -1581,6 +1632,8 @@ static struct phy_driver realtek_drvs[]
+ 	}, {
+ 		.match_phy_device = rtl8221b_vn_cg_c45_match_phy_device,
+ 		.name           = "RTL8221B-VN-CG 2.5Gbps PHY (C45)",
++		.config_intr	= rtl8221b_config_intr,
++		.handle_interrupt = rtl8221b_handle_interrupt,
+ 		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+ 		.config_init    = rtl822xb_config_init,
diff --git a/target/linux/generic/pending-6.12/720-07-net-phy-realtek-mark-existing-MMDs-as-present.patch b/target/linux/generic/pending-6.12/720-07-net-phy-realtek-mark-existing-MMDs-as-present.patch
new file mode 100644
index 0000000000..9c93a26b40
--- /dev/null
+++ b/target/linux/generic/pending-6.12/720-07-net-phy-realtek-mark-existing-MMDs-as-present.patch
@@ -0,0 +1,27 @@
+From 1addfb042a9d27788a0fb2c2935045b56fd8560e Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 23 Jan 2025 03:25:29 +0000
+Subject: [PATCH] net: phy: realtek: mark existing MMDs as present
+
+When using Clause-45 mode to access RealTek RTL8221B 2.5G PHYs some
+versions of the PHY fail to report the MMDs present on the PHY.
+Mark MMDs PMAPMD, PCS and AN which are always existing according to
+the datasheet as present to fix that.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/phy/realtek/realtek_main.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -1046,6 +1046,9 @@ static int rtl822x_c45_get_features(stru
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_TP_BIT,
+ 			 phydev->supported);
+ 
++	phydev->c45_ids.mmds_present |= MDIO_DEVS_PMAPMD | MDIO_DEVS_PCS |
++				        MDIO_DEVS_AN;
++
+ 	return genphy_c45_pma_read_abilities(phydev);
+ }
+ 
diff --git a/target/linux/generic/pending-6.12/720-08-net-phy-realtek-work-around-broken-serdes.patch b/target/linux/generic/pending-6.12/720-08-net-phy-realtek-work-around-broken-serdes.patch
new file mode 100644
index 0000000000..48a9ba08da
--- /dev/null
+++ b/target/linux/generic/pending-6.12/720-08-net-phy-realtek-work-around-broken-serdes.patch
@@ -0,0 +1,58 @@
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 30 Jan 2025 05:33:12 +0000
+Subject: [PATCH] net: phy: realtek: work around broken SerDes
+
+For still unknown reasons the SerDes init sequence may sometimes
+time out because a self-clearing bit never clears, indicating the
+PHY has entered an unrecoverable error state.
+
+Work-around the issue by triggering a hardware reset and retry the
+setup sequence while warning the user that this has happened.
+This is really more of a work-around than a fix, and should be
+replaced by a better actual fix in future (hopefully).
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -926,6 +926,22 @@ static int rtl822xb_config_init(struct p
+ 	return 0;
+ }
+ 
++static int rtl822xb_config_init_war(struct phy_device *phydev)
++{
++	int ret;
++
++	ret = rtl822xb_config_init(phydev);
++
++	if (ret == -ETIMEDOUT) {
++		phydev_warn(phydev, "SerDes setup timed out, retrying\n");
++		phy_device_reset(phydev, 1);
++		phy_device_reset(phydev, 0);
++		ret = rtl822xb_config_init(phydev);
++	}
++
++	return ret;
++}
++
+ static int rtl822xb_get_rate_matching(struct phy_device *phydev,
+ 				      phy_interface_t iface)
+ {
+@@ -1609,7 +1625,7 @@ static struct phy_driver realtek_drvs[]
+ 		.handle_interrupt = rtl8221b_handle_interrupt,
+ 		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+-		.config_init    = rtl822xb_config_init,
++		.config_init    = rtl822xb_config_init_war,
+ 		.get_rate_matching = rtl822xb_get_rate_matching,
+ 		.get_features   = rtl822x_c45_get_features,
+ 		.config_aneg    = rtl822x_c45_config_aneg,
+@@ -1639,7 +1655,7 @@ static struct phy_driver realtek_drvs[]
+ 		.handle_interrupt = rtl8221b_handle_interrupt,
+ 		.soft_reset     = genphy_soft_reset,
+ 		.probe		= rtl822x_probe,
+-		.config_init    = rtl822xb_config_init,
++		.config_init    = rtl822xb_config_init_war,
+ 		.get_rate_matching = rtl822xb_get_rate_matching,
+ 		.get_features   = rtl822x_c45_get_features,
+ 		.config_aneg    = rtl822x_c45_config_aneg,
diff --git a/target/linux/generic/pending-6.12/720-09-net-phy-realtek-disable-MDIO-broadcast.patch b/target/linux/generic/pending-6.12/720-09-net-phy-realtek-disable-MDIO-broadcast.patch
new file mode 100644
index 0000000000..d783b292e8
--- /dev/null
+++ b/target/linux/generic/pending-6.12/720-09-net-phy-realtek-disable-MDIO-broadcast.patch
@@ -0,0 +1,27 @@
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 30 Jan 2025 05:38:31 +0000
+Subject: [PATCH] net: phy: realtek: disable MDIO broadcast
+
+RealTek's PHYs by default also listen on MDIO address 0 which is defined
+as broadcast address. This can lead to problems if there is an actual PHY
+(such as MT7981 built-in PHY) present at this address, as accessing that
+PHY may then confuse the RealTek PHY.
+
+Disabled listening on the MDIO broadcast address to avoid such problems.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+--- a/drivers/net/phy/realtek/realtek_main.c
++++ b/drivers/net/phy/realtek/realtek_main.c
+@@ -852,6 +852,11 @@ static int rtl822xb_config_init(struct p
+ 			     phydev->host_interfaces) ||
+ 		    phydev->interface == PHY_INTERFACE_MODE_SGMII;
+ 
++	/* disable listening on MDIO broadcast address (0) */
++	ret = phy_clear_bits_mmd(phydev, MDIO_MMD_VEND2, 0xa430, BIT(13));
++	if (ret < 0)
++		return ret;
++
+ 	/* fill in possible interfaces */
+ 	__assign_bit(PHY_INTERFACE_MODE_2500BASEX, phydev->possible_interfaces,
+ 		     has_2500);
diff --git a/target/linux/generic/pending-6.12/730-net-ethernet-mtk_eth_soc-reset-all-TX-queues-on-DMA-.patch b/target/linux/generic/pending-6.12/730-net-ethernet-mtk_eth_soc-reset-all-TX-queues-on-DMA-.patch
new file mode 100644
index 0000000000..2d91bbec4f
--- /dev/null
+++ b/target/linux/generic/pending-6.12/730-net-ethernet-mtk_eth_soc-reset-all-TX-queues-on-DMA-.patch
@@ -0,0 +1,49 @@
+From 7d41a5a8e9c91cc6bb011dd953570738583dd091 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Wed, 18 Sep 2024 02:01:01 +0100
+Subject: [PATCH] net: ethernet: mtk_eth_soc: reset all TX queues on DMA free
+
+The purpose of resetting the TX queue is to reset the
+byte and packet count as well as to clear the software
+flow control XOFF bit.
+
+MediaTek developers pointed out that netdev_reset_queue would only
+resets queue 0 of the network device.
+Queues that are not reset may cause unexpected issues.
+
+Packets may stop being sent after reset and "transmit timeout" log may
+be displayed.
+
+Import fix from MediaTek's SDK to resolve this issue.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c | 18 ++++++++++++++----
+ 1 file changed, 14 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -3150,11 +3150,19 @@ static int mtk_dma_init(struct mtk_eth *
+ static void mtk_dma_free(struct mtk_eth *eth)
+ {
+ 	const struct mtk_soc_data *soc = eth->soc;
+-	int i;
++	int i, j, txqs = 1;
++
++	if (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))
++		txqs = MTK_QDMA_NUM_QUEUES;
++
++	for (i = 0; i < MTK_MAX_DEVS; i++) {
++		if (!eth->netdev[i])
++			continue;
++
++		for (j = 0; j < txqs; j++)
++			netdev_tx_reset_queue(netdev_get_tx_queue(eth->netdev[i], j));
++	}
+ 
+-	for (i = 0; i < MTK_MAX_DEVS; i++)
+-		if (eth->netdev[i])
+-			netdev_reset_queue(eth->netdev[i]);
+ 	if (!MTK_HAS_CAPS(soc->caps, MTK_SRAM) && eth->scratch_ring) {
+ 		dma_free_coherent(eth->dma_dev,
+ 				  MTK_QDMA_RING_SIZE * soc->tx.desc_size,
diff --git a/target/linux/generic/pending-6.12/731-net-permit-ieee80211_ptr-even-with-no-CFG82111-suppo.patch b/target/linux/generic/pending-6.12/731-net-permit-ieee80211_ptr-even-with-no-CFG82111-suppo.patch
new file mode 100644
index 0000000000..50d3403772
--- /dev/null
+++ b/target/linux/generic/pending-6.12/731-net-permit-ieee80211_ptr-even-with-no-CFG82111-suppo.patch
@@ -0,0 +1,59 @@
+From 686c603f67ae87bf21a61b5e4b1564443f41c3ee Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Thu, 20 Oct 2022 03:34:43 +0200
+Subject: [PATCH] net: permit ieee80211_ptr even with no CFG82111 support
+
+Introduce a new flag CONFIG_CFG80211_HEADERS to compile in ieee80211_ptr
+even if CFG80211 support is not compiled in. This is needed for the
+backports project and for any downstream wireless driver that loads in
+the kernel dynamically.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ include/linux/netdevice.h       | 2 +-
+ net/batman-adv/hard-interface.c | 2 +-
+ net/wireless/Kconfig            | 4 ++++
+ 3 files changed, 6 insertions(+), 2 deletions(-)
+
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -2224,7 +2224,7 @@ struct net_device {
+ #if IS_ENABLED(CONFIG_AX25)
+ 	struct ax25_dev	__rcu	*ax25_ptr;
+ #endif
+-#if IS_ENABLED(CONFIG_CFG80211)
++#if IS_ENABLED(CONFIG_CFG80211_HEADERS)
+ 	struct wireless_dev	*ieee80211_ptr;
+ #endif
+ #if IS_ENABLED(CONFIG_IEEE802154) || IS_ENABLED(CONFIG_6LOWPAN)
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -309,7 +309,7 @@ static bool batadv_is_cfg80211_netdev(st
+ 	if (!net_device)
+ 		return false;
+ 
+-#if IS_ENABLED(CONFIG_CFG80211)
++#if IS_ENABLED(CONFIG_CFG80211_HEADERS)
+ 	/* cfg80211 drivers have to set ieee80211_ptr */
+ 	if (net_device->ieee80211_ptr)
+ 		return true;
+--- a/net/wireless/Kconfig
++++ b/net/wireless/Kconfig
+@@ -26,6 +26,7 @@ config CFG80211
+ 	# using a different algorithm, though right now they shouldn't
+ 	# (this is here rather than below to allow it to be a module)
+ 	select CRYPTO_SHA256 if CFG80211_USE_KERNEL_REGDB_KEYS
++	select CFG80211_HEADERS
+ 	help
+ 	  cfg80211 is the Linux wireless LAN (802.11) configuration API.
+ 	  Enable this if you have a wireless device.
+@@ -36,6 +37,9 @@ config CFG80211
+ 
+ 	  When built as a module it will be called cfg80211.
+ 
++config CFG80211_HEADERS
++	bool "cfg80211 - headers support"
++
+ if CFG80211
+ 
+ config NL80211_TESTMODE
diff --git a/target/linux/generic/pending-6.12/732-00-net-ethernet-mtk_eth_soc-compile-out-netsys-v2-code-.patch b/target/linux/generic/pending-6.12/732-00-net-ethernet-mtk_eth_soc-compile-out-netsys-v2-code-.patch
new file mode 100644
index 0000000000..ec6ed6e035
--- /dev/null
+++ b/target/linux/generic/pending-6.12/732-00-net-ethernet-mtk_eth_soc-compile-out-netsys-v2-code-.patch
@@ -0,0 +1,44 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 27 Oct 2022 23:39:52 +0200
+Subject: [PATCH] net: ethernet: mtk_eth_soc: compile out netsys v2 code
+ on mt7621
+
+Avoid some branches in the hot path on low-end devices with limited CPU power,
+and reduce code size
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+@@ -1344,6 +1344,22 @@ struct mtk_mac {
+ /* the struct describing the SoC. these are declared in the soc_xyz.c files */
+ extern const struct of_device_id of_mtk_match[];
+ 
++#ifdef CONFIG_SOC_MT7621
++static inline bool mtk_is_netsys_v1(struct mtk_eth *eth)
++{
++	return true;
++}
++
++static inline bool mtk_is_netsys_v2_or_greater(struct mtk_eth *eth)
++{
++	return false;
++}
++
++static inline bool mtk_is_netsys_v3_or_greater(struct mtk_eth *eth)
++{
++	return false;
++}
++#else
+ static inline bool mtk_is_netsys_v1(struct mtk_eth *eth)
+ {
+ 	return eth->soc->version == 1;
+@@ -1358,6 +1374,7 @@ static inline bool mtk_is_netsys_v3_or_g
+ {
+ 	return eth->soc->version > 2;
+ }
++#endif
+ 
+ static inline struct mtk_foe_entry *
+ mtk_foe_get_entry(struct mtk_ppe *ppe, u16 hash)
diff --git a/target/linux/generic/pending-6.12/732-01-net-ethernet-mtk_eth_soc-work-around-issue-with-send.patch b/target/linux/generic/pending-6.12/732-01-net-ethernet-mtk_eth_soc-work-around-issue-with-send.patch
new file mode 100644
index 0000000000..f4b07485ea
--- /dev/null
+++ b/target/linux/generic/pending-6.12/732-01-net-ethernet-mtk_eth_soc-work-around-issue-with-send.patch
@@ -0,0 +1,102 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 3 Nov 2022 12:38:49 +0100
+Subject: [PATCH] net: ethernet: mtk_eth_soc: work around issue with sending
+ small fragments
+
+When lots of frames are sent with a number of very small fragments, an
+internal FIFO can overflow, causing the DMA engine to lock up lock up and
+transmit attempts time out.
+
+Fix this on MT7986 by increasing the reserved FIFO space.
+Fix this on older chips by detecting the presence of small fragments and use
+skb_gso_segment + skb_linearize to deal with them.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -26,6 +26,7 @@
+ #include <linux/bitfield.h>
+ #include <net/dsa.h>
+ #include <net/dst_metadata.h>
++#include <net/gso.h>
+ #include <net/page_pool/helpers.h>
+ 
+ #include "mtk_eth_soc.h"
+@@ -1607,12 +1608,28 @@ static void mtk_wake_queue(struct mtk_et
+ 	}
+ }
+ 
++static bool mtk_skb_has_small_frag(struct sk_buff *skb)
++{
++	int min_size = 16;
++	int i;
++
++	if (skb_headlen(skb) < min_size)
++		return true;
++
++	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++)
++		if (skb_frag_size(&skb_shinfo(skb)->frags[i]) < min_size)
++			return true;
++
++	return false;
++}
++
+ static netdev_tx_t mtk_start_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct mtk_mac *mac = netdev_priv(dev);
+ 	struct mtk_eth *eth = mac->hw;
+ 	struct mtk_tx_ring *ring = &eth->tx_ring;
+ 	struct net_device_stats *stats = &dev->stats;
++	struct sk_buff *segs, *next;
+ 	bool gso = false;
+ 	int tx_num;
+ 
+@@ -1634,6 +1651,18 @@ static netdev_tx_t mtk_start_xmit(struct
+ 		return NETDEV_TX_BUSY;
+ 	}
+ 
++	if (mtk_is_netsys_v1(eth) &&
++	    skb_is_gso(skb) && mtk_skb_has_small_frag(skb)) {
++		segs = skb_gso_segment(skb, dev->features & ~NETIF_F_ALL_TSO);
++		if (IS_ERR(segs))
++			goto drop;
++
++		if (segs) {
++			consume_skb(skb);
++			skb = segs;
++		}
++	}
++
+ 	/* TSO: fill MSS info in tcp checksum field */
+ 	if (skb_is_gso(skb)) {
+ 		if (skb_cow_head(skb, 0)) {
+@@ -1649,8 +1678,14 @@ static netdev_tx_t mtk_start_xmit(struct
+ 		}
+ 	}
+ 
+-	if (mtk_tx_map(skb, dev, tx_num, ring, gso) < 0)
+-		goto drop;
++	skb_list_walk_safe(skb, skb, next) {
++		if ((mtk_is_netsys_v1(eth) &&
++		     mtk_skb_has_small_frag(skb) && skb_linearize(skb)) ||
++		    mtk_tx_map(skb, dev, tx_num, ring, gso) < 0) {
++				stats->tx_dropped++;
++				dev_kfree_skb_any(skb);
++		}
++	}
+ 
+ 	if (unlikely(atomic_read(&ring->free_count) <= ring->thresh))
+ 		netif_tx_stop_all_queues(dev);
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+@@ -278,7 +278,7 @@
+ #define MTK_CHK_DDONE_EN	BIT(28)
+ #define MTK_DMAD_WR_WDONE	BIT(26)
+ #define MTK_WCOMP_EN		BIT(24)
+-#define MTK_RESV_BUF		(0x40 << 16)
++#define MTK_RESV_BUF		(0x80 << 16)
+ #define MTK_MUTLI_CNT		(0x4 << 12)
+ #define MTK_LEAKY_BUCKET_EN	BIT(11)
+ 
diff --git a/target/linux/generic/pending-6.12/732-02-net-ethernet-mtk_eth_soc-set-NETIF_F_ALL_TSO.patch b/target/linux/generic/pending-6.12/732-02-net-ethernet-mtk_eth_soc-set-NETIF_F_ALL_TSO.patch
new file mode 100644
index 0000000000..bd7a1b96f2
--- /dev/null
+++ b/target/linux/generic/pending-6.12/732-02-net-ethernet-mtk_eth_soc-set-NETIF_F_ALL_TSO.patch
@@ -0,0 +1,21 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 28 Oct 2022 12:54:48 +0200
+Subject: [PATCH] net: ethernet: mtk_eth_soc: set NETIF_F_ALL_TSO
+
+Significantly improves performance by avoiding unnecessary segmentation
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+@@ -49,8 +49,7 @@
+ #define MTK_HW_FEATURES		(NETIF_F_IP_CSUM | \
+ 				 NETIF_F_RXCSUM | \
+ 				 NETIF_F_HW_VLAN_CTAG_TX | \
+-				 NETIF_F_SG | NETIF_F_TSO | \
+-				 NETIF_F_TSO6 | \
++				 NETIF_F_SG | NETIF_F_ALL_TSO | \
+ 				 NETIF_F_IPV6_CSUM |\
+ 				 NETIF_F_HW_TC)
+ #define MTK_HW_FEATURES_MT7628	(NETIF_F_SG | NETIF_F_RXCSUM)
diff --git a/target/linux/generic/pending-6.12/733-01-net-ethernet-mtk_eth_soc-use-napi_build_skb.patch b/target/linux/generic/pending-6.12/733-01-net-ethernet-mtk_eth_soc-use-napi_build_skb.patch
new file mode 100644
index 0000000000..36c1d499d3
--- /dev/null
+++ b/target/linux/generic/pending-6.12/733-01-net-ethernet-mtk_eth_soc-use-napi_build_skb.patch
@@ -0,0 +1,30 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 20 May 2024 14:29:58 +0200
+Subject: [PATCH] net: ethernet: mtk_eth_soc: use napi_build_skb()
+
+The napi_build_skb() can reuse the skb in skb cache per CPU or
+can allocate skbs in bulk, which helps improve the performance.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -2151,7 +2151,7 @@ static int mtk_poll_rx(struct napi_struc
+ 			if (ret != XDP_PASS)
+ 				goto skip_rx;
+ 
+-			skb = build_skb(data, PAGE_SIZE);
++			skb = napi_build_skb(data, PAGE_SIZE);
+ 			if (unlikely(!skb)) {
+ 				page_pool_put_full_page(ring->page_pool,
+ 							page, true);
+@@ -2189,7 +2189,7 @@ static int mtk_poll_rx(struct napi_struc
+ 			dma_unmap_single(eth->dma_dev, ((u64)trxd.rxd1 | addr64),
+ 					 ring->buf_size, DMA_FROM_DEVICE);
+ 
+-			skb = build_skb(data, ring->frag_size);
++			skb = napi_build_skb(data, ring->frag_size);
+ 			if (unlikely(!skb)) {
+ 				netdev->stats.rx_dropped++;
+ 				skb_free_frag(data);
diff --git a/target/linux/generic/pending-6.12/734-net-ethernet-mediatek-enlarge-DMA-reserve-buffer.patch b/target/linux/generic/pending-6.12/734-net-ethernet-mediatek-enlarge-DMA-reserve-buffer.patch
new file mode 100644
index 0000000000..d9e2873262
--- /dev/null
+++ b/target/linux/generic/pending-6.12/734-net-ethernet-mediatek-enlarge-DMA-reserve-buffer.patch
@@ -0,0 +1,44 @@
+From: Chad Monroe <chad@monroe.io>
+Date: Mon, 16 Sep 2024 19:29:03 -0700
+Subject: [PATCH] net: ethernet: mediatek: increase QDMA RESV_BUF size
+
+Increase QDMA RESV_BUF from 2K to 3K for netsys v2 to match Mediatek SDK[1].
+This helps reduce the possibility of Ethernet transmit timeouts.
+
+[1]: https://git01.mediatek.com/plugins/gitiles/openwrt/feeds/mtk-openwrt-feeds/+/19d8456c3051e5f6dabf42fa770916a2126ea4bf
+
+Signed-off-by: Chad Monroe <chad@monroe.io>
+---
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c |    6 ++++--
+ drivers/net/ethernet/mediatek/mtk_eth_soc.h |    1 +
+ 2 files changed, 5 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+@@ -279,6 +279,7 @@
+ #define MTK_WCOMP_EN		BIT(24)
+ #define MTK_RESV_BUF		(0x80 << 16)
+ #define MTK_MUTLI_CNT		(0x4 << 12)
++#define MTK_RESV_BUF_MASK	(0xff << 16)
+ #define MTK_LEAKY_BUCKET_EN	BIT(11)
+ 
+ /* QDMA Flow Control Register */
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -3324,12 +3324,14 @@ static int mtk_start_dma(struct mtk_eth
+ 		       MTK_TX_BT_32DWORDS | MTK_NDP_CO_PRO |
+ 		       MTK_RX_2B_OFFSET | MTK_TX_WB_DDONE;
+ 
+-		if (mtk_is_netsys_v2_or_greater(eth))
++		if (mtk_is_netsys_v2_or_greater(eth)) {
++			val &= ~MTK_RESV_BUF_MASK;
+ 			val |= MTK_MUTLI_CNT | MTK_RESV_BUF |
+ 			       MTK_WCOMP_EN | MTK_DMAD_WR_WDONE |
+ 			       MTK_CHK_DDONE_EN;
+-		else
++		} else {
+ 			val |= MTK_RX_BT_32DWORDS;
++		}
+ 		mtk_w32(eth, val, reg_map->qdma.glo_cfg);
+ 
+ 		mtk_w32(eth,
diff --git a/target/linux/generic/pending-6.12/736-03-net-ethernet-mtk_eth_soc-improve-keeping-track-of-of.patch b/target/linux/generic/pending-6.12/736-03-net-ethernet-mtk_eth_soc-improve-keeping-track-of-of.patch
new file mode 100644
index 0000000000..c50348382a
--- /dev/null
+++ b/target/linux/generic/pending-6.12/736-03-net-ethernet-mtk_eth_soc-improve-keeping-track-of-of.patch
@@ -0,0 +1,334 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 23 Mar 2023 10:24:11 +0100
+Subject: [PATCH] net: ethernet: mtk_eth_soc: improve keeping track of
+ offloaded flows
+
+Unify tracking of L2 and L3 flows. Use the generic list field in struct
+mtk_foe_entry for tracking L2 subflows. Preparation for improving
+flow accounting support.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/net/ethernet/mediatek/mtk_ppe.c | 162 ++++++++++++------------
+ drivers/net/ethernet/mediatek/mtk_ppe.h |  15 +--
+ 2 files changed, 86 insertions(+), 91 deletions(-)
+
+--- a/drivers/net/ethernet/mediatek/mtk_ppe.c
++++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
+@@ -479,42 +479,43 @@ int mtk_foe_entry_set_queue(struct mtk_e
+ 	return 0;
+ }
+ 
++static int
++mtk_flow_entry_match_len(struct mtk_eth *eth, struct mtk_foe_entry *entry)
++{
++	int type = mtk_get_ib1_pkt_type(eth, entry->ib1);
++
++	if (type > MTK_PPE_PKT_TYPE_IPV4_DSLITE)
++		return offsetof(struct mtk_foe_entry, ipv6._rsv);
++	else
++		return offsetof(struct mtk_foe_entry, ipv4.ib2);
++}
++
+ static bool
+ mtk_flow_entry_match(struct mtk_eth *eth, struct mtk_flow_entry *entry,
+-		     struct mtk_foe_entry *data)
++		     struct mtk_foe_entry *data, int len)
+ {
+-	int type, len;
+-
+ 	if ((data->ib1 ^ entry->data.ib1) & MTK_FOE_IB1_UDP)
+ 		return false;
+ 
+-	type = mtk_get_ib1_pkt_type(eth, entry->data.ib1);
+-	if (type > MTK_PPE_PKT_TYPE_IPV4_DSLITE)
+-		len = offsetof(struct mtk_foe_entry, ipv6._rsv);
+-	else
+-		len = offsetof(struct mtk_foe_entry, ipv4.ib2);
+-
+ 	return !memcmp(&entry->data.data, &data->data, len - 4);
+ }
+ 
+ static void
+-__mtk_foe_entry_clear(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
++__mtk_foe_entry_clear(struct mtk_ppe *ppe, struct mtk_flow_entry *entry,
++		      bool set_state)
+ {
+-	struct hlist_head *head;
+ 	struct hlist_node *tmp;
+ 
+ 	if (entry->type == MTK_FLOW_TYPE_L2) {
+ 		rhashtable_remove_fast(&ppe->l2_flows, &entry->l2_node,
+ 				       mtk_flow_l2_ht_params);
+ 
+-		head = &entry->l2_flows;
+-		hlist_for_each_entry_safe(entry, tmp, head, l2_data.list)
+-			__mtk_foe_entry_clear(ppe, entry);
++		hlist_for_each_entry_safe(entry, tmp, &entry->l2_flows, l2_list)
++			__mtk_foe_entry_clear(ppe, entry, set_state);
+ 		return;
+ 	}
+ 
+-	hlist_del_init(&entry->list);
+-	if (entry->hash != 0xffff) {
++	if (entry->hash != 0xffff && set_state) {
+ 		struct mtk_foe_entry *hwe = mtk_foe_get_entry(ppe, entry->hash);
+ 
+ 		hwe->ib1 &= ~MTK_FOE_IB1_STATE;
+@@ -535,7 +536,8 @@ __mtk_foe_entry_clear(struct mtk_ppe *pp
+ 	if (entry->type != MTK_FLOW_TYPE_L2_SUBFLOW)
+ 		return;
+ 
+-	hlist_del_init(&entry->l2_data.list);
++	hlist_del_init(&entry->l2_list);
++	hlist_del_init(&entry->list);
+ 	kfree(entry);
+ }
+ 
+@@ -551,66 +553,55 @@ static int __mtk_foe_entry_idle_time(str
+ 		return now - timestamp;
+ }
+ 
++static bool
++mtk_flow_entry_update(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
++{
++	struct mtk_foe_entry foe = {};
++	struct mtk_foe_entry *hwe;
++	u16 hash = entry->hash;
++	int len;
++
++	if (hash == 0xffff)
++		return false;
++
++	hwe = mtk_foe_get_entry(ppe, hash);
++	len = mtk_flow_entry_match_len(ppe->eth, &entry->data);
++	memcpy(&foe, hwe, len);
++
++	if (!mtk_flow_entry_match(ppe->eth, entry, &foe, len) ||
++	    FIELD_GET(MTK_FOE_IB1_STATE, foe.ib1) != MTK_FOE_STATE_BIND)
++		return false;
++
++	entry->data.ib1 = foe.ib1;
++
++	return true;
++}
++
+ static void
+ mtk_flow_entry_update_l2(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
+ {
+ 	u32 ib1_ts_mask = mtk_get_ib1_ts_mask(ppe->eth);
+ 	struct mtk_flow_entry *cur;
+-	struct mtk_foe_entry *hwe;
+ 	struct hlist_node *tmp;
+ 	int idle;
+ 
+ 	idle = __mtk_foe_entry_idle_time(ppe, entry->data.ib1);
+-	hlist_for_each_entry_safe(cur, tmp, &entry->l2_flows, l2_data.list) {
++	hlist_for_each_entry_safe(cur, tmp, &entry->l2_flows, l2_list) {
+ 		int cur_idle;
+-		u32 ib1;
+-
+-		hwe = mtk_foe_get_entry(ppe, cur->hash);
+-		ib1 = READ_ONCE(hwe->ib1);
+ 
+-		if (FIELD_GET(MTK_FOE_IB1_STATE, ib1) != MTK_FOE_STATE_BIND) {
+-			cur->hash = 0xffff;
+-			__mtk_foe_entry_clear(ppe, cur);
++		if (!mtk_flow_entry_update(ppe, cur)) {
++			__mtk_foe_entry_clear(ppe, entry, false);
+ 			continue;
+ 		}
+ 
+-		cur_idle = __mtk_foe_entry_idle_time(ppe, ib1);
++		cur_idle = __mtk_foe_entry_idle_time(ppe, cur->data.ib1);
+ 		if (cur_idle >= idle)
+ 			continue;
+ 
+ 		idle = cur_idle;
+ 		entry->data.ib1 &= ~ib1_ts_mask;
+-		entry->data.ib1 |= ib1 & ib1_ts_mask;
+-	}
+-}
+-
+-static void
+-mtk_flow_entry_update(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
+-{
+-	struct mtk_foe_entry foe = {};
+-	struct mtk_foe_entry *hwe;
+-
+-	spin_lock_bh(&ppe_lock);
+-
+-	if (entry->type == MTK_FLOW_TYPE_L2) {
+-		mtk_flow_entry_update_l2(ppe, entry);
+-		goto out;
++		entry->data.ib1 |= cur->data.ib1 & ib1_ts_mask;
+ 	}
+-
+-	if (entry->hash == 0xffff)
+-		goto out;
+-
+-	hwe = mtk_foe_get_entry(ppe, entry->hash);
+-	memcpy(&foe, hwe, ppe->eth->soc->foe_entry_size);
+-	if (!mtk_flow_entry_match(ppe->eth, entry, &foe)) {
+-		entry->hash = 0xffff;
+-		goto out;
+-	}
+-
+-	entry->data.ib1 = foe.ib1;
+-
+-out:
+-	spin_unlock_bh(&ppe_lock);
+ }
+ 
+ static void
+@@ -653,7 +644,8 @@ __mtk_foe_entry_commit(struct mtk_ppe *p
+ void mtk_foe_entry_clear(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
+ {
+ 	spin_lock_bh(&ppe_lock);
+-	__mtk_foe_entry_clear(ppe, entry);
++	__mtk_foe_entry_clear(ppe, entry, true);
++	hlist_del_init(&entry->list);
+ 	spin_unlock_bh(&ppe_lock);
+ }
+ 
+@@ -700,8 +692,8 @@ mtk_foe_entry_commit_subflow(struct mtk_
+ {
+ 	const struct mtk_soc_data *soc = ppe->eth->soc;
+ 	struct mtk_flow_entry *flow_info;
+-	struct mtk_foe_entry foe = {}, *hwe;
+ 	struct mtk_foe_mac_info *l2;
++	struct mtk_foe_entry *hwe;
+ 	u32 ib1_mask = mtk_get_ib1_pkt_type_mask(ppe->eth) | MTK_FOE_IB1_UDP;
+ 	int type;
+ 
+@@ -709,30 +701,30 @@ mtk_foe_entry_commit_subflow(struct mtk_
+ 	if (!flow_info)
+ 		return;
+ 
+-	flow_info->l2_data.base_flow = entry;
+ 	flow_info->type = MTK_FLOW_TYPE_L2_SUBFLOW;
+ 	flow_info->hash = hash;
+ 	hlist_add_head(&flow_info->list,
+ 		       &ppe->foe_flow[hash / soc->hash_offset]);
+-	hlist_add_head(&flow_info->l2_data.list, &entry->l2_flows);
++	hlist_add_head(&flow_info->l2_list, &entry->l2_flows);
+ 
+ 	hwe = mtk_foe_get_entry(ppe, hash);
+-	memcpy(&foe, hwe, soc->foe_entry_size);
+-	foe.ib1 &= ib1_mask;
+-	foe.ib1 |= entry->data.ib1 & ~ib1_mask;
++	memcpy(&flow_info->data, hwe, soc->foe_entry_size);
++	flow_info->data.ib1 &= ib1_mask;
++	flow_info->data.ib1 |= entry->data.ib1 & ~ib1_mask;
+ 
+-	l2 = mtk_foe_entry_l2(ppe->eth, &foe);
++	l2 = mtk_foe_entry_l2(ppe->eth, &flow_info->data);
+ 	memcpy(l2, &entry->data.bridge.l2, sizeof(*l2));
+ 
+-	type = mtk_get_ib1_pkt_type(ppe->eth, foe.ib1);
++	type = mtk_get_ib1_pkt_type(ppe->eth, flow_info->data.ib1);
+ 	if (type == MTK_PPE_PKT_TYPE_IPV4_HNAPT)
+-		memcpy(&foe.ipv4.new, &foe.ipv4.orig, sizeof(foe.ipv4.new));
++		memcpy(&flow_info->data.ipv4.new, &flow_info->data.ipv4.orig,
++		       sizeof(flow_info->data.ipv4.new));
+ 	else if (type >= MTK_PPE_PKT_TYPE_IPV6_ROUTE_3T && l2->etype == ETH_P_IP)
+ 		l2->etype = ETH_P_IPV6;
+ 
+-	*mtk_foe_entry_ib2(ppe->eth, &foe) = entry->data.bridge.ib2;
++	*mtk_foe_entry_ib2(ppe->eth, &flow_info->data) = entry->data.bridge.ib2;
+ 
+-	__mtk_foe_entry_commit(ppe, &foe, hash);
++	__mtk_foe_entry_commit(ppe, &flow_info->data, hash);
+ }
+ 
+ void __mtk_ppe_check_skb(struct mtk_ppe *ppe, struct sk_buff *skb, u16 hash)
+@@ -742,9 +734,11 @@ void __mtk_ppe_check_skb(struct mtk_ppe
+ 	struct mtk_foe_entry *hwe = mtk_foe_get_entry(ppe, hash);
+ 	struct mtk_flow_entry *entry;
+ 	struct mtk_foe_bridge key = {};
++	struct mtk_foe_entry foe = {};
+ 	struct hlist_node *n;
+ 	struct ethhdr *eh;
+ 	bool found = false;
++	int entry_len;
+ 	u8 *tag;
+ 
+ 	spin_lock_bh(&ppe_lock);
+@@ -752,20 +746,14 @@ void __mtk_ppe_check_skb(struct mtk_ppe
+ 	if (FIELD_GET(MTK_FOE_IB1_STATE, hwe->ib1) == MTK_FOE_STATE_BIND)
+ 		goto out;
+ 
+-	hlist_for_each_entry_safe(entry, n, head, list) {
+-		if (entry->type == MTK_FLOW_TYPE_L2_SUBFLOW) {
+-			if (unlikely(FIELD_GET(MTK_FOE_IB1_STATE, hwe->ib1) ==
+-				     MTK_FOE_STATE_BIND))
+-				continue;
+-
+-			entry->hash = 0xffff;
+-			__mtk_foe_entry_clear(ppe, entry);
+-			continue;
+-		}
++	entry_len = mtk_flow_entry_match_len(ppe->eth, hwe);
++	memcpy(&foe, hwe, entry_len);
+ 
+-		if (found || !mtk_flow_entry_match(ppe->eth, entry, hwe)) {
++	hlist_for_each_entry_safe(entry, n, head, list) {
++		if (found ||
++		    !mtk_flow_entry_match(ppe->eth, entry, &foe, entry_len)) {
+ 			if (entry->hash != 0xffff)
+-				entry->hash = 0xffff;
++				__mtk_foe_entry_clear(ppe, entry, false);
+ 			continue;
+ 		}
+ 
+@@ -816,9 +804,17 @@ out:
+ 
+ int mtk_foe_entry_idle_time(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
+ {
+-	mtk_flow_entry_update(ppe, entry);
++	int idle;
++
++	spin_lock_bh(&ppe_lock);
++	if (entry->type == MTK_FLOW_TYPE_L2)
++		mtk_flow_entry_update_l2(ppe, entry);
++	else
++		mtk_flow_entry_update(ppe, entry);
++	idle = __mtk_foe_entry_idle_time(ppe, entry->data.ib1);
++	spin_unlock_bh(&ppe_lock);
+ 
+-	return __mtk_foe_entry_idle_time(ppe, entry->data.ib1);
++	return idle;
+ }
+ 
+ int mtk_ppe_prepare_reset(struct mtk_ppe *ppe)
+--- a/drivers/net/ethernet/mediatek/mtk_ppe.h
++++ b/drivers/net/ethernet/mediatek/mtk_ppe.h
+@@ -286,7 +286,12 @@ enum {
+ 
+ struct mtk_flow_entry {
+ 	union {
+-		struct hlist_node list;
++		/* regular flows + L2 subflows */
++		struct {
++			struct hlist_node list;
++			struct hlist_node l2_list;
++		};
++		/* L2 flows */
+ 		struct {
+ 			struct rhash_head l2_node;
+ 			struct hlist_head l2_flows;
+@@ -296,13 +301,7 @@ struct mtk_flow_entry {
+ 	s8 wed_index;
+ 	u8 ppe_index;
+ 	u16 hash;
+-	union {
+-		struct mtk_foe_entry data;
+-		struct {
+-			struct mtk_flow_entry *base_flow;
+-			struct hlist_node list;
+-		} l2_data;
+-	};
++	struct mtk_foe_entry data;
+ 	struct rhash_head node;
+ 	unsigned long cookie;
+ };
diff --git a/target/linux/generic/pending-6.12/736-04-net-ethernet-mediatek-fix-ppe-flow-accounting-for-L2.patch b/target/linux/generic/pending-6.12/736-04-net-ethernet-mediatek-fix-ppe-flow-accounting-for-L2.patch
new file mode 100644
index 0000000000..1916613e54
--- /dev/null
+++ b/target/linux/generic/pending-6.12/736-04-net-ethernet-mediatek-fix-ppe-flow-accounting-for-L2.patch
@@ -0,0 +1,343 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 23 Mar 2023 11:05:22 +0100
+Subject: [PATCH] net: ethernet: mediatek: fix ppe flow accounting for L2
+ flows
+
+For L2 flows, the packet/byte counters should report the sum of the
+counters of their subflows, both current and expired.
+In order to make this work, change the way that accounting data is tracked.
+Reset counters when a flow enters bind. Once it expires (or enters unbind),
+store the last counter value in struct mtk_flow_entry.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/ethernet/mediatek/mtk_ppe.c
++++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
+@@ -83,9 +83,9 @@ static int mtk_ppe_mib_wait_busy(struct
+ 	int ret;
+ 	u32 val;
+ 
+-	ret = readl_poll_timeout(ppe->base + MTK_PPE_MIB_SER_CR, val,
+-				 !(val & MTK_PPE_MIB_SER_CR_ST),
+-				 20, MTK_PPE_WAIT_TIMEOUT_US);
++	ret = readl_poll_timeout_atomic(ppe->base + MTK_PPE_MIB_SER_CR, val,
++					!(val & MTK_PPE_MIB_SER_CR_ST),
++					20, MTK_PPE_WAIT_TIMEOUT_US);
+ 
+ 	if (ret)
+ 		dev_err(ppe->dev, "MIB table busy");
+@@ -93,17 +93,31 @@ static int mtk_ppe_mib_wait_busy(struct
+ 	return ret;
+ }
+ 
+-static int mtk_mib_entry_read(struct mtk_ppe *ppe, u16 index, u64 *bytes, u64 *packets)
++static inline struct mtk_foe_accounting *
++mtk_ppe_acct_data(struct mtk_ppe *ppe, u16 index)
++{
++	if (!ppe->acct_table)
++		return NULL;
++
++	return ppe->acct_table + index * sizeof(struct mtk_foe_accounting);
++}
++
++struct mtk_foe_accounting *mtk_ppe_mib_entry_read(struct mtk_ppe *ppe, u16 index)
+ {
+ 	u32 val, cnt_r0, cnt_r1, cnt_r2;
++	struct mtk_foe_accounting *acct;
+ 	int ret;
+ 
+ 	val = FIELD_PREP(MTK_PPE_MIB_SER_CR_ADDR, index) | MTK_PPE_MIB_SER_CR_ST;
+ 	ppe_w32(ppe, MTK_PPE_MIB_SER_CR, val);
+ 
++	acct = mtk_ppe_acct_data(ppe, index);
++	if (!acct)
++		return NULL;
++
+ 	ret = mtk_ppe_mib_wait_busy(ppe);
+ 	if (ret)
+-		return ret;
++		return acct;
+ 
+ 	cnt_r0 = readl(ppe->base + MTK_PPE_MIB_SER_R0);
+ 	cnt_r1 = readl(ppe->base + MTK_PPE_MIB_SER_R1);
+@@ -112,19 +126,19 @@ static int mtk_mib_entry_read(struct mtk
+ 	if (mtk_is_netsys_v3_or_greater(ppe->eth)) {
+ 		/* 64 bit for each counter */
+ 		u32 cnt_r3 = readl(ppe->base + MTK_PPE_MIB_SER_R3);
+-		*bytes = ((u64)cnt_r1 << 32) | cnt_r0;
+-		*packets = ((u64)cnt_r3 << 32) | cnt_r2;
++		acct->bytes += ((u64)cnt_r1 << 32) | cnt_r0;
++		acct->packets += ((u64)cnt_r3 << 32) | cnt_r2;
+ 	} else {
+ 		/* 48 bit byte counter, 40 bit packet counter */
+ 		u32 byte_cnt_low = FIELD_GET(MTK_PPE_MIB_SER_R0_BYTE_CNT_LOW, cnt_r0);
+ 		u32 byte_cnt_high = FIELD_GET(MTK_PPE_MIB_SER_R1_BYTE_CNT_HIGH, cnt_r1);
+ 		u32 pkt_cnt_low = FIELD_GET(MTK_PPE_MIB_SER_R1_PKT_CNT_LOW, cnt_r1);
+ 		u32 pkt_cnt_high = FIELD_GET(MTK_PPE_MIB_SER_R2_PKT_CNT_HIGH, cnt_r2);
+-		*bytes = ((u64)byte_cnt_high << 32) | byte_cnt_low;
+-		*packets = ((u64)pkt_cnt_high << 16) | pkt_cnt_low;
++		acct->bytes += ((u64)byte_cnt_high << 32) | byte_cnt_low;
++		acct->packets += ((u64)pkt_cnt_high << 16) | pkt_cnt_low;
+ 	}
+ 
+-	return 0;
++	return acct;
+ }
+ 
+ static void mtk_ppe_cache_clear(struct mtk_ppe *ppe)
+@@ -522,14 +536,6 @@ __mtk_foe_entry_clear(struct mtk_ppe *pp
+ 		hwe->ib1 |= FIELD_PREP(MTK_FOE_IB1_STATE, MTK_FOE_STATE_INVALID);
+ 		dma_wmb();
+ 		mtk_ppe_cache_clear(ppe);
+-
+-		if (ppe->accounting) {
+-			struct mtk_foe_accounting *acct;
+-
+-			acct = ppe->acct_table + entry->hash * sizeof(*acct);
+-			acct->packets = 0;
+-			acct->bytes = 0;
+-		}
+ 	}
+ 	entry->hash = 0xffff;
+ 
+@@ -554,11 +560,14 @@ static int __mtk_foe_entry_idle_time(str
+ }
+ 
+ static bool
+-mtk_flow_entry_update(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
++mtk_flow_entry_update(struct mtk_ppe *ppe, struct mtk_flow_entry *entry,
++		      u64 *packets, u64 *bytes)
+ {
++	struct mtk_foe_accounting *acct;
+ 	struct mtk_foe_entry foe = {};
+ 	struct mtk_foe_entry *hwe;
+ 	u16 hash = entry->hash;
++	bool ret = false;
+ 	int len;
+ 
+ 	if (hash == 0xffff)
+@@ -569,18 +578,35 @@ mtk_flow_entry_update(struct mtk_ppe *pp
+ 	memcpy(&foe, hwe, len);
+ 
+ 	if (!mtk_flow_entry_match(ppe->eth, entry, &foe, len) ||
+-	    FIELD_GET(MTK_FOE_IB1_STATE, foe.ib1) != MTK_FOE_STATE_BIND)
+-		return false;
++	    FIELD_GET(MTK_FOE_IB1_STATE, foe.ib1) != MTK_FOE_STATE_BIND) {
++		acct = mtk_ppe_acct_data(ppe, hash);
++		if (acct) {
++			entry->prev_packets += acct->packets;
++			entry->prev_bytes += acct->bytes;
++		}
++
++		goto out;
++	}
+ 
+ 	entry->data.ib1 = foe.ib1;
++	acct = mtk_ppe_mib_entry_read(ppe, hash);
++	ret = true;
++
++out:
++	if (acct) {
++		*packets += acct->packets;
++		*bytes += acct->bytes;
++	}
+ 
+-	return true;
++	return ret;
+ }
+ 
+ static void
+ mtk_flow_entry_update_l2(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
+ {
+ 	u32 ib1_ts_mask = mtk_get_ib1_ts_mask(ppe->eth);
++	u64 *packets = &entry->packets;
++	u64 *bytes = &entry->bytes;
+ 	struct mtk_flow_entry *cur;
+ 	struct hlist_node *tmp;
+ 	int idle;
+@@ -589,7 +615,9 @@ mtk_flow_entry_update_l2(struct mtk_ppe
+ 	hlist_for_each_entry_safe(cur, tmp, &entry->l2_flows, l2_list) {
+ 		int cur_idle;
+ 
+-		if (!mtk_flow_entry_update(ppe, cur)) {
++		if (!mtk_flow_entry_update(ppe, cur, packets, bytes)) {
++			entry->prev_packets += cur->prev_packets;
++			entry->prev_bytes += cur->prev_bytes;
+ 			__mtk_foe_entry_clear(ppe, entry, false);
+ 			continue;
+ 		}
+@@ -604,10 +632,29 @@ mtk_flow_entry_update_l2(struct mtk_ppe
+ 	}
+ }
+ 
++void mtk_foe_entry_get_stats(struct mtk_ppe *ppe, struct mtk_flow_entry *entry,
++			     int *idle)
++{
++	entry->packets = entry->prev_packets;
++	entry->bytes = entry->prev_bytes;
++
++	spin_lock_bh(&ppe_lock);
++
++	if (entry->type == MTK_FLOW_TYPE_L2)
++		mtk_flow_entry_update_l2(ppe, entry);
++	else
++		mtk_flow_entry_update(ppe, entry, &entry->packets, &entry->bytes);
++
++	*idle = __mtk_foe_entry_idle_time(ppe, entry->data.ib1);
++
++	spin_unlock_bh(&ppe_lock);
++}
++
+ static void
+ __mtk_foe_entry_commit(struct mtk_ppe *ppe, struct mtk_foe_entry *entry,
+ 		       u16 hash)
+ {
++	struct mtk_foe_accounting *acct;
+ 	struct mtk_eth *eth = ppe->eth;
+ 	u16 timestamp = mtk_eth_timestamp(eth);
+ 	struct mtk_foe_entry *hwe;
+@@ -638,6 +685,12 @@ __mtk_foe_entry_commit(struct mtk_ppe *p
+ 
+ 	dma_wmb();
+ 
++	acct = mtk_ppe_mib_entry_read(ppe, hash);
++	if (acct) {
++		acct->packets = 0;
++		acct->bytes = 0;
++	}
++
+ 	mtk_ppe_cache_clear(ppe);
+ }
+ 
+@@ -802,21 +855,6 @@ out:
+ 	spin_unlock_bh(&ppe_lock);
+ }
+ 
+-int mtk_foe_entry_idle_time(struct mtk_ppe *ppe, struct mtk_flow_entry *entry)
+-{
+-	int idle;
+-
+-	spin_lock_bh(&ppe_lock);
+-	if (entry->type == MTK_FLOW_TYPE_L2)
+-		mtk_flow_entry_update_l2(ppe, entry);
+-	else
+-		mtk_flow_entry_update(ppe, entry);
+-	idle = __mtk_foe_entry_idle_time(ppe, entry->data.ib1);
+-	spin_unlock_bh(&ppe_lock);
+-
+-	return idle;
+-}
+-
+ int mtk_ppe_prepare_reset(struct mtk_ppe *ppe)
+ {
+ 	if (!ppe)
+@@ -844,32 +882,6 @@ int mtk_ppe_prepare_reset(struct mtk_ppe
+ 	return mtk_ppe_wait_busy(ppe);
+ }
+ 
+-struct mtk_foe_accounting *mtk_foe_entry_get_mib(struct mtk_ppe *ppe, u32 index,
+-						 struct mtk_foe_accounting *diff)
+-{
+-	struct mtk_foe_accounting *acct;
+-	int size = sizeof(struct mtk_foe_accounting);
+-	u64 bytes, packets;
+-
+-	if (!ppe->accounting)
+-		return NULL;
+-
+-	if (mtk_mib_entry_read(ppe, index, &bytes, &packets))
+-		return NULL;
+-
+-	acct = ppe->acct_table + index * size;
+-
+-	acct->bytes += bytes;
+-	acct->packets += packets;
+-
+-	if (diff) {
+-		diff->bytes = bytes;
+-		diff->packets = packets;
+-	}
+-
+-	return acct;
+-}
+-
+ struct mtk_ppe *mtk_ppe_init(struct mtk_eth *eth, void __iomem *base, int index)
+ {
+ 	bool accounting = eth->soc->has_accounting;
+--- a/drivers/net/ethernet/mediatek/mtk_ppe.h
++++ b/drivers/net/ethernet/mediatek/mtk_ppe.h
+@@ -304,6 +304,8 @@ struct mtk_flow_entry {
+ 	struct mtk_foe_entry data;
+ 	struct rhash_head node;
+ 	unsigned long cookie;
++	u64 prev_packets, prev_bytes;
++	u64 packets, bytes;
+ };
+ 
+ struct mtk_mib_entry {
+@@ -348,6 +350,7 @@ void mtk_ppe_deinit(struct mtk_eth *eth)
+ void mtk_ppe_start(struct mtk_ppe *ppe);
+ int mtk_ppe_stop(struct mtk_ppe *ppe);
+ int mtk_ppe_prepare_reset(struct mtk_ppe *ppe);
++struct mtk_foe_accounting *mtk_ppe_mib_entry_read(struct mtk_ppe *ppe, u16 index);
+ 
+ void __mtk_ppe_check_skb(struct mtk_ppe *ppe, struct sk_buff *skb, u16 hash);
+ 
+@@ -397,9 +400,8 @@ int mtk_foe_entry_set_queue(struct mtk_e
+ 			    unsigned int queue);
+ int mtk_foe_entry_commit(struct mtk_ppe *ppe, struct mtk_flow_entry *entry);
+ void mtk_foe_entry_clear(struct mtk_ppe *ppe, struct mtk_flow_entry *entry);
+-int mtk_foe_entry_idle_time(struct mtk_ppe *ppe, struct mtk_flow_entry *entry);
+ int mtk_ppe_debugfs_init(struct mtk_ppe *ppe, int index);
+-struct mtk_foe_accounting *mtk_foe_entry_get_mib(struct mtk_ppe *ppe, u32 index,
+-						 struct mtk_foe_accounting *diff);
++void mtk_foe_entry_get_stats(struct mtk_ppe *ppe, struct mtk_flow_entry *entry,
++			     int *idle);
+ 
+ #endif
+--- a/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c
++++ b/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c
+@@ -97,7 +97,7 @@ mtk_ppe_debugfs_foe_show(struct seq_file
+ 		if (bind && state != MTK_FOE_STATE_BIND)
+ 			continue;
+ 
+-		acct = mtk_foe_entry_get_mib(ppe, i, NULL);
++		acct = mtk_ppe_mib_entry_read(ppe, i);
+ 
+ 		type = mtk_get_ib1_pkt_type(ppe->eth, entry->ib1);
+ 		seq_printf(m, "%05x %s %7s", i,
+--- a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
++++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
+@@ -520,24 +520,21 @@ static int
+ mtk_flow_offload_stats(struct mtk_eth *eth, struct flow_cls_offload *f)
+ {
+ 	struct mtk_flow_entry *entry;
+-	struct mtk_foe_accounting diff;
+-	u32 idle;
++	u64 packets, bytes;
++	int idle;
+ 
+ 	entry = rhashtable_lookup(&eth->flow_table, &f->cookie,
+ 				  mtk_flow_ht_params);
+ 	if (!entry)
+ 		return -ENOENT;
+ 
+-	idle = mtk_foe_entry_idle_time(eth->ppe[entry->ppe_index], entry);
++	packets = entry->packets;
++	bytes = entry->bytes;
++	mtk_foe_entry_get_stats(eth->ppe[entry->ppe_index], entry, &idle);
++	f->stats.pkts += entry->packets - packets;
++	f->stats.bytes += entry->bytes - bytes;
+ 	f->stats.lastused = jiffies - idle * HZ;
+ 
+-	if (entry->hash != 0xFFFF &&
+-	    mtk_foe_entry_get_mib(eth->ppe[entry->ppe_index], entry->hash,
+-				  &diff)) {
+-		f->stats.pkts += diff.packets;
+-		f->stats.bytes += diff.bytes;
+-	}
+-
+ 	return 0;
+ }
+ 
diff --git a/target/linux/generic/pending-6.12/737-net-ethernet-mtk_eth_soc-add-paths-and-SerDes-modes-.patch b/target/linux/generic/pending-6.12/737-net-ethernet-mtk_eth_soc-add-paths-and-SerDes-modes-.patch
new file mode 100644
index 0000000000..908eb6fae3
--- /dev/null
+++ b/target/linux/generic/pending-6.12/737-net-ethernet-mtk_eth_soc-add-paths-and-SerDes-modes-.patch
@@ -0,0 +1,890 @@
+From d5e337e7aecc2e1cc9e96768062610adb95f8f72 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Tue, 12 Dec 2023 03:51:14 +0000
+Subject: [PATCH] net: ethernet: mtk_eth_soc: add paths and SerDes modes for
+ MT7988
+
+MT7988 comes with a built-in 2.5G PHY as well as SerDes lanes to
+connect external PHYs or transceivers in USXGMII, 10GBase-R, 5GBase-R,
+2500Base-X, 1000Base-X and Cisco SGMII interface modes.
+
+Implement support for configuring for the new paths to SerDes interfaces
+and the internal 2.5G PHY.
+
+Add USXGMII PCS driver for 10GBase-R, 5GBase-R and USXGMII mode, and
+setup the new PHYA on MT7988 to access the also still existing old
+LynxI PCS for 1000Base-X, 2500Base-X and Cisco SGMII PCS interface
+modes.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/ethernet/mediatek/mtk_eth_path.c | 122 +++++++-
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c  | 292 +++++++++++++++++--
+ drivers/net/ethernet/mediatek/mtk_eth_soc.h  | 107 ++++++-
+ 3 files changed, 470 insertions(+), 51 deletions(-)
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_path.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_path.c
+@@ -31,10 +31,20 @@ static const char *mtk_eth_path_name(u64
+ 		return "gmac2_rgmii";
+ 	case MTK_ETH_PATH_GMAC2_SGMII:
+ 		return "gmac2_sgmii";
++	case MTK_ETH_PATH_GMAC2_2P5GPHY:
++		return "gmac2_2p5gphy";
+ 	case MTK_ETH_PATH_GMAC2_GEPHY:
+ 		return "gmac2_gephy";
++	case MTK_ETH_PATH_GMAC3_SGMII:
++		return "gmac3_sgmii";
+ 	case MTK_ETH_PATH_GDM1_ESW:
+ 		return "gdm1_esw";
++	case MTK_ETH_PATH_GMAC1_USXGMII:
++		return "gmac1_usxgmii";
++	case MTK_ETH_PATH_GMAC2_USXGMII:
++		return "gmac2_usxgmii";
++	case MTK_ETH_PATH_GMAC3_USXGMII:
++		return "gmac3_usxgmii";
+ 	default:
+ 		return "unknown path";
+ 	}
+@@ -127,6 +137,27 @@ static int set_mux_u3_gmac2_to_qphy(stru
+ 	return 0;
+ }
+ 
++static int set_mux_gmac2_to_2p5gphy(struct mtk_eth *eth, u64 path)
++{
++	int ret;
++
++	if (path == MTK_ETH_PATH_GMAC2_2P5GPHY) {
++		ret = regmap_clear_bits(eth->ethsys, ETHSYS_SYSCFG0, SYSCFG0_SGMII_GMAC2_V2);
++		if (ret)
++			return ret;
++
++		/* Setup mux to 2p5g PHY */
++		ret = regmap_clear_bits(eth->infra, TOP_MISC_NETSYS_PCS_MUX, MUX_G2_USXGMII_SEL);
++		if (ret)
++			return ret;
++
++		dev_dbg(eth->dev, "path %s in %s updated\n",
++			mtk_eth_path_name(path), __func__);
++	}
++
++	return 0;
++}
++
+ static int set_mux_gmac1_gmac2_to_sgmii_rgmii(struct mtk_eth *eth, u64 path)
+ {
+ 	unsigned int val = 0;
+@@ -165,7 +196,48 @@ static int set_mux_gmac1_gmac2_to_sgmii_
+ 	return 0;
+ }
+ 
+-static int set_mux_gmac12_to_gephy_sgmii(struct mtk_eth *eth, u64 path)
++static int set_mux_gmac123_to_usxgmii(struct mtk_eth *eth, u64 path)
++{
++	unsigned int val = 0;
++	bool updated = true;
++	int mac_id = 0;
++
++	/* Disable SYSCFG1 SGMII */
++	regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
++
++	switch (path) {
++	case MTK_ETH_PATH_GMAC1_USXGMII:
++		val &= ~(u32)SYSCFG0_SGMII_GMAC1_V2;
++		mac_id = MTK_GMAC1_ID;
++		break;
++	case MTK_ETH_PATH_GMAC2_USXGMII:
++		val &= ~(u32)SYSCFG0_SGMII_GMAC2_V2;
++		mac_id = MTK_GMAC2_ID;
++		break;
++	case MTK_ETH_PATH_GMAC3_USXGMII:
++		val &= ~(u32)SYSCFG0_SGMII_GMAC3_V2;
++		mac_id = MTK_GMAC3_ID;
++		break;
++	default:
++		updated = false;
++	};
++
++	if (updated) {
++		regmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,
++				   SYSCFG0_SGMII_MASK, val);
++
++		if (mac_id == MTK_GMAC2_ID)
++			regmap_set_bits(eth->infra, TOP_MISC_NETSYS_PCS_MUX,
++					MUX_G2_USXGMII_SEL);
++	}
++
++	dev_dbg(eth->dev, "path %s in %s updated = %d\n",
++		mtk_eth_path_name(path), __func__, updated);
++
++	return 0;
++}
++
++static int set_mux_gmac123_to_gephy_sgmii(struct mtk_eth *eth, u64 path)
+ {
+ 	unsigned int val = 0;
+ 	bool updated = true;
+@@ -182,6 +254,9 @@ static int set_mux_gmac12_to_gephy_sgmii
+ 	case MTK_ETH_PATH_GMAC2_SGMII:
+ 		val |= SYSCFG0_SGMII_GMAC2_V2;
+ 		break;
++	case MTK_ETH_PATH_GMAC3_SGMII:
++		val |= SYSCFG0_SGMII_GMAC3_V2;
++		break;
+ 	default:
+ 		updated = false;
+ 	}
+@@ -210,13 +285,25 @@ static const struct mtk_eth_muxc mtk_eth
+ 		.cap_bit = MTK_ETH_MUX_U3_GMAC2_TO_QPHY,
+ 		.set_path = set_mux_u3_gmac2_to_qphy,
+ 	}, {
++		.name = "mux_gmac2_to_2p5gphy",
++		.cap_bit = MTK_ETH_MUX_GMAC2_TO_2P5GPHY,
++		.set_path = set_mux_gmac2_to_2p5gphy,
++	}, {
+ 		.name = "mux_gmac1_gmac2_to_sgmii_rgmii",
+ 		.cap_bit = MTK_ETH_MUX_GMAC1_GMAC2_TO_SGMII_RGMII,
+ 		.set_path = set_mux_gmac1_gmac2_to_sgmii_rgmii,
+ 	}, {
+ 		.name = "mux_gmac12_to_gephy_sgmii",
+ 		.cap_bit = MTK_ETH_MUX_GMAC12_TO_GEPHY_SGMII,
+-		.set_path = set_mux_gmac12_to_gephy_sgmii,
++		.set_path = set_mux_gmac123_to_gephy_sgmii,
++	}, {
++		.name = "mux_gmac123_to_gephy_sgmii",
++		.cap_bit = MTK_ETH_MUX_GMAC123_TO_GEPHY_SGMII,
++		.set_path = set_mux_gmac123_to_gephy_sgmii,
++	}, {
++		.name = "mux_gmac123_to_usxgmii",
++		.cap_bit = MTK_ETH_MUX_GMAC123_TO_USXGMII,
++		.set_path = set_mux_gmac123_to_usxgmii,
+ 	},
+ };
+ 
+@@ -249,12 +336,39 @@ out:
+ 	return err;
+ }
+ 
++int mtk_gmac_usxgmii_path_setup(struct mtk_eth *eth, int mac_id)
++{
++	u64 path;
++
++	path = (mac_id == MTK_GMAC1_ID) ?  MTK_ETH_PATH_GMAC1_USXGMII :
++	       (mac_id == MTK_GMAC2_ID) ?  MTK_ETH_PATH_GMAC2_USXGMII :
++					   MTK_ETH_PATH_GMAC3_USXGMII;
++
++	/* Setup proper MUXes along the path */
++	return mtk_eth_mux_setup(eth, path);
++}
++
+ int mtk_gmac_sgmii_path_setup(struct mtk_eth *eth, int mac_id)
+ {
+ 	u64 path;
+ 
+-	path = (mac_id == 0) ?  MTK_ETH_PATH_GMAC1_SGMII :
+-				MTK_ETH_PATH_GMAC2_SGMII;
++	path = (mac_id == MTK_GMAC1_ID) ? MTK_ETH_PATH_GMAC1_SGMII :
++	       (mac_id == MTK_GMAC2_ID) ? MTK_ETH_PATH_GMAC2_SGMII :
++					  MTK_ETH_PATH_GMAC3_SGMII;
++
++	/* Setup proper MUXes along the path */
++	return mtk_eth_mux_setup(eth, path);
++}
++
++int mtk_gmac_2p5gphy_path_setup(struct mtk_eth *eth, int mac_id)
++{
++	u64 path = 0;
++
++	if (mac_id == MTK_GMAC2_ID)
++		path = MTK_ETH_PATH_GMAC2_2P5GPHY;
++
++	if (!path)
++		return -EINVAL;
+ 
+ 	/* Setup proper MUXes along the path */
+ 	return mtk_eth_mux_setup(eth, path);
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -22,6 +22,8 @@
+ #include <linux/pinctrl/devinfo.h>
+ #include <linux/phylink.h>
+ #include <linux/pcs/pcs-mtk-lynxi.h>
++#include <linux/pcs/pcs-mtk-usxgmii.h>
++#include <linux/phy/phy.h>
+ #include <linux/jhash.h>
+ #include <linux/bitfield.h>
+ #include <net/dsa.h>
+@@ -514,6 +516,30 @@ static void mtk_setup_bridge_switch(stru
+ 		MTK_GSW_CFG);
+ }
+ 
++static bool mtk_check_gmac23_idle(struct mtk_mac *mac)
++{
++	u32 mac_fsm, gdm_fsm;
++
++	mac_fsm = mtk_r32(mac->hw, MTK_MAC_FSM(mac->id));
++
++	switch (mac->id) {
++	case MTK_GMAC2_ID:
++		gdm_fsm = mtk_r32(mac->hw, MTK_FE_GDM2_FSM);
++		break;
++	case MTK_GMAC3_ID:
++		gdm_fsm = mtk_r32(mac->hw, MTK_FE_GDM3_FSM);
++		break;
++	default:
++		return true;
++	};
++
++	if ((mac_fsm & 0xFFFF0000) == 0x01010000 &&
++	    (gdm_fsm & 0xFFFF0000) == 0x00000000)
++		return true;
++
++	return false;
++}
++
+ static struct phylink_pcs *mtk_mac_select_pcs(struct phylink_config *config,
+ 					      phy_interface_t interface)
+ {
+@@ -522,6 +548,21 @@ static struct phylink_pcs *mtk_mac_selec
+ 	struct mtk_eth *eth = mac->hw;
+ 	unsigned int sid;
+ 
++	if (mtk_is_netsys_v3_or_greater(eth)) {
++		switch (interface) {
++		case PHY_INTERFACE_MODE_1000BASEX:
++		case PHY_INTERFACE_MODE_2500BASEX:
++		case PHY_INTERFACE_MODE_SGMII:
++			return mac->sgmii_pcs;
++		case PHY_INTERFACE_MODE_5GBASER:
++		case PHY_INTERFACE_MODE_10GBASER:
++		case PHY_INTERFACE_MODE_USXGMII:
++			return mac->usxgmii_pcs;
++		default:
++			return NULL;
++		}
++	}
++
+ 	if (interface == PHY_INTERFACE_MODE_SGMII ||
+ 	    phy_interface_mode_is_8023z(interface)) {
+ 		sid = (MTK_HAS_CAPS(eth->soc->caps, MTK_SHARED_SGMII)) ?
+@@ -573,7 +614,22 @@ static void mtk_mac_config(struct phylin
+ 					goto init_err;
+ 			}
+ 			break;
++		case PHY_INTERFACE_MODE_USXGMII:
++		case PHY_INTERFACE_MODE_10GBASER:
++		case PHY_INTERFACE_MODE_5GBASER:
++			if (MTK_HAS_CAPS(eth->soc->caps, MTK_USXGMII)) {
++				err = mtk_gmac_usxgmii_path_setup(eth, mac->id);
++				if (err)
++					goto init_err;
++			}
++			break;
+ 		case PHY_INTERFACE_MODE_INTERNAL:
++			if (mac->id == MTK_GMAC2_ID &&
++			    MTK_HAS_CAPS(eth->soc->caps, MTK_2P5GPHY)) {
++				err = mtk_gmac_2p5gphy_path_setup(eth, mac->id);
++				if (err)
++					goto init_err;
++			}
+ 			break;
+ 		default:
+ 			goto err_phy;
+@@ -620,8 +676,6 @@ static void mtk_mac_config(struct phylin
+ 		val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, mac->id);
+ 		val |= SYSCFG0_GE_MODE(ge_mode, mac->id);
+ 		regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
+-
+-		mac->interface = state->interface;
+ 	}
+ 
+ 	/* SGMII */
+@@ -638,21 +692,40 @@ static void mtk_mac_config(struct phylin
+ 
+ 		/* Save the syscfg0 value for mac_finish */
+ 		mac->syscfg0 = val;
+-	} else if (phylink_autoneg_inband(mode)) {
++	} else if (state->interface != PHY_INTERFACE_MODE_USXGMII &&
++		   state->interface != PHY_INTERFACE_MODE_10GBASER &&
++		   state->interface != PHY_INTERFACE_MODE_5GBASER &&
++		   phylink_autoneg_inband(mode)) {
+ 		dev_err(eth->dev,
+-			"In-band mode not supported in non SGMII mode!\n");
++			"In-band mode not supported in non-SerDes modes!\n");
+ 		return;
+ 	}
+ 
+ 	/* Setup gmac */
+-	if (mtk_is_netsys_v3_or_greater(eth) &&
+-	    mac->interface == PHY_INTERFACE_MODE_INTERNAL) {
+-		mtk_w32(mac->hw, MTK_GDMA_XGDM_SEL, MTK_GDMA_EG_CTRL(mac->id));
+-		mtk_w32(mac->hw, MAC_MCR_FORCE_LINK_DOWN, MTK_MAC_MCR(mac->id));
++	if (mtk_is_netsys_v3_or_greater(eth)) {
++		if (mtk_interface_mode_is_xgmii(state->interface)) {
++			mtk_w32(mac->hw, MTK_GDMA_XGDM_SEL, MTK_GDMA_EG_CTRL(mac->id));
++			mtk_w32(mac->hw, MAC_MCR_FORCE_LINK_DOWN, MTK_MAC_MCR(mac->id));
++
++			if (mac->id == MTK_GMAC1_ID)
++				mtk_setup_bridge_switch(eth);
++		} else {
++			mtk_w32(eth, 0, MTK_GDMA_EG_CTRL(mac->id));
+ 
+-		mtk_setup_bridge_switch(eth);
++			/* FIXME: In current hardware design, we have to reset FE
++			 * when swtiching XGDM to GDM. Therefore, here trigger an SER
++			 * to let GDM go back to the initial state.
++			 */
++			if ((mtk_interface_mode_is_xgmii(mac->interface) ||
++			     mac->interface == PHY_INTERFACE_MODE_NA) &&
++			    !mtk_check_gmac23_idle(mac) &&
++			    !test_bit(MTK_RESETTING, &eth->state))
++				schedule_work(&eth->pending_work);
++		}
+ 	}
+ 
++	mac->interface = state->interface;
++
+ 	return;
+ 
+ err_phy:
+@@ -665,6 +738,18 @@ init_err:
+ 		mac->id, phy_modes(state->interface), err);
+ }
+ 
++static int mtk_mac_prepare(struct phylink_config *config, unsigned int mode,
++			   phy_interface_t interface)
++{
++	struct mtk_mac *mac = container_of(config, struct mtk_mac,
++					   phylink_config);
++
++	if (mac->pextp && mac->interface != interface)
++		phy_reset(mac->pextp);
++
++	return 0;
++}
++
+ static int mtk_mac_finish(struct phylink_config *config, unsigned int mode,
+ 			  phy_interface_t interface)
+ {
+@@ -673,6 +758,10 @@ static int mtk_mac_finish(struct phylink
+ 	struct mtk_eth *eth = mac->hw;
+ 	u32 mcr_cur, mcr_new;
+ 
++	/* Setup PMA/PMD */
++	if (mac->pextp)
++		phy_set_mode_ext(mac->pextp, PHY_MODE_ETHERNET, interface);
++
+ 	/* Enable SGMII */
+ 	if (interface == PHY_INTERFACE_MODE_SGMII ||
+ 	    phy_interface_mode_is_8023z(interface))
+@@ -697,10 +786,14 @@ static void mtk_mac_link_down(struct phy
+ {
+ 	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+ 					   phylink_config);
+-	u32 mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
+ 
+-	mcr &= ~(MAC_MCR_TX_EN | MAC_MCR_RX_EN | MAC_MCR_FORCE_LINK);
+-	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
++	if (!mtk_interface_mode_is_xgmii(interface)) {
++		mtk_m32(mac->hw, MAC_MCR_TX_EN | MAC_MCR_RX_EN | MAC_MCR_FORCE_LINK, 0, MTK_MAC_MCR(mac->id));
++		if (mtk_is_netsys_v3_or_greater(mac->hw))
++			mtk_m32(mac->hw, MTK_XGMAC_FORCE_LINK(mac->id), 0, MTK_XGMAC_STS(mac->id));
++	} else if (mtk_is_netsys_v3_or_greater(mac->hw) && mac->id != MTK_GMAC1_ID) {
++		mtk_m32(mac->hw, XMAC_MCR_TRX_DISABLE, XMAC_MCR_TRX_DISABLE, MTK_XMAC_MCR(mac->id));
++	}
+ }
+ 
+ static void mtk_set_queue_speed(struct mtk_eth *eth, unsigned int idx,
+@@ -772,13 +865,11 @@ static void mtk_set_queue_speed(struct m
+ 	mtk_w32(eth, val, soc->reg_map->qdma.qtx_sch + ofs);
+ }
+ 
+-static void mtk_mac_link_up(struct phylink_config *config,
+-			    struct phy_device *phy,
+-			    unsigned int mode, phy_interface_t interface,
+-			    int speed, int duplex, bool tx_pause, bool rx_pause)
++static void mtk_gdm_mac_link_up(struct mtk_mac *mac,
++				struct phy_device *phy,
++				unsigned int mode, phy_interface_t interface,
++				int speed, int duplex, bool tx_pause, bool rx_pause)
+ {
+-	struct mtk_mac *mac = container_of(config, struct mtk_mac,
+-					   phylink_config);
+ 	u32 mcr;
+ 
+ 	mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));
+@@ -822,9 +913,63 @@ static void mtk_mac_link_up(struct phyli
+ 	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
+ }
+ 
++static void mtk_xgdm_mac_link_up(struct mtk_mac *mac,
++				 struct phy_device *phy,
++				 unsigned int mode, phy_interface_t interface,
++				 int speed, int duplex, bool tx_pause, bool rx_pause)
++{
++	u32 mcr, force_link = 0;
++
++	if (mac->id == MTK_GMAC1_ID)
++		return;
++
++	/* Eliminate the interference(before link-up) caused by PHY noise */
++	mtk_m32(mac->hw, XMAC_LOGIC_RST, 0, MTK_XMAC_LOGIC_RST(mac->id));
++	mdelay(20);
++	mtk_m32(mac->hw, XMAC_GLB_CNTCLR, XMAC_GLB_CNTCLR, MTK_XMAC_CNT_CTRL(mac->id));
++
++	if (mac->interface == PHY_INTERFACE_MODE_INTERNAL || mac->id == MTK_GMAC3_ID)
++		force_link = MTK_XGMAC_FORCE_LINK(mac->id);
++
++	mtk_m32(mac->hw, MTK_XGMAC_FORCE_LINK(mac->id), force_link, MTK_XGMAC_STS(mac->id));
++
++	mcr = mtk_r32(mac->hw, MTK_XMAC_MCR(mac->id));
++	mcr &= ~(XMAC_MCR_FORCE_TX_FC | XMAC_MCR_FORCE_RX_FC | XMAC_MCR_TRX_DISABLE);
++	/* Configure pause modes -
++	 * phylink will avoid these for half duplex
++	 */
++	if (tx_pause)
++		mcr |= XMAC_MCR_FORCE_TX_FC;
++	if (rx_pause)
++		mcr |= XMAC_MCR_FORCE_RX_FC;
++
++	mtk_w32(mac->hw, mcr, MTK_XMAC_MCR(mac->id));
++}
++
++static void mtk_mac_link_up(struct phylink_config *config,
++			    struct phy_device *phy,
++			    unsigned int mode, phy_interface_t interface,
++			    int speed, int duplex, bool tx_pause, bool rx_pause)
++{
++	struct mtk_mac *mac = container_of(config, struct mtk_mac,
++					   phylink_config);
++
++	if (mtk_is_netsys_v3_or_greater(mac->hw) && mtk_interface_mode_is_xgmii(interface))
++		mtk_xgdm_mac_link_up(mac, phy, mode, interface, speed, duplex,
++				     tx_pause, rx_pause);
++	else
++		mtk_gdm_mac_link_up(mac, phy, mode, interface, speed, duplex,
++				    tx_pause, rx_pause);
++
++	/* Repeat pextp setup to tune link */
++	if (mac->pextp)
++		phy_set_mode_ext(mac->pextp, PHY_MODE_ETHERNET, interface);
++}
++
+ static const struct phylink_mac_ops mtk_phylink_ops = {
+ 	.mac_select_pcs = mtk_mac_select_pcs,
+ 	.mac_config = mtk_mac_config,
++	.mac_prepare = mtk_mac_prepare,
+ 	.mac_finish = mtk_mac_finish,
+ 	.mac_link_down = mtk_mac_link_down,
+ 	.mac_link_up = mtk_mac_link_up,
+@@ -3432,6 +3577,9 @@ static int mtk_open(struct net_device *d
+ 
+ 	ppe_num = eth->soc->ppe_num;
+ 
++	if (mac->pextp)
++		phy_power_on(mac->pextp);
++
+ 	err = phylink_of_phy_connect(mac->phylink, mac->of_node, 0);
+ 	if (err) {
+ 		netdev_err(dev, "%s: could not attach PHY: %d\n", __func__,
+@@ -3582,6 +3730,9 @@ static int mtk_stop(struct net_device *d
+ 	for (i = 0; i < ARRAY_SIZE(eth->ppe); i++)
+ 		mtk_ppe_stop(eth->ppe[i]);
+ 
++	if (mac->pextp)
++		phy_power_off(mac->pextp);
++
+ 	return 0;
+ }
+ 
+@@ -4672,6 +4823,7 @@ static const struct net_device_ops mtk_n
+ static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
+ {
+ 	const __be32 *_id = of_get_property(np, "reg", NULL);
++	struct device_node *pcs_np;
+ 	phy_interface_t phy_mode;
+ 	struct phylink *phylink;
+ 	struct mtk_mac *mac;
+@@ -4710,16 +4862,41 @@ static int mtk_add_mac(struct mtk_eth *e
+ 	mac->id = id;
+ 	mac->hw = eth;
+ 	mac->of_node = np;
++	pcs_np = of_parse_phandle(mac->of_node, "pcs-handle", 0);
++	if (pcs_np) {
++		mac->sgmii_pcs = mtk_pcs_lynxi_get(eth->dev, pcs_np);
++		if (IS_ERR(mac->sgmii_pcs)) {
++			if (PTR_ERR(mac->sgmii_pcs) == -EPROBE_DEFER)
++				return -EPROBE_DEFER;
+ 
+-	err = of_get_ethdev_address(mac->of_node, eth->netdev[id]);
+-	if (err == -EPROBE_DEFER)
+-		return err;
++			dev_err(eth->dev, "cannot select SGMII PCS, error %ld\n",
++				PTR_ERR(mac->sgmii_pcs));
++			return PTR_ERR(mac->sgmii_pcs);
++		}
++	}
+ 
+-	if (err) {
+-		/* If the mac address is invalid, use random mac address */
+-		eth_hw_addr_random(eth->netdev[id]);
+-		dev_err(eth->dev, "generated random MAC address %pM\n",
+-			eth->netdev[id]->dev_addr);
++	pcs_np = of_parse_phandle(mac->of_node, "pcs-handle", 1);
++	if (pcs_np) {
++		mac->usxgmii_pcs = mtk_usxgmii_pcs_get(eth->dev, pcs_np);
++		if (IS_ERR(mac->usxgmii_pcs)) {
++			if (PTR_ERR(mac->usxgmii_pcs) == -EPROBE_DEFER)
++				return -EPROBE_DEFER;
++
++			dev_err(eth->dev, "cannot select USXGMII PCS, error %ld\n",
++				PTR_ERR(mac->usxgmii_pcs));
++			return PTR_ERR(mac->usxgmii_pcs);
++		}
++	}
++
++	if (mtk_is_netsys_v3_or_greater(eth) && (mac->sgmii_pcs || mac->usxgmii_pcs)) {
++		mac->pextp = devm_of_phy_get(eth->dev, mac->of_node, NULL);
++		if (IS_ERR(mac->pextp)) {
++			if (PTR_ERR(mac->pextp) != -EPROBE_DEFER)
++				dev_err(eth->dev, "cannot get PHY, error %ld\n",
++					PTR_ERR(mac->pextp));
++
++			return PTR_ERR(mac->pextp);
++		}
+ 	}
+ 
+ 	memset(mac->hwlro_ip, 0, sizeof(mac->hwlro_ip));
+@@ -4802,8 +4979,21 @@ static int mtk_add_mac(struct mtk_eth *e
+ 		phy_interface_zero(mac->phylink_config.supported_interfaces);
+ 		__set_bit(PHY_INTERFACE_MODE_INTERNAL,
+ 			  mac->phylink_config.supported_interfaces);
++	} else if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_USXGMII)) {
++		mac->phylink_config.mac_capabilities |= MAC_5000FD | MAC_10000FD;
++		__set_bit(PHY_INTERFACE_MODE_5GBASER,
++			  mac->phylink_config.supported_interfaces);
++		__set_bit(PHY_INTERFACE_MODE_10GBASER,
++			  mac->phylink_config.supported_interfaces);
++		__set_bit(PHY_INTERFACE_MODE_USXGMII,
++			  mac->phylink_config.supported_interfaces);
+ 	}
+ 
++	if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_2P5GPHY) &&
++	    id == MTK_GMAC2_ID)
++		__set_bit(PHY_INTERFACE_MODE_INTERNAL,
++			  mac->phylink_config.supported_interfaces);
++
+ 	phylink = phylink_create(&mac->phylink_config,
+ 				 of_fwnode_handle(mac->of_node),
+ 				 phy_mode, &mtk_phylink_ops);
+@@ -4854,6 +5044,26 @@ free_netdev:
+ 	return err;
+ }
+ 
++static int mtk_mac_assign_address(struct mtk_eth *eth, int i, bool test_defer_only)
++{
++	int err = of_get_ethdev_address(eth->mac[i]->of_node, eth->netdev[i]);
++
++	if (err == -EPROBE_DEFER)
++		return err;
++
++	if (test_defer_only)
++		return 0;
++
++	if (err) {
++		/* If the mac address is invalid, use random mac address */
++		eth_hw_addr_random(eth->netdev[i]);
++		dev_err(eth->dev, "generated random MAC address %pM\n",
++			eth->netdev[i]);
++	}
++
++	return 0;
++}
++
+ void mtk_eth_set_dma_device(struct mtk_eth *eth, struct device *dma_dev)
+ {
+ 	struct net_device *dev, *tmp;
+@@ -5000,7 +5210,8 @@ static int mtk_probe(struct platform_dev
+ 			regmap_write(cci, 0, 3);
+ 	}
+ 
+-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII)) {
++	if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII) &&
++	    !mtk_is_netsys_v3_or_greater(eth)) {
+ 		err = mtk_sgmii_init(eth);
+ 
+ 		if (err)
+@@ -5111,6 +5322,24 @@ static int mtk_probe(struct platform_dev
+ 		}
+ 	}
+ 
++	for (i = 0; i < MTK_MAX_DEVS; i++) {
++		if (!eth->netdev[i])
++			continue;
++
++		err = mtk_mac_assign_address(eth, i, true);
++		if (err)
++			goto err_deinit_hw;
++	}
++
++	for (i = 0; i < MTK_MAX_DEVS; i++) {
++		if (!eth->netdev[i])
++			continue;
++
++		err = mtk_mac_assign_address(eth, i, false);
++		if (err)
++			goto err_deinit_hw;
++	}
++
+ 	if (MTK_HAS_CAPS(eth->soc->caps, MTK_SHARED_INT)) {
+ 		err = devm_request_irq(eth->dev, eth->irq[0],
+ 				       mtk_handle_irq, 0,
+@@ -5221,6 +5450,11 @@ static void mtk_remove(struct platform_d
+ 		mtk_stop(eth->netdev[i]);
+ 		mac = netdev_priv(eth->netdev[i]);
+ 		phylink_disconnect_phy(mac->phylink);
++		if (mac->sgmii_pcs)
++			mtk_pcs_lynxi_put(mac->sgmii_pcs);
++
++		if (mac->usxgmii_pcs)
++			mtk_usxgmii_pcs_put(mac->usxgmii_pcs);
+ 	}
+ 
+ 	mtk_wed_exit();
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+@@ -15,6 +15,7 @@
+ #include <linux/u64_stats_sync.h>
+ #include <linux/refcount.h>
+ #include <linux/phylink.h>
++#include <linux/reset.h>
+ #include <linux/rhashtable.h>
+ #include <linux/dim.h>
+ #include <linux/bitfield.h>
+@@ -524,6 +525,21 @@
+ #define INTF_MODE_RGMII_1000    (TRGMII_MODE | TRGMII_CENTRAL_ALIGNED)
+ #define INTF_MODE_RGMII_10_100  0
+ 
++/* XFI Mac control registers */
++#define MTK_XMAC_BASE(x)	(0x12000 + (((x) - 1) * 0x1000))
++#define MTK_XMAC_MCR(x)		(MTK_XMAC_BASE(x))
++#define XMAC_MCR_TRX_DISABLE	0xf
++#define XMAC_MCR_FORCE_TX_FC	BIT(5)
++#define XMAC_MCR_FORCE_RX_FC	BIT(4)
++
++/* XFI Mac logic reset registers */
++#define MTK_XMAC_LOGIC_RST(x)	(MTK_XMAC_BASE(x) + 0x10)
++#define XMAC_LOGIC_RST		BIT(0)
++
++/* XFI Mac count global control */
++#define MTK_XMAC_CNT_CTRL(x)	(MTK_XMAC_BASE(x) + 0x100)
++#define XMAC_GLB_CNTCLR		BIT(0)
++
+ /* GPIO port control registers for GMAC 2*/
+ #define GPIO_OD33_CTRL8		0x4c0
+ #define GPIO_BIAS_CTRL		0xed0
+@@ -549,6 +565,7 @@
+ #define SYSCFG0_SGMII_GMAC2    ((3 << 8) & SYSCFG0_SGMII_MASK)
+ #define SYSCFG0_SGMII_GMAC1_V2 BIT(9)
+ #define SYSCFG0_SGMII_GMAC2_V2 BIT(8)
++#define SYSCFG0_SGMII_GMAC3_V2 BIT(7)
+ 
+ 
+ /* ethernet subsystem clock register */
+@@ -587,6 +604,11 @@
+ #define GEPHY_MAC_SEL          BIT(1)
+ 
+ /* Top misc registers */
++#define TOP_MISC_NETSYS_PCS_MUX	0x0
++#define NETSYS_PCS_MUX_MASK	GENMASK(1, 0)
++#define	MUX_G2_USXGMII_SEL	BIT(1)
++#define MUX_HSGMII1_G1_SEL	BIT(0)
++
+ #define USB_PHY_SWITCH_REG	0x218
+ #define QPHY_SEL_MASK		GENMASK(1, 0)
+ #define SGMII_QPHY_SEL		0x2
+@@ -611,6 +633,8 @@
+ #define MT7628_SDM_RBCNT	(MT7628_SDM_OFFSET + 0x10c)
+ #define MT7628_SDM_CS_ERR	(MT7628_SDM_OFFSET + 0x110)
+ 
++/* Debug Purpose Register */
++#define MTK_PSE_FQFC_CFG	0x100
+ #define MTK_FE_CDM1_FSM		0x220
+ #define MTK_FE_CDM2_FSM		0x224
+ #define MTK_FE_CDM3_FSM		0x238
+@@ -619,6 +643,11 @@
+ #define MTK_FE_CDM6_FSM		0x328
+ #define MTK_FE_GDM1_FSM		0x228
+ #define MTK_FE_GDM2_FSM		0x22C
++#define MTK_FE_GDM3_FSM		0x23C
++#define MTK_FE_PSE_FREE		0x240
++#define MTK_FE_DROP_FQ		0x244
++#define MTK_FE_DROP_FC		0x248
++#define MTK_FE_DROP_PPE		0x24C
+ 
+ #define MTK_MAC_FSM(x)		(0x1010C + ((x) * 0x100))
+ 
+@@ -951,6 +980,8 @@ enum mkt_eth_capabilities {
+ 	MTK_RGMII_BIT = 0,
+ 	MTK_TRGMII_BIT,
+ 	MTK_SGMII_BIT,
++	MTK_USXGMII_BIT,
++	MTK_2P5GPHY_BIT,
+ 	MTK_ESW_BIT,
+ 	MTK_GEPHY_BIT,
+ 	MTK_MUX_BIT,
+@@ -971,8 +1002,11 @@ enum mkt_eth_capabilities {
+ 	MTK_ETH_MUX_GDM1_TO_GMAC1_ESW_BIT,
+ 	MTK_ETH_MUX_GMAC2_GMAC0_TO_GEPHY_BIT,
+ 	MTK_ETH_MUX_U3_GMAC2_TO_QPHY_BIT,
++	MTK_ETH_MUX_GMAC2_TO_2P5GPHY_BIT,
+ 	MTK_ETH_MUX_GMAC1_GMAC2_TO_SGMII_RGMII_BIT,
+ 	MTK_ETH_MUX_GMAC12_TO_GEPHY_SGMII_BIT,
++	MTK_ETH_MUX_GMAC123_TO_GEPHY_SGMII_BIT,
++	MTK_ETH_MUX_GMAC123_TO_USXGMII_BIT,
+ 
+ 	/* PATH BITS */
+ 	MTK_ETH_PATH_GMAC1_RGMII_BIT,
+@@ -980,14 +1014,21 @@ enum mkt_eth_capabilities {
+ 	MTK_ETH_PATH_GMAC1_SGMII_BIT,
+ 	MTK_ETH_PATH_GMAC2_RGMII_BIT,
+ 	MTK_ETH_PATH_GMAC2_SGMII_BIT,
++	MTK_ETH_PATH_GMAC2_2P5GPHY_BIT,
+ 	MTK_ETH_PATH_GMAC2_GEPHY_BIT,
++	MTK_ETH_PATH_GMAC3_SGMII_BIT,
+ 	MTK_ETH_PATH_GDM1_ESW_BIT,
++	MTK_ETH_PATH_GMAC1_USXGMII_BIT,
++	MTK_ETH_PATH_GMAC2_USXGMII_BIT,
++	MTK_ETH_PATH_GMAC3_USXGMII_BIT,
+ };
+ 
+ /* Supported hardware group on SoCs */
+ #define MTK_RGMII		BIT_ULL(MTK_RGMII_BIT)
+ #define MTK_TRGMII		BIT_ULL(MTK_TRGMII_BIT)
+ #define MTK_SGMII		BIT_ULL(MTK_SGMII_BIT)
++#define MTK_USXGMII		BIT_ULL(MTK_USXGMII_BIT)
++#define MTK_2P5GPHY		BIT_ULL(MTK_2P5GPHY_BIT)
+ #define MTK_ESW			BIT_ULL(MTK_ESW_BIT)
+ #define MTK_GEPHY		BIT_ULL(MTK_GEPHY_BIT)
+ #define MTK_MUX			BIT_ULL(MTK_MUX_BIT)
+@@ -1010,10 +1051,16 @@ enum mkt_eth_capabilities {
+ 	BIT_ULL(MTK_ETH_MUX_GMAC2_GMAC0_TO_GEPHY_BIT)
+ #define MTK_ETH_MUX_U3_GMAC2_TO_QPHY		\
+ 	BIT_ULL(MTK_ETH_MUX_U3_GMAC2_TO_QPHY_BIT)
++#define MTK_ETH_MUX_GMAC2_TO_2P5GPHY		\
++	BIT_ULL(MTK_ETH_MUX_GMAC2_TO_2P5GPHY_BIT)
+ #define MTK_ETH_MUX_GMAC1_GMAC2_TO_SGMII_RGMII	\
+ 	BIT_ULL(MTK_ETH_MUX_GMAC1_GMAC2_TO_SGMII_RGMII_BIT)
+ #define MTK_ETH_MUX_GMAC12_TO_GEPHY_SGMII	\
+ 	BIT_ULL(MTK_ETH_MUX_GMAC12_TO_GEPHY_SGMII_BIT)
++#define MTK_ETH_MUX_GMAC123_TO_GEPHY_SGMII	\
++	BIT_ULL(MTK_ETH_MUX_GMAC123_TO_GEPHY_SGMII_BIT)
++#define MTK_ETH_MUX_GMAC123_TO_USXGMII	\
++	BIT_ULL(MTK_ETH_MUX_GMAC123_TO_USXGMII_BIT)
+ 
+ /* Supported path present on SoCs */
+ #define MTK_ETH_PATH_GMAC1_RGMII	BIT_ULL(MTK_ETH_PATH_GMAC1_RGMII_BIT)
+@@ -1021,8 +1068,13 @@ enum mkt_eth_capabilities {
+ #define MTK_ETH_PATH_GMAC1_SGMII	BIT_ULL(MTK_ETH_PATH_GMAC1_SGMII_BIT)
+ #define MTK_ETH_PATH_GMAC2_RGMII	BIT_ULL(MTK_ETH_PATH_GMAC2_RGMII_BIT)
+ #define MTK_ETH_PATH_GMAC2_SGMII	BIT_ULL(MTK_ETH_PATH_GMAC2_SGMII_BIT)
++#define MTK_ETH_PATH_GMAC2_2P5GPHY	BIT_ULL(MTK_ETH_PATH_GMAC2_2P5GPHY_BIT)
+ #define MTK_ETH_PATH_GMAC2_GEPHY	BIT_ULL(MTK_ETH_PATH_GMAC2_GEPHY_BIT)
++#define MTK_ETH_PATH_GMAC3_SGMII	BIT_ULL(MTK_ETH_PATH_GMAC3_SGMII_BIT)
+ #define MTK_ETH_PATH_GDM1_ESW		BIT_ULL(MTK_ETH_PATH_GDM1_ESW_BIT)
++#define MTK_ETH_PATH_GMAC1_USXGMII	BIT_ULL(MTK_ETH_PATH_GMAC1_USXGMII_BIT)
++#define MTK_ETH_PATH_GMAC2_USXGMII	BIT_ULL(MTK_ETH_PATH_GMAC2_USXGMII_BIT)
++#define MTK_ETH_PATH_GMAC3_USXGMII	BIT_ULL(MTK_ETH_PATH_GMAC3_USXGMII_BIT)
+ 
+ #define MTK_GMAC1_RGMII		(MTK_ETH_PATH_GMAC1_RGMII | MTK_RGMII)
+ #define MTK_GMAC1_TRGMII	(MTK_ETH_PATH_GMAC1_TRGMII | MTK_TRGMII)
+@@ -1030,7 +1082,12 @@ enum mkt_eth_capabilities {
+ #define MTK_GMAC2_RGMII		(MTK_ETH_PATH_GMAC2_RGMII | MTK_RGMII)
+ #define MTK_GMAC2_SGMII		(MTK_ETH_PATH_GMAC2_SGMII | MTK_SGMII)
+ #define MTK_GMAC2_GEPHY		(MTK_ETH_PATH_GMAC2_GEPHY | MTK_GEPHY)
++#define MTK_GMAC2_2P5GPHY	(MTK_ETH_PATH_GMAC2_2P5GPHY | MTK_2P5GPHY)
++#define MTK_GMAC3_SGMII		(MTK_ETH_PATH_GMAC3_SGMII | MTK_SGMII)
+ #define MTK_GDM1_ESW		(MTK_ETH_PATH_GDM1_ESW | MTK_ESW)
++#define MTK_GMAC1_USXGMII	(MTK_ETH_PATH_GMAC1_USXGMII | MTK_USXGMII)
++#define MTK_GMAC2_USXGMII	(MTK_ETH_PATH_GMAC2_USXGMII | MTK_USXGMII)
++#define MTK_GMAC3_USXGMII	(MTK_ETH_PATH_GMAC3_USXGMII | MTK_USXGMII)
+ 
+ /* MUXes present on SoCs */
+ /* 0: GDM1 -> GMAC1, 1: GDM1 -> ESW */
+@@ -1049,10 +1106,20 @@ enum mkt_eth_capabilities {
+ 	(MTK_ETH_MUX_GMAC1_GMAC2_TO_SGMII_RGMII | MTK_MUX | \
+ 	MTK_SHARED_SGMII)
+ 
++/* 2: GMAC2 -> XGMII */
++#define MTK_MUX_GMAC2_TO_2P5GPHY      \
++	(MTK_ETH_MUX_GMAC2_TO_2P5GPHY | MTK_MUX | MTK_INFRA)
++
+ /* 0: GMACx -> GEPHY, 1: GMACx -> SGMII where x is 1 or 2 */
+ #define MTK_MUX_GMAC12_TO_GEPHY_SGMII   \
+ 	(MTK_ETH_MUX_GMAC12_TO_GEPHY_SGMII | MTK_MUX)
+ 
++#define MTK_MUX_GMAC123_TO_GEPHY_SGMII   \
++	(MTK_ETH_MUX_GMAC123_TO_GEPHY_SGMII | MTK_MUX)
++
++#define MTK_MUX_GMAC123_TO_USXGMII   \
++	(MTK_ETH_MUX_GMAC123_TO_USXGMII | MTK_MUX | MTK_INFRA)
++
+ #define MTK_HAS_CAPS(caps, _x)		(((caps) & (_x)) == (_x))
+ 
+ #define MT7621_CAPS  (MTK_GMAC1_RGMII | MTK_GMAC1_TRGMII | \
+@@ -1084,8 +1151,12 @@ enum mkt_eth_capabilities {
+ 		      MTK_MUX_GMAC12_TO_GEPHY_SGMII | MTK_QDMA | \
+ 		      MTK_RSTCTRL_PPE1 | MTK_SRAM)
+ 
+-#define MT7988_CAPS  (MTK_36BIT_DMA | MTK_GDM1_ESW | MTK_QDMA | \
+-		      MTK_RSTCTRL_PPE1 | MTK_RSTCTRL_PPE2 | MTK_SRAM)
++#define MT7988_CAPS  (MTK_36BIT_DMA | MTK_GDM1_ESW | MTK_GMAC1_SGMII | \
++		      MTK_GMAC2_2P5GPHY | MTK_GMAC2_SGMII | MTK_GMAC2_USXGMII | \
++		      MTK_GMAC3_SGMII | MTK_GMAC3_USXGMII | \
++		      MTK_MUX_GMAC123_TO_GEPHY_SGMII | \
++		      MTK_MUX_GMAC123_TO_USXGMII | MTK_MUX_GMAC2_TO_2P5GPHY | \
++		      MTK_QDMA | MTK_RSTCTRL_PPE1 | MTK_RSTCTRL_PPE2 | MTK_SRAM)
+ 
+ struct mtk_tx_dma_desc_info {
+ 	dma_addr_t	addr;
+@@ -1333,6 +1404,9 @@ struct mtk_mac {
+ 	struct device_node		*of_node;
+ 	struct phylink			*phylink;
+ 	struct phylink_config		phylink_config;
++	struct phylink_pcs		*sgmii_pcs;
++	struct phylink_pcs		*usxgmii_pcs;
++	struct phy			*pextp;
+ 	struct mtk_eth			*hw;
+ 	struct mtk_hw_stats		*hw_stats;
+ 	__be32				hwlro_ip[MTK_MAX_LRO_IP_CNT];
+@@ -1456,6 +1530,19 @@ static inline u32 mtk_get_ib2_multicast_
+ 	return MTK_FOE_IB2_MULTICAST;
+ }
+ 
++static inline bool mtk_interface_mode_is_xgmii(phy_interface_t interface)
++{
++	switch (interface) {
++	case PHY_INTERFACE_MODE_INTERNAL:
++	case PHY_INTERFACE_MODE_USXGMII:
++	case PHY_INTERFACE_MODE_10GBASER:
++	case PHY_INTERFACE_MODE_5GBASER:
++		return true;
++	default:
++		return false;
++	}
++}
++
+ /* read the hardware status register */
+ void mtk_stats_update_mac(struct mtk_mac *mac);
+ 
+@@ -1464,8 +1551,10 @@ u32 mtk_r32(struct mtk_eth *eth, unsigne
+ u32 mtk_m32(struct mtk_eth *eth, u32 mask, u32 set, unsigned int reg);
+ 
+ int mtk_gmac_sgmii_path_setup(struct mtk_eth *eth, int mac_id);
++int mtk_gmac_2p5gphy_path_setup(struct mtk_eth *eth, int mac_id);
+ int mtk_gmac_gephy_path_setup(struct mtk_eth *eth, int mac_id);
+ int mtk_gmac_rgmii_path_setup(struct mtk_eth *eth, int mac_id);
++int mtk_gmac_usxgmii_path_setup(struct mtk_eth *eth, int mac_id);
+ 
+ int mtk_eth_offload_init(struct mtk_eth *eth, u8 id);
+ int mtk_eth_setup_tc(struct net_device *dev, enum tc_setup_type type,
diff --git a/target/linux/generic/pending-6.12/738-01-net-ethernet-mtk_eth_soc-reduce-rx-ring-size-for-older.patch b/target/linux/generic/pending-6.12/738-01-net-ethernet-mtk_eth_soc-reduce-rx-ring-size-for-older.patch
new file mode 100644
index 0000000000..12bb216d93
--- /dev/null
+++ b/target/linux/generic/pending-6.12/738-01-net-ethernet-mtk_eth_soc-reduce-rx-ring-size-for-older.patch
@@ -0,0 +1,104 @@
+From: Felix Fietkau <nbd@nbd.name>
+Subject: [PATCH net-next 3/4] net: ethernet: mtk_eth_soc: reduce rx ring size for older chipsets
+Date: Tue, 15 Oct 2024 13:09:37 +0200
+
+Commit c57e55819443 ("net: ethernet: mtk_eth_soc: handle dma buffer
+size soc specific") resolved some tx timeout issues by bumping FQ and
+tx ring sizes from 512 to 2048 entries (the value used in the MediaTek
+SDK), however it also changed the rx ring size for all chipsets in the
+same way.
+
+Based on a few tests, it seems that a symmetric rx/tx ring size of 2048
+really only makes sense on MT7988, which is capable of 10G ethernet links.
+
+Older chipsets are typically deployed in systems that are more memory
+constrained and don't actually need the larger rings to handle received
+packets.
+
+In order to reduce wasted memory set the ring size based on the SoC to
+the following values:
+- 2048 on MT7988
+- 1024 on MT7986
+- 512 (previous value) on everything else, except:
+- 256 on RT5350 (the oldest supported chipset)
+
+Fixes: c57e55819443 ("net: ethernet: mtk_eth_soc: handle dma buffer size soc specific")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c | 16 ++++++++--------
+ 1 file changed, 8 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -5485,7 +5485,7 @@ static const struct mtk_soc_data mt2701_
+ 		.desc_size = sizeof(struct mtk_rx_dma),
+ 		.irq_done_mask = MTK_RX_DONE_INT,
+ 		.dma_l4_valid = RX_DMA_L4_VALID,
+-		.dma_size = MTK_DMA_SIZE(2K),
++		.dma_size = MTK_DMA_SIZE(512),
+ 		.dma_max_len = MTK_TX_DMA_BUF_LEN,
+ 		.dma_len_offset = 16,
+ 	},
+@@ -5513,7 +5513,7 @@ static const struct mtk_soc_data mt7621_
+ 		.desc_size = sizeof(struct mtk_rx_dma),
+ 		.irq_done_mask = MTK_RX_DONE_INT,
+ 		.dma_l4_valid = RX_DMA_L4_VALID,
+-		.dma_size = MTK_DMA_SIZE(2K),
++		.dma_size = MTK_DMA_SIZE(512),
+ 		.dma_max_len = MTK_TX_DMA_BUF_LEN,
+ 		.dma_len_offset = 16,
+ 	},
+@@ -5543,7 +5543,7 @@ static const struct mtk_soc_data mt7622_
+ 		.desc_size = sizeof(struct mtk_rx_dma),
+ 		.irq_done_mask = MTK_RX_DONE_INT,
+ 		.dma_l4_valid = RX_DMA_L4_VALID,
+-		.dma_size = MTK_DMA_SIZE(2K),
++		.dma_size = MTK_DMA_SIZE(512),
+ 		.dma_max_len = MTK_TX_DMA_BUF_LEN,
+ 		.dma_len_offset = 16,
+ 	},
+@@ -5572,7 +5572,7 @@ static const struct mtk_soc_data mt7623_
+ 		.desc_size = sizeof(struct mtk_rx_dma),
+ 		.irq_done_mask = MTK_RX_DONE_INT,
+ 		.dma_l4_valid = RX_DMA_L4_VALID,
+-		.dma_size = MTK_DMA_SIZE(2K),
++		.dma_size = MTK_DMA_SIZE(512),
+ 		.dma_max_len = MTK_TX_DMA_BUF_LEN,
+ 		.dma_len_offset = 16,
+ 	},
+@@ -5598,7 +5598,7 @@ static const struct mtk_soc_data mt7629_
+ 		.desc_size = sizeof(struct mtk_rx_dma),
+ 		.irq_done_mask = MTK_RX_DONE_INT,
+ 		.dma_l4_valid = RX_DMA_L4_VALID,
+-		.dma_size = MTK_DMA_SIZE(2K),
++		.dma_size = MTK_DMA_SIZE(512),
+ 		.dma_max_len = MTK_TX_DMA_BUF_LEN,
+ 		.dma_len_offset = 16,
+ 	},
+@@ -5630,7 +5630,7 @@ static const struct mtk_soc_data mt7981_
+ 		.dma_l4_valid = RX_DMA_L4_VALID_V2,
+ 		.dma_max_len = MTK_TX_DMA_BUF_LEN,
+ 		.dma_len_offset = 16,
+-		.dma_size = MTK_DMA_SIZE(2K),
++		.dma_size = MTK_DMA_SIZE(512),
+ 	},
+ };
+ 
+@@ -5660,7 +5660,7 @@ static const struct mtk_soc_data mt7986_
+ 		.dma_l4_valid = RX_DMA_L4_VALID_V2,
+ 		.dma_max_len = MTK_TX_DMA_BUF_LEN,
+ 		.dma_len_offset = 16,
+-		.dma_size = MTK_DMA_SIZE(2K),
++		.dma_size = MTK_DMA_SIZE(1K),
+ 	},
+ };
+ 
+@@ -5713,7 +5713,7 @@ static const struct mtk_soc_data rt5350_
+ 		.dma_l4_valid = RX_DMA_L4_VALID_PDMA,
+ 		.dma_max_len = MTK_TX_DMA_BUF_LEN,
+ 		.dma_len_offset = 16,
+-		.dma_size = MTK_DMA_SIZE(2K),
++		.dma_size = MTK_DMA_SIZE(256),
+ 	},
+ };
+ 
diff --git a/target/linux/generic/pending-6.12/738-02-net-ethernet-mtk_eth_soc-do-not-enable-page-pool-sta.patch b/target/linux/generic/pending-6.12/738-02-net-ethernet-mtk_eth_soc-do-not-enable-page-pool-sta.patch
new file mode 100644
index 0000000000..a8a4dafb0f
--- /dev/null
+++ b/target/linux/generic/pending-6.12/738-02-net-ethernet-mtk_eth_soc-do-not-enable-page-pool-sta.patch
@@ -0,0 +1,43 @@
+From: Danila Romanov <pervokur@gmail.com>
+Date: Wed, 22 Jan 2025 06:48:45 +0100
+Subject: [PATCH] net: ethernet: mtk_eth_soc: do not enable page pool stats by
+ default
+
+There is no reason for it to be enabled by default.
+Align mtk_eth_soc driver to mt76 driver.
+
+This option incurs additional CPU cost in allocation and recycle paths
+and additional memory cost to store the statistics.
+
+Signed-off-by: Danila Romanov <pervokur@gmail.com>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/ethernet/mediatek/Kconfig
++++ b/drivers/net/ethernet/mediatek/Kconfig
+@@ -26,7 +26,6 @@ config NET_MEDIATEK_SOC
+ 	select PHYLINK
+ 	select DIMLIB
+ 	select PAGE_POOL
+-	select PAGE_POOL_STATS
+ 	select PCS_MTK_LYNXI
+ 	select REGMAP_MMIO
+ 	help
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -4591,6 +4591,7 @@ static int mtk_get_sset_count(struct net
+ 
+ static void mtk_ethtool_pp_stats(struct mtk_eth *eth, u64 *data)
+ {
++#ifdef CONFIG_PAGE_POOL_STATS
+ 	struct page_pool_stats stats = {};
+ 	int i;
+ 
+@@ -4603,6 +4604,7 @@ static void mtk_ethtool_pp_stats(struct
+ 		page_pool_get_stats(ring->page_pool, &stats);
+ 	}
+ 	page_pool_ethtool_stats_get(data, &stats);
++#endif
+ }
+ 
+ static void mtk_get_ethtool_stats(struct net_device *dev,
diff --git a/target/linux/generic/pending-6.12/739-01-dt-bindings-phy-mediatek-xfi-tphy-add-new-bindings.patch b/target/linux/generic/pending-6.12/739-01-dt-bindings-phy-mediatek-xfi-tphy-add-new-bindings.patch
new file mode 100644
index 0000000000..1f1c40b1d9
--- /dev/null
+++ b/target/linux/generic/pending-6.12/739-01-dt-bindings-phy-mediatek-xfi-tphy-add-new-bindings.patch
@@ -0,0 +1,136 @@
+From patchwork Thu Feb  1 21:52:20 2024
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 13541842
+Date: Thu, 1 Feb 2024 21:52:20 +0000
+From: Daniel Golle <daniel@makrotopia.org>
+To: Bc-bocun Chen <bc-bocun.chen@mediatek.com>,
+	Steven Liu <steven.liu@mediatek.com>,
+	John Crispin <john@phrozen.org>,
+	Chunfeng Yun <chunfeng.yun@mediatek.com>,
+	Vinod Koul <vkoul@kernel.org>,
+	Kishon Vijay Abraham I <kishon@kernel.org>,
+	Rob Herring <robh@kernel.org>,
+	Krzysztof Kozlowski <krzysztof.kozlowski+dt@linaro.org>,
+	Conor Dooley <conor+dt@kernel.org>,
+	Daniel Golle <daniel@makrotopia.org>,
+	Qingfang Deng <dqfext@gmail.com>,
+	SkyLake Huang <SkyLake.Huang@mediatek.com>,
+	Matthias Brugger <matthias.bgg@gmail.com>,
+	AngeloGioacchino Del Regno <angelogioacchino.delregno@collabora.com>,
+	Philipp Zabel <p.zabel@pengutronix.de>,
+	linux-arm-kernel@lists.infradead.org,
+	linux-mediatek@lists.infradead.org, linux-phy@lists.infradead.org,
+	devicetree@vger.kernel.org, linux-kernel@vger.kernel.org,
+	netdev@vger.kernel.org
+Subject: [PATCH 1/2] dt-bindings: phy: mediatek,xfi-tphy: add new bindings
+Message-ID: 
+ <702afb0c1246d95c90b22e57105304028bdd3083.1706823233.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+List-Id: Linux Phy Mailing list <linux-phy.lists.infradead.org>
+
+Add bindings for the MediaTek XFI T-PHY Ethernet SerDes PHY found in the
+MediaTek MT7988 SoC which can operate at various interfaces modes:
+
+via USXGMII PCS:
+ * USXGMII
+ * 10GBase-R
+ * 5GBase-R
+
+via LynxI SGMII PCS:
+ * 2500Base-X
+ * 1000Base-X
+ * Cisco SGMII (MAC side)
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ .../bindings/phy/mediatek,xfi-tphy.yaml       | 80 +++++++++++++++++++
+ 1 file changed, 80 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/phy/mediatek,xfi-tphy.yaml
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/phy/mediatek,xfi-tphy.yaml
+@@ -0,0 +1,80 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/phy/mediatek,xfi-tphy.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: MediaTek XFI T-PHY
++
++maintainers:
++  - Daniel Golle <daniel@makrotopia.org>
++
++description:
++  The MediaTek XFI SerDes T-PHY provides the physical SerDes lanes
++  used by the (10G/5G) USXGMII PCS and (1G/2.5G) LynxI PCS found in
++  MediaTek's 10G-capabale SoCs.
++
++properties:
++  $nodename:
++    pattern: "^phy@[0-9a-f]+$"
++
++  compatible:
++    const: mediatek,mt7988-xfi-tphy
++
++  reg:
++    maxItems: 1
++
++  clocks:
++    items:
++      - description: XFI PHY clock
++      - description: XFI register clock
++
++  clock-names:
++    items:
++      - const: xfipll
++      - const: topxtal
++
++  resets:
++    items:
++      - description: PEXTP reset
++
++  mediatek,usxgmii-performance-errata:
++    $ref: /schemas/types.yaml#/definitions/flag
++    description:
++      One instance of the T-PHY on MT7988 suffers from a performance
++      problem in 10GBase-R mode which needs a work-around in the driver.
++      The work-around is enabled using this flag.
++
++  "#phy-cells":
++    const: 0
++
++required:
++  - compatible
++  - reg
++  - clocks
++  - clock-names
++  - resets
++  - "#phy-cells"
++
++additionalProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/clock/mediatek,mt7988-clk.h>
++    soc {
++      #address-cells = <2>;
++      #size-cells = <2>;
++
++      phy@11f20000 {
++        compatible = "mediatek,mt7988-xfi-tphy";
++        reg = <0 0x11f20000 0 0x10000>;
++        clocks = <&xfi_pll CLK_XFIPLL_PLL_EN>,
++                 <&topckgen CLK_TOP_XFI_PHY_0_XTAL_SEL>;
++        clock-names = "xfipll", "topxtal";
++        resets = <&watchdog 14>;
++        mediatek,usxgmii-performance-errata;
++        #phy-cells = <0>;
++      };
++    };
++
++...
diff --git a/target/linux/generic/pending-6.12/739-03-net-pcs-pcs-mtk-lynxi-add-platform-driver-for-MT7988.patch b/target/linux/generic/pending-6.12/739-03-net-pcs-pcs-mtk-lynxi-add-platform-driver-for-MT7988.patch
new file mode 100644
index 0000000000..8eb9d35b58
--- /dev/null
+++ b/target/linux/generic/pending-6.12/739-03-net-pcs-pcs-mtk-lynxi-add-platform-driver-for-MT7988.patch
@@ -0,0 +1,369 @@
+From 4b1a2716299c0e96a698044aebf3f80513509ae7 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Tue, 12 Dec 2023 03:47:18 +0000
+Subject: [PATCH 3/5] net: pcs: pcs-mtk-lynxi: add platform driver for MT7988
+
+Introduce a proper platform MFD driver for the LynxI (H)SGMII PCS which
+is going to initially be used for the MT7988 SoC.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/pcs/pcs-mtk-lynxi.c   | 227 ++++++++++++++++++++++++++++--
+ include/linux/pcs/pcs-mtk-lynxi.h |  11 ++
+ 2 files changed, 227 insertions(+), 11 deletions(-)
+
+--- a/drivers/net/pcs/pcs-mtk-lynxi.c
++++ b/drivers/net/pcs/pcs-mtk-lynxi.c
+@@ -1,6 +1,6 @@
+ // SPDX-License-Identifier: GPL-2.0
+ // Copyright (c) 2018-2019 MediaTek Inc.
+-/* A library for MediaTek SGMII circuit
++/* A library and platform driver for the MediaTek LynxI SGMII circuit
+  *
+  * Author: Sean Wang <sean.wang@mediatek.com>
+  * Author: Alexander Couzens <lynxis@fe80.eu>
+@@ -8,11 +8,17 @@
+  *
+  */
+ 
++#include <linux/clk.h>
+ #include <linux/mdio.h>
++#include <linux/mfd/syscon.h>
++#include <linux/mutex.h>
+ #include <linux/of.h>
++#include <linux/of_platform.h>
+ #include <linux/pcs/pcs-mtk-lynxi.h>
+ #include <linux/phylink.h>
++#include <linux/platform_device.h>
+ #include <linux/regmap.h>
++#include <linux/reset.h>
+ 
+ /* SGMII subsystem config registers */
+ /* BMCR (low 16) BMSR (high 16) */
+@@ -65,6 +71,8 @@
+ #define SGMII_PN_SWAP_MASK		GENMASK(1, 0)
+ #define SGMII_PN_SWAP_TX_RX		(BIT(0) | BIT(1))
+ 
++#define MTK_NETSYS_V3_AMA_RGC3		0x128
++
+ /* struct mtk_pcs_lynxi -  This structure holds each sgmii regmap andassociated
+  *                         data
+  * @regmap:                The register map pointing at the range used to setup
+@@ -74,15 +82,29 @@
+  * @interface:             Currently configured interface mode
+  * @pcs:                   Phylink PCS structure
+  * @flags:                 Flags indicating hardware properties
++ * @rstc:                  Reset controller
++ * @sgmii_sel:             SGMII Register Clock
++ * @sgmii_rx:              SGMII RX Clock
++ * @sgmii_tx:              SGMII TX Clock
++ * @node:                  List node
+  */
+ struct mtk_pcs_lynxi {
+ 	struct regmap		*regmap;
++	struct device		*dev;
+ 	u32			ana_rgc3;
+ 	phy_interface_t		interface;
+ 	struct			phylink_pcs pcs;
+ 	u32			flags;
++	struct reset_control	*rstc;
++	struct clk		*sgmii_sel;
++	struct clk		*sgmii_rx;
++	struct clk		*sgmii_tx;
++	struct list_head	node;
+ };
+ 
++static LIST_HEAD(mtk_pcs_lynxi_instances);
++static DEFINE_MUTEX(instance_mutex);
++
+ static struct mtk_pcs_lynxi *pcs_to_mtk_pcs_lynxi(struct phylink_pcs *pcs)
+ {
+ 	return container_of(pcs, struct mtk_pcs_lynxi, pcs);
+@@ -102,6 +124,17 @@ static void mtk_pcs_lynxi_get_state(stru
+ 					 FIELD_GET(SGMII_LPA, adv));
+ }
+ 
++static void mtk_sgmii_reset(struct mtk_pcs_lynxi *mpcs)
++{
++	if (!mpcs->rstc)
++		return;
++
++	reset_control_assert(mpcs->rstc);
++	udelay(100);
++	reset_control_deassert(mpcs->rstc);
++	mdelay(1);
++}
++
+ static int mtk_pcs_lynxi_config(struct phylink_pcs *pcs, unsigned int neg_mode,
+ 				phy_interface_t interface,
+ 				const unsigned long *advertising,
+@@ -147,6 +180,7 @@ static int mtk_pcs_lynxi_config(struct p
+ 				SGMII_PHYA_PWD);
+ 
+ 		/* Reset SGMII PCS state */
++		mtk_sgmii_reset(mpcs);
+ 		regmap_set_bits(mpcs->regmap, SGMSYS_RESERVED_0,
+ 				SGMII_SW_RESET);
+ 
+@@ -233,10 +267,29 @@ static void mtk_pcs_lynxi_link_up(struct
+ 	}
+ }
+ 
++static int mtk_pcs_lynxi_enable(struct phylink_pcs *pcs)
++{
++	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
++
++	if (mpcs->sgmii_tx && mpcs->sgmii_rx) {
++		clk_prepare_enable(mpcs->sgmii_rx);
++		clk_prepare_enable(mpcs->sgmii_tx);
++	}
++
++	return 0;
++}
++
+ static void mtk_pcs_lynxi_disable(struct phylink_pcs *pcs)
+ {
+ 	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
+ 
++	regmap_set_bits(mpcs->regmap, SGMSYS_QPHY_PWR_STATE_CTRL, SGMII_PHYA_PWD);
++
++	if (mpcs->sgmii_tx && mpcs->sgmii_rx) {
++		clk_disable_unprepare(mpcs->sgmii_tx);
++		clk_disable_unprepare(mpcs->sgmii_rx);
++	}
++
+ 	mpcs->interface = PHY_INTERFACE_MODE_NA;
+ }
+ 
+@@ -246,11 +299,12 @@ static const struct phylink_pcs_ops mtk_
+ 	.pcs_an_restart = mtk_pcs_lynxi_restart_an,
+ 	.pcs_link_up = mtk_pcs_lynxi_link_up,
+ 	.pcs_disable = mtk_pcs_lynxi_disable,
++	.pcs_enable = mtk_pcs_lynxi_enable,
+ };
+ 
+-struct phylink_pcs *mtk_pcs_lynxi_create(struct device *dev,
+-					 struct regmap *regmap, u32 ana_rgc3,
+-					 u32 flags)
++static struct phylink_pcs *mtk_pcs_lynxi_init(struct device *dev, struct regmap *regmap,
++					      u32 ana_rgc3, u32 flags,
++					      struct mtk_pcs_lynxi *prealloc)
+ {
+ 	struct mtk_pcs_lynxi *mpcs;
+ 	u32 id, ver;
+@@ -258,29 +312,33 @@ struct phylink_pcs *mtk_pcs_lynxi_create
+ 
+ 	ret = regmap_read(regmap, SGMSYS_PCS_DEVICE_ID, &id);
+ 	if (ret < 0)
+-		return NULL;
++		return ERR_PTR(ret);
+ 
+ 	if (id != SGMII_LYNXI_DEV_ID) {
+ 		dev_err(dev, "unknown PCS device id %08x\n", id);
+-		return NULL;
++		return ERR_PTR(-ENODEV);
+ 	}
+ 
+ 	ret = regmap_read(regmap, SGMSYS_PCS_SCRATCH, &ver);
+ 	if (ret < 0)
+-		return NULL;
++		return ERR_PTR(ret);
+ 
+ 	ver = FIELD_GET(SGMII_DEV_VERSION, ver);
+ 	if (ver != 0x1) {
+ 		dev_err(dev, "unknown PCS device version %04x\n", ver);
+-		return NULL;
++		return ERR_PTR(-ENODEV);
+ 	}
+ 
+ 	dev_dbg(dev, "MediaTek LynxI SGMII PCS (id 0x%08x, ver 0x%04x)\n", id,
+ 		ver);
+ 
+-	mpcs = kzalloc(sizeof(*mpcs), GFP_KERNEL);
+-	if (!mpcs)
+-		return NULL;
++	if (prealloc) {
++		mpcs = prealloc;
++	} else {
++		mpcs = kzalloc(sizeof(*mpcs), GFP_KERNEL);
++		if (!mpcs)
++			return ERR_PTR(-ENOMEM);
++	};
+ 
+ 	mpcs->ana_rgc3 = ana_rgc3;
+ 	mpcs->regmap = regmap;
+@@ -291,6 +349,13 @@ struct phylink_pcs *mtk_pcs_lynxi_create
+ 	mpcs->interface = PHY_INTERFACE_MODE_NA;
+ 
+ 	return &mpcs->pcs;
++};
++
++struct phylink_pcs *mtk_pcs_lynxi_create(struct device *dev,
++					 struct regmap *regmap, u32 ana_rgc3,
++					 u32 flags)
++{
++	return mtk_pcs_lynxi_init(dev, regmap, ana_rgc3, flags, NULL);
+ }
+ EXPORT_SYMBOL(mtk_pcs_lynxi_create);
+ 
+@@ -303,5 +368,142 @@ void mtk_pcs_lynxi_destroy(struct phylin
+ }
+ EXPORT_SYMBOL(mtk_pcs_lynxi_destroy);
+ 
++static int mtk_pcs_lynxi_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = dev->of_node;
++	struct mtk_pcs_lynxi *mpcs;
++	struct phylink_pcs *pcs;
++	struct regmap *regmap;
++	u32 flags = 0;
++
++	mpcs = devm_kzalloc(dev, sizeof(*mpcs), GFP_KERNEL);
++	if (!mpcs)
++		return -ENOMEM;
++
++	mpcs->dev = dev;
++	regmap = syscon_node_to_regmap(np->parent);
++	if (IS_ERR(regmap))
++		return PTR_ERR(regmap);
++
++	if (of_property_read_bool(np->parent, "mediatek,pnswap"))
++		flags |= MTK_SGMII_FLAG_PN_SWAP;
++
++	mpcs->rstc = of_reset_control_get_shared(np->parent, NULL);
++	if (IS_ERR(mpcs->rstc))
++		return PTR_ERR(mpcs->rstc);
++
++	reset_control_deassert(mpcs->rstc);
++	mpcs->sgmii_sel = devm_clk_get_enabled(dev, "sgmii_sel");
++	if (IS_ERR(mpcs->sgmii_sel))
++		return PTR_ERR(mpcs->sgmii_sel);
++
++	mpcs->sgmii_rx = devm_clk_get(dev, "sgmii_rx");
++	if (IS_ERR(mpcs->sgmii_rx))
++		return PTR_ERR(mpcs->sgmii_rx);
++
++	mpcs->sgmii_tx = devm_clk_get(dev, "sgmii_tx");
++	if (IS_ERR(mpcs->sgmii_tx))
++		return PTR_ERR(mpcs->sgmii_tx);
++
++	pcs = mtk_pcs_lynxi_init(dev, regmap, (uintptr_t)of_device_get_match_data(dev),
++				 flags, mpcs);
++	if (IS_ERR(pcs))
++		return PTR_ERR(pcs);
++
++	regmap_set_bits(mpcs->regmap, SGMSYS_QPHY_PWR_STATE_CTRL, SGMII_PHYA_PWD);
++
++	platform_set_drvdata(pdev, mpcs);
++
++	mutex_lock(&instance_mutex);
++	list_add_tail(&mpcs->node, &mtk_pcs_lynxi_instances);
++	mutex_unlock(&instance_mutex);
++
++	return 0;
++}
++
++static void mtk_pcs_lynxi_remove(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct mtk_pcs_lynxi *cur, *tmp;
++
++	mutex_lock(&instance_mutex);
++	list_for_each_entry_safe(cur, tmp, &mtk_pcs_lynxi_instances, node)
++		if (cur->dev == dev) {
++			list_del(&cur->node);
++			kfree(cur);
++			break;
++		}
++	mutex_unlock(&instance_mutex);
++}
++
++static const struct of_device_id mtk_pcs_lynxi_of_match[] = {
++	{ .compatible = "mediatek,mt7988-sgmii", .data = (void *)MTK_NETSYS_V3_AMA_RGC3 },
++	{ /* sentinel */ },
++};
++MODULE_DEVICE_TABLE(of, mtk_pcs_lynxi_of_match);
++
++struct phylink_pcs *mtk_pcs_lynxi_get(struct device *dev, struct device_node *np)
++{
++	struct platform_device *pdev;
++	struct mtk_pcs_lynxi *mpcs;
++
++	if (!np)
++		return NULL;
++
++	if (!of_device_is_available(np))
++		return ERR_PTR(-ENODEV);
++
++	if (!of_match_node(mtk_pcs_lynxi_of_match, np))
++		return ERR_PTR(-EINVAL);
++
++	pdev = of_find_device_by_node(np);
++	if (!pdev || !platform_get_drvdata(pdev)) {
++		if (pdev)
++			put_device(&pdev->dev);
++		return ERR_PTR(-EPROBE_DEFER);
++	}
++
++	mpcs = platform_get_drvdata(pdev);
++	device_link_add(dev, mpcs->dev, DL_FLAG_AUTOREMOVE_CONSUMER);
++
++	return &mpcs->pcs;
++}
++EXPORT_SYMBOL(mtk_pcs_lynxi_get);
++
++void mtk_pcs_lynxi_put(struct phylink_pcs *pcs)
++{
++	struct mtk_pcs_lynxi *cur, *mpcs = NULL;
++
++	if (!pcs)
++		return;
++
++	mutex_lock(&instance_mutex);
++	list_for_each_entry(cur, &mtk_pcs_lynxi_instances, node)
++		if (pcs == &cur->pcs) {
++			mpcs = cur;
++			break;
++		}
++	mutex_unlock(&instance_mutex);
++
++	if (WARN_ON(!mpcs))
++		return;
++
++	put_device(mpcs->dev);
++}
++EXPORT_SYMBOL(mtk_pcs_lynxi_put);
++
++static struct platform_driver mtk_pcs_lynxi_driver = {
++	.driver = {
++		.name			= "mtk-pcs-lynxi",
++		.suppress_bind_attrs	= true,
++		.of_match_table		= mtk_pcs_lynxi_of_match,
++	},
++	.probe = mtk_pcs_lynxi_probe,
++	.remove_new = mtk_pcs_lynxi_remove,
++};
++module_platform_driver(mtk_pcs_lynxi_driver);
++
++MODULE_AUTHOR("Daniel Golle <daniel@makrotopia.org>");
+ MODULE_DESCRIPTION("MediaTek SGMII library for LynxI");
+ MODULE_LICENSE("GPL");
+--- a/include/linux/pcs/pcs-mtk-lynxi.h
++++ b/include/linux/pcs/pcs-mtk-lynxi.h
+@@ -10,4 +10,15 @@ struct phylink_pcs *mtk_pcs_lynxi_create
+ 					 struct regmap *regmap,
+ 					 u32 ana_rgc3, u32 flags);
+ void mtk_pcs_lynxi_destroy(struct phylink_pcs *pcs);
++
++#if IS_ENABLED(CONFIG_PCS_MTK_LYNXI)
++struct phylink_pcs *mtk_pcs_lynxi_get(struct device *dev, struct device_node *np);
++void mtk_pcs_lynxi_put(struct phylink_pcs *pcs);
++#else
++static inline struct phylink_pcs *mtk_pcs_lynxi_get(struct device *dev, struct device_node *np)
++{
++	return NULL;
++}
++static inline void mtk_pcs_lynxi_put(struct phylink_pcs *pcs) { }
++#endif /* IS_ENABLED(CONFIG_PCS_MTK_LYNXI) */
+ #endif
diff --git a/target/linux/generic/pending-6.12/739-04-dt-bindings-net-pcs-add-bindings-for-MediaTek-USXGMI.patch b/target/linux/generic/pending-6.12/739-04-dt-bindings-net-pcs-add-bindings-for-MediaTek-USXGMI.patch
new file mode 100644
index 0000000000..215bd2ca2e
--- /dev/null
+++ b/target/linux/generic/pending-6.12/739-04-dt-bindings-net-pcs-add-bindings-for-MediaTek-USXGMI.patch
@@ -0,0 +1,81 @@
+From 7d88d79c0f65b27a92754d7547f7af098b3de67b Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Tue, 12 Dec 2023 03:47:31 +0000
+Subject: [PATCH 4/5] dt-bindings: net: pcs: add bindings for MediaTek USXGMII
+ PCS
+
+MediaTek's USXGMII can be found in the MT7988 SoC. We need to access
+it in order to configure and monitor the Ethernet SerDes link in
+USXGMII, 10GBase-R and 5GBase-R mode. By including a wrapped
+legacy 1000Base-X/2500Base-X/Cisco SGMII LynxI PCS as well, those
+interface modes are also available.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ .../bindings/net/pcs/mediatek,usxgmii.yaml    | 60 +++++++++++++++++++
+ 1 file changed, 60 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/net/pcs/mediatek,usxgmii.yaml
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/net/pcs/mediatek,usxgmii.yaml
+@@ -0,0 +1,60 @@
++# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/net/pcs/mediatek,usxgmii.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: MediaTek USXGMII PCS
++
++maintainers:
++  - Daniel Golle <daniel@makrotopia.org>
++
++description:
++  The MediaTek USXGMII PCS provides physical link control and status
++  for USXGMII, 10GBase-R and 5GBase-R links on the SerDes interfaces
++  provided by the PEXTP PHY.
++  In order to also support legacy 2500Base-X, 1000Base-X and Cisco
++  SGMII an existing mediatek,*-sgmiisys LynxI PCS is wrapped to
++  provide those interfaces modes on the same SerDes interfaces shared
++  with the USXGMII PCS.
++
++properties:
++  $nodename:
++    pattern: "^pcs@[0-9a-f]+$"
++
++  compatible:
++    const: mediatek,mt7988-usxgmiisys
++
++  reg:
++    maxItems: 1
++
++  clocks:
++    items:
++      - description: USXGMII top-level clock
++
++  resets:
++    items:
++      - description: XFI reset
++
++required:
++  - compatible
++  - reg
++  - clocks
++  - resets
++
++additionalProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/clock/mediatek,mt7988-clk.h>
++    #define MT7988_TOPRGU_XFI0_GRST 12
++    soc {
++      #address-cells = <2>;
++      #size-cells = <2>;
++        usxgmiisys0: pcs@10080000 {
++          compatible = "mediatek,mt7988-usxgmiisys";
++          reg = <0 0x10080000 0 0x1000>;
++          clocks = <&topckgen CLK_TOP_USXGMII_SBUS_0_SEL>;
++          resets = <&watchdog MT7988_TOPRGU_XFI0_GRST>;
++        };
++    };
diff --git a/target/linux/generic/pending-6.12/739-05-net-pcs-add-driver-for-MediaTek-USXGMII-PCS.patch b/target/linux/generic/pending-6.12/739-05-net-pcs-add-driver-for-MediaTek-USXGMII-PCS.patch
new file mode 100644
index 0000000000..381b3a98cd
--- /dev/null
+++ b/target/linux/generic/pending-6.12/739-05-net-pcs-add-driver-for-MediaTek-USXGMII-PCS.patch
@@ -0,0 +1,545 @@
+From dde0e95fff92e9f5009f3bea75278e0e34a48822 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Tue, 12 Dec 2023 03:47:47 +0000
+Subject: [PATCH 5/5] net: pcs: add driver for MediaTek USXGMII PCS
+
+Add driver for USXGMII PCS found in the MediaTek MT7988 SoC and supporting
+USXGMII, 10GBase-R and 5GBase-R interface modes.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ MAINTAINERS                         |   2 +
+ drivers/net/pcs/Kconfig             |  11 +
+ drivers/net/pcs/Makefile            |   1 +
+ drivers/net/pcs/pcs-mtk-usxgmii.c   | 456 ++++++++++++++++++++++++++++
+ include/linux/pcs/pcs-mtk-usxgmii.h |  27 ++
+ 5 files changed, 497 insertions(+)
+ create mode 100644 drivers/net/pcs/pcs-mtk-usxgmii.c
+ create mode 100644 include/linux/pcs/pcs-mtk-usxgmii.h
+
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -14419,7 +14419,9 @@ M:	Daniel Golle <daniel@makrotopia.org>
+ L:	netdev@vger.kernel.org
+ S:	Maintained
+ F:	drivers/net/pcs/pcs-mtk-lynxi.c
++F:	drivers/net/pcs/pcs-mtk-usxgmii.c
+ F:	include/linux/pcs/pcs-mtk-lynxi.h
++F:	include/linux/pcs/pcs-mtk-usxgmii.h
+ 
+ MEDIATEK ETHERNET PHY DRIVERS
+ M:	Daniel Golle <daniel@makrotopia.org>
+--- a/drivers/net/pcs/Kconfig
++++ b/drivers/net/pcs/Kconfig
+@@ -25,6 +25,17 @@ config PCS_MTK_LYNXI
+ 	  This module provides helpers to phylink for managing the LynxI PCS
+ 	  which is part of MediaTek's SoC and Ethernet switch ICs.
+ 
++config PCS_MTK_USXGMII
++	tristate "MediaTek USXGMII PCS"
++	select PCS_MTK_LYNXI
++	select PHY_MTK_PEXTP
++	select PHYLINK
++	help
++	  This module provides a driver for MediaTek's USXGMII PCS supporting
++	  10GBase-R, 5GBase-R and USXGMII interface modes.
++	  1000Base-X, 2500Base-X and Cisco SGMII are supported on the same
++	  differential pairs via an embedded LynxI PHY.
++
+ config PCS_RZN1_MIIC
+ 	tristate "Renesas RZ/N1 MII converter"
+ 	depends on OF && (ARCH_RZN1 || COMPILE_TEST)
+--- a/drivers/net/pcs/Makefile
++++ b/drivers/net/pcs/Makefile
+@@ -8,3 +8,4 @@ obj-$(CONFIG_PCS_XPCS)		+= pcs_xpcs.o
+ obj-$(CONFIG_PCS_LYNX)		+= pcs-lynx.o
+ obj-$(CONFIG_PCS_MTK_LYNXI)	+= pcs-mtk-lynxi.o
+ obj-$(CONFIG_PCS_RZN1_MIIC)	+= pcs-rzn1-miic.o
++obj-$(CONFIG_PCS_MTK_USXGMII)	+= pcs-mtk-usxgmii.o
+--- /dev/null
++++ b/drivers/net/pcs/pcs-mtk-usxgmii.c
+@@ -0,0 +1,454 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2023 MediaTek Inc.
++ * Author: Henry Yen <henry.yen@mediatek.com>
++ *         Daniel Golle <daniel@makrotopia.org>
++ */
++
++#include <linux/clk.h>
++#include <linux/io.h>
++#include <linux/mfd/syscon.h>
++#include <linux/mdio.h>
++#include <linux/mutex.h>
++#include <linux/of.h>
++#include <linux/of_platform.h>
++#include <linux/reset.h>
++#include <linux/pcs/pcs-mtk-usxgmii.h>
++#include <linux/platform_device.h>
++
++/* USXGMII subsystem config registers */
++/* Register to control speed */
++#define RG_PHY_TOP_SPEED_CTRL1			0x80c
++#define USXGMII_RATE_UPDATE_MODE		BIT(31)
++#define USXGMII_MAC_CK_GATED			BIT(29)
++#define USXGMII_IF_FORCE_EN			BIT(28)
++#define USXGMII_RATE_ADAPT_MODE			GENMASK(10, 8)
++#define USXGMII_RATE_ADAPT_MODE_X1		0
++#define USXGMII_RATE_ADAPT_MODE_X2		1
++#define USXGMII_RATE_ADAPT_MODE_X4		2
++#define USXGMII_RATE_ADAPT_MODE_X10		3
++#define USXGMII_RATE_ADAPT_MODE_X100		4
++#define USXGMII_RATE_ADAPT_MODE_X5		5
++#define USXGMII_RATE_ADAPT_MODE_X50		6
++#define USXGMII_XFI_RX_MODE			GENMASK(6, 4)
++#define USXGMII_XFI_TX_MODE			GENMASK(2, 0)
++#define USXGMII_XFI_MODE_10G			0
++#define USXGMII_XFI_MODE_5G			1
++#define USXGMII_XFI_MODE_2P5G			3
++
++/* Register to control PCS AN */
++#define RG_PCS_AN_CTRL0				0x810
++#define USXGMII_AN_RESTART			BIT(31)
++#define USXGMII_AN_SYNC_CNT			GENMASK(30, 11)
++#define USXGMII_AN_ENABLE			BIT(0)
++
++#define RG_PCS_AN_CTRL2				0x818
++#define USXGMII_LINK_TIMER_IDLE_DETECT		GENMASK(29, 20)
++#define USXGMII_LINK_TIMER_COMP_ACK_DETECT	GENMASK(19, 10)
++#define USXGMII_LINK_TIMER_AN_RESTART		GENMASK(9, 0)
++
++/* Register to read PCS AN status */
++#define RG_PCS_AN_STS0				0x81c
++#define USXGMII_LPA				GENMASK(15, 0)
++#define USXGMII_LPA_LATCH			BIT(31)
++
++/* Register to read PCS link status */
++#define RG_PCS_RX_STATUS0			0x904
++#define RG_PCS_RX_STATUS_UPDATE			BIT(16)
++#define RG_PCS_RX_LINK_STATUS			BIT(2)
++
++/* struct mtk_usxgmii_pcs - This structure holds each usxgmii PCS
++ * @pcs:		Phylink PCS structure
++ * @dev:		Pointer to device structure
++ * @base:		IO memory to access PCS hardware
++ * @clk:		Pointer to USXGMII clk
++ * @reset:		Pointer to USXGMII reset control
++ * @interface:		Currently selected interface mode
++ * @neg_mode:		Currently used phylink neg_mode
++ * @node:		List node
++ */
++struct mtk_usxgmii_pcs {
++	struct phylink_pcs		pcs;
++	struct device			*dev;
++	void __iomem			*base;
++	struct clk			*clk;
++	struct reset_control		*reset;
++	phy_interface_t			interface;
++	unsigned int			neg_mode;
++	struct list_head		node;
++};
++
++static LIST_HEAD(mtk_usxgmii_pcs_instances);
++static DEFINE_MUTEX(instance_mutex);
++
++static u32 mtk_r32(struct mtk_usxgmii_pcs *mpcs, unsigned int reg)
++{
++	return ioread32(mpcs->base + reg);
++}
++
++static void mtk_m32(struct mtk_usxgmii_pcs *mpcs, unsigned int reg, u32 mask, u32 set)
++{
++	u32 val;
++
++	val = ioread32(mpcs->base + reg);
++	val &= ~mask;
++	val |= set;
++	iowrite32(val, mpcs->base + reg);
++}
++
++static struct mtk_usxgmii_pcs *pcs_to_mtk_usxgmii_pcs(struct phylink_pcs *pcs)
++{
++	return container_of(pcs, struct mtk_usxgmii_pcs, pcs);
++}
++
++static void mtk_usxgmii_reset(struct mtk_usxgmii_pcs *mpcs)
++{
++	reset_control_assert(mpcs->reset);
++	udelay(100);
++	reset_control_deassert(mpcs->reset);
++
++	mdelay(10);
++}
++
++static int mtk_usxgmii_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,
++				  phy_interface_t interface,
++				  const unsigned long *advertising,
++				  bool permit_pause_to_mac)
++{
++	struct mtk_usxgmii_pcs *mpcs = pcs_to_mtk_usxgmii_pcs(pcs);
++	unsigned int an_ctrl = 0, link_timer = 0, xfi_mode = 0, adapt_mode = 0;
++	bool mode_changed = false;
++
++	if (interface == PHY_INTERFACE_MODE_USXGMII) {
++		an_ctrl = FIELD_PREP(USXGMII_AN_SYNC_CNT, 0x1FF) | USXGMII_AN_ENABLE;
++		link_timer = FIELD_PREP(USXGMII_LINK_TIMER_IDLE_DETECT, 0x7B) |
++			     FIELD_PREP(USXGMII_LINK_TIMER_COMP_ACK_DETECT, 0x7B) |
++			     FIELD_PREP(USXGMII_LINK_TIMER_AN_RESTART, 0x7B);
++		xfi_mode = FIELD_PREP(USXGMII_XFI_RX_MODE, USXGMII_XFI_MODE_10G) |
++			   FIELD_PREP(USXGMII_XFI_TX_MODE, USXGMII_XFI_MODE_10G);
++	} else if (interface == PHY_INTERFACE_MODE_10GBASER) {
++		an_ctrl = FIELD_PREP(USXGMII_AN_SYNC_CNT, 0x1FF);
++		link_timer = FIELD_PREP(USXGMII_LINK_TIMER_IDLE_DETECT, 0x7B) |
++			     FIELD_PREP(USXGMII_LINK_TIMER_COMP_ACK_DETECT, 0x7B) |
++			     FIELD_PREP(USXGMII_LINK_TIMER_AN_RESTART, 0x7B);
++		xfi_mode = FIELD_PREP(USXGMII_XFI_RX_MODE, USXGMII_XFI_MODE_10G) |
++			   FIELD_PREP(USXGMII_XFI_TX_MODE, USXGMII_XFI_MODE_10G);
++		adapt_mode = USXGMII_RATE_UPDATE_MODE;
++	} else if (interface == PHY_INTERFACE_MODE_5GBASER) {
++		an_ctrl = FIELD_PREP(USXGMII_AN_SYNC_CNT, 0xFF);
++		link_timer = FIELD_PREP(USXGMII_LINK_TIMER_IDLE_DETECT, 0x3D) |
++			     FIELD_PREP(USXGMII_LINK_TIMER_COMP_ACK_DETECT, 0x3D) |
++			     FIELD_PREP(USXGMII_LINK_TIMER_AN_RESTART, 0x3D);
++		xfi_mode = FIELD_PREP(USXGMII_XFI_RX_MODE, USXGMII_XFI_MODE_5G) |
++			   FIELD_PREP(USXGMII_XFI_TX_MODE, USXGMII_XFI_MODE_5G);
++		adapt_mode = USXGMII_RATE_UPDATE_MODE;
++	} else {
++		return -EINVAL;
++	}
++
++	adapt_mode |= FIELD_PREP(USXGMII_RATE_ADAPT_MODE, USXGMII_RATE_ADAPT_MODE_X1);
++
++	if (mpcs->interface != interface) {
++		mpcs->interface = interface;
++		mode_changed = true;
++	}
++
++	mtk_usxgmii_reset(mpcs);
++
++	/* Setup USXGMII AN ctrl */
++	mtk_m32(mpcs, RG_PCS_AN_CTRL0,
++		USXGMII_AN_SYNC_CNT | USXGMII_AN_ENABLE,
++		an_ctrl);
++
++	mtk_m32(mpcs, RG_PCS_AN_CTRL2,
++		USXGMII_LINK_TIMER_IDLE_DETECT |
++		USXGMII_LINK_TIMER_COMP_ACK_DETECT |
++		USXGMII_LINK_TIMER_AN_RESTART,
++		link_timer);
++
++	mpcs->neg_mode = neg_mode;
++
++	/* Gated MAC CK */
++	mtk_m32(mpcs, RG_PHY_TOP_SPEED_CTRL1,
++		USXGMII_MAC_CK_GATED, USXGMII_MAC_CK_GATED);
++
++	/* Enable interface force mode */
++	mtk_m32(mpcs, RG_PHY_TOP_SPEED_CTRL1,
++		USXGMII_IF_FORCE_EN, USXGMII_IF_FORCE_EN);
++
++	/* Setup USXGMII adapt mode */
++	mtk_m32(mpcs, RG_PHY_TOP_SPEED_CTRL1,
++		USXGMII_RATE_UPDATE_MODE | USXGMII_RATE_ADAPT_MODE,
++		adapt_mode);
++
++	/* Setup USXGMII speed */
++	mtk_m32(mpcs, RG_PHY_TOP_SPEED_CTRL1,
++		USXGMII_XFI_RX_MODE | USXGMII_XFI_TX_MODE,
++		xfi_mode);
++
++	usleep_range(1, 10);
++
++	/* Un-gated MAC CK */
++	mtk_m32(mpcs, RG_PHY_TOP_SPEED_CTRL1, USXGMII_MAC_CK_GATED, 0);
++
++	usleep_range(1, 10);
++
++	/* Disable interface force mode for the AN mode */
++	if (an_ctrl & USXGMII_AN_ENABLE)
++		mtk_m32(mpcs, RG_PHY_TOP_SPEED_CTRL1, USXGMII_IF_FORCE_EN, 0);
++
++	return mode_changed;
++}
++
++static void mtk_usxgmii_pcs_get_fixed_speed(struct mtk_usxgmii_pcs *mpcs,
++					    struct phylink_link_state *state)
++{
++	u32 val = mtk_r32(mpcs, RG_PHY_TOP_SPEED_CTRL1);
++	int speed;
++
++	/* Calculate speed from interface speed and rate adapt mode */
++	switch (FIELD_GET(USXGMII_XFI_RX_MODE, val)) {
++	case USXGMII_XFI_MODE_10G:
++		speed = 10000;
++		break;
++	case USXGMII_XFI_MODE_5G:
++		speed = 5000;
++		break;
++	case USXGMII_XFI_MODE_2P5G:
++		speed = 2500;
++		break;
++	default:
++		state->speed = SPEED_UNKNOWN;
++		return;
++	}
++
++	switch (FIELD_GET(USXGMII_RATE_ADAPT_MODE, val)) {
++	case USXGMII_RATE_ADAPT_MODE_X100:
++		speed /= 100;
++		break;
++	case USXGMII_RATE_ADAPT_MODE_X50:
++		speed /= 50;
++		break;
++	case USXGMII_RATE_ADAPT_MODE_X10:
++		speed /= 10;
++		break;
++	case USXGMII_RATE_ADAPT_MODE_X5:
++		speed /= 5;
++		break;
++	case USXGMII_RATE_ADAPT_MODE_X4:
++		speed /= 4;
++		break;
++	case USXGMII_RATE_ADAPT_MODE_X2:
++		speed /= 2;
++		break;
++	case USXGMII_RATE_ADAPT_MODE_X1:
++		break;
++	default:
++		state->speed = SPEED_UNKNOWN;
++		return;
++	}
++
++	state->speed = speed;
++	state->duplex = DUPLEX_FULL;
++}
++
++static void mtk_usxgmii_pcs_get_an_state(struct mtk_usxgmii_pcs *mpcs,
++					 struct phylink_link_state *state)
++{
++	u16 lpa;
++
++	/* Refresh LPA by toggling LPA_LATCH */
++	mtk_m32(mpcs, RG_PCS_AN_STS0, USXGMII_LPA_LATCH, USXGMII_LPA_LATCH);
++	ndelay(1020);
++	mtk_m32(mpcs, RG_PCS_AN_STS0, USXGMII_LPA_LATCH, 0);
++	ndelay(1020);
++	lpa = FIELD_GET(USXGMII_LPA, mtk_r32(mpcs, RG_PCS_AN_STS0));
++
++	phylink_decode_usxgmii_word(state, lpa);
++}
++
++static void mtk_usxgmii_pcs_get_state(struct phylink_pcs *pcs,
++				      struct phylink_link_state *state)
++{
++	struct mtk_usxgmii_pcs *mpcs = pcs_to_mtk_usxgmii_pcs(pcs);
++
++	/* Refresh USXGMII link status by toggling RG_PCS_AN_STATUS_UPDATE */
++	mtk_m32(mpcs, RG_PCS_RX_STATUS0, RG_PCS_RX_STATUS_UPDATE,
++		RG_PCS_RX_STATUS_UPDATE);
++	ndelay(1020);
++	mtk_m32(mpcs, RG_PCS_RX_STATUS0, RG_PCS_RX_STATUS_UPDATE, 0);
++	ndelay(1020);
++
++	/* Read USXGMII link status */
++	state->link = FIELD_GET(RG_PCS_RX_LINK_STATUS,
++				mtk_r32(mpcs, RG_PCS_RX_STATUS0));
++
++	/* Continuously repeat re-configuration sequence until link comes up */
++	if (!state->link) {
++		mtk_usxgmii_pcs_config(pcs, mpcs->neg_mode,
++				       state->interface, NULL, false);
++		return;
++	}
++
++	if (FIELD_GET(USXGMII_AN_ENABLE, mtk_r32(mpcs, RG_PCS_AN_CTRL0)))
++		mtk_usxgmii_pcs_get_an_state(mpcs, state);
++	else
++		mtk_usxgmii_pcs_get_fixed_speed(mpcs, state);
++}
++
++static void mtk_usxgmii_pcs_restart_an(struct phylink_pcs *pcs)
++{
++	struct mtk_usxgmii_pcs *mpcs = pcs_to_mtk_usxgmii_pcs(pcs);
++
++	mtk_m32(mpcs, RG_PCS_AN_CTRL0, USXGMII_AN_RESTART, USXGMII_AN_RESTART);
++}
++
++static void mtk_usxgmii_pcs_link_up(struct phylink_pcs *pcs, unsigned int neg_mode,
++				    phy_interface_t interface,
++				    int speed, int duplex)
++{
++	/* Reconfiguring USXGMII to ensure the quality of the RX signal
++	 * after the line side link up.
++	 */
++	mtk_usxgmii_pcs_config(pcs, neg_mode, interface, NULL, false);
++}
++
++static void mtk_usxgmii_pcs_disable(struct phylink_pcs *pcs)
++{
++	struct mtk_usxgmii_pcs *mpcs = pcs_to_mtk_usxgmii_pcs(pcs);
++
++	mpcs->interface = PHY_INTERFACE_MODE_NA;
++	mpcs->neg_mode = -1;
++}
++
++static const struct phylink_pcs_ops mtk_usxgmii_pcs_ops = {
++	.pcs_config = mtk_usxgmii_pcs_config,
++	.pcs_get_state = mtk_usxgmii_pcs_get_state,
++	.pcs_an_restart = mtk_usxgmii_pcs_restart_an,
++	.pcs_link_up = mtk_usxgmii_pcs_link_up,
++	.pcs_disable = mtk_usxgmii_pcs_disable,
++};
++
++static int mtk_usxgmii_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct mtk_usxgmii_pcs *mpcs;
++
++	mpcs = devm_kzalloc(dev, sizeof(*mpcs), GFP_KERNEL);
++	if (!mpcs)
++		return -ENOMEM;
++
++	mpcs->base = devm_platform_ioremap_resource(pdev, 0);
++	if (IS_ERR(mpcs->base))
++		return PTR_ERR(mpcs->base);
++
++	mpcs->dev = dev;
++	mpcs->pcs.ops = &mtk_usxgmii_pcs_ops;
++	mpcs->pcs.poll = true;
++	mpcs->pcs.neg_mode = true;
++	mpcs->interface = PHY_INTERFACE_MODE_NA;
++	mpcs->neg_mode = -1;
++
++	mpcs->clk = devm_clk_get_enabled(mpcs->dev, NULL);
++	if (IS_ERR(mpcs->clk))
++		return PTR_ERR(mpcs->clk);
++
++	mpcs->reset = devm_reset_control_get_shared(dev, NULL);
++	if (IS_ERR(mpcs->reset))
++		return PTR_ERR(mpcs->reset);
++
++	reset_control_deassert(mpcs->reset);
++
++	platform_set_drvdata(pdev, mpcs);
++
++	mutex_lock(&instance_mutex);
++	list_add_tail(&mpcs->node, &mtk_usxgmii_pcs_instances);
++	mutex_unlock(&instance_mutex);
++
++	return 0;
++}
++
++static void mtk_usxgmii_remove(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct mtk_usxgmii_pcs *cur, *tmp;
++
++	mutex_lock(&instance_mutex);
++	list_for_each_entry_safe(cur, tmp, &mtk_usxgmii_pcs_instances, node)
++		if (cur->dev == dev) {
++			list_del(&cur->node);
++			break;
++		}
++	mutex_unlock(&instance_mutex);
++}
++
++static const struct of_device_id mtk_usxgmii_of_mtable[] = {
++	{ .compatible = "mediatek,mt7988-usxgmiisys" },
++	{ /* sentinel */ },
++};
++MODULE_DEVICE_TABLE(of, mtk_usxgmii_of_mtable);
++
++struct phylink_pcs *mtk_usxgmii_pcs_get(struct device *dev, struct device_node *np)
++{
++	struct platform_device *pdev;
++	struct mtk_usxgmii_pcs *mpcs;
++
++	if (!np)
++		return NULL;
++
++	if (!of_device_is_available(np))
++		return ERR_PTR(-ENODEV);
++
++	if (!of_match_node(mtk_usxgmii_of_mtable, np))
++		return ERR_PTR(-EINVAL);
++
++	pdev = of_find_device_by_node(np);
++	if (!pdev || !platform_get_drvdata(pdev)) {
++		if (pdev)
++			put_device(&pdev->dev);
++		return ERR_PTR(-EPROBE_DEFER);
++	}
++
++	mpcs = platform_get_drvdata(pdev);
++	device_link_add(dev, mpcs->dev, DL_FLAG_AUTOREMOVE_CONSUMER);
++
++	return &mpcs->pcs;
++}
++EXPORT_SYMBOL(mtk_usxgmii_pcs_get);
++
++void mtk_usxgmii_pcs_put(struct phylink_pcs *pcs)
++{
++	struct mtk_usxgmii_pcs *cur, *mpcs = NULL;
++
++	if (!pcs)
++		return;
++
++	mutex_lock(&instance_mutex);
++	list_for_each_entry(cur, &mtk_usxgmii_pcs_instances, node)
++		if (pcs == &cur->pcs) {
++			mpcs = cur;
++			break;
++		}
++	mutex_unlock(&instance_mutex);
++
++	if (WARN_ON(!mpcs))
++		return;
++
++	put_device(mpcs->dev);
++}
++EXPORT_SYMBOL(mtk_usxgmii_pcs_put);
++
++static struct platform_driver mtk_usxgmii_driver = {
++	.driver = {
++		.name			= "mtk_usxgmii",
++		.suppress_bind_attrs	= true,
++		.of_match_table		= mtk_usxgmii_of_mtable,
++	},
++	.probe = mtk_usxgmii_probe,
++	.remove_new = mtk_usxgmii_remove,
++};
++module_platform_driver(mtk_usxgmii_driver);
++
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("MediaTek USXGMII PCS driver");
++MODULE_AUTHOR("Daniel Golle <daniel@makrotopia.org>");
+--- /dev/null
++++ b/include/linux/pcs/pcs-mtk-usxgmii.h
+@@ -0,0 +1,27 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++#ifndef __LINUX_PCS_MTK_USXGMII_H
++#define __LINUX_PCS_MTK_USXGMII_H
++
++#include <linux/phylink.h>
++
++/**
++ * mtk_usxgmii_select_pcs() - Get MediaTek PCS instance
++ * @np:		Pointer to device node indentifying a MediaTek USXGMII PCS
++ * @mode:	Ethernet PHY interface mode
++ *
++ * Return PCS identified by a device node and the PHY interface mode in use
++ *
++ * Return:	Pointer to phylink PCS instance of NULL
++ */
++#if IS_ENABLED(CONFIG_PCS_MTK_USXGMII)
++struct phylink_pcs *mtk_usxgmii_pcs_get(struct device *dev, struct device_node *np);
++void mtk_usxgmii_pcs_put(struct phylink_pcs *pcs);
++#else
++static inline struct phylink_pcs *mtk_usxgmii_pcs_get(struct device *dev, struct device_node *np)
++{
++	return NULL;
++}
++static inline void mtk_usxgmii_pcs_put(struct phylink_pcs *pcs) { }
++#endif /* IS_ENABLED(CONFIG_PCS_MTK_USXGMII) */
++
++#endif /* __LINUX_PCS_MTK_USXGMII_H */
diff --git a/target/linux/generic/pending-6.12/740-net-phy-motorcomm-Add-missing-include.patch b/target/linux/generic/pending-6.12/740-net-phy-motorcomm-Add-missing-include.patch
new file mode 100644
index 0000000000..2a1f908cfb
--- /dev/null
+++ b/target/linux/generic/pending-6.12/740-net-phy-motorcomm-Add-missing-include.patch
@@ -0,0 +1,22 @@
+From 6f291aa7da199c6486cc229b055dcbcd5cee7a21 Mon Sep 17 00:00:00 2001
+From: Hauke Mehrtens <hauke@hauke-m.de>
+Date: Sun, 21 May 2023 22:24:56 +0200
+Subject: [PATCH] net: phy: motorcomm: Add missing include
+
+Directly include linux/bitfield.h which provides FIELD_PREP.
+
+Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
+---
+ drivers/net/phy/motorcomm.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/phy/motorcomm.c
++++ b/drivers/net/phy/motorcomm.c
+@@ -6,6 +6,7 @@
+  * Author: Frank <Frank.Sae@motor-comm.com>
+  */
+ 
++#include <linux/bitfield.h>
+ #include <linux/etherdevice.h>
+ #include <linux/kernel.h>
+ #include <linux/module.h>
diff --git a/target/linux/generic/pending-6.12/741-net-phy-broadcom-update-dependency-condition.patch b/target/linux/generic/pending-6.12/741-net-phy-broadcom-update-dependency-condition.patch
new file mode 100644
index 0000000000..f5621e34ee
--- /dev/null
+++ b/target/linux/generic/pending-6.12/741-net-phy-broadcom-update-dependency-condition.patch
@@ -0,0 +1,35 @@
+From 1be3688b3eaa7ea2d9e19bd29ae6a6a51c121a0b Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Sat, 16 Nov 2024 22:36:15 +0100
+Subject: [PATCH] net: phy: broadcom: update dependency condition
+
+The broadcom PHY driver only has to depend upon PTP_1588_CLOCK_OPTIONAL
+if NETWORK_PHY_TIMESTAMPING is enabled. The PTP functionality is stubbed
+in this case.
+
+Reflect this circumstance in the dependence condition. This allows to
+build the driver as a built-in module even if PTP is built as a module.
+
+This is required to include the broadcom PHY module regardless of the
+built-setting of the PTP subsystem. On ath79 (and probably more)
+targets with Broadcom PHY, Gigabit operation is currently broken as the
+PHY driver is only built as a module in case all kernel-packages are
+built. Due to this circumstance, affected devices fall back to using the
+generic PHY driver.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ drivers/net/phy/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -139,7 +139,7 @@ config BROADCOM_PHY
+ 	tristate "Broadcom 54XX PHYs"
+ 	select BCM_NET_PHYLIB
+ 	select BCM_NET_PHYPTP if NETWORK_PHY_TIMESTAMPING
+-	depends on PTP_1588_CLOCK_OPTIONAL
++	depends on NETWORK_PHY_TIMESTAMPING=n || PTP_1588_CLOCK_OPTIONAL
+ 	help
+ 	  Currently supports the BCM5411, BCM5421, BCM5461, BCM54616S, BCM5464,
+ 	  BCM5481, BCM54810 and BCM5482 PHYs.
diff --git a/target/linux/generic/pending-6.12/780-ARM-kirkwood-add-missing-linux-if_ether.h-for-ETH_AL.patch b/target/linux/generic/pending-6.12/780-ARM-kirkwood-add-missing-linux-if_ether.h-for-ETH_AL.patch
new file mode 100644
index 0000000000..39ba71606e
--- /dev/null
+++ b/target/linux/generic/pending-6.12/780-ARM-kirkwood-add-missing-linux-if_ether.h-for-ETH_AL.patch
@@ -0,0 +1,61 @@
+From patchwork Thu Aug  5 22:23:30 2021
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12422209
+Date: Thu, 5 Aug 2021 23:23:30 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-arm-kernel@lists.infradead.org, netdev@vger.kernel.org,
+ linux-kernel@vger.kernel.org
+Cc: "David S. Miller" <davem@davemloft.net>, Andrew Lunn <andrew@lunn.ch>,
+ Michael Walle <michael@walle.cc>
+Subject: [PATCH] ARM: kirkwood: add missing <linux/if_ether.h> for ETH_ALEN
+Message-ID: <YQxk4jrbm31NM1US@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+X-BeenThere: linux-arm-kernel@lists.infradead.org
+X-Mailman-Version: 2.1.34
+Precedence: list
+List-Id: <linux-arm-kernel.lists.infradead.org>
+List-Archive: <http://lists.infradead.org/pipermail/linux-arm-kernel/>
+Sender: "linux-arm-kernel" <linux-arm-kernel-bounces@lists.infradead.org>
+
+After commit 83216e3988cd1 ("of: net: pass the dst buffer to
+of_get_mac_address()") build fails for kirkwood as ETH_ALEN is not
+defined.
+
+arch/arm/mach-mvebu/kirkwood.c: In function 'kirkwood_dt_eth_fixup':
+arch/arm/mach-mvebu/kirkwood.c:87:13: error: 'ETH_ALEN' undeclared (first use in this function); did you mean 'ESTALE'?
+   u8 tmpmac[ETH_ALEN];
+             ^~~~~~~~
+             ESTALE
+arch/arm/mach-mvebu/kirkwood.c:87:13: note: each undeclared identifier is reported only once for each function it appears in
+arch/arm/mach-mvebu/kirkwood.c:87:6: warning: unused variable 'tmpmac' [-Wunused-variable]
+   u8 tmpmac[ETH_ALEN];
+      ^~~~~~
+make[5]: *** [scripts/Makefile.build:262: arch/arm/mach-mvebu/kirkwood.o] Error 1
+make[5]: *** Waiting for unfinished jobs....
+
+Add missing #include <linux/if_ether.h> to fix this.
+
+Cc: David S. Miller <davem@davemloft.net>
+Cc: Andrew Lunn <andrew@lunn.ch>
+Cc: Michael Walle <michael@walle.cc>
+Reported-by: https://buildbot.openwrt.org/master/images/#/builders/56/builds/220/steps/44/logs/stdio
+Fixes: 83216e3988cd1 ("of: net: pass the dst buffer to of_get_mac_address()")
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ arch/arm/mach-mvebu/kirkwood.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm/mach-mvebu/kirkwood.c
++++ b/arch/arm/mach-mvebu/kirkwood.c
+@@ -11,6 +11,7 @@
+ #include <linux/kernel.h>
+ #include <linux/init.h>
+ #include <linux/mbus.h>
++#include <linux/if_ether.h>
+ #include <linux/of.h>
+ #include <linux/of_address.h>
+ #include <linux/of_net.h>
diff --git a/target/linux/generic/pending-6.12/790-bus-mhi-core-add-SBL-state-callback.patch b/target/linux/generic/pending-6.12/790-bus-mhi-core-add-SBL-state-callback.patch
new file mode 100644
index 0000000000..fe0f260ae3
--- /dev/null
+++ b/target/linux/generic/pending-6.12/790-bus-mhi-core-add-SBL-state-callback.patch
@@ -0,0 +1,48 @@
+From 5f7c5e1c0d7a79be144e5efc1f24728ddd7fc25c Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Sat, 5 Nov 2022 20:02:56 +0100
+Subject: [PATCH 1/2] bus: mhi: core: add SBL state callback
+
+Add support for SBL state callback in MHI core.
+
+It is required for ath11k MHI devices in order to be able to set QRTR
+instance ID in the SBL state so that QRTR instance ID-s dont conflict in
+case of multiple PCI/MHI cards or AHB + PCI/MHI card.
+Setting QRTR instance ID is only possible in SBL state and there is
+currently no way to ensure that we are in that state, so provide a
+callback that the controller can trigger off.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ drivers/bus/mhi/host/main.c | 1 +
+ include/linux/mhi.h         | 2 ++
+ 2 files changed, 3 insertions(+)
+
+--- a/drivers/bus/mhi/host/main.c
++++ b/drivers/bus/mhi/host/main.c
+@@ -906,6 +906,7 @@ int mhi_process_ctrl_ev_ring(struct mhi_
+ 			switch (event) {
+ 			case MHI_EE_SBL:
+ 				st = DEV_ST_TRANSITION_SBL;
++				mhi_cntrl->status_cb(mhi_cntrl, MHI_CB_EE_SBL_MODE);
+ 				break;
+ 			case MHI_EE_WFW:
+ 			case MHI_EE_AMSS:
+--- a/include/linux/mhi.h
++++ b/include/linux/mhi.h
+@@ -34,6 +34,7 @@ struct mhi_buf_info;
+  * @MHI_CB_SYS_ERROR: MHI device entered error state (may recover)
+  * @MHI_CB_FATAL_ERROR: MHI device entered fatal error state
+  * @MHI_CB_BW_REQ: Received a bandwidth switch request from device
++ * @MHI_CB_EE_SBL_MODE: MHI device entered SBL mode
+  */
+ enum mhi_callback {
+ 	MHI_CB_IDLE,
+@@ -45,6 +46,7 @@ enum mhi_callback {
+ 	MHI_CB_SYS_ERROR,
+ 	MHI_CB_FATAL_ERROR,
+ 	MHI_CB_BW_REQ,
++	MHI_CB_EE_SBL_MODE,
+ };
+ 
+ /**
diff --git a/target/linux/generic/pending-6.12/791-tg3-Fix-DMA-allocations-on-57766-devices.patch b/target/linux/generic/pending-6.12/791-tg3-Fix-DMA-allocations-on-57766-devices.patch
new file mode 100644
index 0000000000..bc29761445
--- /dev/null
+++ b/target/linux/generic/pending-6.12/791-tg3-Fix-DMA-allocations-on-57766-devices.patch
@@ -0,0 +1,31 @@
+From f992b15965177e2f280fb6f41f292214f9a6f8d5 Mon Sep 17 00:00:00 2001
+From: Pavan Chebbi <pavan.chebbi@broadcom.com>
+Date: Tue, 10 Dec 2024 03:28:31 -0800
+Subject: [PATCH] tg3: Fix DMA allocations on 57766 devices
+
+The coherent DMA mask of 31b may not be accepted if
+the DMA mask is configured to use higher memories of
+64b. Set the DMA mask also to lower 32b for 57766
+devices.
+
+Fixes: 614f4d166eee ("tg3: Set coherent DMA mask bits to 31 for BCM57766 chipsets")
+Reported-By: Rui Salvaterra <rsalvaterra@gmail.com>
+Signed-off-by: Pavan Chebbi <pavan.chebbi@broadcom.com>
+---
+ drivers/net/ethernet/broadcom/tg3.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/broadcom/tg3.c
++++ b/drivers/net/ethernet/broadcom/tg3.c
+@@ -17802,8 +17802,10 @@ static int tg3_init_one(struct pci_dev *
+ 	} else
+ 		persist_dma_mask = dma_mask = DMA_BIT_MASK(64);
+ 
+-	if (tg3_asic_rev(tp) == ASIC_REV_57766)
++	if (tg3_asic_rev(tp) == ASIC_REV_57766) {
++		dma_mask = DMA_BIT_MASK(32);
+ 		persist_dma_mask = DMA_BIT_MASK(31);
++	}
+ 
+ 	/* Configure DMA attributes. */
+ 	if (dma_mask > DMA_BIT_MASK(32)) {
diff --git a/target/linux/generic/pending-6.12/800-bcma-get-SoC-device-struct-copy-its-DMA-params-to-th.patch b/target/linux/generic/pending-6.12/800-bcma-get-SoC-device-struct-copy-its-DMA-params-to-th.patch
new file mode 100644
index 0000000000..4a9c188d17
--- /dev/null
+++ b/target/linux/generic/pending-6.12/800-bcma-get-SoC-device-struct-copy-its-DMA-params-to-th.patch
@@ -0,0 +1,73 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Subject: [PATCH] bcma: get SoC device struct & copy its DMA params to the
+ subdevices
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+For bus devices to be fully usable it's required to set their DMA
+parameters.
+
+For years it has been missing and remained unnoticed because of
+mips_dma_alloc_coherent() silently handling the empty coherent_dma_mask.
+Kernel 4.19 came with a lot of DMA changes and caused a regression on
+the bcm47xx. Starting with the commit f8c55dc6e828 ("MIPS: use generic
+dma noncoherent ops for simple noncoherent platforms") DMA coherent
+allocations just fail. Example:
+[    1.114914] bgmac_bcma bcma0:2: Allocation of TX ring 0x200 failed
+[    1.121215] bgmac_bcma bcma0:2: Unable to alloc memory for DMA
+[    1.127626] bgmac_bcma: probe of bcma0:2 failed with error -12
+[    1.133838] bgmac_bcma: Broadcom 47xx GBit MAC driver loaded
+
+This change fixes above regression in addition to the MIPS bcm47xx
+commit 321c46b91550 ("MIPS: BCM47XX: Setup struct device for the SoC").
+
+It also fixes another *old* GPIO regression caused by a parent pointing
+to the NULL:
+[    0.157054] missing gpiochip .dev parent pointer
+[    0.157287] bcma: bus0: Error registering GPIO driver: -22
+introduced by the commit 74f4e0cc6108 ("bcma: switch GPIO portions to
+use GPIOLIB_IRQCHIP").
+
+Fixes: f8c55dc6e828 ("MIPS: use generic dma noncoherent ops for simple noncoherent platforms")
+Fixes: 74f4e0cc6108 ("bcma: switch GPIO portions to use GPIOLIB_IRQCHIP")
+Cc: linux-mips@linux-mips.org
+Cc: Christoph Hellwig <hch@lst.de>
+Cc: Linus Walleij <linus.walleij@linaro.org>
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+---
+
+--- a/drivers/bcma/host_soc.c
++++ b/drivers/bcma/host_soc.c
+@@ -191,6 +191,8 @@ int __init bcma_host_soc_init(struct bcm
+ 	struct bcma_bus *bus = &soc->bus;
+ 	int err;
+ 
++	bus->dev = soc->dev;
++
+ 	/* Scan bus and initialize it */
+ 	err = bcma_bus_early_register(bus);
+ 	if (err)
+--- a/drivers/bcma/main.c
++++ b/drivers/bcma/main.c
+@@ -237,13 +237,17 @@ EXPORT_SYMBOL(bcma_core_irq);
+ 
+ void bcma_prepare_core(struct bcma_bus *bus, struct bcma_device *core)
+ {
+-	device_initialize(&core->dev);
++	struct device *dev = &core->dev;
++
++	device_initialize(dev);
+ 	core->dev.release = bcma_release_core_dev;
+ 	core->dev.bus = &bcma_bus_type;
+-	dev_set_name(&core->dev, "bcma%d:%d", bus->num, core->core_index);
++	dev_set_name(dev, "bcma%d:%d", bus->num, core->core_index);
+ 	core->dev.parent = bus->dev;
+-	if (bus->dev)
++	if (bus->dev) {
+ 		bcma_of_fill_device(bus->dev, core);
++		dma_coerce_mask_and_coherent(dev, bus->dev->coherent_dma_mask);
++	}
+ 
+ 	switch (bus->hosttype) {
+ 	case BCMA_HOSTTYPE_PCI:
diff --git a/target/linux/generic/pending-6.12/801-gpio-gpio-cascade-add-generic-GPIO-cascade.patch b/target/linux/generic/pending-6.12/801-gpio-gpio-cascade-add-generic-GPIO-cascade.patch
new file mode 100644
index 0000000000..e3b37eecc1
--- /dev/null
+++ b/target/linux/generic/pending-6.12/801-gpio-gpio-cascade-add-generic-GPIO-cascade.patch
@@ -0,0 +1,217 @@
+From fc23ea48ba52c24f201fe5ca0132ee1a3de5a70a Mon Sep 17 00:00:00 2001
+From: Mauri Sandberg <maukka@ext.kapsi.fi>
+Date: Thu, 25 Mar 2021 11:48:05 +0200
+Subject: [PATCH 2/2] gpio: gpio-cascade: add generic GPIO cascade
+
+Adds support for building cascades of GPIO lines. That is, it allows
+setups when there is one upstream line and multiple cascaded lines, out
+of which one can be chosen at a time. The status of the upstream line
+can be conveyed to the selected cascaded line or, vice versa, the status
+of the cascaded line can be conveyed to the upstream line.
+
+A multiplexer is being used to select, which cascaded GPIO line is being
+used at any given time.
+
+At the moment only input direction is supported. In future it should be
+possible to add support for output direction, too.
+
+Signed-off-by: Mauri Sandberg <maukka@ext.kapsi.fi>
+Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
+Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
+---
+v7 -> v8:
+ - rearrange members in struct gpio_cascade
+ - cosmetic changes in file header and in one function declaration
+ - added Reviewed-by tags by Linus and Andy
+v6 -> v7:
+ - In Kconfig add info about module name
+ - adhere to new convention that allows lines longer than 80 chars
+ - use dev_probe_err with upstream gpio line too
+ - refactor for cleaner exit of probe function.
+v5 -> v6:
+ - In Kconfig, remove dependency to OF_GPIO and select only MULTIPLEXER
+ - refactor code preferring one-liners
+ - clean up prints, removing them from success-path.
+ - don't explicitly set gpio_chip.of_node as it's done in the GPIO library
+ - use devm_gpiochip_add_data instead of gpiochip_add
+v4 -> v5:
+ - renamed gpio-mux-input -> gpio-cascade. refactored code accordingly
+   here and there and changed to use new bindings and compatible string
+   - ambigious and vague 'pin' was rename to 'upstream_line'
+ - dropped Tested-by and Reviewed-by due to changes in bindings
+ - dropped Reported-by suggested by an automatic bot as it was not really
+   appropriate to begin with
+ - functionally it's the same as v4
+v3 -> v4:
+ - Changed author email
+ - Included Tested-by and Reviewed-by from Drew
+v2 -> v3:
+ - use managed device resources
+ - update Kconfig description
+v1 -> v2:
+ - removed .owner from platform_driver as per test bot's instruction
+ - added MODULE_AUTHOR, MODULE_DESCRIPTION, MODULE_LICENSE
+ - added gpio_mux_input_get_direction as it's recommended for all chips
+ - removed because this is input only chip: gpio_mux_input_set_value
+ - removed because they are not needed for input/output only chips:
+     gpio_mux_input_direction_input
+     gpio_mux_input_direction_output
+ - fixed typo in an error message
+ - added info message about successful registration
+ - removed can_sleep flag as this does not sleep while getting GPIO value
+   like I2C or SPI do
+ - Updated description in Kconfig
+---
+ drivers/gpio/Kconfig        |  15 +++++
+ drivers/gpio/Makefile       |   1 +
+ drivers/gpio/gpio-cascade.c | 117 ++++++++++++++++++++++++++++++++++++
+ 3 files changed, 133 insertions(+)
+ create mode 100644 drivers/gpio/gpio-cascade.c
+
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -1929,4 +1929,19 @@ config GPIO_VIRTUSER
+ 
+ endmenu
+ 
++comment "Other GPIO expanders"
++
++config GPIO_CASCADE
++	tristate "General GPIO cascade"
++	select MULTIPLEXER
++	help
++	  Say yes here to enable support for generic GPIO cascade.
++
++	  This allows building one-to-many cascades of GPIO lines using
++	  different types of multiplexers readily available. At the
++	  moment only input lines are supported.
++
++	  To build the driver as a module choose 'm' and the resulting module
++	  will be called 'gpio-cascade'.
++
+ endif
+--- a/drivers/gpio/Makefile
++++ b/drivers/gpio/Makefile
+@@ -45,6 +45,7 @@ obj-$(CONFIG_GPIO_BD9571MWV)		+= gpio-bd
+ obj-$(CONFIG_GPIO_BRCMSTB)		+= gpio-brcmstb.o
+ obj-$(CONFIG_GPIO_BT8XX)		+= gpio-bt8xx.o
+ obj-$(CONFIG_GPIO_CADENCE)		+= gpio-cadence.o
++obj-$(CONFIG_GPIO_CASCADE)		+= gpio-cascade.o
+ obj-$(CONFIG_GPIO_CLPS711X)		+= gpio-clps711x.o
+ obj-$(CONFIG_GPIO_SNPS_CREG)		+= gpio-creg-snps.o
+ obj-$(CONFIG_GPIO_CROS_EC)		+= gpio-cros-ec.o
+--- /dev/null
++++ b/drivers/gpio/gpio-cascade.c
+@@ -0,0 +1,112 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ *  A generic GPIO cascade driver
++ *
++ *  Copyright (C) 2021 Mauri Sandberg <maukka@ext.kapsi.fi>
++ *
++ * This allows building cascades of GPIO lines in a manner illustrated
++ * below:
++ *
++ *                 /|---- Cascaded GPIO line 0
++ *  Upstream      | |---- Cascaded GPIO line 1
++ *  GPIO line ----+ | .
++ *                | | .
++ *                 \|---- Cascaded GPIO line n
++ *
++ * A multiplexer is being used to select, which cascaded line is being
++ * addressed at any given time.
++ *
++ * At the moment only input mode is supported due to lack of means for
++ * testing output functionality. At least theoretically output should be
++ * possible with open drain constructions.
++ */
++
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/platform_device.h>
++#include <linux/mux/consumer.h>
++
++#include <linux/gpio/consumer.h>
++#include <linux/gpio/driver.h>
++
++struct gpio_cascade {
++	struct gpio_chip	gpio_chip;
++	struct device		*parent;
++	struct mux_control	*mux_control;
++	struct gpio_desc	*upstream_line;
++};
++
++static int gpio_cascade_get_direction(struct gpio_chip *gc, unsigned int offset)
++{
++	return GPIO_LINE_DIRECTION_IN;
++}
++
++static int gpio_cascade_get_value(struct gpio_chip *gc, unsigned int offset)
++{
++	struct gpio_cascade *cas = gpiochip_get_data(gc);
++	int ret;
++
++	ret = mux_control_select(cas->mux_control, offset);
++	if (ret)
++		return ret;
++
++	ret = gpiod_get_value(cas->upstream_line);
++	mux_control_deselect(cas->mux_control);
++	return ret;
++}
++
++static int gpio_cascade_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct gpio_cascade *cas;
++	struct mux_control *mc;
++	struct gpio_desc *upstream;
++	struct gpio_chip *gc;
++
++	cas = devm_kzalloc(dev, sizeof(*cas), GFP_KERNEL);
++	if (!cas)
++		return -ENOMEM;
++
++	mc = devm_mux_control_get(dev, NULL);
++	if (IS_ERR(mc))
++		return dev_err_probe(dev, PTR_ERR(mc), "unable to get mux-control\n");
++
++	cas->mux_control = mc;
++	upstream = devm_gpiod_get(dev, "upstream",  GPIOD_IN);
++	if (IS_ERR(upstream))
++		return dev_err_probe(dev, PTR_ERR(upstream), "unable to claim upstream GPIO line\n");
++
++	cas->upstream_line = upstream;
++	cas->parent = dev;
++
++	gc = &cas->gpio_chip;
++	gc->get = gpio_cascade_get_value;
++	gc->get_direction = gpio_cascade_get_direction;
++	gc->base = -1;
++	gc->ngpio = mux_control_states(mc);
++	gc->label = dev_name(cas->parent);
++	gc->parent = cas->parent;
++	gc->owner = THIS_MODULE;
++
++	platform_set_drvdata(pdev, cas);
++	return devm_gpiochip_add_data(dev, &cas->gpio_chip, cas);
++}
++
++static const struct of_device_id gpio_cascade_id[] = {
++	{ .compatible = "gpio-cascade" },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, gpio_cascade_id);
++
++static struct platform_driver gpio_cascade_driver = {
++	.driver	= {
++		.name		= "gpio-cascade",
++		.of_match_table = gpio_cascade_id,
++	},
++	.probe	= gpio_cascade_probe,
++};
++module_platform_driver(gpio_cascade_driver);
++
++MODULE_AUTHOR("Mauri Sandberg <maukka@ext.kapsi.fi>");
++MODULE_DESCRIPTION("Generic GPIO cascade");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/pending-6.12/802-OPP-Provide-old-opp-to-config_clks-on-_set_opp.patch b/target/linux/generic/pending-6.12/802-OPP-Provide-old-opp-to-config_clks-on-_set_opp.patch
new file mode 100644
index 0000000000..aedeeb4e9f
--- /dev/null
+++ b/target/linux/generic/pending-6.12/802-OPP-Provide-old-opp-to-config_clks-on-_set_opp.patch
@@ -0,0 +1,108 @@
+From fd59b838dd90452f61a17dc9e5ff175205003068 Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Thu, 15 Sep 2022 18:49:43 +0200
+Subject: [PATCH] OPP: Provide old opp to config_clks on _set_opp
+
+With the target opp, also pass the old opp to config_clks function.
+This can be useful when a driver needs to take decision on what fequency
+to set based on what is the current frequency without using a
+clk_get_freq call.
+Update the only user of custom config_clks (tegra30 devfreq driver) to
+this new implementation.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ drivers/devfreq/tegra30-devfreq.c |  5 +++--
+ drivers/opp/core.c                | 11 ++++++-----
+ include/linux/pm_opp.h            | 11 ++++++-----
+ 3 files changed, 15 insertions(+), 12 deletions(-)
+
+--- a/drivers/devfreq/tegra30-devfreq.c
++++ b/drivers/devfreq/tegra30-devfreq.c
+@@ -823,8 +823,9 @@ static int devm_tegra_devfreq_init_hw(st
+ 
+ static int tegra_devfreq_config_clks_nop(struct device *dev,
+ 					 struct opp_table *opp_table,
+-					 struct dev_pm_opp *opp, void *data,
+-					 bool scaling_down)
++					 struct dev_pm_opp *old_opp,
++					 struct dev_pm_opp *opp,
++					 void *data, bool scaling_down)
+ {
+ 	/* We want to skip clk configuration via dev_pm_opp_set_opp() */
+ 	return 0;
+--- a/drivers/opp/core.c
++++ b/drivers/opp/core.c
+@@ -965,7 +965,8 @@ static int _set_opp_voltage(struct devic
+ 
+ static int
+ _opp_config_clk_single(struct device *dev, struct opp_table *opp_table,
+-		       struct dev_pm_opp *opp, void *data, bool scaling_down)
++		       struct dev_pm_opp *old_opp, struct dev_pm_opp *opp,
++		       void *data, bool scaling_down)
+ {
+ 	unsigned long *target = data;
+ 	unsigned long freq;
+@@ -997,8 +998,8 @@ _opp_config_clk_single(struct device *de
+  * the order in which they are present in the array while scaling up.
+  */
+ int dev_pm_opp_config_clks_simple(struct device *dev,
+-		struct opp_table *opp_table, struct dev_pm_opp *opp, void *data,
+-		bool scaling_down)
++		struct opp_table *opp_table, struct dev_pm_opp *old_opp,
++		struct dev_pm_opp *opp, void *data, bool scaling_down)
+ {
+ 	int ret, i;
+ 
+@@ -1265,7 +1266,7 @@ static int _set_opp(struct device *dev,
+ 	}
+ 
+ 	if (opp_table->config_clks) {
+-		ret = opp_table->config_clks(dev, opp_table, opp, clk_data, scaling_down);
++		ret = opp_table->config_clks(dev, opp_table, old_opp, opp, clk_data, scaling_down);
+ 		if (ret)
+ 			return ret;
+ 	}
+@@ -1344,7 +1345,7 @@ int dev_pm_opp_set_rate(struct device *d
+ 		 * equivalent to a clk_set_rate()
+ 		 */
+ 		if (!_get_opp_count(opp_table)) {
+-			ret = opp_table->config_clks(dev, opp_table, NULL,
++			ret = opp_table->config_clks(dev, opp_table, NULL, NULL,
+ 						     &target_freq, false);
+ 			goto put_opp_table;
+ 		}
+--- a/include/linux/pm_opp.h
++++ b/include/linux/pm_opp.h
+@@ -50,7 +50,8 @@ typedef int (*config_regulators_t)(struc
+ 			struct dev_pm_opp *old_opp, struct dev_pm_opp *new_opp,
+ 			struct regulator **regulators, unsigned int count);
+ 
+-typedef int (*config_clks_t)(struct device *dev, struct opp_table *opp_table,
++typedef int (*config_clks_t)(struct device *dev,
++			struct opp_table *opp_table, struct dev_pm_opp *old_opp,
+ 			struct dev_pm_opp *opp, void *data, bool scaling_down);
+ 
+ /**
+@@ -184,8 +185,8 @@ int dev_pm_opp_set_config(struct device
+ int devm_pm_opp_set_config(struct device *dev, struct dev_pm_opp_config *config);
+ void dev_pm_opp_clear_config(int token);
+ int dev_pm_opp_config_clks_simple(struct device *dev,
+-		struct opp_table *opp_table, struct dev_pm_opp *opp, void *data,
+-		bool scaling_down);
++		struct opp_table *opp_table, struct dev_pm_opp *old_opp,
++		struct dev_pm_opp *opp, void *data, bool scaling_down);
+ 
+ struct dev_pm_opp *dev_pm_opp_xlate_required_opp(struct opp_table *src_table, struct opp_table *dst_table, struct dev_pm_opp *src_opp);
+ int dev_pm_opp_xlate_performance_state(struct opp_table *src_table, struct opp_table *dst_table, unsigned int pstate);
+@@ -395,8 +396,8 @@ static inline int devm_pm_opp_set_config
+ static inline void dev_pm_opp_clear_config(int token) {}
+ 
+ static inline int dev_pm_opp_config_clks_simple(struct device *dev,
+-		struct opp_table *opp_table, struct dev_pm_opp *opp, void *data,
+-		bool scaling_down)
++		struct opp_table *opp_table, struct dev_pm_opp *old_opp,
++		struct dev_pm_opp *opp, void *data, bool scaling_down)
+ {
+ 	return -EOPNOTSUPP;
+ }
diff --git a/target/linux/generic/pending-6.12/802-nvmem-u-boot-env-align-endianness-of-crc32-values.patch b/target/linux/generic/pending-6.12/802-nvmem-u-boot-env-align-endianness-of-crc32-values.patch
new file mode 100644
index 0000000000..29fe668f8d
--- /dev/null
+++ b/target/linux/generic/pending-6.12/802-nvmem-u-boot-env-align-endianness-of-crc32-values.patch
@@ -0,0 +1,45 @@
+From 0e71cac033bb7689c4dfa2e6814191337ef770f5 Mon Sep 17 00:00:00 2001
+From: INAGAKI Hiroshi <musashino.open@gmail.com>
+Date: Thu, 13 Oct 2022 00:51:33 +0900
+Subject: [PATCH] nvmem: layouts: u-boot-env: align endianness of crc32 values
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This patch fixes crc32 error on Big-Endianness system by conversion of
+calculated crc32 value.
+
+Little-Endianness system:
+
+  obtained crc32: Little
+calculated crc32: Little
+
+Big-Endianness system:
+
+  obtained crc32: Little
+calculated crc32: Big
+
+log (APRESIA ApresiaLightGS120GT-SS, RTL8382M, Big-Endianness):
+
+[    8.570000] u_boot_env 18001200.spi:flash@0:partitions:partition@c0000: Invalid calculated CRC32: 0x88cd6f09 (expected: 0x096fcd88)
+[    8.580000] u_boot_env: probe of 18001200.spi:flash@0:partitions:partition@c0000 failed with error -22
+
+Fixes: f955dc1445069 ("nvmem: add driver handling U-Boot environment variables")
+
+Signed-off-by: INAGAKI Hiroshi <musashino.open@gmail.com>
+Acked-by: Rafał Miłecki <rafal@milecki.pl>
+Tested-by: Christian Lamparter <chunkeey@gmail.com>
+Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
+---
+
+--- a/drivers/nvmem/layouts/u-boot-env.c
++++ b/drivers/nvmem/layouts/u-boot-env.c
+@@ -148,7 +148,7 @@ int u_boot_env_parse(struct device *dev,
+ 	crc32_data_len = dev_size - crc32_data_offset;
+ 	data_len = dev_size - data_offset;
+ 
+-	calc = crc32(~0, buf + crc32_data_offset, crc32_data_len) ^ ~0L;
++	calc = le32_to_cpu((__le32)crc32(~0, buf + crc32_data_offset, crc32_data_len) ^ ~0L);
+ 	if (calc != crc32) {
+ 		dev_err(dev, "Invalid calculated CRC32: 0x%08x (expected: 0x%08x)\n", calc, crc32);
+ 		err = -EINVAL;
diff --git a/target/linux/generic/pending-6.12/804-nvmem-core-support-mac-base-fixed-layout-cells.patch b/target/linux/generic/pending-6.12/804-nvmem-core-support-mac-base-fixed-layout-cells.patch
new file mode 100644
index 0000000000..446099a2a9
--- /dev/null
+++ b/target/linux/generic/pending-6.12/804-nvmem-core-support-mac-base-fixed-layout-cells.patch
@@ -0,0 +1,124 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Thu, 13 Jul 2023 18:29:19 +0200
+Subject: [PATCH] nvmem: core: support "mac-base" fixed layout cells
+
+Fixed layout binding allows specifying "mac-base" NVMEM cells. It's used
+for base MAC address (that can be used for calculating relative
+addresses). It can be stored in a raw binary format or as an ASCII
+string.
+---
+
+--- a/drivers/nvmem/Kconfig
++++ b/drivers/nvmem/Kconfig
+@@ -2,6 +2,7 @@
+ menuconfig NVMEM
+ 	bool "NVMEM Support"
+ 	imply NVMEM_LAYOUTS
++	select GENERIC_NET_UTILS
+ 	help
+ 	  Support for NVMEM(Non Volatile Memory) devices like EEPROM, EFUSES...
+ 
+--- a/drivers/nvmem/core.c
++++ b/drivers/nvmem/core.c
+@@ -7,9 +7,12 @@
+  */
+ 
+ #include <linux/device.h>
++#include <linux/ctype.h>
++#include <linux/etherdevice.h>
+ #include <linux/export.h>
+ #include <linux/fs.h>
+ #include <linux/idr.h>
++#include <linux/if_ether.h>
+ #include <linux/init.h>
+ #include <linux/kref.h>
+ #include <linux/module.h>
+@@ -797,6 +800,62 @@ static int nvmem_validate_keepouts(struc
+ 	return 0;
+ }
+ 
++static int nvmem_mac_base_raw_read(void *context, const char *id, int index, unsigned int offset,
++				   void *buf, size_t bytes)
++{
++	if (WARN_ON(bytes != ETH_ALEN))
++		return -EINVAL;
++
++	if (index)
++		eth_addr_add(buf, index);
++
++	return 0;
++}
++
++static int nvmem_mac_base_ascii_read(void *context, const char *id, int index, unsigned int offset,
++				     void *buf, size_t bytes)
++{
++	u8 mac[ETH_ALEN];
++
++	if (WARN_ON(bytes != 3 * ETH_ALEN - 1))
++		return -EINVAL;
++
++	if (!mac_pton(buf, mac))
++		return -EINVAL;
++
++	if (index)
++		eth_addr_add(mac, index);
++
++	ether_addr_copy(buf, mac);
++
++	return 0;
++}
++
++static int nvmem_mac_base_hex_read(void *context, const char *id, int index, unsigned int offset,
++				   void *buf, size_t bytes)
++{
++	u8 mac[ETH_ALEN], *hexstr;
++	int i;
++
++	if (WARN_ON(bytes != 2 * ETH_ALEN))
++		return -EINVAL;
++
++	hexstr = (u8 *)buf;
++	for (i = 0; i < ETH_ALEN; i++) {
++		if (!isxdigit(hexstr[i * 2]) || !isxdigit(hexstr[i * 2 + 1]))
++			return -EINVAL;
++
++		mac[i] = (hex_to_bin(hexstr[i * 2]) << 4) | hex_to_bin(hexstr[i * 2 + 1]);
++	}
++
++	if (index)
++		eth_addr_add(mac, index);
++
++	ether_addr_copy(buf, mac);
++
++	return 0;
++}
++
+ static int nvmem_add_cells_from_dt(struct nvmem_device *nvmem, struct device_node *np)
+ {
+ 	struct device *dev = &nvmem->dev;
+@@ -836,6 +895,25 @@ static int nvmem_add_cells_from_dt(struc
+ 		if (nvmem->fixup_dt_cell_info)
+ 			nvmem->fixup_dt_cell_info(nvmem, &info);
+ 
++		if (of_device_is_compatible(np, "fixed-layout")) {
++			if (of_device_is_compatible(child, "mac-base")) {
++				if (info.bytes == ETH_ALEN) {
++					info.raw_len = info.bytes;
++					info.bytes = ETH_ALEN;
++					info.read_post_process = nvmem_mac_base_raw_read;
++				} else if (info.bytes == 2 * ETH_ALEN) {
++					info.raw_len = info.bytes;
++					info.bytes = ETH_ALEN;
++					info.read_post_process = nvmem_mac_base_hex_read;
++				} else if (info.bytes == 3 * ETH_ALEN - 1) {
++					info.raw_len = info.bytes;
++					info.bytes = ETH_ALEN;
++					info.read_post_process = nvmem_mac_base_ascii_read;
++				}
++
++			}
++		}
++
+ 		ret = nvmem_add_one_cell(nvmem, &info);
+ 		kfree(info.name);
+ 		if (ret) {
diff --git a/target/linux/generic/pending-6.12/809-01-nvmem-core-generalize-mac-base-cells-handling.patch b/target/linux/generic/pending-6.12/809-01-nvmem-core-generalize-mac-base-cells-handling.patch
new file mode 100644
index 0000000000..139a925ccf
--- /dev/null
+++ b/target/linux/generic/pending-6.12/809-01-nvmem-core-generalize-mac-base-cells-handling.patch
@@ -0,0 +1,248 @@
+From fd0e523037439520813db7c57df5bd37cdf40f7e Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Mon, 3 Feb 2025 00:10:18 +0100
+Subject: [PATCH 1/2] nvmem: core: generalize "mac-base" cells handling
+
+Generalize support of "mac-base" nvmem cells and provide a GPL symbol to
+permit also other NVMEM layout driver to parse mac-base cells.
+
+It's VERY COMMON for some specially formatted NVMEM to expose a mac
+address in ASCII format or HEX format hence prevent code duplication by
+exposing a common helper.
+
+Such helper will change the nvmem_info_cell and apply the correct post
+process function to correctly parse the mac address.
+
+Since the API requires OF and is only related to layout, move the
+function in layouts.c to correctly handle non-OF NVMEM.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ drivers/nvmem/core.c           | 79 +--------------------------------
+ drivers/nvmem/layouts.c        | 80 ++++++++++++++++++++++++++++++++++
+ include/linux/nvmem-provider.h |  4 ++
+ 3 files changed, 86 insertions(+), 77 deletions(-)
+
+--- a/drivers/nvmem/core.c
++++ b/drivers/nvmem/core.c
+@@ -7,12 +7,9 @@
+  */
+ 
+ #include <linux/device.h>
+-#include <linux/ctype.h>
+-#include <linux/etherdevice.h>
+ #include <linux/export.h>
+ #include <linux/fs.h>
+ #include <linux/idr.h>
+-#include <linux/if_ether.h>
+ #include <linux/init.h>
+ #include <linux/kref.h>
+ #include <linux/module.h>
+@@ -800,62 +797,6 @@ static int nvmem_validate_keepouts(struc
+ 	return 0;
+ }
+ 
+-static int nvmem_mac_base_raw_read(void *context, const char *id, int index, unsigned int offset,
+-				   void *buf, size_t bytes)
+-{
+-	if (WARN_ON(bytes != ETH_ALEN))
+-		return -EINVAL;
+-
+-	if (index)
+-		eth_addr_add(buf, index);
+-
+-	return 0;
+-}
+-
+-static int nvmem_mac_base_ascii_read(void *context, const char *id, int index, unsigned int offset,
+-				     void *buf, size_t bytes)
+-{
+-	u8 mac[ETH_ALEN];
+-
+-	if (WARN_ON(bytes != 3 * ETH_ALEN - 1))
+-		return -EINVAL;
+-
+-	if (!mac_pton(buf, mac))
+-		return -EINVAL;
+-
+-	if (index)
+-		eth_addr_add(mac, index);
+-
+-	ether_addr_copy(buf, mac);
+-
+-	return 0;
+-}
+-
+-static int nvmem_mac_base_hex_read(void *context, const char *id, int index, unsigned int offset,
+-				   void *buf, size_t bytes)
+-{
+-	u8 mac[ETH_ALEN], *hexstr;
+-	int i;
+-
+-	if (WARN_ON(bytes != 2 * ETH_ALEN))
+-		return -EINVAL;
+-
+-	hexstr = (u8 *)buf;
+-	for (i = 0; i < ETH_ALEN; i++) {
+-		if (!isxdigit(hexstr[i * 2]) || !isxdigit(hexstr[i * 2 + 1]))
+-			return -EINVAL;
+-
+-		mac[i] = (hex_to_bin(hexstr[i * 2]) << 4) | hex_to_bin(hexstr[i * 2 + 1]);
+-	}
+-
+-	if (index)
+-		eth_addr_add(mac, index);
+-
+-	ether_addr_copy(buf, mac);
+-
+-	return 0;
+-}
+-
+ static int nvmem_add_cells_from_dt(struct nvmem_device *nvmem, struct device_node *np)
+ {
+ 	struct device *dev = &nvmem->dev;
+@@ -895,24 +836,8 @@ static int nvmem_add_cells_from_dt(struc
+ 		if (nvmem->fixup_dt_cell_info)
+ 			nvmem->fixup_dt_cell_info(nvmem, &info);
+ 
+-		if (of_device_is_compatible(np, "fixed-layout")) {
+-			if (of_device_is_compatible(child, "mac-base")) {
+-				if (info.bytes == ETH_ALEN) {
+-					info.raw_len = info.bytes;
+-					info.bytes = ETH_ALEN;
+-					info.read_post_process = nvmem_mac_base_raw_read;
+-				} else if (info.bytes == 2 * ETH_ALEN) {
+-					info.raw_len = info.bytes;
+-					info.bytes = ETH_ALEN;
+-					info.read_post_process = nvmem_mac_base_hex_read;
+-				} else if (info.bytes == 3 * ETH_ALEN - 1) {
+-					info.raw_len = info.bytes;
+-					info.bytes = ETH_ALEN;
+-					info.read_post_process = nvmem_mac_base_ascii_read;
+-				}
+-
+-			}
+-		}
++		if (of_device_is_compatible(np, "fixed-layout"))
++			nvmem_layout_parse_mac_base(&info);
+ 
+ 		ret = nvmem_add_one_cell(nvmem, &info);
+ 		kfree(info.name);
+--- a/drivers/nvmem/layouts.c
++++ b/drivers/nvmem/layouts.c
+@@ -6,8 +6,11 @@
+  * Author: Miquel Raynal <miquel.raynal@bootlin.com
+  */
+ 
++#include <linux/ctype.h>
+ #include <linux/device.h>
+ #include <linux/dma-mapping.h>
++#include <linux/etherdevice.h>
++#include <linux/if_ether.h>
+ #include <linux/nvmem-consumer.h>
+ #include <linux/nvmem-provider.h>
+ #include <linux/of.h>
+@@ -21,6 +24,83 @@
+ #define to_nvmem_layout_device(_dev) \
+ 	container_of((_dev), struct nvmem_layout, dev)
+ 
++static int nvmem_mac_base_raw_read(void *context, const char *id, int index, unsigned int offset,
++				   void *buf, size_t bytes)
++{
++	if (WARN_ON(bytes != ETH_ALEN))
++		return -EINVAL;
++
++	if (index)
++		eth_addr_add(buf, index);
++
++	return 0;
++}
++
++static int nvmem_mac_base_ascii_read(void *context, const char *id, int index, unsigned int offset,
++				     void *buf, size_t bytes)
++{
++	u8 mac[ETH_ALEN];
++
++	if (WARN_ON(bytes != 3 * ETH_ALEN - 1))
++		return -EINVAL;
++
++	if (!mac_pton(buf, mac))
++		return -EINVAL;
++
++	if (index)
++		eth_addr_add(mac, index);
++
++	ether_addr_copy(buf, mac);
++
++	return 0;
++}
++
++static int nvmem_mac_base_hex_read(void *context, const char *id, int index, unsigned int offset,
++				   void *buf, size_t bytes)
++{
++	u8 mac[ETH_ALEN], *hexstr;
++	int i;
++
++	if (WARN_ON(bytes != 2 * ETH_ALEN))
++		return -EINVAL;
++
++	hexstr = (u8 *)buf;
++	for (i = 0; i < ETH_ALEN; i++) {
++		if (!isxdigit(hexstr[i * 2]) || !isxdigit(hexstr[i * 2 + 1]))
++			return -EINVAL;
++
++		mac[i] = (hex_to_bin(hexstr[i * 2]) << 4) | hex_to_bin(hexstr[i * 2 + 1]);
++	}
++
++	if (index)
++		eth_addr_add(mac, index);
++
++	ether_addr_copy(buf, mac);
++
++	return 0;
++}
++
++void nvmem_layout_parse_mac_base(struct nvmem_cell_info *info)
++{
++	if (!of_device_is_compatible(info->np, "mac-base"))
++		return;
++
++	if (info->bytes == ETH_ALEN) {
++		info->raw_len = info->bytes;
++		info->bytes = ETH_ALEN;
++		info->read_post_process = nvmem_mac_base_raw_read;
++	} else if (info->bytes == 2 * ETH_ALEN) {
++		info->raw_len = info->bytes;
++		info->bytes = ETH_ALEN;
++		info->read_post_process = nvmem_mac_base_hex_read;
++	} else if (info->bytes == 3 * ETH_ALEN - 1) {
++		info->raw_len = info->bytes;
++		info->bytes = ETH_ALEN;
++		info->read_post_process = nvmem_mac_base_ascii_read;
++	}
++}
++EXPORT_SYMBOL_GPL(nvmem_layout_parse_mac_base);
++
+ static int nvmem_layout_bus_match(struct device *dev, const struct device_driver *drv)
+ {
+ 	return of_driver_match_device(dev, drv);
+--- a/include/linux/nvmem-provider.h
++++ b/include/linux/nvmem-provider.h
+@@ -242,6 +242,8 @@ static inline void nvmem_layout_unregist
+ 
+ #if IS_ENABLED(CONFIG_NVMEM) && IS_ENABLED(CONFIG_OF)
+ 
++void nvmem_layout_parse_mac_base(struct nvmem_cell_info *info);
++
+ /**
+  * of_nvmem_layout_get_container() - Get OF node of layout container
+  *
+@@ -254,6 +256,8 @@ struct device_node *of_nvmem_layout_get_
+ 
+ #else  /* CONFIG_NVMEM && CONFIG_OF */
+ 
++static inline void nvmem_layout_parse_mac_base(struct nvmem_cell_info *info) {}
++
+ static inline struct device_node *of_nvmem_layout_get_container(struct nvmem_device *nvmem)
+ {
+ 	return NULL;
diff --git a/target/linux/generic/pending-6.12/809-02-nvmem-layouts-add-support-for-ascii-env-driver.patch b/target/linux/generic/pending-6.12/809-02-nvmem-layouts-add-support-for-ascii-env-driver.patch
new file mode 100644
index 0000000000..0906e0f725
--- /dev/null
+++ b/target/linux/generic/pending-6.12/809-02-nvmem-layouts-add-support-for-ascii-env-driver.patch
@@ -0,0 +1,204 @@
+From 38287e8ec5c0281377fc70f11f20bcd9986a05f5 Mon Sep 17 00:00:00 2001
+From: Christian Marangi <ansuelsmth@gmail.com>
+Date: Mon, 3 Feb 2025 00:36:12 +0100
+Subject: [PATCH 2/2] nvmem: layouts: add support for ascii-env driver
+
+Add support for simple ASCII envirorment driver for NVMEM layouts.
+
+It's very common for devices to store simple text file format in
+partition for environment varibles. The most common pattern is variable
+name, a delimiter and variable value all separated by a new line
+character (\n).
+
+This driver adds support for exporting such data and expose NVMEM cells
+so they can be referenced by other drivers. This driver also supports
+parsing mac-base NVMEM cells to parse ASCII or HEX mac address.
+
+Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
+---
+ drivers/nvmem/layouts/Kconfig     |  13 +++
+ drivers/nvmem/layouts/Makefile    |   1 +
+ drivers/nvmem/layouts/ascii-env.c | 140 ++++++++++++++++++++++++++++++
+ 3 files changed, 154 insertions(+)
+ create mode 100644 drivers/nvmem/layouts/ascii-env.c
+
+--- a/drivers/nvmem/layouts/Kconfig
++++ b/drivers/nvmem/layouts/Kconfig
+@@ -37,6 +37,19 @@ config NVMEM_LAYOUT_U_BOOT_ENV
+ 
+ 	  If unsure, say N.
+ 
++config NVMEM_LAYOUT_ASCII_ENV
++	tristate "ASCII environment variables layout"
++	help
++	  It's very common for devices to store simple text file format in
++	  partition for environment varibles. The most common pattern is variable
++	  name, a delimiter and variable value all separated by a new line
++	  character (\n).
++	  This driver adds support for exporting such data and expose NVMEM cells
++	  so they can be referenced by other drivers. This driver also supports
++	  parsing mac-base NVMEM cells to parse ASCII or HEX mac address.
++
++	  If unsure, say N.
++
+ endmenu
+ 
+ endif
+--- a/drivers/nvmem/layouts/Makefile
++++ b/drivers/nvmem/layouts/Makefile
+@@ -6,3 +6,4 @@
+ obj-$(CONFIG_NVMEM_LAYOUT_SL28_VPD) += sl28vpd.o
+ obj-$(CONFIG_NVMEM_LAYOUT_ONIE_TLV) += onie-tlv.o
+ obj-$(CONFIG_NVMEM_LAYOUT_U_BOOT_ENV) += u-boot-env.o
++obj-$(CONFIG_NVMEM_LAYOUT_ASCII_ENV) += ascii-env.o
+--- /dev/null
++++ b/drivers/nvmem/layouts/ascii-env.c
+@@ -0,0 +1,148 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (C) 2024 Christian Marangi <ansuelsmth@gmail.com>
++ *
++ * This borrow some parse logic from u-boot-env.
++ */
++#include <linux/nvmem-consumer.h>
++#include <linux/nvmem-provider.h>
++#include <linux/of.h>
++#include <linux/slab.h>
++
++struct ascii_env_match_data {
++	const char delim;
++};
++
++/*
++ * Parse a buffer as an ASCII text with name delimiter value and each pattern separated
++ * with a new line char '\n'
++ * Example: (delimiter '=')
++ *   name=value\nname2=value2\n
++ *   2 Cell:
++ *   - name: value
++ *   - name2: value2
++ */
++static int ascii_env_parse_cells(struct device *dev, struct nvmem_device *nvmem, uint8_t *buf,
++				 size_t data_len, const char delim)
++{
++	char *var, *value, *eq, *lf;
++	char *data = buf;
++
++	/*
++	 * Warning the inner loop take care of replacing '\n'
++	 * with '\0', hence we can use strlen on value.
++	 */
++	for (var = data; var < data + data_len && *var;
++	     var = value + strlen(value) + 1) {
++		struct nvmem_cell_info info = {};
++		struct device_node *child;
++		const char *label;
++
++		eq = strchr(var, delim);
++		if (!eq)
++			break;
++		*eq = '\0';
++		value = eq + 1;
++
++		/* Replace '\n' with '\0' to use strlen for value */
++		lf = strchr(value, '\n');
++		if (!lf)
++			break;
++		*lf = '\0';
++
++		info.name = devm_kstrdup(dev, var, GFP_KERNEL);
++		if (!info.name)
++			return -ENOMEM;
++		info.offset = value - data;
++		info.bytes = strlen(value);
++		info.np = of_get_child_by_name(dev->of_node, info.name);
++		for_each_child_of_node(dev->of_node, child) {
++			if (!of_property_read_string(child, "label", &label) &&
++			    !strncmp(info.name, label, info.bytes))
++			    	info.np = child;
++			else if (of_node_name_eq(child, info.name))
++				info.np = child;
++		}
++
++		nvmem_layout_parse_mac_base(&info);
++
++		nvmem_add_one_cell(nvmem, &info);
++	}
++
++	return 0;
++}
++
++static int ascii_env_add_cells(struct nvmem_layout *layout)
++{
++	struct nvmem_device *nvmem = layout->nvmem;
++	const struct ascii_env_match_data *data;
++	struct device *dev = &layout->dev;
++	size_t dev_size;
++	uint8_t *buf;
++	int bytes;
++	int ret;
++
++	/* Get the delimiter for name value pattern */
++	data = device_get_match_data(dev);
++
++	dev_size = nvmem_dev_size(nvmem);
++
++	buf = kzalloc(dev_size, GFP_KERNEL);
++	if (!buf) {
++		ret = -ENOMEM;
++		goto err_out;
++	}
++
++	bytes = nvmem_device_read(nvmem, 0, dev_size, buf);
++	if (bytes < 0) {
++		ret = bytes;
++		goto err_kfree;
++	} else if (bytes != dev_size) {
++		ret = -EIO;
++		goto err_kfree;
++	}
++
++	buf[dev_size - 1] = '\0';
++	ret = ascii_env_parse_cells(dev, nvmem, buf, dev_size, data->delim);
++
++err_kfree:
++	kfree(buf);
++err_out:
++	return ret;
++}
++
++static int ascii_env_probe(struct nvmem_layout *layout)
++{
++	layout->add_cells = ascii_env_add_cells;
++
++	return nvmem_layout_register(layout);
++}
++
++static void ascii_env_remove(struct nvmem_layout *layout)
++{
++	nvmem_layout_unregister(layout);
++}
++
++static const struct ascii_env_match_data ascii_env_eq = {
++	.delim = '=',
++};
++
++static const struct of_device_id ascii_env_of_match_table[] = {
++	{ .compatible = "ascii-eq-delim-env", .data = &ascii_env_eq, },
++	{},
++};
++
++static struct nvmem_layout_driver ascii_env_layout = {
++	.driver = {
++		.name = "ascii-env-layout",
++		.of_match_table = ascii_env_of_match_table,
++	},
++	.probe = ascii_env_probe,
++	.remove = ascii_env_remove,
++};
++module_nvmem_layout_driver(ascii_env_layout);
++
++MODULE_AUTHOR("Christian Marangi <ansuelsmth@gmail.com>");
++MODULE_LICENSE("GPL");
++MODULE_DEVICE_TABLE(of, ascii_env_of_match_table);
++MODULE_DESCRIPTION("NVMEM layout driver for ASCII environment variables");
diff --git a/target/linux/generic/pending-6.12/809-03-nvmem-layouts-ascii-env-handle-CRLF-while-parsing.patch b/target/linux/generic/pending-6.12/809-03-nvmem-layouts-ascii-env-handle-CRLF-while-parsing.patch
new file mode 100644
index 0000000000..ab5fc58d0e
--- /dev/null
+++ b/target/linux/generic/pending-6.12/809-03-nvmem-layouts-ascii-env-handle-CRLF-while-parsing.patch
@@ -0,0 +1,58 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Thu, 06 Feb 2025 21:55:28 +0400
+Subject: [PATCH] nvmem: layouts: ascii-env handle CRLF while parsing
+
+The current driver supports LF line endings only.
+
+For CRLF-based line endings in the ASCII env, the length of the value of
+the variable passed to nvmem_layout_parse_mac_base is 18 bytes instead
+of an expected length of 17 causing the parsing to fail.
+So, let's add the ability to handle CRLF line endings by adding a
+condition to check if the value ends with a '\r' character and replace it
+with '\0' to properly parse the mac address.
+
+Tested on Linksys MX2000, MX5500, and SPNMX56.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/nvmem/layouts/ascii-env.c
++++ b/drivers/nvmem/layouts/ascii-env.c
+@@ -25,18 +25,20 @@ struct ascii_env_match_data {
+ static int ascii_env_parse_cells(struct device *dev, struct nvmem_device *nvmem, uint8_t *buf,
+ 				 size_t data_len, const char delim)
+ {
+-	char *var, *value, *eq, *lf;
++	char *var, *value, *eq, *lf, *cr;
+ 	char *data = buf;
++	uint incr = 0;
+ 
+ 	/*
+ 	 * Warning the inner loop take care of replacing '\n'
+ 	 * with '\0', hence we can use strlen on value.
+ 	 */
+ 	for (var = data; var < data + data_len && *var;
+-	     var = value + strlen(value) + 1) {
++	     var = value + strlen(value) + incr) {
+ 		struct nvmem_cell_info info = {};
+ 		struct device_node *child;
+ 		const char *label;
++		incr = 0;
+ 
+ 		eq = strchr(var, delim);
+ 		if (!eq)
+@@ -49,6 +51,15 @@ static int ascii_env_parse_cells(struct
+ 		if (!lf)
+ 			break;
+ 		*lf = '\0';
++		incr++;
++
++		/* For CRLF based env, replace '\r' with '\0' too to use strlen
++		 * for value, and increment var by one in loop for next variable */
++		cr = strchr(value, '\r');
++		if (cr) {
++			*cr = '\0';
++			incr++;
++		}
+ 
+ 		info.name = devm_kstrdup(dev, var, GFP_KERNEL);
+ 		if (!info.name)
diff --git a/target/linux/generic/pending-6.12/810-pci_disable_common_quirks.patch b/target/linux/generic/pending-6.12/810-pci_disable_common_quirks.patch
new file mode 100644
index 0000000000..559348332f
--- /dev/null
+++ b/target/linux/generic/pending-6.12/810-pci_disable_common_quirks.patch
@@ -0,0 +1,62 @@
+From: Gabor Juhos <juhosg@openwrt.org>
+Subject: debloat: add kernel config option to disabling common PCI quirks
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+---
+ drivers/pci/Kconfig  | 6 ++++++
+ drivers/pci/quirks.c | 6 ++++++
+ 2 files changed, 12 insertions(+)
+
+--- a/drivers/pci/Kconfig
++++ b/drivers/pci/Kconfig
+@@ -118,6 +118,13 @@ config XEN_PCIDEV_FRONTEND
+ 	  The PCI device frontend driver allows the kernel to import arbitrary
+ 	  PCI devices from a PCI backend to support PCI driver domains.
+ 
++config PCI_DISABLE_COMMON_QUIRKS
++	bool "PCI disable common quirks"
++	depends on PCI
++	help
++	  If you don't know what to do here, say N.
++
++
+ config PCI_ATS
+ 	bool
+ 
+--- a/drivers/pci/quirks.c
++++ b/drivers/pci/quirks.c
+@@ -313,6 +313,7 @@ static void quirk_mmio_always_on(struct
+ DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_ANY_ID, PCI_ANY_ID,
+ 				PCI_CLASS_BRIDGE_HOST, 8, quirk_mmio_always_on);
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
+ /*
+  * The Mellanox Tavor device gives false positive parity errors.  Disable
+  * parity error reporting.
+@@ -3508,6 +3509,8 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f9, quirk_intel_mc_errata);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65fa, quirk_intel_mc_errata);
+ 
++#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
++
+ /*
+  * Ivytown NTB BAR sizes are misreported by the hardware due to an erratum.
+  * To work around this, query the size it should be configured to by the
+@@ -3533,6 +3536,8 @@ static void quirk_intel_ntb(struct pci_d
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x0e08, quirk_intel_ntb);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x0e0d, quirk_intel_ntb);
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
++
+ /*
+  * Some BIOS implementations leave the Intel GPU interrupts enabled, even
+  * though no one is handling them (e.g., if the i915 driver is never
+@@ -3571,6 +3576,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0152, disable_igfx_irq);
+ 
++#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
++
+ /*
+  * PCI devices which are on Intel chips can skip the 10ms delay
+  * before entering D3 mode.
diff --git a/target/linux/generic/pending-6.12/811-pci_disable_usb_common_quirks.patch b/target/linux/generic/pending-6.12/811-pci_disable_usb_common_quirks.patch
new file mode 100644
index 0000000000..4e0360d47f
--- /dev/null
+++ b/target/linux/generic/pending-6.12/811-pci_disable_usb_common_quirks.patch
@@ -0,0 +1,63 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 26 Apr 2025 21:10:40 +0200
+Subject: [PATCH] debloat: disable common USB quirks
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ drivers/usb/host/pci-quirks.c | 7 +++++++
+ drivers/usb/host/pci-quirks.h | 4 ++++
+ 2 files changed, 11 insertions(+)
+
+--- a/drivers/usb/host/pci-quirks.c
++++ b/drivers/usb/host/pci-quirks.c
+@@ -590,6 +590,7 @@ bool usb_amd_pt_check_port(struct device
+ EXPORT_SYMBOL_GPL(usb_amd_pt_check_port);
+ #endif /* CONFIG_USB_PCI_AMD */
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
+ static int usb_asmedia_wait_write(struct pci_dev *pdev)
+ {
+ 	unsigned long retry_count;
+@@ -642,6 +643,7 @@ static inline int io_type_enabled(struct
+ }
+ 
+ #define mmio_enabled(dev) io_type_enabled(dev, PCI_COMMAND_MEMORY)
++#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
+ 
+ #if defined(CONFIG_HAS_IOPORT) && IS_ENABLED(CONFIG_USB_UHCI_HCD)
+ /*
+@@ -724,6 +726,10 @@ reset_needed:
+ 	return 1;
+ }
+ EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
++#endif
++
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
++#if defined(CONFIG_HAS_IOPORT) && IS_ENABLED(CONFIG_USB_UHCI_HCD)
+ 
+ #define pio_enabled(dev) io_type_enabled(dev, PCI_COMMAND_IO)
+ 
+@@ -1304,3 +1310,4 @@ static void quirk_usb_early_handoff(stru
+ }
+ DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_ANY_ID, PCI_ANY_ID,
+ 			PCI_CLASS_SERIAL_USB, 8, quirk_usb_early_handoff);
++#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
+--- a/drivers/usb/host/pci-quirks.h
++++ b/drivers/usb/host/pci-quirks.h
+@@ -38,12 +38,16 @@ static inline bool usb_amd_pt_check_port
+ #ifdef CONFIG_USB_PCI
+ void uhci_reset_hc(struct pci_dev *pdev, unsigned long base);
+ int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base);
++#endif
++
++#if defined(CONFIG_USB_PCI) && !defined(CONFIG_PCI_DISABLE_COMMON_QUIRKS)
+ void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev);
+ void usb_enable_intel_xhci_ports(struct pci_dev *xhci_pdev);
+ void usb_disable_xhci_ports(struct pci_dev *xhci_pdev);
+ #else
+ struct pci_dev;
+ static inline void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev) {}
++static inline void usb_enable_intel_xhci_ports(struct pci_dev *xhci_pdev) {}
+ static inline void usb_disable_xhci_ports(struct pci_dev *xhci_pdev) {}
+ #endif  /* CONFIG_USB_PCI */
+ 
diff --git a/target/linux/generic/pending-6.12/834-ledtrig-libata.patch b/target/linux/generic/pending-6.12/834-ledtrig-libata.patch
new file mode 100644
index 0000000000..72e2a76b62
--- /dev/null
+++ b/target/linux/generic/pending-6.12/834-ledtrig-libata.patch
@@ -0,0 +1,145 @@
+From: Daniel Golle <daniel@makrotopia.org>
+Subject: libata: add ledtrig support
+
+This adds a LED trigger for each ATA port indicating disk activity.
+
+As this is needed only on specific platforms (NAS SoCs and such),
+these platforms should define ARCH_WANTS_LIBATA_LEDS if there
+are boards with LED(s) intended to indicate ATA disk activity and
+need the OS to take care of that.
+In that way, if not selected, LED trigger support not will be
+included in libata-core and both, codepaths and structures remain
+untouched.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/ata/Kconfig       | 16 ++++++++++++++++
+ drivers/ata/libata-core.c | 41 +++++++++++++++++++++++++++++++++++++++++
+ include/linux/libata.h    |  9 +++++++++
+ 3 files changed, 66 insertions(+)
+
+--- a/drivers/ata/Kconfig
++++ b/drivers/ata/Kconfig
+@@ -67,6 +67,22 @@ config ATA_FORCE
+ 
+ 	  If unsure, say Y.
+ 
++config ARCH_WANT_LIBATA_LEDS
++	bool
++
++config ATA_LEDS
++	bool "support ATA port LED triggers"
++	depends on ARCH_WANT_LIBATA_LEDS
++	select NEW_LEDS
++	select LEDS_CLASS
++	select LEDS_TRIGGERS
++	default y
++	help
++	  This option adds a LED trigger for each registered ATA port.
++	  It is used to drive disk activity leds connected via GPIO.
++
++	  If unsure, say N.
++
+ config ATA_ACPI
+ 	bool "ATA ACPI Support"
+ 	depends on ACPI
+--- a/drivers/ata/libata-core.c
++++ b/drivers/ata/libata-core.c
+@@ -703,6 +703,17 @@ static inline void ata_set_tf_cdl(struct
+ 	qc->flags |= ATA_QCFLAG_HAS_CDL | ATA_QCFLAG_RESULT_TF;
+ }
+ 
++#ifdef CONFIG_ATA_LEDS
++#define LIBATA_BLINK_DELAY 20 /* ms */
++static inline void ata_led_act(struct ata_port *ap)
++{
++	if (unlikely(!ap->ledtrig))
++		return;
++
++	led_trigger_blink_oneshot(ap->ledtrig, LIBATA_BLINK_DELAY, LIBATA_BLINK_DELAY, 0);
++}
++#endif
++
+ /**
+  *	ata_build_rw_tf - Build ATA taskfile for given read/write request
+  *	@qc: Metadata associated with the taskfile to build
+@@ -4767,6 +4778,9 @@ void __ata_qc_complete(struct ata_queued
+ 		link->active_tag = ATA_TAG_POISON;
+ 		ap->nr_active_links--;
+ 	}
++#ifdef CONFIG_ATA_LEDS
++	ata_led_act(ap);
++#endif
+ 
+ 	/* clear exclusive status */
+ 	if (unlikely(qc->flags & ATA_QCFLAG_CLEAR_EXCL &&
+@@ -5489,6 +5503,9 @@ struct ata_port *ata_port_alloc(struct a
+ 	ap->stats.unhandled_irq = 1;
+ 	ap->stats.idle_irq = 1;
+ #endif
++#ifdef CONFIG_ATA_LEDS
++	ap->ledtrig = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);
++#endif
+ 	ata_sff_port_init(ap);
+ 
+ 	ata_force_pflags(ap);
+@@ -5505,6 +5522,12 @@ void ata_port_free(struct ata_port *ap)
+ 	kfree(ap->pmp_link);
+ 	kfree(ap->slave_link);
+ 	ida_free(&ata_ida, ap->print_id);
++#ifdef CONFIG_ATA_LEDS
++	if (ap->ledtrig) {
++		led_trigger_unregister(ap->ledtrig);
++		kfree(ap->ledtrig);
++	};
++#endif
+ 	kfree(ap);
+ }
+ EXPORT_SYMBOL_GPL(ata_port_free);
+@@ -5909,7 +5932,23 @@ int ata_host_register(struct ata_host *h
+ 		WARN_ON(1);
+ 		return -EINVAL;
+ 	}
++#ifdef CONFIG_ATA_LEDS
++	for (i = 0; i < host->n_ports; i++) {
++		if (unlikely(!host->ports[i]->ledtrig))
++			continue;
+ 
++		snprintf(host->ports[i]->ledtrig_name,
++			sizeof(host->ports[i]->ledtrig_name), "ata%u",
++			host->ports[i]->print_id);
++
++		host->ports[i]->ledtrig->name = host->ports[i]->ledtrig_name;
++
++		if (led_trigger_register(host->ports[i]->ledtrig)) {
++			kfree(host->ports[i]->ledtrig);
++			host->ports[i]->ledtrig = NULL;
++		}
++	}
++#endif
+ 	/* Create associated sysfs transport objects  */
+ 	for (i = 0; i < host->n_ports; i++) {
+ 		rc = ata_tport_add(host->dev,host->ports[i]);
+--- a/include/linux/libata.h
++++ b/include/linux/libata.h
+@@ -23,6 +23,9 @@
+ #include <linux/cdrom.h>
+ #include <linux/sched.h>
+ #include <linux/async.h>
++#ifdef CONFIG_ATA_LEDS
++#include <linux/leds.h>
++#endif
+ 
+ /*
+  * Define if arch has non-standard setup.  This is a _PCI_ standard
+@@ -934,6 +937,10 @@ struct ata_port {
+ #ifdef CONFIG_ATA_ACPI
+ 	struct ata_acpi_gtm	__acpi_init_gtm; /* use ata_acpi_init_gtm() */
+ #endif
++#ifdef CONFIG_ATA_LEDS
++	struct led_trigger	*ledtrig;
++	char			ledtrig_name[8];
++#endif
+ };
+ 
+ /* The following initializer overrides a method to NULL whether one of
diff --git a/target/linux/generic/pending-6.12/840-hwrng-bcm2835-set-quality-to-1000.patch b/target/linux/generic/pending-6.12/840-hwrng-bcm2835-set-quality-to-1000.patch
new file mode 100644
index 0000000000..3172ad5a16
--- /dev/null
+++ b/target/linux/generic/pending-6.12/840-hwrng-bcm2835-set-quality-to-1000.patch
@@ -0,0 +1,26 @@
+From d6988cf1d16faac56899918bb2b1be8d85155e3f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?=C3=81lvaro=20Fern=C3=A1ndez=20Rojas?= <noltari@gmail.com>
+Date: Sat, 20 Feb 2021 18:36:38 +0100
+Subject: [PATCH] hwrng: bcm2835: set quality to 1000
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This allows devices without a high precission timer to reduce boot from >100s
+to <30s.
+
+Signed-off-by: Álvaro Fernández Rojas <noltari@gmail.com>
+---
+ drivers/char/hw_random/bcm2835-rng.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/char/hw_random/bcm2835-rng.c
++++ b/drivers/char/hw_random/bcm2835-rng.c
+@@ -169,6 +169,7 @@ static int bcm2835_rng_probe(struct plat
+ 	priv->rng.init = bcm2835_rng_init;
+ 	priv->rng.read = bcm2835_rng_read;
+ 	priv->rng.cleanup = bcm2835_rng_cleanup;
++	priv->rng.quality = 1000;
+ 
+ 	if (dev_of_node(dev)) {
+ 		rng_id = of_match_node(bcm2835_rng_of_match, dev->of_node);
diff --git a/target/linux/generic/pending-6.12/850-0023-PCI-aardvark-Make-main-irq_chip-structure-a-static-d.patch b/target/linux/generic/pending-6.12/850-0023-PCI-aardvark-Make-main-irq_chip-structure-a-static-d.patch
new file mode 100644
index 0000000000..6a90959f61
--- /dev/null
+++ b/target/linux/generic/pending-6.12/850-0023-PCI-aardvark-Make-main-irq_chip-structure-a-static-d.patch
@@ -0,0 +1,102 @@
+From 663b9f99bb35dbc0c7b685f71ee3668a60d31320 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Mon, 10 Jan 2022 02:02:00 +0100
+Subject: [PATCH] PCI: aardvark: Make main irq_chip structure a static driver
+ structure
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Marc Zyngier says [1] that we should use struct irq_chip as a global
+static struct in the driver. Even though the structure currently
+contains a dynamic member (parent_device), Marc says [2] that he plans
+to kill it and make the structure completely static.
+
+We have already converted others irq_chip structures in this driver in
+this way, but we omitted this one because the .name member is
+dynamically created from device's name, and the name is displayed in
+sysfs, so changing it would break sysfs ABI.
+
+The rationale for changing the name (to "advk-INT") in spite of sysfs
+ABI, and thus allowing to convert to a static structure, is that after
+the other changes we made in this series, the IRQ chip is basically
+something different: it no logner generates ERR and PME interrupts (they
+are generated by emulated bridge's rp_irq_chip).
+
+[1] https://lore.kernel.org/linux-pci/877dbcvngf.wl-maz@kernel.org/
+[2] https://lore.kernel.org/linux-pci/874k6gvkhz.wl-maz@kernel.org/
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 25 +++++++------------------
+ 1 file changed, 7 insertions(+), 18 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -276,7 +276,6 @@ struct advk_pcie {
+ 	u8 wins_count;
+ 	struct irq_domain *rp_irq_domain;
+ 	struct irq_domain *irq_domain;
+-	struct irq_chip irq_chip;
+ 	raw_spinlock_t irq_lock;
+ 	struct irq_domain *msi_domain;
+ 	struct irq_domain *msi_inner_domain;
+@@ -1418,14 +1417,19 @@ static void advk_pcie_irq_unmask(struct
+ 	raw_spin_unlock_irqrestore(&pcie->irq_lock, flags);
+ }
+ 
++static struct irq_chip advk_irq_chip = {
++	.name		= "advk-INT",
++	.irq_mask	= advk_pcie_irq_mask,
++	.irq_unmask	= advk_pcie_irq_unmask,
++};
++
+ static int advk_pcie_irq_map(struct irq_domain *h,
+ 			     unsigned int virq, irq_hw_number_t hwirq)
+ {
+ 	struct advk_pcie *pcie = h->host_data;
+ 
+ 	irq_set_status_flags(virq, IRQ_LEVEL);
+-	irq_set_chip_and_handler(virq, &pcie->irq_chip,
+-				 handle_level_irq);
++	irq_set_chip_and_handler(virq, &advk_irq_chip, handle_level_irq);
+ 	irq_set_chip_data(virq, pcie);
+ 
+ 	return 0;
+@@ -1485,7 +1489,6 @@ static int advk_pcie_init_irq_domain(str
+ 	struct device *dev = &pcie->pdev->dev;
+ 	struct device_node *node = dev->of_node;
+ 	struct device_node *pcie_intc_node;
+-	struct irq_chip *irq_chip;
+ 	int ret = 0;
+ 
+ 	raw_spin_lock_init(&pcie->irq_lock);
+@@ -1496,28 +1499,14 @@ static int advk_pcie_init_irq_domain(str
+ 		return -ENODEV;
+ 	}
+ 
+-	irq_chip = &pcie->irq_chip;
+-
+-	irq_chip->name = devm_kasprintf(dev, GFP_KERNEL, "%s-irq",
+-					dev_name(dev));
+-	if (!irq_chip->name) {
+-		ret = -ENOMEM;
+-		goto out_put_node;
+-	}
+-
+-	irq_chip->irq_mask = advk_pcie_irq_mask;
+-	irq_chip->irq_unmask = advk_pcie_irq_unmask;
+-
+ 	pcie->irq_domain =
+ 		irq_domain_add_linear(pcie_intc_node, PCI_NUM_INTX,
+ 				      &advk_pcie_irq_domain_ops, pcie);
+ 	if (!pcie->irq_domain) {
+ 		dev_err(dev, "Failed to get a INTx IRQ domain\n");
+ 		ret = -ENOMEM;
+-		goto out_put_node;
+ 	}
+ 
+-out_put_node:
+ 	of_node_put(pcie_intc_node);
+ 	return ret;
+ }
diff --git a/target/linux/generic/pending-6.12/890-usb-serial-add-support-for-CH348.patch b/target/linux/generic/pending-6.12/890-usb-serial-add-support-for-CH348.patch
new file mode 100644
index 0000000000..028ecf41f7
--- /dev/null
+++ b/target/linux/generic/pending-6.12/890-usb-serial-add-support-for-CH348.patch
@@ -0,0 +1,783 @@
+From df1357358eec062241bddd2995e7ef0ce86cf45a Mon Sep 17 00:00:00 2001
+X-Patchwork-Submitter: Corentin Labbe <clabbe@baylibre.com>
+X-Patchwork-Id: 13656881
+Message-Id: <20240507131522.3546113-2-clabbe@baylibre.com>
+X-Mailer: git-send-email 2.25.1
+In-Reply-To: <20240507131522.3546113-1-clabbe@baylibre.com>
+References: <20240507131522.3546113-1-clabbe@baylibre.com>
+Precedence: bulk
+X-Mailing-List: linux-usb@vger.kernel.org
+List-Id: <linux-usb.vger.kernel.org>
+From: Corentin Labbe <clabbe@baylibre.com>
+Date: Tue, 7 May 2024 13:15:22 +0000
+Subject: [PATCH v7] usb: serial: add support for CH348
+
+The CH348 is an USB octo port serial adapter.
+The device multiplexes all 8 ports in the same pair of Bulk endpoints.
+Since there is no public datasheet, unfortunately it remains some magic values
+
+Signed-off-by: Corentin Labbe <clabbe@baylibre.com>
+Tested-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+---
+ drivers/usb/serial/Kconfig  |   9 +
+ drivers/usb/serial/Makefile |   1 +
+ drivers/usb/serial/ch348.c  | 725 ++++++++++++++++++++++++++++++++++++
+ 3 files changed, 735 insertions(+)
+ create mode 100644 drivers/usb/serial/ch348.c
+
+--- a/drivers/usb/serial/Kconfig
++++ b/drivers/usb/serial/Kconfig
+@@ -112,6 +112,15 @@ config USB_SERIAL_CH341
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called ch341.
+ 
++config USB_SERIAL_CH348
++	tristate "USB Winchiphead CH348 Octo Port Serial Driver"
++	help
++	  Say Y here if you want to use a Winchiphead CH348 octo port
++	  USB to serial adapter.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called ch348.
++
+ config USB_SERIAL_WHITEHEAT
+ 	tristate "USB ConnectTech WhiteHEAT Serial Driver"
+ 	select USB_EZUSB_FX2
+--- a/drivers/usb/serial/Makefile
++++ b/drivers/usb/serial/Makefile
+@@ -15,6 +15,7 @@ obj-$(CONFIG_USB_SERIAL_AIRCABLE)		+= ai
+ obj-$(CONFIG_USB_SERIAL_ARK3116)		+= ark3116.o
+ obj-$(CONFIG_USB_SERIAL_BELKIN)			+= belkin_sa.o
+ obj-$(CONFIG_USB_SERIAL_CH341)			+= ch341.o
++obj-$(CONFIG_USB_SERIAL_CH348)			+= ch348.o
+ obj-$(CONFIG_USB_SERIAL_CP210X)			+= cp210x.o
+ obj-$(CONFIG_USB_SERIAL_CYBERJACK)		+= cyberjack.o
+ obj-$(CONFIG_USB_SERIAL_CYPRESS_M8)		+= cypress_m8.o
+--- /dev/null
++++ b/drivers/usb/serial/ch348.c
+@@ -0,0 +1,725 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * USB serial driver for USB to Octal UARTs chip ch348.
++ *
++ * Copyright (C) 2022 Corentin Labbe <clabbe@baylibre.com>
++ * With the help of Neil Armstrong <neil.armstrong@linaro.org>
++ * and the help of Martin Blumenstingl <martin.blumenstingl@googlemail.com>
++ */
++
++#include <linux/completion.h>
++#include <linux/errno.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/mutex.h>
++#include <linux/overflow.h>
++#include <linux/serial.h>
++#include <linux/slab.h>
++#include <linux/tty.h>
++#include <linux/tty_driver.h>
++#include <linux/tty_flip.h>
++#include <linux/usb.h>
++#include <linux/usb/serial.h>
++
++#define CH348_CMD_TIMEOUT   2000
++
++#define CH348_CTO_D	0x01
++#define CH348_CTO_R	0x02
++
++#define CH348_CTI_C	0x10
++#define CH348_CTI_DSR	0x20
++#define CH348_CTI_R	0x40
++#define CH348_CTI_DCD	0x80
++
++#define CH348_LO	0x02
++#define CH348_LP	0x04
++#define CH348_LF	0x08
++#define CH348_LB	0x10
++
++#define CMD_W_R		0xC0
++#define CMD_W_BR	0x80
++
++#define CMD_WB_E	0x90
++#define CMD_RB_E	0xC0
++
++#define M_NOR		0x00
++#define M_HF		0x03
++
++#define R_MOD		0x97
++#define R_IO_D		0x98
++#define R_IO_O		0x99
++#define R_IO_I		0x9b
++#define R_TM_O		0x9c
++#define R_INIT		0xa1
++
++#define R_C1		0x01
++#define R_C2		0x02
++#define R_C4		0x04
++#define R_C5		0x06
++
++#define R_II_B1		0x06
++#define R_II_B2		0x02
++#define R_II_B3		0x00
++
++#define CMD_VER		0x96
++
++#define CH348_RX_PORT_CHUNK_LENGTH	32
++#define CH348_RX_PORT_MAX_LENGTH	30
++
++struct ch348_rxbuf {
++	u8 port;
++	u8 length;
++	u8 data[CH348_RX_PORT_MAX_LENGTH];
++} __packed;
++
++struct ch348_txbuf {
++	u8 port;
++	__le16 length;
++	u8 data[];
++} __packed;
++
++#define CH348_TX_HDRSIZE offsetof(struct ch348_txbuf, data)
++
++struct ch348_initbuf {
++	u8 cmd;
++	u8 reg;
++	u8 port;
++	__be32 baudrate;
++	u8 format;
++	u8 paritytype;
++	u8 databits;
++	u8 rate;
++	u8 unknown;
++} __packed;
++
++#define CH348_MAXPORT 8
++
++/*
++ * The CH348 multiplexes rx & tx into a pair of Bulk USB endpoints for
++ * the 8 serial ports, and another pair of Bulk USB endpoints to
++ * set port settings and receive port status events.
++ *
++ * The USB serial cores ties every Bulk endpoints pairs to each ports,
++ * but in our case it will set port 0 with the rx/tx endpoints
++ * and port 1 with the setup/status endpoints.
++ *
++ * To still take advantage of the generic code, we (re-)initialize
++ * the USB serial port structure with the correct USB endpoint
++ * for read and write, and write proper process_read_urb()
++ * and prepare_write_buffer() to correctly (de-)multiplex data.
++ * Also we use a custom write() implementation to wait until the buffer
++ * has been fully transmitted to prevent TX buffer overruns.
++ */
++
++/*
++ * struct ch348_port - per-port information
++ * @uartmode:		UART port current mode
++ * @write_completion:	completion event when the TX buffer has been written out
++ */
++struct ch348_port {
++	u8 uartmode;
++	struct completion write_completion;
++};
++
++/*
++ * struct ch348 - main container for all this driver information
++ * @udev:		pointer to the CH348 USB device
++ * @ports:		List of per-port information
++ * @serial:		pointer to the serial structure
++ * @write_lock:		protect against concurrent writes so we don't lose data
++ * @cmd_ep:		endpoint number for configure operations
++ * @status_urb:		URB for status
++ * @status_buffer:	buffer used by status_urb
++ */
++struct ch348 {
++	struct usb_device *udev;
++	struct ch348_port ports[CH348_MAXPORT];
++	struct usb_serial *serial;
++
++	struct mutex write_lock;
++
++	int cmd_ep;
++
++	struct urb *status_urb;
++	u8 status_buffer[];
++};
++
++struct ch348_magic {
++	u8 action;
++	u8 reg;
++	u8 control;
++} __packed;
++
++struct ch348_status_entry {
++	u8 portnum:4;
++	u8 unused:4;
++	u8 reg_iir;
++	union {
++		u8 lsr_signal;
++		u8 modem_signal;
++		u8 init_data[10];
++	};
++} __packed;
++
++static void ch348_process_status_urb(struct urb *urb)
++{
++	struct ch348_status_entry *status_entry;
++	struct ch348 *ch348 = urb->context;
++	int ret, status = urb->status;
++	struct usb_serial_port *port;
++	unsigned int i, status_len;
++
++	switch (status) {
++	case 0:
++		/* success */
++		break;
++	case -ECONNRESET:
++	case -ENOENT:
++	case -ESHUTDOWN:
++		/* this urb is terminated, clean up */
++		dev_dbg(&urb->dev->dev, "%s - urb shutting down with status: %d\n",
++			__func__, status);
++		return;
++	default:
++		dev_err(&urb->dev->dev, "%s - nonzero urb status received: %d\n",
++			__func__, status);
++		goto exit;
++	}
++
++	if (urb->actual_length < 3) {
++		dev_warn(&ch348->udev->dev,
++			 "Received too short status buffer with %u bytes\n",
++			 urb->actual_length);
++		goto exit;
++	}
++
++	for (i = 0; i < urb->actual_length;) {
++		status_entry = urb->transfer_buffer + i;
++
++		if (status_entry->portnum >= CH348_MAXPORT) {
++			dev_warn(&ch348->udev->dev,
++				 "Invalid port %d in status entry\n",
++				 status_entry->portnum);
++			break;
++		}
++
++		port = ch348->serial->port[status_entry->portnum];
++		status_len = 3;
++
++		if (!status_entry->reg_iir) {
++			dev_dbg(&port->dev, "Ignoring status with zero reg_iir\n");
++		} else if (status_entry->reg_iir == R_INIT) {
++			status_len = 12;
++		} else if ((status_entry->reg_iir & 0x0f) == R_II_B1) {
++			if (status_entry->lsr_signal & CH348_LO)
++				port->icount.overrun++;
++			if (status_entry->lsr_signal & CH348_LP)
++				port->icount.parity++;
++			if (status_entry->lsr_signal & CH348_LF)
++				port->icount.frame++;
++			if (status_entry->lsr_signal & CH348_LF)
++				port->icount.brk++;
++		} else if ((status_entry->reg_iir & 0x0f) == R_II_B2) {
++			complete_all(&ch348->ports[status_entry->portnum].write_completion);
++		} else {
++			dev_warn(&port->dev,
++				 "Unsupported status with reg_iir 0x%02x\n",
++				 status_entry->reg_iir);
++		}
++
++		usb_serial_debug_data(&port->dev, __func__, status_len,
++				      urb->transfer_buffer + i);
++
++		i += status_len;
++	}
++
++exit:
++	ret = usb_submit_urb(urb, GFP_ATOMIC);
++	if (ret)
++		dev_err(&urb->dev->dev, "%s - usb_submit_urb failed; %d\n",
++			__func__, ret);
++}
++
++/*
++ * Some values came from vendor tree, and we have no meaning for them, this
++ * function simply use them.
++ */
++static int ch348_do_magic(struct ch348 *ch348, int portnum, u8 action, u8 reg, u8 control)
++{
++	struct ch348_magic *buffer;
++	int ret, len;
++
++	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
++	if (!buffer)
++		return -ENOMEM;
++
++	if (portnum < 4)
++		reg += 0x10 * portnum;
++	else
++		reg += 0x10 * (portnum - 4) + 0x08;
++
++	buffer->action = action;
++	buffer->reg = reg;
++	buffer->control = control;
++
++	ret = usb_bulk_msg(ch348->udev, ch348->cmd_ep, buffer, 3, &len,
++			   CH348_CMD_TIMEOUT);
++	if (ret)
++		dev_err(&ch348->udev->dev, "Failed to write magic err=%d\n", ret);
++
++	kfree(buffer);
++
++	return ret;
++}
++
++static int ch348_configure(struct ch348 *ch348, int portnum)
++{
++	int ret;
++
++	ret = ch348_do_magic(ch348, portnum, CMD_W_R, R_C2, 0x87);
++	if (ret)
++		return ret;
++
++	return ch348_do_magic(ch348, portnum, CMD_W_R, R_C4, 0x08);
++}
++
++static void ch348_process_read_urb(struct urb *urb)
++{
++	struct usb_serial_port *port = urb->context;
++	struct ch348 *ch348 = usb_get_serial_data(port->serial);
++	unsigned int portnum, usblen, i;
++	struct ch348_rxbuf *rxb;
++
++	if (urb->actual_length < 2) {
++		dev_dbg(&ch348->udev->dev, "Empty rx buffer\n");
++		return;
++	}
++
++	for (i = 0; i < urb->actual_length; i += CH348_RX_PORT_CHUNK_LENGTH) {
++		rxb = urb->transfer_buffer + i;
++		portnum = rxb->port;
++		if (portnum >= CH348_MAXPORT) {
++			dev_dbg(&ch348->udev->dev, "Invalid port %d\n", portnum);
++			break;
++		}
++
++		port = ch348->serial->port[portnum];
++
++		usblen = rxb->length;
++		if (usblen > CH348_RX_PORT_MAX_LENGTH) {
++			dev_dbg(&port->dev, "Invalid length %d for port %d\n",
++				usblen, portnum);
++			break;
++		}
++
++		tty_insert_flip_string(&port->port, rxb->data, usblen);
++		tty_flip_buffer_push(&port->port);
++		port->icount.rx += usblen;
++		usb_serial_debug_data(&port->dev, __func__, usblen, rxb->data);
++	}
++}
++
++static int ch348_prepare_write_buffer(struct usb_serial_port *port, void *dest, size_t size)
++{
++	struct ch348_txbuf *rxt = dest;
++	int count;
++
++	count = kfifo_out_locked(&port->write_fifo, rxt->data,
++				 size - CH348_TX_HDRSIZE, &port->lock);
++
++	rxt->port = port->port_number;
++	rxt->length = cpu_to_le16(count);
++
++	return count + CH348_TX_HDRSIZE;
++}
++
++static int ch348_write(struct tty_struct *tty, struct usb_serial_port *port,
++		       const unsigned char *buf, int count)
++{
++	struct ch348 *ch348 = usb_get_serial_data(port->serial);
++	struct ch348_port *ch348_port = &ch348->ports[port->port_number];
++	int ret, max_tx_size;
++
++	if (tty_get_baud_rate(tty) < 9600 && count >= 128)
++		/*
++		 * Writing larger buffers can take longer than the hardware
++		 * allows before discarding the write buffer. Limit the
++		 * transfer size in such cases.
++		 * These values have been found by empirical testing.
++		 */
++		max_tx_size = 128;
++	else
++		/*
++		* Only ingest as many bytes as we can transfer with one URB at
++		* a time. Once an URB has been written we need to wait for the
++		* R_II_B2 status event before we are allowed to send more data.
++		* If we ingest more data then usb_serial_generic_write() will
++		* internally try to process as much data as possible with any
++		* number of URBs without giving us the chance to wait in
++		* between transfers.
++		*/
++		max_tx_size = port->bulk_out_size - CH348_TX_HDRSIZE;
++
++	reinit_completion(&ch348_port->write_completion);
++
++	mutex_lock(&ch348->write_lock);
++
++	/*
++	 * For any (remaining) bytes that we did not transfer TTY core will
++	 * call us again, with the buffer and count adjusted to the remaining
++	 * data.
++	 */
++	ret = usb_serial_generic_write(tty, port, buf, min(count, max_tx_size));
++
++	mutex_unlock(&ch348->write_lock);
++
++	if (ret <= 0)
++		return ret;
++
++	if (!wait_for_completion_interruptible_timeout(&ch348_port->write_completion,
++						       msecs_to_jiffies(CH348_CMD_TIMEOUT))) {
++		dev_err_console(port, "Failed to wait for TX buffer flush\n");
++		return -ETIMEDOUT;
++	}
++
++	return ret;
++}
++
++static int ch348_set_uartmode(struct ch348 *ch348, int portnum, u8 mode)
++{
++	int ret;
++
++	if (ch348->ports[portnum].uartmode == M_NOR && mode == M_HF) {
++		ret = ch348_do_magic(ch348, portnum, CMD_W_BR, R_C4, 0x51);
++		if (ret)
++			return ret;
++		ch348->ports[portnum].uartmode = M_HF;
++	}
++
++	if (ch348->ports[portnum].uartmode == M_HF && mode == M_NOR) {
++		ret = ch348_do_magic(ch348, portnum, CMD_W_BR, R_C4, 0x50);
++		if (ret)
++			return ret;
++		ch348->ports[portnum].uartmode = M_NOR;
++	}
++	return 0;
++}
++
++static void ch348_set_termios(struct tty_struct *tty, struct usb_serial_port *port,
++			      const struct ktermios *termios_old)
++{
++	struct ch348 *ch348 = usb_get_serial_data(port->serial);
++	struct ktermios *termios = &tty->termios;
++	int ret, portnum = port->port_number;
++	struct ch348_initbuf *buffer;
++	speed_t	baudrate;
++	u8 format;
++
++	if (termios_old && !tty_termios_hw_change(&tty->termios, termios_old))
++		return;
++
++	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
++	if (!buffer) {
++		if (termios_old)
++			tty->termios = *termios_old;
++		return;
++	}
++
++	/*
++	 * The datasheet states that only baud rates in range of 1200..6000000
++	 * are supported. Tests however show that even baud rates as low as 50
++	 * and as high as 12000000 are working in practice.
++	 */
++	baudrate = clamp(tty_get_baud_rate(tty), 50, 12000000);
++
++	format = termios->c_cflag & CSTOPB ? 2 : 1;
++
++	buffer->paritytype = 0;
++	if (termios->c_cflag & PARENB) {
++		if (termios->c_cflag & PARODD)
++			buffer->paritytype += 1;
++		else
++			buffer->paritytype += 2;
++		if  (termios->c_cflag & CMSPAR)
++			buffer->paritytype += 2;
++	}
++
++	switch (C_CSIZE(tty)) {
++	case CS5:
++		buffer->databits = 5;
++		break;
++	case CS6:
++		buffer->databits = 6;
++		break;
++	case CS7:
++		buffer->databits = 7;
++		break;
++	case CS8:
++	default:
++		buffer->databits = 8;
++		break;
++	}
++	buffer->cmd = CMD_WB_E | (portnum & 0x0F);
++	buffer->reg = R_INIT;
++	buffer->port = portnum;
++	buffer->baudrate = cpu_to_be32(baudrate);
++
++	if (format == 2)
++		buffer->format = 0x02;
++	else if (format == 1)
++		buffer->format = 0x00;
++
++	buffer->rate = max_t(speed_t, 5, (10000 * 15 / baudrate) + 1);
++
++	ret = usb_bulk_msg(ch348->udev, ch348->cmd_ep, buffer,
++			   sizeof(*buffer), NULL, CH348_CMD_TIMEOUT);
++	if (ret < 0) {
++		dev_err(&ch348->udev->dev, "Failed to change line settings: err=%d\n",
++			ret);
++		goto out;
++	}
++
++	ret = ch348_do_magic(ch348, portnum, CMD_W_R, R_C1, 0x0F);
++	if (ret < 0)
++		goto out;
++
++	if (C_CRTSCTS(tty))
++		ret = ch348_set_uartmode(ch348, portnum, M_HF);
++	else
++		ret = ch348_set_uartmode(ch348, portnum, M_NOR);
++
++out:
++	kfree(buffer);
++}
++
++static int ch348_open(struct tty_struct *tty, struct usb_serial_port *port)
++{
++	struct ch348 *ch348 = usb_get_serial_data(port->serial);
++	int ret;
++
++	if (tty)
++		ch348_set_termios(tty, port, NULL);
++
++	ret = ch348_configure(ch348, port->port_number);
++	if (ret) {
++		dev_err(&ch348->udev->dev, "Fail to configure err=%d\n", ret);
++		return ret;
++	}
++
++	return usb_serial_generic_open(tty, port);
++}
++
++static int ch348_attach(struct usb_serial *serial)
++{
++	struct usb_endpoint_descriptor *epcmd, *epstatus;
++	struct usb_serial_port *port0 = serial->port[1];
++	struct usb_device *usb_dev = serial->dev;
++	int status_buffer_size, i, ret;
++	struct usb_interface *intf;
++	struct ch348 *ch348;
++
++	intf = usb_ifnum_to_if(usb_dev, 0);
++	epstatus = &intf->cur_altsetting->endpoint[2].desc;
++	epcmd = &intf->cur_altsetting->endpoint[3].desc;
++
++	status_buffer_size = usb_endpoint_maxp(epstatus);
++
++	ch348 = kzalloc(struct_size(ch348, status_buffer, status_buffer_size),
++			GFP_KERNEL);
++	if (!ch348)
++		return -ENOMEM;
++
++	usb_set_serial_data(serial, ch348);
++
++	ch348->udev = serial->dev;
++	ch348->serial = serial;
++	mutex_init(&ch348->write_lock);
++
++	for (i = 0; i < CH348_MAXPORT; i++)
++		init_completion(&ch348->ports[i].write_completion);
++
++	ch348->status_urb = usb_alloc_urb(0, GFP_KERNEL);
++	if (!ch348->status_urb) {
++		ret = -ENOMEM;
++		goto err_free_ch348;
++	}
++
++	usb_fill_bulk_urb(ch348->status_urb, ch348->udev,
++			  usb_rcvbulkpipe(ch348->udev, epstatus->bEndpointAddress),
++			  ch348->status_buffer, status_buffer_size,
++			  ch348_process_status_urb, ch348);
++
++	ret = usb_submit_urb(ch348->status_urb, GFP_KERNEL);
++	if (ret) {
++		dev_err(&ch348->udev->dev,
++			"%s - failed to submit status/interrupt urb %i\n",
++			__func__, ret);
++		goto err_free_status_urb;
++	}
++
++	ret = usb_serial_generic_submit_read_urbs(port0, GFP_KERNEL);
++	if (ret)
++		goto err_kill_status_urb;
++
++	ch348->cmd_ep = usb_sndbulkpipe(usb_dev, epcmd->bEndpointAddress);
++
++	return 0;
++
++err_kill_status_urb:
++	usb_kill_urb(ch348->status_urb);
++err_free_status_urb:
++	usb_free_urb(ch348->status_urb);
++err_free_ch348:
++	kfree(ch348);
++	return ret;
++}
++
++static void ch348_release(struct usb_serial *serial)
++{
++	struct ch348 *ch348 = usb_get_serial_data(serial);
++
++	usb_kill_urb(ch348->status_urb);
++	usb_free_urb(ch348->status_urb);
++
++	kfree(ch348);
++}
++
++static void ch348_print_version(struct usb_serial *serial)
++{
++	u8 *version_buf;
++	int ret;
++
++	version_buf = kzalloc(4, GFP_KERNEL);
++	if (!version_buf)
++		return;
++
++	ret = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
++			      CMD_VER,
++			      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
++			      0, 0, version_buf, 4, CH348_CMD_TIMEOUT);
++	if (ret < 0)
++		dev_dbg(&serial->dev->dev, "Failed to read CMD_VER: %d\n", ret);
++	else
++		dev_info(&serial->dev->dev, "Found WCH CH348%s\n",
++			 (version_buf[1] & 0x80) ? "Q" : "L");
++
++	kfree(version_buf);
++}
++
++static int ch348_probe(struct usb_serial *serial, const struct usb_device_id *id)
++{
++	struct usb_endpoint_descriptor *epread, *epwrite, *epstatus, *epcmd;
++	struct usb_device *usb_dev = serial->dev;
++	struct usb_interface *intf;
++	int ret;
++
++	intf = usb_ifnum_to_if(usb_dev, 0);
++
++	ret = usb_find_common_endpoints(intf->cur_altsetting, &epread, &epwrite,
++					NULL, NULL);
++	if (ret) {
++		dev_err(&serial->dev->dev, "Failed to find basic endpoints ret=%d\n", ret);
++		return ret;
++	}
++
++	epstatus = &intf->cur_altsetting->endpoint[2].desc;
++	if (!usb_endpoint_is_bulk_in(epstatus)) {
++		dev_err(&serial->dev->dev, "Missing second bulk in (STATUS/INT)\n");
++		return -ENODEV;
++	}
++
++	epcmd = &intf->cur_altsetting->endpoint[3].desc;
++	if (!usb_endpoint_is_bulk_out(epcmd)) {
++		dev_err(&serial->dev->dev, "Missing second bulk out (CMD)\n");
++		return -ENODEV;
++	}
++
++	ch348_print_version(serial);
++
++	return 0;
++}
++
++static int ch348_calc_num_ports(struct usb_serial *serial,
++				struct usb_serial_endpoints *epds)
++{
++	int i;
++
++	for (i = 1; i < CH348_MAXPORT; ++i) {
++		epds->bulk_out[i] = epds->bulk_out[0];
++		epds->bulk_in[i] = epds->bulk_in[0];
++	}
++
++	epds->num_bulk_out = CH348_MAXPORT;
++	epds->num_bulk_in = CH348_MAXPORT;
++
++	return CH348_MAXPORT;
++}
++
++static int ch348_suspend(struct usb_serial *serial, pm_message_t message)
++{
++	struct ch348 *ch348 = usb_get_serial_data(serial);
++
++	usb_kill_urb(ch348->status_urb);
++
++	return 0;
++}
++
++static int ch348_resume(struct usb_serial *serial)
++{
++	struct ch348 *ch348 = usb_get_serial_data(serial);
++	int ret;
++
++	ret = usb_submit_urb(ch348->status_urb, GFP_KERNEL);
++	if (ret) {
++		dev_err(&ch348->udev->dev,
++			"%s - failed to submit status/interrupt urb %i\n",
++			__func__, ret);
++		return ret;
++	}
++
++	ret = usb_serial_generic_resume(serial);
++	if (ret)
++		usb_kill_urb(ch348->status_urb);
++
++	return ret;
++}
++
++static const struct usb_device_id ch348_ids[] = {
++	{ USB_DEVICE(0x1a86, 0x55d9), },
++	{ /* sentinel */ }
++};
++
++MODULE_DEVICE_TABLE(usb, ch348_ids);
++
++static struct usb_serial_driver ch348_device = {
++	.driver = {
++		.owner = THIS_MODULE,
++		.name = "ch348",
++	},
++	.id_table =		ch348_ids,
++	.num_ports =		CH348_MAXPORT,
++	.num_bulk_in =		1,
++	.num_bulk_out =		1,
++	.open =			ch348_open,
++	.set_termios =		ch348_set_termios,
++	.process_read_urb =	ch348_process_read_urb,
++	.prepare_write_buffer =	ch348_prepare_write_buffer,
++	.write =		ch348_write,
++	.probe =		ch348_probe,
++	.calc_num_ports =	ch348_calc_num_ports,
++	.attach =		ch348_attach,
++	.release =		ch348_release,
++	.suspend =		ch348_suspend,
++	.resume =		ch348_resume,
++};
++
++static struct usb_serial_driver * const serial_drivers[] = {
++	&ch348_device, NULL
++};
++
++module_usb_serial_driver(serial_drivers, ch348_ids);
++
++MODULE_AUTHOR("Corentin Labbe <clabbe@baylibre.com>");
++MODULE_DESCRIPTION("USB CH348 Octo port serial converter driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/pending-6.12/891-dt-bindings-leds-Add-LED1202-LED-Controller.patch b/target/linux/generic/pending-6.12/891-dt-bindings-leds-Add-LED1202-LED-Controller.patch
new file mode 100644
index 0000000000..164256081a
--- /dev/null
+++ b/target/linux/generic/pending-6.12/891-dt-bindings-leds-Add-LED1202-LED-Controller.patch
@@ -0,0 +1,181 @@
+From: Vicentiu Galanopulo <vicentiu.galanopulo@remote-tech.co.uk>
+To: Pavel Machek <pavel@ucw.cz>, Lee Jones <lee@kernel.org>,
+	Rob Herring <robh@kernel.org>,
+	Krzysztof Kozlowski <krzk+dt@kernel.org>,
+	Conor Dooley <conor+dt@kernel.org>,
+	Jonathan Corbet <corbet@lwn.net>,
+	Vicentiu Galanopulo <vicentiu.galanopulo@remote-tech.co.uk>,
+	linux-leds@vger.kernel.org, devicetree@vger.kernel.org,
+	linux-kernel@vger.kernel.org, linux-doc@vger.kernel.org
+Cc: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Subject: [PATCH v11 2/3] dt-bindings: leds: Add LED1202 LED Controller
+Date: Wed, 18 Dec 2024 18:33:58 +0000	[thread overview]
+Message-ID: <20241218183401.41687-3-vicentiu.galanopulo@remote-tech.co.uk> (raw)
+In-Reply-To: <20241218183401.41687-1-vicentiu.galanopulo@remote-tech.co.uk>
+
+The LED1202 is a 12-channel low quiescent current LED driver with:
+  * Supply range from 2.6 V to 5 V
+  * 20 mA current capability per channel
+  * 1.8 V compatible I2C control interface
+  * 8-bit analog dimming individual control
+  * 12-bit local PWM resolution
+  * 8 programmable patterns
+
+If the led node is present in the controller then the channel is
+set to active.
+
+Signed-off-by: Vicentiu Galanopulo <vicentiu.galanopulo@remote-tech.co.uk>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+---
+    v1: https://lore.kernel.org/lkml/ZnCnnQfwuRueCIQ0@admins-Air/T/
+    v2: https://lore.kernel.org/all/ZniNdGgKyUMV-hjq@admins-Air/T/
+    v3: https://lore.kernel.org/all/ZniNdGgKyUMV-hjq@admins-Air/T/
+    
+    Changes in v4:
+      - remove label property, use devm_led_classdev_register_ext instead
+    Changes in v3:
+      - remove active property
+    Changes in v2:
+      - renamed label to remove color from it
+      - add color property for each node
+      - add function and function-enumerator property for each node
+
+ .../devicetree/bindings/leds/st,led1202.yaml  | 132 ++++++++++++++++++
+ 1 file changed, 132 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/leds/st,led1202.yaml
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/leds/st,led1202.yaml
+@@ -0,0 +1,132 @@
++# SPDX-License-Identifier: GPL-2.0-only OR BSD-2-Clause
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/leds/st,led1202.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: ST LED1202 LED controllers
++
++maintainers:
++  - Vicentiu Galanopulo <vicentiu.galanopulo@remote-tech.co.uk>
++
++description: |
++  The LED1202 is a 12-channel low quiescent current LED controller
++  programmable via I2C; The output current can be adjusted separately
++  for each channel by 8-bit analog and 12-bit digital dimming control.
++  Datasheet available at
++  https://www.st.com/en/power-management/led1202.html
++
++properties:
++  compatible:
++    const: st,led1202
++
++  reg:
++    maxItems: 1
++
++  "#address-cells":
++    const: 1
++
++  "#size-cells":
++    const: 0
++
++patternProperties:
++  "^led@[0-9a-f]$":
++    type: object
++    $ref: common.yaml#
++    unevaluatedProperties: false
++
++    properties:
++      reg:
++        minimum: 0
++        maximum: 11
++
++    required:
++      - reg
++
++required:
++  - compatible
++  - reg
++  - "#address-cells"
++  - "#size-cells"
++
++additionalProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/leds/common.h>
++
++    i2c {
++        #address-cells = <1>;
++        #size-cells = <0>;
++
++        led-controller@58 {
++            compatible = "st,led1202";
++            reg = <0x58>;
++            #address-cells = <1>;
++            #size-cells = <0>;
++
++            led@0 {
++                reg = <0x0>;
++                function = LED_FUNCTION_STATUS;
++                color = <LED_COLOR_ID_RED>;
++                function-enumerator = <1>;
++            };
++
++            led@1 {
++                reg = <0x1>;
++                function = LED_FUNCTION_STATUS;
++                color = <LED_COLOR_ID_GREEN>;
++                function-enumerator = <2>;
++            };
++
++            led@2 {
++                reg = <0x2>;
++                function = LED_FUNCTION_STATUS;
++                color = <LED_COLOR_ID_BLUE>;
++                function-enumerator = <3>;
++            };
++
++            led@3 {
++                reg = <0x3>;
++                function = LED_FUNCTION_STATUS;
++                color = <LED_COLOR_ID_RED>;
++                function-enumerator = <4>;
++            };
++
++            led@4 {
++                reg = <0x4>;
++                function = LED_FUNCTION_STATUS;
++                color = <LED_COLOR_ID_GREEN>;
++                function-enumerator = <5>;
++            };
++
++            led@5 {
++                reg = <0x5>;
++                function = LED_FUNCTION_STATUS;
++                color = <LED_COLOR_ID_BLUE>;
++                function-enumerator = <6>;
++            };
++
++            led@6 {
++                reg = <0x6>;
++                function = LED_FUNCTION_STATUS;
++                color = <LED_COLOR_ID_RED>;
++                function-enumerator = <7>;
++            };
++
++            led@7 {
++                reg = <0x7>;
++                function = LED_FUNCTION_STATUS;
++                color = <LED_COLOR_ID_GREEN>;
++                function-enumerator = <8>;
++            };
++
++            led@8 {
++                reg = <0x8>;
++                function = LED_FUNCTION_STATUS;
++                color = <LED_COLOR_ID_BLUE>;
++                function-enumerator = <9>;
++            };
++        };
++    };
++...
diff --git a/target/linux/generic/pending-6.12/892-leds-Add-LED1202-I2C-driver.patch b/target/linux/generic/pending-6.12/892-leds-Add-LED1202-I2C-driver.patch
new file mode 100644
index 0000000000..089f0921ff
--- /dev/null
+++ b/target/linux/generic/pending-6.12/892-leds-Add-LED1202-I2C-driver.patch
@@ -0,0 +1,513 @@
+From: Vicentiu Galanopulo <vicentiu.galanopulo@remote-tech.co.uk>
+To: Pavel Machek <pavel@ucw.cz>, Lee Jones <lee@kernel.org>,
+	Rob Herring <robh@kernel.org>,
+	Krzysztof Kozlowski <krzk+dt@kernel.org>,
+	Conor Dooley <conor+dt@kernel.org>,
+	Jonathan Corbet <corbet@lwn.net>,
+	Vicentiu Galanopulo <vicentiu.galanopulo@remote-tech.co.uk>,
+	linux-leds@vger.kernel.org, devicetree@vger.kernel.org,
+	linux-kernel@vger.kernel.org, linux-doc@vger.kernel.org
+Subject: [PATCH v11 3/3] leds: Add LED1202 I2C driver
+Date: Wed, 18 Dec 2024 18:33:59 +0000	[thread overview]
+Message-ID: <20241218183401.41687-4-vicentiu.galanopulo@remote-tech.co.uk> (raw)
+In-Reply-To: <20241218183401.41687-1-vicentiu.galanopulo@remote-tech.co.uk>
+
+The output current can be adjusted separately for each channel by 8-bit
+analog (current sink input) and 12-bit digital (PWM) dimming control. The
+LED1202 implements 12 low-side current generators with independent dimming
+control.
+Internal volatile memory allows the user to store up to 8 different patterns,
+each pattern is a particular output configuration in terms of PWM
+duty-cycle (on 4096 steps). Analog dimming (on 256 steps) is per channel but
+common to all patterns. Each device tree LED node will have a corresponding
+entry in /sys/class/leds with the label name. The brightness property
+corresponds to the per channel analog dimming, while the patterns[1-8] to the
+PWM dimming control.
+
+Signed-off-by: Vicentiu Galanopulo <vicentiu.galanopulo@remote-tech.co.uk>
+---
+    Changes in v10:
+      - update description help in Kconfig
+      - move st1202_led and st1202_chip into one line, declaration and definition
+    Changes in v9:
+      - log errors directly in st1202_write_reg and st1202_read_reg
+      - use mutex guards instead of lock/unlock
+      - remove i2c_set_clientdata
+    Changes in v7:
+      - fix st1202_brightness_get() error: uninitialized symbol 'value'
+    Changes in v6:
+      - fix build error
+    Changes in v5:
+      - remove unused macros
+      - switch to using devm_led_classdev_register_ext (struct st1202_led update)
+      - add prescalar_to_milliseconds (convert [22..5660]ms to [0..255] reg value)
+      - remove register range check in dt_init (range protected by yaml)
+      - address all review comments in v4
+    Changes in v4:
+      - Remove attributes/extended attributes implementation
+      - Use /sys/class/leds/<led>/hw_pattern (Pavel suggestion)
+      - Implement review findings of Christophe JAILLET
+    Changes in v3:
+      - Rename all ll1202 to st1202, including driver file name
+      - Convert all magic numbers to defines
+      - Refactor the show/store callbacks as per Lee's and Thomas's review
+      - Remove ll1202_get_channel and use dev_ext_attributes instead
+      - Log all error values for all the functions
+      - Use sysfs_emit for show callbacks
+    Changes in v2:
+      - Fix build error for device_attribute modes
+
+ drivers/leds/Kconfig       |  10 +
+ drivers/leds/Makefile      |   1 +
+ drivers/leds/leds-st1202.c | 416 +++++++++++++++++++++++++++++++++++++
+ 3 files changed, 427 insertions(+)
+ create mode 100644 drivers/leds/leds-st1202.c
+
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -931,6 +931,16 @@ config LEDS_LM36274
+ 	  Say Y to enable the LM36274 LED driver for TI LMU devices.
+ 	  This supports the LED device LM36274.
+ 
++config LEDS_ST1202
++	tristate "LED Support for STMicroelectronics LED1202 I2C chips"
++	depends on LEDS_CLASS
++	depends on I2C
++	depends on OF
++	select LEDS_TRIGGERS
++	help
++	  Say Y to enable support for LEDs connected to LED1202
++	  LED driver chips accessed via the I2C bus.
++
+ config LEDS_TPS6105X
+ 	tristate "LED support for TI TPS6105X"
+ 	depends on LEDS_CLASS
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -82,6 +82,7 @@ obj-$(CONFIG_LEDS_PWM)			+= leds-pwm.o
+ obj-$(CONFIG_LEDS_REGULATOR)		+= leds-regulator.o
+ obj-$(CONFIG_LEDS_SC27XX_BLTC)		+= leds-sc27xx-bltc.o
+ obj-$(CONFIG_LEDS_SUN50I_A100)		+= leds-sun50i-a100.o
++obj-$(CONFIG_LEDS_ST1202)		+= leds-st1202.o
+ obj-$(CONFIG_LEDS_SUNFIRE)		+= leds-sunfire.o
+ obj-$(CONFIG_LEDS_SYSCON)		+= leds-syscon.o
+ obj-$(CONFIG_LEDS_TCA6507)		+= leds-tca6507.o
+--- /dev/null
++++ b/drivers/leds/leds-st1202.c
+@@ -0,0 +1,416 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * LED driver for STMicroelectronics LED1202 chip
++ *
++ * Copyright (C) 2024 Remote-Tech Ltd. UK
++ */
++
++#include <linux/cleanup.h>
++#include <linux/ctype.h>
++#include <linux/delay.h>
++#include <linux/err.h>
++#include <linux/gpio.h>
++#include <linux/i2c.h>
++#include <linux/leds.h>
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/string.h>
++
++#define ST1202_CHAN_DISABLE_ALL            0x00
++#define ST1202_CHAN_ENABLE_HIGH            0x03
++#define ST1202_CHAN_ENABLE_LOW             0x02
++#define ST1202_CONFIG_REG                  0x04
++/* PATS: Pattern sequence feature enable */
++#define ST1202_CONFIG_REG_PATS             BIT(7)
++/* PATSR: Pattern sequence runs (self-clear when sequence is finished) */
++#define ST1202_CONFIG_REG_PATSR            BIT(6)
++#define ST1202_CONFIG_REG_SHFT             BIT(3)
++#define ST1202_DEV_ENABLE                  0x01
++#define ST1202_DEV_ENABLE_ON               BIT(0)
++#define ST1202_DEV_ENABLE_RESET            BIT(7)
++#define ST1202_DEVICE_ID                   0x00
++#define ST1202_ILED_REG0                   0x09
++#define ST1202_MAX_LEDS                    12
++#define ST1202_MAX_PATTERNS                8
++#define ST1202_MILLIS_PATTERN_DUR_MAX      5660
++#define ST1202_MILLIS_PATTERN_DUR_MIN      22
++#define ST1202_PATTERN_DUR                 0x16
++#define ST1202_PATTERN_PWM                 0x1E
++#define ST1202_PATTERN_REP                 0x15
++
++struct st1202_led {
++	struct fwnode_handle *fwnode;
++	struct led_classdev led_cdev;
++	struct st1202_chip *chip;
++	bool is_active;
++	int led_num;
++};
++
++struct st1202_chip {
++	struct i2c_client *client;
++	struct mutex lock;
++	struct st1202_led leds[ST1202_MAX_LEDS];
++};
++
++static struct st1202_led *cdev_to_st1202_led(struct led_classdev *cdev)
++{
++	return container_of(cdev, struct st1202_led, led_cdev);
++}
++
++static int st1202_read_reg(struct st1202_chip *chip, int reg, uint8_t *val)
++{
++	struct device *dev = &chip->client->dev;
++	int ret;
++
++	ret = i2c_smbus_read_byte_data(chip->client, reg);
++	if (ret < 0) {
++		dev_err(dev, "Failed to read register [0x%x]: %d\n", reg, ret);
++		return ret;
++	}
++
++	*val = (uint8_t)ret;
++	return 0;
++}
++
++static int st1202_write_reg(struct st1202_chip *chip, int reg, uint8_t val)
++{
++	struct device *dev = &chip->client->dev;
++	int ret;
++
++	ret = i2c_smbus_write_byte_data(chip->client, reg, val);
++	if (ret != 0)
++		dev_err(dev, "Failed to write %d to register [0x%x]: %d\n", val, reg, ret);
++
++	return ret;
++}
++
++static uint8_t st1202_prescalar_to_miliseconds(unsigned int value)
++{
++	return value / ST1202_MILLIS_PATTERN_DUR_MIN - 1;
++}
++
++static int st1202_pwm_pattern_write(struct st1202_chip *chip, int led_num,
++				int pattern, unsigned int value)
++{
++	u8 value_l, value_h;
++	int ret;
++
++	value_l = (u8)value;
++	value_h = (u8)(value >> 8);
++
++	/*
++	 *  Datasheet: Register address low = 1Eh + 2*(xh) + 18h*(yh),
++	 *  where x is the channel number (led number) in hexadecimal (x = 00h .. 0Bh)
++	 *  and y is the pattern number in hexadecimal (y = 00h .. 07h)
++	 */
++	ret = st1202_write_reg(chip, (ST1202_PATTERN_PWM + (led_num * 2) + 0x18 * pattern),
++				value_l);
++	if (ret != 0)
++		return ret;
++
++	/*
++	 * Datasheet: Register address high = 1Eh + 01h + 2(xh) +18h*(yh),
++	 * where x is the channel number in hexadecimal (x = 00h .. 0Bh)
++	 * and y is the pattern number in hexadecimal (y = 00h .. 07h)
++	 */
++	ret = st1202_write_reg(chip, (ST1202_PATTERN_PWM + 0x1 + (led_num * 2) + 0x18 * pattern),
++				value_h);
++	if (ret != 0)
++		return ret;
++
++	return 0;
++}
++
++static int st1202_duration_pattern_write(struct st1202_chip *chip, int pattern,
++					unsigned int value)
++{
++	return st1202_write_reg(chip, (ST1202_PATTERN_DUR + pattern),
++				st1202_prescalar_to_miliseconds(value));
++}
++
++static void st1202_brightness_set(struct led_classdev *led_cdev,
++				enum led_brightness value)
++{
++	struct st1202_led *led = cdev_to_st1202_led(led_cdev);
++	struct st1202_chip *chip = led->chip;
++
++	guard(mutex)(&chip->lock);
++
++	st1202_write_reg(chip, ST1202_ILED_REG0 + led->led_num, value);
++}
++
++static enum led_brightness st1202_brightness_get(struct led_classdev *led_cdev)
++{
++	struct st1202_led *led = cdev_to_st1202_led(led_cdev);
++	struct st1202_chip *chip = led->chip;
++	u8 value = 0;
++
++	guard(mutex)(&chip->lock);
++
++	st1202_read_reg(chip, ST1202_ILED_REG0 + led->led_num, &value);
++
++	return value;
++}
++
++static int st1202_channel_set(struct st1202_chip *chip, int led_num, bool active)
++{
++	u8 chan_low, chan_high;
++	int ret;
++
++	guard(mutex)(&chip->lock);
++
++	if (led_num <= 7) {
++		ret = st1202_read_reg(chip, ST1202_CHAN_ENABLE_LOW, &chan_low);
++		if (ret < 0)
++			return ret;
++
++		chan_low = active ? chan_low | BIT(led_num) : chan_low & ~BIT(led_num);
++
++		ret = st1202_write_reg(chip, ST1202_CHAN_ENABLE_LOW, chan_low);
++		if (ret < 0)
++			return ret;
++
++	} else {
++		ret = st1202_read_reg(chip, ST1202_CHAN_ENABLE_HIGH, &chan_high);
++		if (ret < 0)
++			return ret;
++
++		chan_high = active ? chan_high | (BIT(led_num) >> 8) :
++					chan_high & ~(BIT(led_num) >> 8);
++
++		ret = st1202_write_reg(chip, ST1202_CHAN_ENABLE_HIGH, chan_high);
++		if (ret < 0)
++			return ret;
++	}
++
++	return 0;
++}
++
++static int st1202_led_set(struct led_classdev *ldev, enum led_brightness value)
++{
++	struct st1202_led *led = cdev_to_st1202_led(ldev);
++	struct st1202_chip *chip = led->chip;
++
++	return st1202_channel_set(chip, led->led_num, value == LED_OFF ? false : true);
++}
++
++static int st1202_led_pattern_clear(struct led_classdev *ldev)
++{
++	struct st1202_led *led = cdev_to_st1202_led(ldev);
++	struct st1202_chip *chip = led->chip;
++	int ret;
++
++	guard(mutex)(&chip->lock);
++
++	for (int patt = 0; patt < ST1202_MAX_PATTERNS; patt++) {
++		ret = st1202_pwm_pattern_write(chip, led->led_num, patt, LED_OFF);
++		if (ret != 0)
++			return ret;
++
++		ret = st1202_duration_pattern_write(chip, patt, ST1202_MILLIS_PATTERN_DUR_MIN);
++		if (ret != 0)
++			return ret;
++	}
++
++	return 0;
++}
++
++static int st1202_led_pattern_set(struct led_classdev *ldev,
++				struct led_pattern *pattern,
++				u32 len, int repeat)
++{
++	struct st1202_led *led = cdev_to_st1202_led(ldev);
++	struct st1202_chip *chip = led->chip;
++	int ret;
++
++	if (len > ST1202_MAX_PATTERNS)
++		return -EINVAL;
++
++	guard(mutex)(&chip->lock);
++
++	for (int patt = 0; patt < len; patt++) {
++		if (pattern[patt].delta_t < ST1202_MILLIS_PATTERN_DUR_MIN ||
++				pattern[patt].delta_t > ST1202_MILLIS_PATTERN_DUR_MAX)
++			return -EINVAL;
++
++		ret = st1202_pwm_pattern_write(chip, led->led_num, patt, pattern[patt].brightness);
++		if (ret != 0)
++			return ret;
++
++		ret = st1202_duration_pattern_write(chip, patt, pattern[patt].delta_t);
++		if (ret != 0)
++			return ret;
++	}
++
++	ret = st1202_write_reg(chip, ST1202_PATTERN_REP, repeat);
++	if (ret != 0)
++		return ret;
++
++	ret = st1202_write_reg(chip, ST1202_CONFIG_REG, (ST1202_CONFIG_REG_PATSR |
++							ST1202_CONFIG_REG_PATS | ST1202_CONFIG_REG_SHFT));
++	if (ret != 0)
++		return ret;
++
++	return 0;
++}
++
++static int st1202_dt_init(struct st1202_chip *chip)
++{
++	struct device *dev = &chip->client->dev;
++	struct st1202_led *led;
++	int err, reg;
++
++	for_each_available_child_of_node_scoped(dev_of_node(dev), child) {
++		struct led_init_data init_data = {};
++
++		err = of_property_read_u32(child, "reg", &reg);
++		if (err)
++			return dev_err_probe(dev, err, "Invalid register\n");
++
++		led = &chip->leds[reg];
++		led->is_active = true;
++		led->fwnode = of_fwnode_handle(child);
++
++		led->led_cdev.max_brightness = U8_MAX;
++		led->led_cdev.brightness_set_blocking = st1202_led_set;
++		led->led_cdev.pattern_set = st1202_led_pattern_set;
++		led->led_cdev.pattern_clear = st1202_led_pattern_clear;
++		led->led_cdev.default_trigger = "pattern";
++
++		init_data.fwnode = led->fwnode;
++		init_data.devicename = "st1202";
++		init_data.default_label = ":";
++
++		err = devm_led_classdev_register_ext(dev, &led->led_cdev, &init_data);
++		if (err < 0)
++			return dev_err_probe(dev, err, "Failed to register LED class device\n");
++
++		led->led_cdev.brightness_set = st1202_brightness_set;
++		led->led_cdev.brightness_get = st1202_brightness_get;
++	}
++
++	return 0;
++}
++
++static int st1202_setup(struct st1202_chip *chip)
++{
++	int ret;
++
++	guard(mutex)(&chip->lock);
++
++	/*
++	 * Once the supply voltage is applied, the LED1202 executes some internal checks,
++	 * afterwords it stops the oscillator and puts the internal LDO in quiescent mode.
++	 * To start the device, EN bit must be set inside the “Device Enable” register at
++	 * address 01h. As soon as EN is set, the LED1202 loads the adjustment parameters
++	 * from the internal non-volatile memory and performs an auto-calibration procedure
++	 * in order to increase the output current precision.
++	 * Such initialization lasts about 6.5 ms.
++	 */
++
++	/* Reset the chip during setup */
++	ret = st1202_write_reg(chip, ST1202_DEV_ENABLE, ST1202_DEV_ENABLE_RESET);
++	if (ret < 0)
++		return ret;
++
++	/* Enable phase-shift delay feature */
++	ret = st1202_write_reg(chip, ST1202_CONFIG_REG, ST1202_CONFIG_REG_SHFT);
++	if (ret < 0)
++		return ret;
++
++	/* Enable the device */
++	ret = st1202_write_reg(chip, ST1202_DEV_ENABLE, ST1202_DEV_ENABLE_ON);
++	if (ret < 0)
++		return ret;
++
++	/* Duration of initialization */
++	usleep_range(6500, 10000);
++
++	/* Deactivate all LEDS (channels) and activate only the ones found in Device Tree */
++	ret = st1202_write_reg(chip, ST1202_CHAN_ENABLE_LOW, ST1202_CHAN_DISABLE_ALL);
++	if (ret < 0)
++		return ret;
++
++	ret = st1202_write_reg(chip, ST1202_CHAN_ENABLE_HIGH, ST1202_CHAN_DISABLE_ALL);
++	if (ret < 0)
++		return ret;
++
++	ret = st1202_write_reg(chip, ST1202_CONFIG_REG,
++				ST1202_CONFIG_REG_PATS | ST1202_CONFIG_REG_PATSR);
++	if (ret < 0)
++		return ret;
++
++	return 0;
++}
++
++static int st1202_probe(struct i2c_client *client)
++{
++	struct st1202_chip *chip;
++	struct st1202_led *led;
++	int ret;
++
++	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
++		return dev_err_probe(&client->dev, -EIO, "SMBUS Byte Data not Supported\n");
++
++	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
++	if (!chip)
++		return -ENOMEM;
++
++	devm_mutex_init(&client->dev, &chip->lock);
++	chip->client = client;
++
++	ret = st1202_dt_init(chip);
++	if (ret < 0)
++		return ret;
++
++	ret = st1202_setup(chip);
++	if (ret < 0)
++		return ret;
++
++	for (int i = 0; i < ST1202_MAX_LEDS; i++) {
++		led = &chip->leds[i];
++		led->chip = chip;
++		led->led_num = i;
++
++		if (!led->is_active)
++			continue;
++
++		ret = st1202_channel_set(led->chip, led->led_num, true);
++		if (ret < 0)
++			return dev_err_probe(&client->dev, ret,
++					"Failed to activate LED channel\n");
++
++		ret = st1202_led_pattern_clear(&led->led_cdev);
++		if (ret < 0)
++			return dev_err_probe(&client->dev, ret,
++					"Failed to clear LED pattern\n");
++	}
++
++	return 0;
++}
++
++static const struct i2c_device_id st1202_id[] = {
++	{ "st1202-i2c" },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(i2c, st1202_id);
++
++static const struct of_device_id st1202_dt_ids[] = {
++	{ .compatible = "st,led1202" },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, st1202_dt_ids);
++
++static struct i2c_driver st1202_driver = {
++	.driver = {
++		.name = "leds-st1202",
++		.of_match_table = of_match_ptr(st1202_dt_ids),
++	},
++	.probe = st1202_probe,
++	.id_table = st1202_id,
++};
++module_i2c_driver(st1202_driver);
++
++MODULE_AUTHOR("Remote Tech LTD");
++MODULE_DESCRIPTION("STMicroelectronics LED1202 : 12-channel constant current LED driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/pending-6.12/893-leds_st1202-Fix-NULL-pointer-access-error.patch b/target/linux/generic/pending-6.12/893-leds_st1202-Fix-NULL-pointer-access-error.patch
new file mode 100644
index 0000000000..d763c5dfbd
--- /dev/null
+++ b/target/linux/generic/pending-6.12/893-leds_st1202-Fix-NULL-pointer-access-error.patch
@@ -0,0 +1,70 @@
+From e3da313ebcace17f1227566fe1b0d0c3883061f9 Mon Sep 17 00:00:00 2001
+From: Manuel Fombuena <fombuena@outlook.com>
+Date: Fri, 17 Jan 2025 12:31:49 +0000
+Subject: [PATCH 1/5] leds: leds-st1202: fix NULL pointer access on race
+ condition
+
+st1202_dt_init() calls devm_led_classdev_register_ext() before the
+internal data structures are properly setup, so the leds become visible
+to user space while being partially initialized, leading to a window
+where trying to access them causes a NULL pointer access.
+
+This change moves devm_led_classdev_register_ext() to the last thing to
+happen during initialization to eliminate it.
+
+Signed-off-by: Manuel Fombuena <fombuena@outlook.com>
+---
+ drivers/leds/leds-st1202.c | 21 ++++++++++-----------
+ 1 file changed, 10 insertions(+), 11 deletions(-)
+
+--- a/drivers/leds/leds-st1202.c
++++ b/drivers/leds/leds-st1202.c
+@@ -261,8 +261,6 @@ static int st1202_dt_init(struct st1202_
+ 	int err, reg;
+ 
+ 	for_each_available_child_of_node_scoped(dev_of_node(dev), child) {
+-		struct led_init_data init_data = {};
+-
+ 		err = of_property_read_u32(child, "reg", &reg);
+ 		if (err)
+ 			return dev_err_probe(dev, err, "Invalid register\n");
+@@ -276,15 +274,6 @@ static int st1202_dt_init(struct st1202_
+ 		led->led_cdev.pattern_set = st1202_led_pattern_set;
+ 		led->led_cdev.pattern_clear = st1202_led_pattern_clear;
+ 		led->led_cdev.default_trigger = "pattern";
+-
+-		init_data.fwnode = led->fwnode;
+-		init_data.devicename = "st1202";
+-		init_data.default_label = ":";
+-
+-		err = devm_led_classdev_register_ext(dev, &led->led_cdev, &init_data);
+-		if (err < 0)
+-			return dev_err_probe(dev, err, "Failed to register LED class device\n");
+-
+ 		led->led_cdev.brightness_set = st1202_brightness_set;
+ 		led->led_cdev.brightness_get = st1202_brightness_get;
+ 	}
+@@ -368,6 +357,7 @@ static int st1202_probe(struct i2c_clien
+ 		return ret;
+ 
+ 	for (int i = 0; i < ST1202_MAX_LEDS; i++) {
++		struct led_init_data init_data = {};
+ 		led = &chip->leds[i];
+ 		led->chip = chip;
+ 		led->led_num = i;
+@@ -384,6 +374,15 @@ static int st1202_probe(struct i2c_clien
+ 		if (ret < 0)
+ 			return dev_err_probe(&client->dev, ret,
+ 					"Failed to clear LED pattern\n");
++
++		init_data.fwnode = led->fwnode;
++		init_data.devicename = "st1202";
++		init_data.default_label = ":";
++
++		ret = devm_led_classdev_register_ext(&client->dev, &led->led_cdev, &init_data);
++		if (ret < 0)
++			return dev_err_probe(&client->dev, ret,
++					"Failed to register LED class device\n");
+ 	}
+ 
+ 	return 0;
diff --git a/target/linux/generic/pending-6.12/900-net-ag71xx-fix-qca9530-and-qca9550-mdio-probe.patch b/target/linux/generic/pending-6.12/900-net-ag71xx-fix-qca9530-and-qca9550-mdio-probe.patch
new file mode 100644
index 0000000000..c0e318e86e
--- /dev/null
+++ b/target/linux/generic/pending-6.12/900-net-ag71xx-fix-qca9530-and-qca9550-mdio-probe.patch
@@ -0,0 +1,25 @@
+From 440415703692af4548e836832ef0434e87fbc357 Mon Sep 17 00:00:00 2001
+From: Oskari Lemmela <oskari@lemmela.net>
+Date: Sat, 13 Jul 2024 18:56:59 +0300
+Subject: [PATCH] net: ag71xx: fix qca9530 and qca9550 mdio probe
+
+Newer QCA9530 and QCA9550 devices should use same div table as AR933X.
+
+Fixes: d51b6ce441d3 ("net: ethernet: add ag71xx driver")
+Signed-off-by: Oskari Lemmela <oskari@lemmela.net>
+---
+ drivers/net/ethernet/atheros/ag71xx.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/ethernet/atheros/ag71xx.c
++++ b/drivers/net/ethernet/atheros/ag71xx.c
+@@ -641,7 +641,8 @@ static int ag71xx_mdio_get_divider(struc
+ 	if (!ref_clock)
+ 		return -EINVAL;
+ 
+-	if (ag71xx_is(ag, AR9330) || ag71xx_is(ag, AR9340)) {
++	if (ag71xx_is(ag, AR9330) || ag71xx_is(ag, AR9340) ||
++	    ag71xx_is(ag, QCA9530) || ag71xx_is(ag, QCA9550)) {
+ 		table = ar933x_mdio_div_table;
+ 		ndivs = ARRAY_SIZE(ar933x_mdio_div_table);
+ 	} else if (ag71xx_is(ag, AR7240)) {
diff --git a/target/linux/generic/pending-6.12/920-mangle_bootargs.patch b/target/linux/generic/pending-6.12/920-mangle_bootargs.patch
new file mode 100644
index 0000000000..11f2edf5f4
--- /dev/null
+++ b/target/linux/generic/pending-6.12/920-mangle_bootargs.patch
@@ -0,0 +1,71 @@
+From: Imre Kaloz <kaloz@openwrt.org>
+Subject: init: add CONFIG_MANGLE_BOOTARGS and disable it by default
+
+Enabling this option renames the bootloader supplied root=
+and rootfstype= variables, which might have to be know but
+would break the automatisms OpenWrt uses.
+
+Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
+---
+ init/Kconfig |  9 +++++++++
+ init/main.c  | 24 ++++++++++++++++++++++++
+ 2 files changed, 33 insertions(+)
+
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -1884,6 +1884,15 @@ config ARCH_HAS_MEMBARRIER_CALLBACKS
+ config ARCH_HAS_MEMBARRIER_SYNC_CORE
+ 	bool
+ 
++config MANGLE_BOOTARGS
++	bool "Rename offending bootargs"
++	depends on EXPERT
++	help
++	  Sometimes the bootloader passed bogus root= and rootfstype=
++	  parameters to the kernel, and while you want to ignore them,
++	  you need to know the values f.e. to support dual firmware
++	  layouts on the flash.
++
+ config HAVE_PERF_EVENTS
+ 	bool
+ 	help
+--- a/init/main.c
++++ b/init/main.c
+@@ -621,6 +621,29 @@ static inline void setup_nr_cpu_ids(void
+ static inline void smp_prepare_cpus(unsigned int maxcpus) { }
+ #endif
+ 
++#ifdef CONFIG_MANGLE_BOOTARGS
++static void __init mangle_bootargs(char *command_line)
++{
++	char *rootdev;
++	char *rootfs;
++
++	rootdev = strstr(command_line, "root=/dev/mtdblock");
++
++	if (rootdev)
++		strncpy(rootdev, "mangled_rootblock=", 18);
++
++	rootfs = strstr(command_line, "rootfstype");
++
++	if (rootfs)
++		strncpy(rootfs, "mangled_fs", 10);
++
++}
++#else
++static void __init mangle_bootargs(char *command_line)
++{
++}
++#endif
++
+ /*
+  * We need to store the untouched command line for future reference.
+  * We also need to store the touched command line since the parameter
+@@ -927,6 +950,7 @@ void start_kernel(void)
+ 	jump_label_init();
+ 	static_call_init();
+ 	early_security_init();
++	mangle_bootargs(command_line);
+ 	setup_boot_config();
+ 	setup_command_line(command_line);
+ 	setup_nr_cpu_ids();
diff --git a/target/linux/ipq40xx/patches-6.6/700-net-ipqess-introduce-the-Qualcomm-IPQESS-driver.patch b/target/linux/ipq40xx/patches-6.6/700-net-ipqess-introduce-the-Qualcomm-IPQESS-driver.patch
index b8557bacc7..3303cfed1d 100644
--- a/target/linux/ipq40xx/patches-6.6/700-net-ipqess-introduce-the-Qualcomm-IPQESS-driver.patch
+++ b/target/linux/ipq40xx/patches-6.6/700-net-ipqess-introduce-the-Qualcomm-IPQESS-driver.patch
@@ -88,7 +88,7 @@ Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
 +ipq_ess-objs := ipqess.o ipqess_ethtool.o
 --- /dev/null
 +++ b/drivers/net/ethernet/qualcomm/ipqess/ipqess.c
-@@ -0,0 +1,1251 @@
+@@ -0,0 +1,1249 @@
 +// SPDX-License-Identifier: GPL-2.0 OR ISC
 +/* Copyright (c) 2014 - 2017, The Linux Foundation. All rights reserved.
 + * Copyright (c) 2017 - 2018, John Crispin <john@phrozen.org>
@@ -1300,7 +1300,7 @@ Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
 +	return err;
 +}
 +
-+static int ipqess_axi_remove(struct platform_device *pdev)
++static void ipqess_axi_remove(struct platform_device *pdev)
 +{
 +	const struct net_device *netdev = platform_get_drvdata(pdev);
 +	struct ipqess *ess = netdev_priv(netdev);
@@ -1313,8 +1313,6 @@ Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
 +
 +	phylink_destroy(ess->phylink);
 +	clk_disable_unprepare(ess->ess_clk);
-+
-+	return 0;
 +}
 +
 +static const struct of_device_id ipqess_of_mtable[] = {
@@ -1329,7 +1327,7 @@ Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
 +		.of_match_table = ipqess_of_mtable,
 +	},
 +	.probe    = ipqess_axi_probe,
-+	.remove   = ipqess_axi_remove,
++	.remove_new   = ipqess_axi_remove,
 +};
 +
 +module_platform_driver(ipqess_axi_driver);
diff --git a/target/linux/ipq40xx/patches-6.6/706-net-dsa-qca8k-add-IPQ4019-built-in-switch-support.patch b/target/linux/ipq40xx/patches-6.6/706-net-dsa-qca8k-add-IPQ4019-built-in-switch-support.patch
index 73e99f2bdc..c0b926b7a1 100644
--- a/target/linux/ipq40xx/patches-6.6/706-net-dsa-qca8k-add-IPQ4019-built-in-switch-support.patch
+++ b/target/linux/ipq40xx/patches-6.6/706-net-dsa-qca8k-add-IPQ4019-built-in-switch-support.patch
@@ -78,7 +78,7 @@ Signed-off-by: Robert Marko <robert.marko@sartura.hr>
  		if (dsa_is_cpu_port(priv->ds, i))
 --- /dev/null
 +++ b/drivers/net/dsa/qca/qca8k-ipq4019.c
-@@ -0,0 +1,950 @@
+@@ -0,0 +1,948 @@
 +// SPDX-License-Identifier: GPL-2.0
 +/*
 + * Copyright (C) 2009 Felix Fietkau <nbd@nbd.name>
@@ -990,14 +990,14 @@ Signed-off-by: Robert Marko <robert.marko@sartura.hr>
 +	return dsa_register_switch(priv->ds);
 +}
 +
-+static int
++static void
 +qca8k_ipq4019_remove(struct platform_device *pdev)
 +{
 +	struct qca8k_priv *priv = dev_get_drvdata(&pdev->dev);
 +	int i;
 +
 +	if (!priv)
-+		return 0;
++		return;
 +
 +	for (i = 0; i < QCA8K_IPQ4019_NUM_PORTS; i++)
 +		qca8k_port_set_status(priv, i, 0);
@@ -1005,8 +1005,6 @@ Signed-off-by: Robert Marko <robert.marko@sartura.hr>
 +	dsa_unregister_switch(priv->ds);
 +
 +	platform_set_drvdata(pdev, NULL);
-+
-+	return 0;
 +}
 +
 +static const struct of_device_id qca8k_ipq4019_of_match[] = {
@@ -1016,7 +1014,7 @@ Signed-off-by: Robert Marko <robert.marko@sartura.hr>
 +
 +static struct platform_driver qca8k_ipq4019_driver = {
 +	.probe = qca8k_ipq4019_probe,
-+	.remove = qca8k_ipq4019_remove,
++	.remove_new = qca8k_ipq4019_remove,
 +	.driver = {
 +		.name = "qca8k-ipq4019",
 +		.of_match_table = qca8k_ipq4019_of_match,
diff --git a/target/linux/lantiq/patches-6.6/0035-owrt-lantiq-wifi-and-ethernet-eeprom-handling.patch b/target/linux/lantiq/patches-6.6/0035-owrt-lantiq-wifi-and-ethernet-eeprom-handling.patch
index 3ece97052b..f65959b1de 100644
--- a/target/linux/lantiq/patches-6.6/0035-owrt-lantiq-wifi-and-ethernet-eeprom-handling.patch
+++ b/target/linux/lantiq/patches-6.6/0035-owrt-lantiq-wifi-and-ethernet-eeprom-handling.patch
@@ -149,7 +149,7 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +static struct platform_driver ath5k_eeprom_driver = {
 +	.driver		= {
 +		.name		= "ath5k,eeprom",
-+		.of_match_table	= of_match_ptr(ath5k_eeprom_ids),
++		.of_match_table	= ath5k_eeprom_ids,
 +	},
 +};
 +
diff --git a/target/linux/layerscape/patches-6.6/701-staging-add-fsl_ppfe-driver.patch b/target/linux/layerscape/patches-6.6/701-staging-add-fsl_ppfe-driver.patch
index 59bbb964c5..964b452f7d 100644
--- a/target/linux/layerscape/patches-6.6/701-staging-add-fsl_ppfe-driver.patch
+++ b/target/linux/layerscape/patches-6.6/701-staging-add-fsl_ppfe-driver.patch
@@ -10254,7 +10254,7 @@ Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
 +#endif /* _PFE_HW_H_ */
 --- /dev/null
 +++ b/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
-@@ -0,0 +1,383 @@
+@@ -0,0 +1,380 @@
 +// SPDX-License-Identifier: GPL-2.0+
 +/*
 + * Copyright 2015-2016 Freescale Semiconductor, Inc.
@@ -10516,14 +10516,13 @@ Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
 +/*
 + * pfe_platform_remove -
 + */
-+static int pfe_platform_remove(struct platform_device *pdev)
++static void pfe_platform_remove(struct platform_device *pdev)
 +{
 +	struct pfe *pfe = platform_get_drvdata(pdev);
-+	int rc;
 +
 +	pr_info("%s\n", __func__);
 +
-+	rc = pfe_remove(pfe);
++	pfe_remove(pfe);
 +
 +	iounmap(pfe->cbus_baseaddr);
 +
@@ -10532,8 +10531,6 @@ Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
 +	platform_set_drvdata(pdev, NULL);
 +
 +	kfree(pfe);
-+
-+	return rc;
 +}
 +
 +#ifdef CONFIG_PM
@@ -10624,7 +10621,7 @@ Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
 +
 +static struct platform_driver pfe_platform_driver = {
 +	.probe = pfe_platform_probe,
-+	.remove = pfe_platform_remove,
++	.remove_new = pfe_platform_remove,
 +	.driver = {
 +		.name = "pfe",
 +		.of_match_table = pfe_match,
diff --git a/target/linux/mediatek/files/drivers/net/phy/rtk/rtl8367s_mdio.c b/target/linux/mediatek/files/drivers/net/phy/rtk/rtl8367s_mdio.c
index d958d622e0..d70aeebad9 100644
--- a/target/linux/mediatek/files/drivers/net/phy/rtk/rtl8367s_mdio.c
+++ b/target/linux/mediatek/files/drivers/net/phy/rtk/rtl8367s_mdio.c
@@ -283,17 +283,15 @@ static int rtk_gsw_probe(struct platform_device *pdev)
 	
 }
 
-static int rtk_gsw_remove(struct platform_device *pdev)
+static void rtk_gsw_remove(struct platform_device *pdev)
 {
 	platform_set_drvdata(pdev, NULL);
 	gsw_debug_proc_exit();
-
-	return 0;
 }
 
 static struct platform_driver gsw_driver = {
 	.probe = rtk_gsw_probe,
-	.remove = rtk_gsw_remove,
+	.remove_new = rtk_gsw_remove,
 	.driver = {
 		.name = "rtk-gsw",
 		.of_match_table = rtk_gsw_match,
diff --git a/target/linux/mediatek/modules.mk b/target/linux/mediatek/modules.mk
index 8480123725..ade8d60ab3 100644
--- a/target/linux/mediatek/modules.mk
+++ b/target/linux/mediatek/modules.mk
@@ -18,7 +18,7 @@ $(eval $(call KernelPackage,ata-ahci-mtk))
 define KernelPackage/btmtkuart
   SUBMENU:=Other modules
   TITLE:=MediaTek HCI UART driver
-  DEPENDS:=@TARGET_mediatek_mt7622 +kmod-bluetooth +mt7622bt-firmware
+  DEPENDS:=@TARGET_mediatek_mt7622 +kmod-bluetooth +kmod-btmtk +mt7622bt-firmware
   KCONFIG:=CONFIG_BT_MTKUART
   FILES:= \
 	$(LINUX_DIR)/drivers/bluetooth/btmtkuart.ko
diff --git a/target/linux/mediatek/mt7622/config-6.6 b/target/linux/mediatek/mt7622/config-6.6
index bdfb06af76..a832806bd0 100644
--- a/target/linux/mediatek/mt7622/config-6.6
+++ b/target/linux/mediatek/mt7622/config-6.6
@@ -424,7 +424,6 @@ CONFIG_RPS=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_DRV_MT7622=y
 CONFIG_RTC_I2C_AND_SPI=y
-# CONFIG_RTL8261N_PHY is not set
 CONFIG_RTL8367S_GSW=y
 CONFIG_RWSEM_SPIN_ON_OWNER=y
 CONFIG_SCHED_MC=y
diff --git a/target/linux/mediatek/mt7623/config-6.6 b/target/linux/mediatek/mt7623/config-6.6
index 8fd0f3a599..b5360df9d9 100644
--- a/target/linux/mediatek/mt7623/config-6.6
+++ b/target/linux/mediatek/mt7623/config-6.6
@@ -529,7 +529,6 @@ CONFIG_RTC_CLASS=y
 # CONFIG_RTC_DRV_MT7622 is not set
 CONFIG_RTC_I2C_AND_SPI=y
 CONFIG_RTC_MC146818_LIB=y
-# CONFIG_RTL8261N_PHY is not set
 # CONFIG_RTL8367S_GSW is not set
 CONFIG_RWSEM_SPIN_ON_OWNER=y
 # CONFIG_SERIAL_8250_DMA is not set
diff --git a/target/linux/mediatek/mt7629/config-6.6 b/target/linux/mediatek/mt7629/config-6.6
index 661f31ced6..728b5728d4 100644
--- a/target/linux/mediatek/mt7629/config-6.6
+++ b/target/linux/mediatek/mt7629/config-6.6
@@ -300,7 +300,6 @@ CONFIG_REGMAP_MMIO=y
 CONFIG_RESET_CONTROLLER=y
 CONFIG_RFS_ACCEL=y
 CONFIG_RPS=y
-# CONFIG_RTL8261N_PHY is not set
 # CONFIG_RTL8367S_GSW is not set
 CONFIG_RWSEM_SPIN_ON_OWNER=y
 CONFIG_SCSI=y
diff --git a/target/linux/mediatek/patches-6.6/500-gsw-rtl8367s-mt7622-support.patch b/target/linux/mediatek/patches-6.6/500-gsw-rtl8367s-mt7622-support.patch
index bb7e7be6d2..639403807f 100644
--- a/target/linux/mediatek/patches-6.6/500-gsw-rtl8367s-mt7622-support.patch
+++ b/target/linux/mediatek/patches-6.6/500-gsw-rtl8367s-mt7622-support.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -416,6 +416,12 @@ config ROCKCHIP_PHY
+@@ -418,6 +418,12 @@ config ROCKCHIP_PHY
  	help
  	  Currently supports the integrated Ethernet PHY.
  
@@ -15,8 +15,8 @@
  	select CRC16
 --- a/drivers/net/phy/Makefile
 +++ b/drivers/net/phy/Makefile
-@@ -102,6 +102,7 @@ obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
- obj-$(CONFIG_REALTEK_PHY)	+= realtek/
+@@ -103,6 +103,7 @@ obj-$(CONFIG_REALTEK_PHY)	+= realtek/
+ obj-y				+= rtl8261n/
  obj-$(CONFIG_RENESAS_PHY)	+= uPD60620.o
  obj-$(CONFIG_ROCKCHIP_PHY)	+= rockchip.o
 +obj-$(CONFIG_RTL8367S_GSW)	+= rtk/
diff --git a/target/linux/qualcommax/Makefile b/target/linux/qualcommax/Makefile
index 3c9bb840e3..b3b6dc6118 100644
--- a/target/linux/qualcommax/Makefile
+++ b/target/linux/qualcommax/Makefile
@@ -6,7 +6,7 @@ BOARDNAME:=Qualcomm Atheros 802.11ax WiSoC-s
 FEATURES:=squashfs ramdisk fpu nand rtc emmc
 KERNELNAME:=Image
 CPU_TYPE:=cortex-a53
-SUBTARGETS:=ipq807x ipq60xx
+SUBTARGETS:=ipq807x ipq60xx ipq50xx
 
 KERNEL_PATCHVER:=6.6
 
diff --git a/target/linux/qualcommax/files/arch/arm64/boot/dts/qcom/ipq5018-ess.dtsi b/target/linux/qualcommax/files/arch/arm64/boot/dts/qcom/ipq5018-ess.dtsi
new file mode 100644
index 0000000000..a42b7bbeaa
--- /dev/null
+++ b/target/linux/qualcommax/files/arch/arm64/boot/dts/qcom/ipq5018-ess.dtsi
@@ -0,0 +1,116 @@
+#include <dt-bindings/net/qcom-ipq-ess.h>
+
+&soc {
+	ess_instance: ess-instance {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		num_devices = <1>;
+
+		switch: ess-switch@39c00000 {
+			compatible = "qcom,ess-switch-ipq50xx";
+			device_id = <0>;
+			cmnblk_clk = "internal_96MHz";
+			reg = <0x39c00000 0x200000>;
+			switch_access_mode = "local bus";
+			clocks = <&gcc GCC_CMN_BLK_AHB_CLK>,
+				 <&gcc GCC_CMN_BLK_SYS_CLK>,
+				 <&gcc GCC_UNIPHY_AHB_CLK>,
+				 <&gcc GCC_UNIPHY_SYS_CLK>,
+				 <&gcc GCC_MDIO0_AHB_CLK>,
+				 <&gcc GCC_MDIO1_AHB_CLK>,
+				 <&gcc GCC_GMAC0_CFG_CLK>,
+				 <&gcc GCC_GMAC0_SYS_CLK>,
+				 <&gcc GCC_GMAC1_CFG_CLK>,
+				 <&gcc GCC_GMAC1_SYS_CLK>,
+				 <&gcc GCC_GEPHY_RX_CLK>,
+				 <&gcc GCC_GEPHY_TX_CLK>,
+				 <&gcc GCC_UNIPHY_RX_CLK>,
+				 <&gcc GCC_UNIPHY_TX_CLK>,
+				 <&gcc GCC_GMAC0_RX_CLK>,
+				 <&gcc GCC_GMAC0_TX_CLK>,
+				 <&gcc GCC_GMAC1_RX_CLK>,
+				 <&gcc GCC_GMAC1_TX_CLK>,
+				 <&gcc GCC_SNOC_GMAC0_AHB_CLK>,
+				 <&gcc GCC_SNOC_GMAC1_AHB_CLK>,
+				 <&gcc GCC_GMAC0_PTP_CLK>,
+				 <&gcc GCC_GMAC1_PTP_CLK>;
+			clock-names = "cmn_ahb_clk",
+				      "cmn_sys_clk",
+				      "uniphy_ahb_clk",
+				      "uniphy_sys_clk",
+				      "gcc_mdio0_ahb_clk",
+				      "gcc_mdio1_ahb_clk",
+				      "gcc_gmac0_cfg_clk",
+				      "gcc_gmac0_sys_clk",
+				      "gcc_gmac1_cfg_clk",
+				      "gcc_gmac1_sys_clk",
+				      "uniphy0_port1_rx_clk",
+				      "uniphy0_port1_tx_clk",
+				      "uniphy1_port5_rx_clk",
+				      "uniphy1_port5_tx_clk",
+				      "nss_port1_rx_clk",
+				      "nss_port1_tx_clk",
+				      "nss_port2_rx_clk",
+				      "nss_port2_tx_clk",
+				      "gcc_snoc_gmac0_ahb_clk",
+				      "gcc_snoc_gmac1_ahb_clk",
+				      "gcc_gmac0_ptp_clk",
+				      "gcc_gmac1_ptp_clk";
+			resets = <&gcc GCC_GMAC0_BCR>,
+				 <&gcc GCC_GMAC1_BCR>,
+				 <&gcc GCC_UNIPHY_BCR>,
+				 <&gcc GCC_UNIPHY_SOFT_RESET>;
+			reset-names = "gmac0_bcr_rst",
+				      "gmac1_bcr_rst",
+				      "uniphy_bcr_rst",
+				      "uniphy1_soft_rst";
+
+			status = "disabled";
+		};
+	};
+
+	ess-uniphy@98000 {
+		compatible = "qcom,ess-uniphy";
+		reg = <0x98000 0x800>;
+		uniphy_access_mode = "local bus";
+	};
+
+	nss-dp-common {
+		compatible = "qcom,nss-dp-common";
+		qcom,tcsr-base = <0x01937000>;
+	};
+
+	dp1: dp1 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <1>;
+
+		reg = <0x39C00000 0x10000>;
+		interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&gcc GCC_SNOC_GMAC0_AXI_CLK>;
+		clock-names = "nss-snoc-gmac-axi-clk";
+
+		qcom,mactype = <2>; /* GMAC_HAL_TYPE_SYN_GMAC */
+		local-mac-address = [000000000000];
+		phy-mode = "internal";
+		phy-handle = <&ge_phy>;
+
+		status = "disabled";
+	};
+
+	dp2: dp2 {
+		device_type = "network";
+		compatible = "qcom,nss-dp";
+		qcom,id = <2>;
+
+		reg = <0x39D00000 0x10000>;
+		interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&gcc GCC_SNOC_GMAC1_AXI_CLK>;
+		clock-names = "nss-snoc-gmac-axi-clk";
+
+		qcom,mactype = <2>; /* GMAC_HAL_TYPE_SYN_GMAC */
+		local-mac-address = [000000000000];
+		phy-mode = "sgmii";
+		status = "disabled";
+	};
+};
diff --git a/target/linux/qualcommax/image/ipq50xx.mk b/target/linux/qualcommax/image/ipq50xx.mk
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/target/linux/qualcommax/ipq50xx/config-default b/target/linux/qualcommax/ipq50xx/config-default
new file mode 100644
index 0000000000..63c1d9dd97
--- /dev/null
+++ b/target/linux/qualcommax/ipq50xx/config-default
@@ -0,0 +1,26 @@
+CONFIG_QCOM_APM=y
+CONFIG_IPQ_GCC_5018=y
+CONFIG_PINCTRL_IPQ5018=y
+
+CONFIG_MTD_SPI_NAND=y
+CONFIG_SPI_QPIC_SNAND=y
+
+CONFIG_IPQ_CMN_PLL=y
+CONFIG_IPQ5018_PHY=y
+CONFIG_NET_DSA=y
+CONFIG_NET_DSA_QCA8K=y
+CONFIG_NET_DSA_TAG_QCA=y
+CONFIG_QCA83XX_PHY=y
+
+CONFIG_QCOM_Q6V5_MPD=y
+CONFIG_QCOM_QMI_HELPERS=y
+
+CONFIG_PHY_QCOM_UNIPHY_PCIE_28LP=y
+CONFIG_PCIE_QCOM=y
+
+CONFIG_PWM=y
+CONFIG_PWM_IPQ=y
+CONFIG_LEDS_PWM=y
+
+CONFIG_PHY_QCOM_M31_USB=y
+CONFIG_USB_DWC3_QCOM=y
diff --git a/target/linux/qualcommax/ipq50xx/target.mk b/target/linux/qualcommax/ipq50xx/target.mk
new file mode 100644
index 0000000000..2e68329265
--- /dev/null
+++ b/target/linux/qualcommax/ipq50xx/target.mk
@@ -0,0 +1,7 @@
+SUBTARGET:=ipq50xx
+BOARDNAME:=Qualcomm Atheros IPQ50xx
+DEFAULT_PACKAGES += ath11k-firmware-ipq5018
+
+define Target/Description
+	Build firmware images for Qualcomm Atheros IPQ50xx based boards.
+endef
diff --git a/target/linux/qualcommax/ipq60xx/config-default b/target/linux/qualcommax/ipq60xx/config-default
index 9ce4b04293..ac9743eb2c 100644
--- a/target/linux/qualcommax/ipq60xx/config-default
+++ b/target/linux/qualcommax/ipq60xx/config-default
@@ -1,6 +1,9 @@
 CONFIG_IPQ_GCC_6018=y
 CONFIG_MTD_SPLIT_FIT_FW=y
 CONFIG_PINCTRL_IPQ6018=y
+CONFIG_PWM=y
+CONFIG_PWM_IPQ=y
+CONFIG_PWM_SYSFS=y
 CONFIG_QCOM_APM=y
 # CONFIG_QCOM_CLK_SMD_RPM is not set
 # CONFIG_QCOM_RPMPD is not set
diff --git a/target/linux/qualcommax/patches-6.6/0065-v6.7-arm64-dts-qcom-ipq5018-add-watchdog.patch b/target/linux/qualcommax/patches-6.6/0065-v6.7-arm64-dts-qcom-ipq5018-add-watchdog.patch
new file mode 100644
index 0000000000..8e973e63f2
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0065-v6.7-arm64-dts-qcom-ipq5018-add-watchdog.patch
@@ -0,0 +1,31 @@
+From 9cbaee8379e620f82112002f973adde19679df31 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 16 Aug 2023 18:14:00 +0200
+Subject: [PATCH] arm64: dts: qcom: ipq5018: add watchdog
+
+Add the required DT node for watchdog operation.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Link: https://lore.kernel.org/r/20230816161455.3310629-2-robimarko@gmail.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -181,6 +181,13 @@
+ 			};
+ 		};
+ 
++		watchdog: watchdog@b017000 {
++			compatible = "qcom,apss-wdt-ipq5018", "qcom,kpss-wdt";
++			reg = <0x0b017000 0x40>;
++			interrupts = <GIC_SPI 3 IRQ_TYPE_EDGE_RISING>;
++			clocks = <&sleep_clk>;
++		};
++
+ 		timer@b120000 {
+ 			compatible = "arm,armv7-timer-mem";
+ 			reg = <0x0b120000 0x1000>;
diff --git a/target/linux/qualcommax/patches-6.6/0066-v6.7-dt-bindings-firmware-qcom-scm-support-indicating-SDI-default-state.patch b/target/linux/qualcommax/patches-6.6/0066-v6.7-dt-bindings-firmware-qcom-scm-support-indicating-SDI-default-state.patch
new file mode 100644
index 0000000000..46d3c61398
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0066-v6.7-dt-bindings-firmware-qcom-scm-support-indicating-SDI-default-state.patch
@@ -0,0 +1,41 @@
+From 92dab9ea5f389c12828283146c60054642453a91 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 16 Aug 2023 18:45:38 +0200
+Subject: [PATCH] dt-bindings: firmware: qcom,scm: support indicating SDI
+ default state
+
+IPQ5018 has SDI (Secure Debug Image) enabled by TZ by default, and that
+means that WDT being asserted or just trying to reboot will hang the board
+in the debug mode and only pulling the power and repowering will help.
+Some IPQ4019 boards like Google WiFI have it enabled as well.
+
+So, lets add a boolean property to indicate that SDI is enabled by default
+and thus needs to be disabled by the kernel.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+Acked-by: Mukesh Ojha <quic_mojha@quicinc.com>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Reviewed-by: Brian Norris <computersforpeace@gmail.com>
+Link: https://lore.kernel.org/r/20230816164641.3371878-1-robimarko@gmail.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ Documentation/devicetree/bindings/firmware/qcom,scm.yaml | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/Documentation/devicetree/bindings/firmware/qcom,scm.yaml
++++ b/Documentation/devicetree/bindings/firmware/qcom,scm.yaml
+@@ -89,6 +89,14 @@ properties:
+       protocol to handle sleeping SCM calls.
+     maxItems: 1
+ 
++  qcom,sdi-enabled:
++    description:
++      Indicates that the SDI (Secure Debug Image) has been enabled by TZ
++      by default and it needs to be disabled.
++      If not disabled WDT assertion or reboot will cause the board to hang
++      in the debug mode.
++    type: boolean
++
+   qcom,dload-mode:
+     $ref: /schemas/types.yaml#/definitions/phandle-array
+     items:
diff --git a/target/linux/qualcommax/patches-6.6/0067-v6.7-firmware-qcom-scm-disable-SDI-if-required.patch b/target/linux/qualcommax/patches-6.6/0067-v6.7-firmware-qcom-scm-disable-SDI-if-required.patch
new file mode 100644
index 0000000000..9df758ae1b
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0067-v6.7-firmware-qcom-scm-disable-SDI-if-required.patch
@@ -0,0 +1,83 @@
+From ff4aa3bc98258a240b9bbab53fd8d2fb8184c485 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 16 Aug 2023 18:45:39 +0200
+Subject: [PATCH] firmware: qcom_scm: disable SDI if required
+
+IPQ5018 has SDI (Secure Debug Image) enabled by TZ by default, and that
+means that WDT being asserted or just trying to reboot will hang the board
+in the debug mode and only pulling the power and repowering will help.
+Some IPQ4019 boards like Google WiFI have it enabled as well.
+
+Luckily, SDI can be disabled via an SCM call.
+
+So, lets use the boolean DT property to identify boards that have SDI
+enabled by default and use the SCM call to disable SDI during SCM probe.
+It is important to disable it as soon as possible as we might have a WDT
+assertion at any time which would then leave the board in debug mode,
+thus disabling it during SCM removal is not enough.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+Reviewed-by: Guru Das Srinagesh <quic_gurus@quicinc.com>
+Link: https://lore.kernel.org/r/20230816164641.3371878-2-robimarko@gmail.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ drivers/firmware/qcom_scm.c | 30 ++++++++++++++++++++++++++++++
+ drivers/firmware/qcom_scm.h |  1 +
+ 2 files changed, 31 insertions(+)
+
+--- a/drivers/firmware/qcom_scm.c
++++ b/drivers/firmware/qcom_scm.c
+@@ -410,6 +410,29 @@ int qcom_scm_set_remote_state(u32 state,
+ }
+ EXPORT_SYMBOL_GPL(qcom_scm_set_remote_state);
+ 
++static int qcom_scm_disable_sdi(void)
++{
++	int ret;
++	struct qcom_scm_desc desc = {
++		.svc = QCOM_SCM_SVC_BOOT,
++		.cmd = QCOM_SCM_BOOT_SDI_CONFIG,
++		.args[0] = 1, /* Disable watchdog debug */
++		.args[1] = 0, /* Disable SDI */
++		.arginfo = QCOM_SCM_ARGS(2),
++		.owner = ARM_SMCCC_OWNER_SIP,
++	};
++	struct qcom_scm_res res;
++
++	ret = qcom_scm_clk_enable();
++	if (ret)
++		return ret;
++	ret = qcom_scm_call(__scm->dev, &desc, &res);
++
++	qcom_scm_clk_disable();
++
++	return ret ? : res.result[0];
++}
++
+ static int __qcom_scm_set_dload_mode(struct device *dev, bool enable)
+ {
+ 	struct qcom_scm_desc desc = {
+@@ -1473,6 +1496,13 @@ static int qcom_scm_probe(struct platfor
+ 
+ 	__get_convention();
+ 
++
++	/*
++	 * Disable SDI if indicated by DT that it is enabled by default.
++	 */
++	if (of_property_read_bool(pdev->dev.of_node, "qcom,sdi-enabled"))
++		qcom_scm_disable_sdi();
++
+ 	/*
+ 	 * If requested enable "download mode", from this point on warmboot
+ 	 * will cause the boot stages to enter download mode, unless
+--- a/drivers/firmware/qcom_scm.h
++++ b/drivers/firmware/qcom_scm.h
+@@ -80,6 +80,7 @@ extern int scm_legacy_call(struct device
+ #define QCOM_SCM_SVC_BOOT		0x01
+ #define QCOM_SCM_BOOT_SET_ADDR		0x01
+ #define QCOM_SCM_BOOT_TERMINATE_PC	0x02
++#define QCOM_SCM_BOOT_SDI_CONFIG	0x09
+ #define QCOM_SCM_BOOT_SET_DLOAD_MODE	0x10
+ #define QCOM_SCM_BOOT_SET_ADDR_MC	0x11
+ #define QCOM_SCM_BOOT_SET_REMOTE_STATE	0x0a
diff --git a/target/linux/qualcommax/patches-6.6/0068-v6.7-dt-bindings-qcom-scm-document-IPQ5018-compatible.patch b/target/linux/qualcommax/patches-6.6/0068-v6.7-dt-bindings-qcom-scm-document-IPQ5018-compatible.patch
new file mode 100644
index 0000000000..d36ccddd27
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0068-v6.7-dt-bindings-qcom-scm-document-IPQ5018-compatible.patch
@@ -0,0 +1,25 @@
+From f6aa7386bc40b552eea8ec1b1d2168afe3b31110 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 16 Aug 2023 18:45:40 +0200
+Subject: [PATCH] dt-bindings: firmware: qcom,scm: document IPQ5018 compatible
+
+It seems that IPQ5018 compatible was never documented in the bindings.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Link: https://lore.kernel.org/r/20230816164641.3371878-3-robimarko@gmail.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ Documentation/devicetree/bindings/firmware/qcom,scm.yaml | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/Documentation/devicetree/bindings/firmware/qcom,scm.yaml
++++ b/Documentation/devicetree/bindings/firmware/qcom,scm.yaml
+@@ -24,6 +24,7 @@ properties:
+           - qcom,scm-apq8064
+           - qcom,scm-apq8084
+           - qcom,scm-ipq4019
++          - qcom,scm-ipq5018
+           - qcom,scm-ipq5332
+           - qcom,scm-ipq6018
+           - qcom,scm-ipq806x
diff --git a/target/linux/qualcommax/patches-6.6/0069-v6.7-arm64-dts-qcom-IPQ5018-indicate-that-SDI-shoud-be-disabled.patch b/target/linux/qualcommax/patches-6.6/0069-v6.7-arm64-dts-qcom-IPQ5018-indicate-that-SDI-shoud-be-disabled.patch
new file mode 100644
index 0000000000..6d598bf50f
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0069-v6.7-arm64-dts-qcom-IPQ5018-indicate-that-SDI-shoud-be-disabled.patch
@@ -0,0 +1,26 @@
+From 79796e87215db9587d6c66ec6f6781e091bc6464 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 16 Aug 2023 18:45:41 +0200
+Subject: [PATCH] arm64: dts: qcom: ipq5018: indicate that SDI should be
+ disabled
+
+Now that SCM has support for indicating that SDI has been enabled by
+default, lets set the property so SCM disables it during probing.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+Link: https://lore.kernel.org/r/20230816164641.3371878-4-robimarko@gmail.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -57,6 +57,7 @@
+ 	firmware {
+ 		scm {
+ 			compatible = "qcom,scm-ipq5018", "qcom,scm";
++			qcom,sdi-enabled;
+ 		};
+ 	};
+ 
diff --git a/target/linux/qualcommax/patches-6.6/0070-v6.7-dt-bindings-phy-qcom-m31-Add-IPQ5018-compatible.patch b/target/linux/qualcommax/patches-6.6/0070-v6.7-dt-bindings-phy-qcom-m31-Add-IPQ5018-compatible.patch
new file mode 100644
index 0000000000..777212249e
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0070-v6.7-dt-bindings-phy-qcom-m31-Add-IPQ5018-compatible.patch
@@ -0,0 +1,28 @@
+From 1852dfaacd3f4358bbfca134b63a02bbb30c1136 Mon Sep 17 00:00:00 2001
+From: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Date: Mon, 4 Sep 2023 12:06:32 +0530
+Subject: [PATCH] dt-bindings: phy: qcom,m31: Add IPQ5018 compatible
+
+IPQ5332 qcom,m31 phy driver can support IPQ5018.
+
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Link: https://lore.kernel.org/r/20230904063635.24975-2-quic_nsekar@quicinc.com
+Signed-off-by: Vinod Koul <vkoul@kernel.org>
+---
+ .../devicetree/bindings/phy/qcom,ipq5332-usb-hsphy.yaml       | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/Documentation/devicetree/bindings/phy/qcom,ipq5332-usb-hsphy.yaml
++++ b/Documentation/devicetree/bindings/phy/qcom,ipq5332-usb-hsphy.yaml
+@@ -17,7 +17,9 @@ description:
+ properties:
+   compatible:
+     items:
+-      - const: qcom,ipq5332-usb-hsphy
++      - enum:
++          - qcom,ipq5018-usb-hsphy
++          - qcom,ipq5332-usb-hsphy
+ 
+   "#phy-cells":
+     const: 0
diff --git a/target/linux/qualcommax/patches-6.6/0071-v6.7-phy-qcom-m31-Add-compatible-phy-init-sequence-for-IPQ5018.patch b/target/linux/qualcommax/patches-6.6/0071-v6.7-phy-qcom-m31-Add-compatible-phy-init-sequence-for-IPQ5018.patch
new file mode 100644
index 0000000000..248b47c694
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0071-v6.7-phy-qcom-m31-Add-compatible-phy-init-sequence-for-IPQ5018.patch
@@ -0,0 +1,89 @@
+From 68320e35f8cb1987b4ad34347fc7033832da99e3 Mon Sep 17 00:00:00 2001
+From: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Date: Mon, 4 Sep 2023 12:06:33 +0530
+Subject: [PATCH] phy: qcom-m31: Add compatible, phy init sequence for IPQ5018
+
+Add phy init sequence and compatible string for IPQ5018
+chipset.
+
+Signed-off-by: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Link: https://lore.kernel.org/r/20230904063635.24975-3-quic_nsekar@quicinc.com
+Signed-off-by: Vinod Koul <vkoul@kernel.org>
+---
+ drivers/phy/qualcomm/phy-qcom-m31.c | 51 +++++++++++++++++++++++++++++
+ 1 file changed, 51 insertions(+)
+
+--- a/drivers/phy/qualcomm/phy-qcom-m31.c
++++ b/drivers/phy/qualcomm/phy-qcom-m31.c
+@@ -82,6 +82,50 @@ struct m31_priv_data {
+ 	unsigned int			nregs;
+ };
+ 
++static const struct m31_phy_regs m31_ipq5018_regs[] = {
++	{
++		.off = USB_PHY_CFG0,
++		.val = UTMI_PHY_OVERRIDE_EN
++	},
++	{
++		.off = USB_PHY_UTMI_CTRL5,
++		.val = POR_EN,
++		.delay = 15
++	},
++	{
++		.off = USB_PHY_FSEL_SEL,
++		.val = FREQ_SEL
++	},
++	{
++		.off = USB_PHY_HS_PHY_CTRL_COMMON0,
++		.val = COMMONONN | FSEL | RETENABLEN
++	},
++	{
++		.off = USB_PHY_REFCLK_CTRL,
++		.val = CLKCORE
++	},
++	{
++		.off = USB_PHY_UTMI_CTRL5,
++		.val = POR_EN
++	},
++	{
++		.off = USB_PHY_HS_PHY_CTRL2,
++		.val = USB2_SUSPEND_N_SEL | USB2_SUSPEND_N | USB2_UTMI_CLK_EN
++	},
++	{
++		.off = USB_PHY_UTMI_CTRL5,
++		.val = 0x0
++	},
++	{
++		.off = USB_PHY_HS_PHY_CTRL2,
++		.val = USB2_SUSPEND_N | USB2_UTMI_CLK_EN
++	},
++	{
++		.off = USB_PHY_CFG0,
++		.val = 0x0
++	},
++};
++
+ static struct m31_phy_regs m31_ipq5332_regs[] = {
+ 	{
+ 		USB_PHY_CFG0,
+@@ -267,6 +311,12 @@ static int m31usb_phy_probe(struct platf
+ 	return PTR_ERR_OR_ZERO(phy_provider);
+ }
+ 
++static const struct m31_priv_data m31_ipq5018_data = {
++	.ulpi_mode = false,
++	.regs = m31_ipq5018_regs,
++	.nregs = ARRAY_SIZE(m31_ipq5018_regs),
++};
++
+ static const struct m31_priv_data m31_ipq5332_data = {
+ 	.ulpi_mode = false,
+ 	.regs = m31_ipq5332_regs,
+@@ -274,6 +324,7 @@ static const struct m31_priv_data m31_ip
+ };
+ 
+ static const struct of_device_id m31usb_phy_id_table[] = {
++	{ .compatible = "qcom,ipq5018-usb-hsphy", .data = &m31_ipq5018_data },
+ 	{ .compatible = "qcom,ipq5332-usb-hsphy", .data = &m31_ipq5332_data },
+ 	{ },
+ };
diff --git a/target/linux/qualcommax/patches-6.6/0072-v6.7-dt-bindings-usb-dwc3-Add-IPQ5018-compatible.patch b/target/linux/qualcommax/patches-6.6/0072-v6.7-dt-bindings-usb-dwc3-Add-IPQ5018-compatible.patch
new file mode 100644
index 0000000000..146fcbff09
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0072-v6.7-dt-bindings-usb-dwc3-Add-IPQ5018-compatible.patch
@@ -0,0 +1,41 @@
+From 3865a64284cc4845c61cf3dc6c7246349d80cc49 Mon Sep 17 00:00:00 2001
+From: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Date: Thu, 31 Aug 2023 08:35:03 +0530
+Subject: [PATCH] dt-bindings: usb: dwc3: Add IPQ5018 compatible
+
+Document the IPQ5018 dwc3 compatible.
+
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Link: https://lore.kernel.org/r/20230831030503.17100-1-quic_nsekar@quicinc.com
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ Documentation/devicetree/bindings/usb/qcom,dwc3.yaml | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/Documentation/devicetree/bindings/usb/qcom,dwc3.yaml
++++ b/Documentation/devicetree/bindings/usb/qcom,dwc3.yaml
+@@ -14,6 +14,7 @@ properties:
+     items:
+       - enum:
+           - qcom,ipq4019-dwc3
++          - qcom,ipq5018-dwc3
+           - qcom,ipq5332-dwc3
+           - qcom,ipq6018-dwc3
+           - qcom,ipq8064-dwc3
+@@ -238,6 +239,7 @@ allOf:
+         compatible:
+           contains:
+             enum:
++              - qcom,ipq5018-dwc3
+               - qcom,ipq5332-dwc3
+               - qcom,msm8994-dwc3
+               - qcom,qcs404-dwc3
+@@ -411,6 +413,7 @@ allOf:
+         compatible:
+           contains:
+             enum:
++              - qcom,ipq5018-dwc3
+               - qcom,ipq5332-dwc3
+               - qcom,sdm660-dwc3
+     then:
diff --git a/target/linux/qualcommax/patches-6.6/0073-v6.8-arm64-dts-qcom-ipq5018-Add-USB-related-nodes.patch b/target/linux/qualcommax/patches-6.6/0073-v6.8-arm64-dts-qcom-ipq5018-Add-USB-related-nodes.patch
new file mode 100644
index 0000000000..99fdae732a
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0073-v6.8-arm64-dts-qcom-ipq5018-Add-USB-related-nodes.patch
@@ -0,0 +1,86 @@
+From e7166f2774aafefd29ff26ffbbb7f6d40ac8ea1c Mon Sep 17 00:00:00 2001
+From: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Date: Mon, 4 Sep 2023 12:06:34 +0530
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add USB related nodes
+
+Add USB phy and controller nodes.
+
+Co-developed-by: Amandeep Singh <quic_amansing@quicinc.com>
+Signed-off-by: Amandeep Singh <quic_amansing@quicinc.com>
+Signed-off-by: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Link: https://lore.kernel.org/r/20230904063635.24975-4-quic_nsekar@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 54 +++++++++++++++++++++++++++
+ 1 file changed, 54 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -94,6 +94,19 @@
+ 		#size-cells = <1>;
+ 		ranges = <0 0 0 0xffffffff>;
+ 
++		usbphy0: phy@5b000 {
++			compatible = "qcom,ipq5018-usb-hsphy";
++			reg = <0x0005b000 0x120>;
++
++			clocks = <&gcc GCC_USB0_PHY_CFG_AHB_CLK>;
++
++			resets = <&gcc GCC_QUSB2_0_PHY_BCR>;
++
++			#phy-cells = <0>;
++
++			status = "disabled";
++		};
++
+ 		tlmm: pinctrl@1000000 {
+ 			compatible = "qcom,ipq5018-tlmm";
+ 			reg = <0x01000000 0x300000>;
+@@ -156,6 +169,47 @@
+ 			status = "disabled";
+ 		};
+ 
++		usb: usb@8af8800 {
++			compatible = "qcom,ipq5018-dwc3", "qcom,dwc3";
++			reg = <0x08af8800 0x400>;
++
++			interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "hs_phy_irq";
++
++			clocks = <&gcc GCC_USB0_MASTER_CLK>,
++				 <&gcc GCC_SYS_NOC_USB0_AXI_CLK>,
++				 <&gcc GCC_USB0_SLEEP_CLK>,
++				 <&gcc GCC_USB0_MOCK_UTMI_CLK>;
++			clock-names = "core",
++				      "iface",
++				      "sleep",
++				      "mock_utmi";
++
++			resets = <&gcc GCC_USB0_BCR>;
++
++			qcom,select-utmi-as-pipe-clk;
++			#address-cells = <1>;
++			#size-cells = <1>;
++			ranges;
++
++			status = "disabled";
++
++			usb_dwc: usb@8a00000 {
++				compatible = "snps,dwc3";
++				reg = <0x08a00000 0xe000>;
++				clocks = <&gcc GCC_USB0_MOCK_UTMI_CLK>;
++				clock-names = "ref";
++				interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
++				phy-names = "usb2-phy";
++				phys = <&usbphy0>;
++				tx-fifo-resize;
++				snps,is-utmi-l1-suspend;
++				snps,hird-threshold = /bits/ 8 <0x0>;
++				snps,dis_u2_susphy_quirk;
++				snps,dis_u3_susphy_quirk;
++			};
++		};
++
+ 		intc: interrupt-controller@b000000 {
+ 			compatible = "qcom,msm-qgic2";
+ 			reg = <0x0b000000 0x1000>,  /* GICD */
diff --git a/target/linux/qualcommax/patches-6.6/0074-v6.8-arm64-dts-qcom-ipq5018-add-QUP1-SPI-controller.patch b/target/linux/qualcommax/patches-6.6/0074-v6.8-arm64-dts-qcom-ipq5018-add-QUP1-SPI-controller.patch
new file mode 100644
index 0000000000..d0d9e45dec
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0074-v6.8-arm64-dts-qcom-ipq5018-add-QUP1-SPI-controller.patch
@@ -0,0 +1,56 @@
+From a1f42e08f0f04b72a6597f080db4bfbb3737910c Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Wed, 4 Oct 2023 21:12:30 +0200
+Subject: [PATCH] arm64: dts: qcom: ipq5018: add QUP1 SPI controller
+
+Add the required BAM and QUP nodes for the QUP1 SPI controller on IPQ5018.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+Reviewed-by: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Link: https://lore.kernel.org/r/20231004191303.331055-1-robimarko@gmail.com
+[bjorn: Padded address to 8 digits, fixed node sort order]
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 24 ++++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -159,6 +159,16 @@
+ 			status = "disabled";
+ 		};
+ 
++		blsp_dma: dma-controller@7884000 {
++			compatible = "qcom,bam-v1.7.0";
++			reg = <0x07884000 0x1d000>;
++			interrupts = <GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "bam_clk";
++			#dma-cells = <1>;
++			qcom,ee = <0>;
++		};
++
+ 		blsp1_uart1: serial@78af000 {
+ 			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
+ 			reg = <0x078af000 0x200>;
+@@ -169,6 +179,20 @@
+ 			status = "disabled";
+ 		};
+ 
++		blsp1_spi1: spi@78b5000 {
++			compatible = "qcom,spi-qup-v2.2.1";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <0x078b5000 0x600>;
++			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP1_SPI_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			dmas = <&blsp_dma 4>, <&blsp_dma 5>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
+ 		usb: usb@8af8800 {
+ 			compatible = "qcom,ipq5018-dwc3", "qcom,dwc3";
+ 			reg = <0x08af8800 0x400>;
diff --git a/target/linux/qualcommax/patches-6.6/0075-v6.8-dt-bindings-clock-qcom-a53pll-add-IPQ5018-compatible.patch b/target/linux/qualcommax/patches-6.6/0075-v6.8-dt-bindings-clock-qcom-a53pll-add-IPQ5018-compatible.patch
new file mode 100644
index 0000000000..314afa76d2
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0075-v6.8-dt-bindings-clock-qcom-a53pll-add-IPQ5018-compatible.patch
@@ -0,0 +1,25 @@
+From 4d45d56e17348c6b6bb2bce126a4a5ea97b19900 Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <quic_gokulsri@quicinc.com>
+Date: Mon, 25 Sep 2023 15:58:24 +0530
+Subject: [PATCH] dt-bindings: clock: qcom,a53pll: add IPQ5018 compatible
+
+Add IPQ5018 compatible to A53 PLL bindings.
+
+Signed-off-by: Gokul Sriram Palanisamy <quic_gokulsri@quicinc.com>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Link: https://lore.kernel.org/r/20230925102826.405446-2-quic_gokulsri@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ Documentation/devicetree/bindings/clock/qcom,a53pll.yaml | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/Documentation/devicetree/bindings/clock/qcom,a53pll.yaml
++++ b/Documentation/devicetree/bindings/clock/qcom,a53pll.yaml
+@@ -16,6 +16,7 @@ description:
+ properties:
+   compatible:
+     enum:
++      - qcom,ipq5018-a53pll
+       - qcom,ipq5332-a53pll
+       - qcom,ipq6018-a53pll
+       - qcom,ipq8074-a53pll
diff --git a/target/linux/qualcommax/patches-6.6/0076-v6.8-clk-qcom-apss-ipq-pll-add-support-for-IPQ5018.patch b/target/linux/qualcommax/patches-6.6/0076-v6.8-clk-qcom-apss-ipq-pll-add-support-for-IPQ5018.patch
new file mode 100644
index 0000000000..46dede07ca
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0076-v6.8-clk-qcom-apss-ipq-pll-add-support-for-IPQ5018.patch
@@ -0,0 +1,62 @@
+From 50492f929486c044b43cb3e2c0e040aa9b61ea2b Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <quic_gokulsri@quicinc.com>
+Date: Mon, 25 Sep 2023 15:58:25 +0530
+Subject: [PATCH] clk: qcom: apss-ipq-pll: add support for IPQ5018
+
+IPQ5018 APSS PLL is of type Stromer. Reuse Stromer Plus PLL offsets,
+add configuration values and the compatible.
+
+Co-developed-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Signed-off-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Signed-off-by: Gokul Sriram Palanisamy <quic_gokulsri@quicinc.com>
+Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
+Link: https://lore.kernel.org/r/20230925102826.405446-3-quic_gokulsri@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ drivers/clk/qcom/apss-ipq-pll.c | 21 +++++++++++++++++++++
+ 1 file changed, 21 insertions(+)
+
+--- a/drivers/clk/qcom/apss-ipq-pll.c
++++ b/drivers/clk/qcom/apss-ipq-pll.c
+@@ -73,6 +73,20 @@ static struct clk_alpha_pll ipq_pll_stro
+ 	},
+ };
+ 
++static const struct alpha_pll_config ipq5018_pll_config = {
++	.l = 0x32,
++	.config_ctl_val = 0x4001075b,
++	.config_ctl_hi_val = 0x304,
++	.main_output_mask = BIT(0),
++	.aux_output_mask = BIT(1),
++	.early_output_mask = BIT(3),
++	.alpha_en_mask = BIT(24),
++	.status_val = 0x3,
++	.status_mask = GENMASK(10, 8),
++	.lock_det = BIT(2),
++	.test_ctl_hi_val = 0x00400003,
++};
++
+ static const struct alpha_pll_config ipq5332_pll_config = {
+ 	.l = 0x2d,
+ 	.config_ctl_val = 0x4001075b,
+@@ -129,6 +143,12 @@ struct apss_pll_data {
+ 	const struct alpha_pll_config *pll_config;
+ };
+ 
++static const struct apss_pll_data ipq5018_pll_data = {
++	.pll_type = CLK_ALPHA_PLL_TYPE_STROMER_PLUS,
++	.pll = &ipq_pll_stromer_plus,
++	.pll_config = &ipq5018_pll_config,
++};
++
+ static struct apss_pll_data ipq5332_pll_data = {
+ 	.pll_type = CLK_ALPHA_PLL_TYPE_STROMER_PLUS,
+ 	.pll = &ipq_pll_stromer_plus,
+@@ -195,6 +215,7 @@ static int apss_ipq_pll_probe(struct pla
+ }
+ 
+ static const struct of_device_id apss_ipq_pll_match_table[] = {
++	{ .compatible = "qcom,ipq5018-a53pll", .data = &ipq5018_pll_data },
+ 	{ .compatible = "qcom,ipq5332-a53pll", .data = &ipq5332_pll_data },
+ 	{ .compatible = "qcom,ipq6018-a53pll", .data = &ipq6018_pll_data },
+ 	{ .compatible = "qcom,ipq8074-a53pll", .data = &ipq8074_pll_data },
diff --git a/target/linux/qualcommax/patches-6.6/0077-v6.8-arm64-dts-qcom-ipq5018-enable-the-CPUFreq-support.patch b/target/linux/qualcommax/patches-6.6/0077-v6.8-arm64-dts-qcom-ipq5018-enable-the-CPUFreq-support.patch
new file mode 100644
index 0000000000..72bec54cb3
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0077-v6.8-arm64-dts-qcom-ipq5018-enable-the-CPUFreq-support.patch
@@ -0,0 +1,98 @@
+From 3e4b53e04281ed3d9c7a4329c027097265c04d54 Mon Sep 17 00:00:00 2001
+From: Gokul Sriram Palanisamy <quic_gokulsri@quicinc.com>
+Date: Mon, 25 Sep 2023 15:58:26 +0530
+Subject: [PATCH] arm64: dts: qcom: ipq5018: enable the CPUFreq support
+
+Add the APCS, A53 PLL, cpu-opp-table nodes to set
+the CPU frequency at 800MHz (idle) or 1.008GHz.
+
+Co-developed-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Signed-off-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Signed-off-by: Gokul Sriram Palanisamy <quic_gokulsri@quicinc.com>
+Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Link: https://lore.kernel.org/r/20230925102826.405446-4-quic_gokulsri@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 40 +++++++++++++++++++++++++++
+ 1 file changed, 40 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -5,6 +5,7 @@
+  * Copyright (c) 2023 The Linux Foundation. All rights reserved.
+  */
+ 
++#include <dt-bindings/clock/qcom,apss-ipq.h>
+ #include <dt-bindings/interrupt-controller/arm-gic.h>
+ #include <dt-bindings/clock/qcom,gcc-ipq5018.h>
+ #include <dt-bindings/reset/qcom,gcc-ipq5018.h>
+@@ -36,6 +37,8 @@
+ 			reg = <0x0>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&L2_0>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			operating-points-v2 = <&cpu_opp_table>;
+ 		};
+ 
+ 		CPU1: cpu@1 {
+@@ -44,6 +47,8 @@
+ 			reg = <0x1>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&L2_0>;
++			clocks = <&apcs_glb APCS_ALIAS0_CORE_CLK>;
++			operating-points-v2 = <&cpu_opp_table>;
+ 		};
+ 
+ 		L2_0: l2-cache {
+@@ -54,6 +59,25 @@
+ 		};
+ 	};
+ 
++	cpu_opp_table: opp-table-cpu {
++		compatible = "operating-points-v2";
++		opp-shared;
++
++		/*
++		opp-800000000 {
++			opp-hz = /bits/ 64 <800000000>;
++			opp-microvolt = <1100000>;
++			clock-latency-ns = <200000>;
++		};
++		*/
++
++		opp-1008000000 {
++			opp-hz = /bits/ 64 <1008000000>;
++			opp-microvolt = <1100000>;
++			clock-latency-ns = <200000>;
++		};
++	};
++
+ 	firmware {
+ 		scm {
+ 			compatible = "qcom,scm-ipq5018", "qcom,scm";
+@@ -267,6 +291,24 @@
+ 			clocks = <&sleep_clk>;
+ 		};
+ 
++		apcs_glb: mailbox@b111000 {
++			compatible = "qcom,ipq5018-apcs-apps-global",
++				     "qcom,ipq6018-apcs-apps-global";
++			reg = <0x0b111000 0x1000>;
++			#clock-cells = <1>;
++			clocks = <&a53pll>, <&xo_board_clk>, <&gcc GPLL0>;
++			clock-names = "pll", "xo", "gpll0";
++			#mbox-cells = <1>;
++		};
++
++		a53pll: clock@b116000 {
++			compatible = "qcom,ipq5018-a53pll";
++			reg = <0x0b116000 0x40>;
++			#clock-cells = <0>;
++			clocks = <&xo_board_clk>;
++			clock-names = "xo";
++		};
++
+ 		timer@b120000 {
+ 			compatible = "arm,armv7-timer-mem";
+ 			reg = <0x0b120000 0x1000>;
diff --git a/target/linux/qualcommax/patches-6.6/0078-v6.8-arm64-dts-qcom-ipq5018-add-few-more-reserved-memory-regions.patch b/target/linux/qualcommax/patches-6.6/0078-v6.8-arm64-dts-qcom-ipq5018-add-few-more-reserved-memory-regions.patch
new file mode 100644
index 0000000000..97631e715a
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0078-v6.8-arm64-dts-qcom-ipq5018-add-few-more-reserved-memory-regions.patch
@@ -0,0 +1,66 @@
+From a427dd16e61f3d145bc24f0ed09692fc25931250 Mon Sep 17 00:00:00 2001
+From: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Date: Wed, 25 Oct 2023 22:12:12 +0530
+Subject: [PATCH] arm64: dts: qcom: ipq5018: add few more reserved memory
+ regions
+
+Like all other IPQ SoCs, bootloader will collect the system RAM contents
+upon crash for the post morterm analysis. If we don't reserve the memory
+region used by bootloader, obviously linux will consume it and upon next
+boot on crash, bootloader will be loaded in the same region, which will
+lead to loose some of the data, sometimes we may miss out critical
+information. So lets reserve the region used by the bootloader.
+
+Similarly SBL copies some data into the reserved region and it will be
+used in the crash scenario. So reserve 1MB for SBL as well.
+
+While at it, enable the SMEM support along with TCSR mutex.
+
+Signed-off-by: Kathiravan Thirumoorthy <quic_kathirav@quicinc.com>
+Reviewed-by: Konrad Dybcio <konrad.dybcio@linaro.org>
+Link: https://lore.kernel.org/r/20231025-ipq5018-misc-v1-1-7d14fde97fe7@quicinc.com
+Signed-off-by: Bjorn Andersson <andersson@kernel.org>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 24 ++++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -106,6 +106,24 @@
+ 		#size-cells = <2>;
+ 		ranges;
+ 
++		bootloader@4a800000 {
++			reg = <0x0 0x4a800000 0x0 0x200000>;
++			no-map;
++		};
++
++		sbl@4aa00000 {
++			reg = <0x0 0x4aa00000 0x0 0x100000>;
++			no-map;
++		};
++
++		smem@4ab00000 {
++			compatible = "qcom,smem";
++			reg = <0x0 0x4ab00000 0x0 0x100000>;
++			no-map;
++
++			hwlocks = <&tcsr_mutex 3>;
++		};
++
+ 		tz_region: tz@4ac00000 {
+ 			reg = <0x0 0x4ac00000 0x0 0x200000>;
+ 			no-map;
+@@ -166,6 +184,12 @@
+ 			#power-domain-cells = <1>;
+ 		};
+ 
++		tcsr_mutex: hwlock@1905000 {
++			compatible = "qcom,tcsr-mutex";
++			reg = <0x01905000 0x20000>;
++			#hwlock-cells = <1>;
++		};
++
+ 		sdhc_1: mmc@7804000 {
+ 			compatible = "qcom,ipq5018-sdhci", "qcom,sdhci-msm-v5";
+ 			reg = <0x7804000 0x1000>;
diff --git a/target/linux/qualcommax/patches-6.6/0080-v6.10-clk-qcom-apss-ipq-pll-use-stromer-ops-for-IPQ5018-to-fix-boot-failure.patch b/target/linux/qualcommax/patches-6.6/0080-v6.10-clk-qcom-apss-ipq-pll-use-stromer-ops-for-IPQ5018-to-fix-boot-failure.patch
new file mode 100644
index 0000000000..ea6f61b57f
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0080-v6.10-clk-qcom-apss-ipq-pll-use-stromer-ops-for-IPQ5018-to-fix-boot-failure.patch
@@ -0,0 +1,83 @@
+From: Gabor Juhos <j4g8y7@gmail.com>
+Subject: [PATCH] clk: qcom: apss-ipq-pll: use stromer ops for IPQ5018 to fix boot failure
+Date: Fri, 15 Mar 2024 17:16:41 +0100
+
+Booting v6.8 results in a hang on various IPQ5018 based boards.
+Investigating the problem showed that the hang happens when the
+clk_alpha_pll_stromer_plus_set_rate() function tries to write
+into the PLL_MODE register of the APSS PLL.
+
+Checking the downstream code revealed that it uses [1] stromer
+specific operations for IPQ5018, whereas in the current code
+the stromer plus specific operations are used.
+
+The ops in the 'ipq_pll_stromer_plus' clock definition can't be
+changed since that is needed for IPQ5332, so add a new alpha pll
+clock declaration which uses the correct stromer ops and use this
+new clock for IPQ5018 to avoid the boot failure.
+
+Also, change pll_type in 'ipq5018_pll_data' to
+CLK_ALPHA_PLL_TYPE_STROMER to better reflect that it is a Stromer
+PLL and change the apss_ipq_pll_probe() function accordingly.
+
+1. https://git.codelinaro.org/clo/qsdk/oss/kernel/linux-ipq-5.4/-/blob/NHSS.QSDK.12.4/drivers/clk/qcom/apss-ipq5018.c#L67
+
+Fixes: 50492f929486 ("clk: qcom: apss-ipq-pll: add support for IPQ5018")
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+---
+ drivers/clk/qcom/apss-ipq-pll.c | 30 +++++++++++++++++++++++++++---
+ 1 file changed, 27 insertions(+), 3 deletions(-)
+
+--- a/drivers/clk/qcom/apss-ipq-pll.c
++++ b/drivers/clk/qcom/apss-ipq-pll.c
+@@ -55,6 +55,29 @@ static struct clk_alpha_pll ipq_pll_huay
+ 	},
+ };
+ 
++static struct clk_alpha_pll ipq_pll_stromer = {
++	.offset = 0x0,
++	/*
++	 * Reuse CLK_ALPHA_PLL_TYPE_STROMER_PLUS register offsets.
++	 * Although this is a bit confusing, but the offset values
++	 * are correct nevertheless.
++	 */
++	.regs = ipq_pll_offsets[CLK_ALPHA_PLL_TYPE_STROMER_PLUS],
++	.flags = SUPPORTS_DYNAMIC_UPDATE,
++	.clkr = {
++		.enable_reg = 0x0,
++		.enable_mask = BIT(0),
++		.hw.init = &(const struct clk_init_data) {
++			.name = "a53pll",
++			.parent_data = &(const struct clk_parent_data) {
++				.fw_name = "xo",
++			},
++			.num_parents = 1,
++			.ops = &clk_alpha_pll_stromer_ops,
++		},
++	},
++};
++
+ static struct clk_alpha_pll ipq_pll_stromer_plus = {
+ 	.offset = 0x0,
+ 	.regs = ipq_pll_offsets[CLK_ALPHA_PLL_TYPE_STROMER_PLUS],
+@@ -144,8 +167,8 @@ struct apss_pll_data {
+ };
+ 
+ static const struct apss_pll_data ipq5018_pll_data = {
+-	.pll_type = CLK_ALPHA_PLL_TYPE_STROMER_PLUS,
+-	.pll = &ipq_pll_stromer_plus,
++	.pll_type = CLK_ALPHA_PLL_TYPE_STROMER,
++	.pll = &ipq_pll_stromer,
+ 	.pll_config = &ipq5018_pll_config,
+ };
+ 
+@@ -203,7 +226,8 @@ static int apss_ipq_pll_probe(struct pla
+ 
+ 	if (data->pll_type == CLK_ALPHA_PLL_TYPE_HUAYRA)
+ 		clk_alpha_pll_configure(data->pll, regmap, data->pll_config);
+-	else if (data->pll_type == CLK_ALPHA_PLL_TYPE_STROMER_PLUS)
++	else if (data->pll_type == CLK_ALPHA_PLL_TYPE_STROMER ||
++		 data->pll_type == CLK_ALPHA_PLL_TYPE_STROMER_PLUS)
+ 		clk_stromer_pll_configure(data->pll, regmap, data->pll_config);
+ 
+ 	ret = devm_clk_register_regmap(dev, &data->pll->clkr);
diff --git a/target/linux/qualcommax/patches-6.6/0081-v6.10-clk-qcom-apss-ipq-pll-fix-PLL-rate-for-IPQ5018.patch b/target/linux/qualcommax/patches-6.6/0081-v6.10-clk-qcom-apss-ipq-pll-fix-PLL-rate-for-IPQ5018.patch
new file mode 100644
index 0000000000..4bf0598c36
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0081-v6.10-clk-qcom-apss-ipq-pll-fix-PLL-rate-for-IPQ5018.patch
@@ -0,0 +1,32 @@
+From: Gabor Juhos <j4g8y7@gmail.com>
+Subject: [PATCH] clk: qcom: apss-ipq-pll: fix PLL rate for IPQ5018
+Date: Tue, 26 Mar 2024 14:34:11 +0100
+
+According to ipq5018.dtsi, the maximum supported rate by the
+CPU is 1.008 GHz on the IPQ5018 platform, however the current
+configuration of the PLL results in 1.2 GHz rate.
+
+Change the 'L' value in the PLL configuration to limit the
+rate to 1.008 GHz. The downstream kernel also uses the same
+value [1]. Also add a comment to indicate the desired
+frequency.
+
+[1] https://git.codelinaro.org/clo/qsdk/oss/kernel/linux-ipq-5.4/-/blob/NHSS.QSDK.12.4/drivers/clk/qcom/apss-ipq5018.c?ref_type=heads#L151
+
+Fixes: 50492f929486 ("clk: qcom: apss-ipq-pll: add support for IPQ5018")
+Signed-off-by: Gabor Juhos <j4g8y7@gmail.com>
+---
+ drivers/clk/qcom/apss-ipq-pll.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/clk/qcom/apss-ipq-pll.c
++++ b/drivers/clk/qcom/apss-ipq-pll.c
+@@ -97,7 +97,7 @@ static struct clk_alpha_pll ipq_pll_stro
+ };
+ 
+ static const struct alpha_pll_config ipq5018_pll_config = {
+-	.l = 0x32,
++	.l = 0x2a,
+ 	.config_ctl_val = 0x4001075b,
+ 	.config_ctl_hi_val = 0x304,
+ 	.main_output_mask = BIT(0),
diff --git a/target/linux/qualcommax/patches-6.6/0140-arm64-dts-qcom-ipq6018-add-NSS-reserved-memory.patch b/target/linux/qualcommax/patches-6.6/0135-arm64-dts-qcom-ipq6018-add-NSS-reserved-memory.patch
similarity index 97%
rename from target/linux/qualcommax/patches-6.6/0140-arm64-dts-qcom-ipq6018-add-NSS-reserved-memory.patch
rename to target/linux/qualcommax/patches-6.6/0135-arm64-dts-qcom-ipq6018-add-NSS-reserved-memory.patch
index 84591c845d..0d53531bc9 100644
--- a/target/linux/qualcommax/patches-6.6/0140-arm64-dts-qcom-ipq6018-add-NSS-reserved-memory.patch
+++ b/target/linux/qualcommax/patches-6.6/0135-arm64-dts-qcom-ipq6018-add-NSS-reserved-memory.patch
@@ -13,7 +13,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
 
 --- a/arch/arm64/boot/dts/qcom/ipq6018.dtsi
 +++ b/arch/arm64/boot/dts/qcom/ipq6018.dtsi
-@@ -199,6 +199,11 @@
+@@ -194,6 +194,11 @@
  			no-map;
  		};
  
diff --git a/target/linux/qualcommax/patches-6.6/0137-arm64-dts-qcom-ipq6018-add-SDHCI-node.patch b/target/linux/qualcommax/patches-6.6/0137-arm64-dts-qcom-ipq6018-add-SDHCI-node.patch
index e1296aa792..6052f41209 100644
--- a/target/linux/qualcommax/patches-6.6/0137-arm64-dts-qcom-ipq6018-add-SDHCI-node.patch
+++ b/target/linux/qualcommax/patches-6.6/0137-arm64-dts-qcom-ipq6018-add-SDHCI-node.patch
@@ -13,7 +13,7 @@ Tested-by: Robert Marko <robimarko@gmail.com>
 
 --- a/arch/arm64/boot/dts/qcom/ipq6018.dtsi
 +++ b/arch/arm64/boot/dts/qcom/ipq6018.dtsi
-@@ -470,6 +470,29 @@
+@@ -475,6 +475,29 @@
  			};
  		};
  
diff --git a/target/linux/qualcommax/patches-6.6/0138-arm64-dts-qcom-ipq6018-add-pwm-node.patch b/target/linux/qualcommax/patches-6.6/0138-arm64-dts-qcom-ipq6018-add-pwm-node.patch
new file mode 100644
index 0000000000..71061ba4f9
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0138-arm64-dts-qcom-ipq6018-add-pwm-node.patch
@@ -0,0 +1,45 @@
+From b4a32d218d424b81a58fbd419e1114b1c1f76168 Mon Sep 17 00:00:00 2001
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 5 Oct 2023 21:35:50 +0530
+Subject: [PATCH] arm64: dts: qcom: ipq6018: add pwm node
+
+Describe the PWM block on IPQ6018.
+
+The PWM is in the TCSR area. Make &tcsr "simple-mfd" compatible, and add
+&pwm as child of &tcsr.
+
+Add also ipq6018 specific compatible string.
+
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Co-developed-by: Baruch Siach <baruch.siach@siklu.com>
+Signed-off-by: Baruch Siach <baruch.siach@siklu.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+---
+ arch/arm64/boot/dts/qcom/ipq6018.dtsi | 15 ++++++++++++++-
+ 1 file changed, 14 insertions(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq6018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq6018.dtsi
+@@ -430,8 +430,21 @@
+ 		};
+ 
+ 		tcsr: syscon@1937000 {
+-			compatible = "qcom,tcsr-ipq6018", "syscon";
++			compatible = "qcom,tcsr-ipq6018", "syscon", "simple-mfd";
+ 			reg = <0x0 0x01937000 0x0 0x21000>;
++			ranges = <0x0 0x0 0x01937000 0x21000>;
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			pwm: pwm@a010 {
++				compatible = "qcom,ipq6018-pwm";
++				reg = <0xa010 0x20>;
++				clocks = <&gcc GCC_ADSS_PWM_CLK>;
++				assigned-clocks = <&gcc GCC_ADSS_PWM_CLK>;
++				assigned-clock-rates = <100000000>;
++				#pwm-cells = <2>;
++				status = "disabled";
++			};
+ 		};
+ 
+ 		usb2: usb@70f8800 {
diff --git a/target/linux/qualcommax/patches-6.6/0140-dt-bindings-pwm-add-IPQ6018-binding.patch b/target/linux/qualcommax/patches-6.6/0140-dt-bindings-pwm-add-IPQ6018-binding.patch
new file mode 100644
index 0000000000..bba8b3457a
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0140-dt-bindings-pwm-add-IPQ6018-binding.patch
@@ -0,0 +1,60 @@
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 5 Oct 2023 21:35:48 +0530
+Subject: [PATCH] dt-bindings: pwm: add IPQ6018 binding
+
+DT binding for the PWM block in Qualcomm IPQ6018 SoC.
+
+Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Co-developed-by: Baruch Siach <baruch.siach@siklu.com>
+Signed-off-by: Baruch Siach <baruch.siach@siklu.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+---
+--- /dev/null
++++ b/Documentation/devicetree/bindings/pwm/qcom,ipq6018-pwm.yaml
+@@ -0,0 +1,45 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/pwm/qcom,ipq6018-pwm.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Qualcomm IPQ6018 PWM controller
++
++maintainers:
++  - Baruch Siach <baruch@tkos.co.il>
++
++properties:
++  compatible:
++    const: qcom,ipq6018-pwm
++
++  reg:
++    description: Offset of PWM register in the TCSR block.
++    maxItems: 1
++
++  clocks:
++    maxItems: 1
++
++  "#pwm-cells":
++    const: 2
++
++required:
++  - compatible
++  - reg
++  - clocks
++  - "#pwm-cells"
++
++additionalProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/clock/qcom,gcc-ipq6018.h>
++
++    pwm: pwm@a010 {
++        compatible = "qcom,ipq6018-pwm";
++        reg = <0xa010 0x20>;
++        clocks = <&gcc GCC_ADSS_PWM_CLK>;
++        assigned-clocks = <&gcc GCC_ADSS_PWM_CLK>;
++        assigned-clock-rates = <100000000>;
++        #pwm-cells = <2>;
++    };
diff --git a/target/linux/qualcommax/patches-6.6/0141-pwm-driver-for-qualcomm-ipq6018-pwm-block.patch b/target/linux/qualcommax/patches-6.6/0141-pwm-driver-for-qualcomm-ipq6018-pwm-block.patch
new file mode 100644
index 0000000000..bf373c5748
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0141-pwm-driver-for-qualcomm-ipq6018-pwm-block.patch
@@ -0,0 +1,334 @@
+From: Devi Priya <quic_devipriy@quicinc.com>
+Date: Thu, 5 Oct 2023 21:35:47 +0530
+Subject: [PATCH] pwm: driver for qualcomm ipq6018 pwm block
+
+Driver for the PWM block in Qualcomm IPQ6018 line of SoCs. Based on
+driver from downstream Codeaurora kernel tree. Removed support for older
+(V1) variants because I have no access to that hardware.
+
+Tested on IPQ6010 based hardware.
+
+Co-developed-by: Baruch Siach <baruch.siach@siklu.com>
+Signed-off-by: Baruch Siach <baruch.siach@siklu.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+---
+ drivers/pwm/Kconfig   |  12 ++
+ drivers/pwm/Makefile  |   1 +
+ drivers/pwm/pwm-ipq.c | 282 ++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 295 insertions(+)
+ create mode 100644 drivers/pwm/pwm-ipq.c
+
+--- a/drivers/pwm/Kconfig
++++ b/drivers/pwm/Kconfig
+@@ -282,6 +282,18 @@ config PWM_INTEL_LGM
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called pwm-intel-lgm.
+ 
++config PWM_IPQ
++	tristate "IPQ PWM support"
++	depends on ARCH_QCOM || COMPILE_TEST
++	depends on HAVE_CLK && HAS_IOMEM
++	help
++	  Generic PWM framework driver for IPQ PWM block which supports
++	  4 pwm channels. Each of the these channels can be configured
++	  independent of each other.
++
++	  To compile this driver as a module, choose M here: the module
++	  will be called pwm-ipq.
++
+ config PWM_IQS620A
+ 	tristate "Azoteq IQS620A PWM support"
+ 	depends on MFD_IQS62X || COMPILE_TEST
+--- a/drivers/pwm/Makefile
++++ b/drivers/pwm/Makefile
+@@ -24,6 +24,7 @@ obj-$(CONFIG_PWM_IMX1)		+= pwm-imx1.o
+ obj-$(CONFIG_PWM_IMX27)		+= pwm-imx27.o
+ obj-$(CONFIG_PWM_IMX_TPM)	+= pwm-imx-tpm.o
+ obj-$(CONFIG_PWM_INTEL_LGM)	+= pwm-intel-lgm.o
++obj-$(CONFIG_PWM_IPQ)		+= pwm-ipq.o
+ obj-$(CONFIG_PWM_IQS620A)	+= pwm-iqs620a.o
+ obj-$(CONFIG_PWM_JZ4740)	+= pwm-jz4740.o
+ obj-$(CONFIG_PWM_KEEMBAY)	+= pwm-keembay.o
+--- /dev/null
++++ b/drivers/pwm/pwm-ipq.c
+@@ -0,0 +1,280 @@
++// SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
++/*
++ * Copyright (c) 2016-2017, 2020 The Linux Foundation. All rights reserved.
++ */
++
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/pwm.h>
++#include <linux/clk.h>
++#include <linux/io.h>
++#include <linux/of.h>
++#include <linux/math64.h>
++#include <linux/of_device.h>
++#include <linux/bitfield.h>
++#include <linux/units.h>
++
++/* The frequency range supported is 1 Hz to clock rate */
++#define IPQ_PWM_MAX_PERIOD_NS	((u64)NSEC_PER_SEC)
++
++/*
++ * The max value specified for each field is based on the number of bits
++ * in the pwm control register for that field
++ */
++#define IPQ_PWM_MAX_DIV		0xFFFF
++
++/*
++ * Two 32-bit registers for each PWM: REG0, and REG1.
++ * Base offset for PWM #i is at 8 * #i.
++ */
++#define IPQ_PWM_REG0			0
++#define IPQ_PWM_REG0_PWM_DIV		GENMASK(15, 0)
++#define IPQ_PWM_REG0_HI_DURATION	GENMASK(31, 16)
++
++#define IPQ_PWM_REG1			4
++#define IPQ_PWM_REG1_PRE_DIV		GENMASK(15, 0)
++/*
++ * Enable bit is set to enable output toggling in pwm device.
++ * Update bit is set to reflect the changed divider and high duration
++ * values in register.
++ */
++#define IPQ_PWM_REG1_UPDATE		BIT(30)
++#define IPQ_PWM_REG1_ENABLE		BIT(31)
++
++struct ipq_pwm_chip {
++	struct pwm_chip chip;
++	struct clk *clk;
++	void __iomem *mem;
++};
++
++static struct ipq_pwm_chip *ipq_pwm_from_chip(struct pwm_chip *chip)
++{
++	return container_of(chip, struct ipq_pwm_chip, chip);
++}
++
++static unsigned int ipq_pwm_reg_read(struct pwm_device *pwm, unsigned int reg)
++{
++	struct ipq_pwm_chip *ipq_chip = ipq_pwm_from_chip(pwm->chip);
++	unsigned int off = 8 * pwm->hwpwm + reg;
++
++	return readl(ipq_chip->mem + off);
++}
++
++static void ipq_pwm_reg_write(struct pwm_device *pwm, unsigned int reg,
++			      unsigned int val)
++{
++	struct ipq_pwm_chip *ipq_chip = ipq_pwm_from_chip(pwm->chip);
++	unsigned int off = 8 * pwm->hwpwm + reg;
++
++	writel(val, ipq_chip->mem + off);
++}
++
++static void config_div_and_duty(struct pwm_device *pwm, unsigned int pre_div,
++				unsigned int pwm_div, unsigned long rate, u64 duty_ns,
++				bool enable)
++{
++	unsigned long hi_dur;
++	unsigned long val = 0;
++
++	/*
++	 * high duration = pwm duty * (pwm div + 1)
++	 * pwm duty = duty_ns / period_ns
++	 */
++	hi_dur = div64_u64(duty_ns * rate, (pre_div + 1) * NSEC_PER_SEC);
++
++	val = FIELD_PREP(IPQ_PWM_REG0_HI_DURATION, hi_dur) |
++		FIELD_PREP(IPQ_PWM_REG0_PWM_DIV, pwm_div);
++	ipq_pwm_reg_write(pwm, IPQ_PWM_REG0, val);
++
++	val = FIELD_PREP(IPQ_PWM_REG1_PRE_DIV, pre_div);
++	ipq_pwm_reg_write(pwm, IPQ_PWM_REG1, val);
++
++	/* PWM enable toggle needs a separate write to REG1 */
++	val |= IPQ_PWM_REG1_UPDATE;
++	if (enable)
++		val |= IPQ_PWM_REG1_ENABLE;
++	ipq_pwm_reg_write(pwm, IPQ_PWM_REG1, val);
++}
++
++static int ipq_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
++			 const struct pwm_state *state)
++{
++	struct ipq_pwm_chip *ipq_chip = ipq_pwm_from_chip(chip);
++	unsigned int pre_div, pwm_div, best_pre_div, best_pwm_div;
++	unsigned long rate = clk_get_rate(ipq_chip->clk);
++	u64 period_ns, duty_ns, period_rate;
++	u64 min_diff;
++
++	if (state->polarity != PWM_POLARITY_NORMAL)
++		return -EINVAL;
++
++	if (state->period < DIV64_U64_ROUND_UP(NSEC_PER_SEC, rate))
++		return -ERANGE;
++
++	period_ns = min(state->period, IPQ_PWM_MAX_PERIOD_NS);
++	duty_ns = min(state->duty_cycle, period_ns);
++
++	/*
++	 * period_ns is 1G or less. As long as rate is less than 16 GHz,
++	 * period_rate does not overflow. Make that explicit.
++	 */
++	if ((unsigned long long)rate > 16ULL * GIGA)
++		return -EINVAL;
++	period_rate = period_ns * rate;
++	best_pre_div = IPQ_PWM_MAX_DIV;
++	best_pwm_div = IPQ_PWM_MAX_DIV;
++	/*
++	 * We don't need to consider pre_div values smaller than
++	 *
++	 *                              period_rate
++	 *  pre_div_min := ------------------------------------
++	 *                 NSEC_PER_SEC * (IPQ_PWM_MAX_DIV + 1)
++	 *
++	 * because pre_div = pre_div_min results in a better
++	 * approximation.
++	 */
++	pre_div = div64_u64(period_rate,
++			    (u64)NSEC_PER_SEC * (IPQ_PWM_MAX_DIV + 1));
++	min_diff = period_rate;
++
++	for (; pre_div <= IPQ_PWM_MAX_DIV; pre_div++) {
++		u64 remainder;
++
++		pwm_div = div64_u64_rem(period_rate,
++					(u64)NSEC_PER_SEC * (pre_div + 1), &remainder);
++		/* pwm_div is unsigned; the check below catches underflow */
++		pwm_div--;
++
++		/*
++		 * Swapping values for pre_div and pwm_div produces the same
++		 * period length. So we can skip all settings with pre_div >
++		 * pwm_div which results in bigger constraints for selecting
++		 * the duty_cycle than with the two values swapped.
++		 */
++		if (pre_div > pwm_div)
++			break;
++
++		/*
++		 * Make sure we can do 100% duty cycle where
++		 * hi_dur == pwm_div + 1
++		 */
++		if (pwm_div > IPQ_PWM_MAX_DIV - 1)
++			continue;
++
++		if (remainder < min_diff) {
++			best_pre_div = pre_div;
++			best_pwm_div = pwm_div;
++			min_diff = remainder;
++
++			if (min_diff == 0) /* bingo */
++				break;
++		}
++	}
++
++	/* config divider values for the closest possible frequency */
++	config_div_and_duty(pwm, best_pre_div, best_pwm_div,
++			    rate, duty_ns, state->enabled);
++
++	return 0;
++}
++
++static int ipq_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
++			     struct pwm_state *state)
++{
++	struct ipq_pwm_chip *ipq_chip = ipq_pwm_from_chip(chip);
++	unsigned long rate = clk_get_rate(ipq_chip->clk);
++	unsigned int pre_div, pwm_div, hi_dur;
++	u64 effective_div, hi_div;
++	u32 reg0, reg1;
++
++	reg0 = ipq_pwm_reg_read(pwm, IPQ_PWM_REG0);
++	reg1 = ipq_pwm_reg_read(pwm, IPQ_PWM_REG1);
++
++	state->polarity = PWM_POLARITY_NORMAL;
++	state->enabled = reg1 & IPQ_PWM_REG1_ENABLE;
++
++	pwm_div = FIELD_GET(IPQ_PWM_REG0_PWM_DIV, reg0);
++	hi_dur = FIELD_GET(IPQ_PWM_REG0_HI_DURATION, reg0);
++	pre_div = FIELD_GET(IPQ_PWM_REG1_PRE_DIV, reg1);
++
++	/* No overflow here, both pre_div and pwm_div <= 0xffff */
++	effective_div = (u64)(pre_div + 1) * (pwm_div + 1);
++	state->period = DIV64_U64_ROUND_UP(effective_div * NSEC_PER_SEC, rate);
++
++	hi_div = hi_dur * (pre_div + 1);
++	state->duty_cycle = DIV64_U64_ROUND_UP(hi_div * NSEC_PER_SEC, rate);
++
++	return 0;
++}
++
++static const struct pwm_ops ipq_pwm_ops = {
++	.apply = ipq_pwm_apply,
++	.get_state = ipq_pwm_get_state,
++	.owner = THIS_MODULE,
++};
++
++static int ipq_pwm_probe(struct platform_device *pdev)
++{
++	struct ipq_pwm_chip *pwm;
++	struct device *dev = &pdev->dev;
++	int ret;
++
++	pwm = devm_kzalloc(dev, sizeof(*pwm), GFP_KERNEL);
++	if (!pwm)
++		return -ENOMEM;
++
++	platform_set_drvdata(pdev, pwm);
++
++	pwm->mem = devm_platform_ioremap_resource(pdev, 0);
++	if (IS_ERR(pwm->mem))
++		return dev_err_probe(dev, PTR_ERR(pwm->mem),
++				"regs map failed");
++
++	pwm->clk = devm_clk_get(dev, NULL);
++	if (IS_ERR(pwm->clk))
++		return dev_err_probe(dev, PTR_ERR(pwm->clk),
++				"failed to get clock");
++
++	ret = clk_prepare_enable(pwm->clk);
++	if (ret)
++		return dev_err_probe(dev, ret, "clock enable failed");
++
++	pwm->chip.dev = dev;
++	pwm->chip.ops = &ipq_pwm_ops;
++	pwm->chip.npwm = 4;
++
++	ret = pwmchip_add(&pwm->chip);
++	if (ret < 0) {
++		dev_err_probe(dev, ret, "pwmchip_add() failed\n");
++		clk_disable_unprepare(pwm->clk);
++	}
++
++	return ret;
++}
++
++static void ipq_pwm_remove(struct platform_device *pdev)
++{
++	struct ipq_pwm_chip *pwm = platform_get_drvdata(pdev);
++
++	pwmchip_remove(&pwm->chip);
++	clk_disable_unprepare(pwm->clk);
++}
++
++static const struct of_device_id pwm_ipq_dt_match[] = {
++	{ .compatible = "qcom,ipq6018-pwm", },
++	{}
++};
++MODULE_DEVICE_TABLE(of, pwm_ipq_dt_match);
++
++static struct platform_driver ipq_pwm_driver = {
++	.driver = {
++		.name = "ipq-pwm",
++		.of_match_table = pwm_ipq_dt_match,
++	},
++	.probe = ipq_pwm_probe,
++	.remove_new = ipq_pwm_remove,
++};
++
++module_platform_driver(ipq_pwm_driver);
++
++MODULE_LICENSE("Dual BSD/GPL");
diff --git a/target/linux/qualcommax/patches-6.6/0142-dt-bindings-mfd-qcom-tcsr-Add-simple-mfd-support-for-IPQ6018.patch b/target/linux/qualcommax/patches-6.6/0142-dt-bindings-mfd-qcom-tcsr-Add-simple-mfd-support-for-IPQ6018.patch
new file mode 100644
index 0000000000..1714fc4e6f
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0142-dt-bindings-mfd-qcom-tcsr-Add-simple-mfd-support-for-IPQ6018.patch
@@ -0,0 +1,148 @@
+From: Devi Priya <quic_devipriy@quicinc.com>
+Subject: [PATCH] dt-bindings: mfd: qcom,tcsr: Add simple-mfd support for IPQ6018
+Date: Thu, 5 Oct 2023 21:35:49 +0530
+
+Update the binding to include pwm as the child node to TCSR block and
+add simple-mfd support for IPQ6018.
+
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+---
+ .../devicetree/bindings/mfd/qcom,tcsr.yaml    | 112 +++++++++++++-----
+ 1 file changed, 81 insertions(+), 31 deletions(-)
+
+--- a/Documentation/devicetree/bindings/mfd/qcom,tcsr.yaml
++++ b/Documentation/devicetree/bindings/mfd/qcom,tcsr.yaml
+@@ -15,49 +15,101 @@ description:
+ 
+ properties:
+   compatible:
+-    items:
+-      - enum:
+-          - qcom,msm8976-tcsr
+-          - qcom,msm8998-tcsr
+-          - qcom,qcs404-tcsr
+-          - qcom,sc7180-tcsr
+-          - qcom,sc7280-tcsr
+-          - qcom,sc8280xp-tcsr
+-          - qcom,sdm630-tcsr
+-          - qcom,sdm845-tcsr
+-          - qcom,sdx55-tcsr
+-          - qcom,sdx65-tcsr
+-          - qcom,sm8150-tcsr
+-          - qcom,sm8450-tcsr
+-          - qcom,tcsr-apq8064
+-          - qcom,tcsr-apq8084
+-          - qcom,tcsr-ipq5332
+-          - qcom,tcsr-ipq6018
+-          - qcom,tcsr-ipq8064
+-          - qcom,tcsr-ipq8074
+-          - qcom,tcsr-ipq9574
+-          - qcom,tcsr-mdm9615
+-          - qcom,tcsr-msm8226
+-          - qcom,tcsr-msm8660
+-          - qcom,tcsr-msm8916
+-          - qcom,tcsr-msm8953
+-          - qcom,tcsr-msm8960
+-          - qcom,tcsr-msm8974
+-          - qcom,tcsr-msm8996
+-      - const: syscon
++    oneOf:
++      - items:
++          - enum:
++              - qcom,msm8976-tcsr
++              - qcom,msm8998-tcsr
++              - qcom,qcs404-tcsr
++              - qcom,sc7180-tcsr
++              - qcom,sc7280-tcsr
++              - qcom,sc8280xp-tcsr
++              - qcom,sdm630-tcsr
++              - qcom,sdm845-tcsr
++              - qcom,sdx55-tcsr
++              - qcom,sdx65-tcsr
++              - qcom,sm4450-tcsr
++              - qcom,sm8150-tcsr
++              - qcom,sm8450-tcsr
++              - qcom,tcsr-apq8064
++              - qcom,tcsr-apq8084
++              - qcom,tcsr-ipq5332
++              - qcom,tcsr-ipq8064
++              - qcom,tcsr-ipq8074
++              - qcom,tcsr-ipq9574
++              - qcom,tcsr-mdm9615
++              - qcom,tcsr-msm8226
++              - qcom,tcsr-msm8660
++              - qcom,tcsr-msm8916
++              - qcom,tcsr-msm8953
++              - qcom,tcsr-msm8960
++              - qcom,tcsr-msm8974
++              - qcom,tcsr-msm8996
++          - const: syscon
++      - items:
++          - const: qcom,tcsr-ipq6018
++          - const: syscon
++          - const: simple-mfd
+ 
+   reg:
+     maxItems: 1
+ 
++  ranges: true
++
++  "#address-cells":
++    const: 1
++
++  "#size-cells":
++    const: 1
++
++patternProperties:
++  "pwm@[a-f0-9]+$":
++    type: object
++    $ref: /schemas/pwm/qcom,ipq6018-pwm.yaml
++
++
+ required:
+   - compatible
+   - reg
+ 
++allOf:
++  - if:
++      not:
++        properties:
++          compatible:
++            contains:
++              enum:
++                - qcom,tcsr-ipq6018
++    then:
++      patternProperties:
++        "pwm@[a-f0-9]+$": false
++
+ additionalProperties: false
+ 
+ examples:
++  # Example 1 - Syscon node found on MSM8960
+   - |
+     syscon@1a400000 {
+         compatible = "qcom,tcsr-msm8960", "syscon";
+         reg = <0x1a400000 0x100>;
+     };
++  # Example 2 - Syscon node found on IPQ6018
++  - |
++    #include <dt-bindings/clock/qcom,gcc-ipq6018.h>
++
++    syscon@1937000 {
++        compatible = "qcom,tcsr-ipq6018", "syscon", "simple-mfd";
++        reg = <0x01937000 0x21000>;
++        ranges = <0 0x1937000 0x21000>;
++        #address-cells = <1>;
++        #size-cells = <1>;
++
++        pwm: pwm@a010 {
++            compatible = "qcom,ipq6018-pwm";
++            reg = <0xa010 0x20>;
++            clocks = <&gcc GCC_ADSS_PWM_CLK>;
++            assigned-clocks = <&gcc GCC_ADSS_PWM_CLK>;
++            assigned-clock-rates = <100000000>;
++            #pwm-cells = <2>;
++        };
++    };
+\ No newline at end of file
diff --git a/target/linux/qualcommax/patches-6.6/0150-dt-bindings-nvmem-add-IPQ5018-compatible.patch b/target/linux/qualcommax/patches-6.6/0150-dt-bindings-nvmem-add-IPQ5018-compatible.patch
new file mode 100644
index 0000000000..c31b2ba497
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0150-dt-bindings-nvmem-add-IPQ5018-compatible.patch
@@ -0,0 +1,22 @@
+From: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Subject: [PATCH V2 1/1] dt-bindings: nvmem: Add compatible for IPQ5018
+Date: Fri, 15 Sep 2023 17:31:20 +0530
+
+Document the QFPROM on IPQ5018.
+
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+---
+ Documentation/devicetree/bindings/nvmem/qcom,qfprom.yaml | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/Documentation/devicetree/bindings/nvmem/qcom,qfprom.yaml
++++ b/Documentation/devicetree/bindings/nvmem/qcom,qfprom.yaml
+@@ -18,6 +18,7 @@ properties:
+       - enum:
+           - qcom,apq8064-qfprom
+           - qcom,apq8084-qfprom
++          - qcom,ipq5018-qfprom
+           - qcom,ipq5332-qfprom
+           - qcom,ipq6018-qfprom
+           - qcom,ipq8064-qfprom
diff --git a/target/linux/qualcommax/patches-6.6/0151-dt-bindings-thermal-qcom-tsens-Add-ipq5018-compatible.patch b/target/linux/qualcommax/patches-6.6/0151-dt-bindings-thermal-qcom-tsens-Add-ipq5018-compatible.patch
new file mode 100644
index 0000000000..36ab4abbdf
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0151-dt-bindings-thermal-qcom-tsens-Add-ipq5018-compatible.patch
@@ -0,0 +1,26 @@
+From: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Date: Fri, 22 Sep 2023 17:21:13 +0530
+Subject: [PATCH] dt-bindings: thermal: qcom-tsens: Add ipq5018 compatible
+
+IPQ5018 has tsens v1.0 block with 4 sensors and 1 interrupt.
+
+Signed-off-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+---
+--- a/Documentation/devicetree/bindings/thermal/qcom-tsens.yaml
++++ b/Documentation/devicetree/bindings/thermal/qcom-tsens.yaml
+@@ -39,6 +39,7 @@ properties:
+       - description: v1 of TSENS
+         items:
+           - enum:
++              - qcom,ipq5018-tsens
+               - qcom,msm8956-tsens
+               - qcom,msm8976-tsens
+               - qcom,qcs404-tsens
+@@ -232,6 +233,7 @@ allOf:
+         compatible:
+           contains:
+             enum:
++              - qcom,ipq5018-tsens
+               - qcom,ipq8064-tsens
+               - qcom,msm8960-tsens
+               - qcom,tsens-v0_1
diff --git a/target/linux/qualcommax/patches-6.6/0152-thermal-qcom-add-new-feat-for-soc-without-rpm.patch b/target/linux/qualcommax/patches-6.6/0152-thermal-qcom-add-new-feat-for-soc-without-rpm.patch
new file mode 100644
index 0000000000..c8f393e2b6
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0152-thermal-qcom-add-new-feat-for-soc-without-rpm.patch
@@ -0,0 +1,45 @@
+From: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Subject: [PATCH] thermal/drivers/qcom: Add new feat for soc without rpm
+Date: Fri, 22 Sep 2023 17:21:14 +0530
+
+In IPQ5018, Tsens IP doesn't have RPM. Hence the early init to
+enable tsens would not be done. So add a flag for that in feat
+and skip enable checks. Without this, tsens probe fails.
+
+Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
+Signed-off-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+---
+ drivers/thermal/qcom/tsens.c | 2 +-
+ drivers/thermal/qcom/tsens.h | 3 +++
+ 2 files changed, 4 insertions(+), 1 deletion(-)
+
+--- a/drivers/thermal/qcom/tsens.c
++++ b/drivers/thermal/qcom/tsens.c
+@@ -974,7 +974,7 @@ int __init init_common(struct tsens_priv
+ 	ret = regmap_field_read(priv->rf[TSENS_EN], &enabled);
+ 	if (ret)
+ 		goto err_put_device;
+-	if (!enabled) {
++	if (!enabled && !(priv->feat->ignore_enable)) {
+ 		dev_err(dev, "%s: device not enabled\n", __func__);
+ 		ret = -ENODEV;
+ 		goto err_put_device;
+--- a/drivers/thermal/qcom/tsens.h
++++ b/drivers/thermal/qcom/tsens.h
+@@ -505,6 +505,8 @@ enum regfield_ids {
+  * @srot_split: does the IP neatly splits the register space into SROT and TM,
+  *              with SROT only being available to secure boot firmware?
+  * @has_watchdog: does this IP support watchdog functionality?
++ * @ignore_enable: does this IP reside in a soc that does not have rpm to
++ *                 do pre-init.
+  * @max_sensors: maximum sensors supported by this version of the IP
+  * @trip_min_temp: minimum trip temperature supported by this version of the IP
+  * @trip_max_temp: maximum trip temperature supported by this version of the IP
+@@ -516,6 +518,7 @@ struct tsens_features {
+ 	unsigned int adc:1;
+ 	unsigned int srot_split:1;
+ 	unsigned int has_watchdog:1;
++	unsigned int ignore_enable:1;
+ 	unsigned int max_sensors;
+ 	int trip_min_temp;
+ 	int trip_max_temp;
diff --git a/target/linux/qualcommax/patches-6.6/0153-thermal-qcom-tsens-add-support-for-IPQ5018-tsens.patch b/target/linux/qualcommax/patches-6.6/0153-thermal-qcom-tsens-add-support-for-IPQ5018-tsens.patch
new file mode 100644
index 0000000000..0de11daf72
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0153-thermal-qcom-tsens-add-support-for-IPQ5018-tsens.patch
@@ -0,0 +1,118 @@
+From: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Subject: [PATCH] thermal/drivers/tsens: Add support for IPQ5018 tsens
+Date: Fri, 22 Sep 2023 17:21:15 +0530
+
+IPQ5018 has tsens IP V1.0, 4 sensors and 1 interrupt.
+The soc does not have a RPM, hence tsens has to be reset and
+enabled in the driver init. Adding the driver support for same.
+
+Signed-off-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+---
+ drivers/thermal/qcom/tsens-v1.c | 60 +++++++++++++++++++++++++++++++++
+ drivers/thermal/qcom/tsens.c    |  3 ++
+ drivers/thermal/qcom/tsens.h    |  2 +-
+ 3 files changed, 64 insertions(+), 1 deletion(-)
+
+--- a/drivers/thermal/qcom/tsens-v1.c
++++ b/drivers/thermal/qcom/tsens-v1.c
+@@ -79,6 +79,18 @@ static struct tsens_features tsens_v1_fe
+ 	.trip_max_temp	= 120000,
+ };
+ 
++static struct tsens_features tsens_v1_ipq5018_feat = {
++	.ver_major	= VER_1_X,
++	.crit_int	= 0,
++	.combo_int	= 0,
++	.adc		= 1,
++	.srot_split	= 1,
++	.max_sensors	= 11,
++	.trip_min_temp	= -40000,
++	.trip_max_temp	= 120000,
++	.ignore_enable	= 1,
++};
++
+ static const struct reg_field tsens_v1_regfields[MAX_REGFIELDS] = {
+ 	/* ----- SROT ------ */
+ 	/* VERSION */
+@@ -150,6 +162,41 @@ static int __init init_8956(struct tsens
+ 	return init_common(priv);
+ }
+ 
++static int __init init_ipq5018(struct tsens_priv *priv)
++{
++	int ret;
++	u32 mask;
++
++	ret = init_common(priv);
++	if (ret < 0) {
++		dev_err(priv->dev, "Init common failed %d\n", ret);
++		return ret;
++	}
++
++	ret = regmap_field_write(priv->rf[TSENS_SW_RST], 1);
++	if (ret) {
++		dev_err(priv->dev, "Reset failed\n");
++		return ret;
++	}
++
++	mask = GENMASK(priv->num_sensors, 0);
++	ret = regmap_field_update_bits(priv->rf[SENSOR_EN], mask, mask);
++	if (ret) {
++		dev_err(priv->dev, "Sensor Enable failed\n");
++		return ret;
++	}
++
++	ret = regmap_field_write(priv->rf[TSENS_EN], 1);
++	if (ret) {
++		dev_err(priv->dev, "Enable failed\n");
++		return ret;
++	}
++
++	ret = regmap_field_write(priv->rf[TSENS_SW_RST], 0);
++
++	return ret;
++}
++
+ static const struct tsens_ops ops_generic_v1 = {
+ 	.init		= init_common,
+ 	.calibrate	= calibrate_v1,
+@@ -194,3 +241,16 @@ struct tsens_plat_data data_8976 = {
+ 	.feat		= &tsens_v1_feat,
+ 	.fields		= tsens_v1_regfields,
+ };
++
++const struct tsens_ops ops_ipq5018 = {
++	.init		= init_ipq5018,
++	.calibrate	= tsens_calibrate_common,
++	.get_temp	= get_temp_tsens_valid,
++};
++
++struct tsens_plat_data data_ipq5018 = {
++	.num_sensors	= 5,
++	.ops		= &ops_ipq5018,
++	.feat		= &tsens_v1_ipq5018_feat,
++	.fields		= tsens_v1_regfields,
++};
+--- a/drivers/thermal/qcom/tsens.c
++++ b/drivers/thermal/qcom/tsens.c
+@@ -1101,6 +1101,9 @@ static SIMPLE_DEV_PM_OPS(tsens_pm_ops, t
+ 
+ static const struct of_device_id tsens_table[] = {
+ 	{
++		.compatible = "qcom,ipq5018-tsens",
++		.data = &data_ipq5018,
++	}, {
+ 		.compatible = "qcom,ipq8064-tsens",
+ 		.data = &data_8960,
+ 	}, {
+--- a/drivers/thermal/qcom/tsens.h
++++ b/drivers/thermal/qcom/tsens.h
+@@ -645,7 +645,7 @@ extern struct tsens_plat_data data_8960;
+ extern struct tsens_plat_data data_8226, data_8909, data_8916, data_8939, data_8974, data_9607;
+ 
+ /* TSENS v1 targets */
+-extern struct tsens_plat_data data_tsens_v1, data_8937, data_8976, data_8956;
++extern struct tsens_plat_data data_tsens_v1, data_8937, data_8976, data_8956, data_ipq5018;
+ 
+ /* TSENS v2 targets */
+ extern struct tsens_plat_data data_8996, data_ipq8074, data_tsens_v2;
diff --git a/target/linux/qualcommax/patches-6.6/0154-dts-qcom-IPQ5018-add-tsens-node.patch b/target/linux/qualcommax/patches-6.6/0154-dts-qcom-IPQ5018-add-tsens-node.patch
new file mode 100644
index 0000000000..4f9b8abfa5
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0154-dts-qcom-IPQ5018-add-tsens-node.patch
@@ -0,0 +1,200 @@
+From: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add tsens node
+Date: Fri, 22 Sep 2023 17:21:16 +0530
+
+IPQ5018 has tsens V1.0 IP with 4 sensors.
+There is no RPM, so tsens has to be manually enabled. Adding the tsens
+and nvmem node and IPQ5018 has 4 thermal sensors (zones). With the
+critical temperature being 120'C and action is to reboot. Adding all
+the 4 zones here.
+
+Signed-off-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 169 ++++++++++++++++++++++++++
+ 1 file changed, 169 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -149,6 +149,117 @@
+ 			status = "disabled";
+ 		};
+ 
++		qfprom: qfprom@a0000 {
++			compatible = "qcom,ipq5018-qfprom", "qcom,qfprom";
++			reg = <0xa0000 0x1000>;
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			tsens_mode: mode@249 {
++				reg = <0x249 1>;
++				bits = <0 3>;
++			};
++
++			tsens_base1: base1@249 {
++				reg = <0x249 2>;
++				bits = <3 8>;
++			};
++
++			tsens_base2: base2@24a {
++				reg = <0x24a 2>;
++				bits = <3 8>;
++			};
++
++			tsens_s0_p1: s0-p1@24b {
++				reg = <0x24b 0x2>;
++				bits = <2 6>;
++			};
++
++			tsens_s0_p2: s0-p2@24c {
++				reg = <0x24c 0x1>;
++				bits = <1 6>;
++			};
++
++			tsens_s1_p1: s1-p1@24c {
++				reg = <0x24c 0x2>;
++				bits = <7 6>;
++			};
++
++			tsens_s1_p2: s1-p2@24d {
++				reg = <0x24d 0x2>;
++				bits = <5 6>;
++			};
++
++			tsens_s2_p1: s2-p1@24e {
++				reg = <0x24e 0x2>;
++				bits = <3 6>;
++			};
++
++			tsens_s2_p2: s2-p2@24f {
++				reg = <0x24f 0x1>;
++				bits = <1 6>;
++			};
++
++			tsens_s3_p1: s3-p1@24f {
++				reg = <0x24f 0x2>;
++				bits = <7 6>;
++			};
++
++			tsens_s3_p2: s3-p2@250 {
++				reg = <0x250 0x2>;
++				bits = <5 6>;
++			};
++
++			tsens_s4_p1: s4-p1@251 {
++				reg = <0x251 0x2>;
++				bits = <3 6>;
++			};
++
++			tsens_s4_p2: s4-p2@254 {
++				reg = <0x254 0x1>;
++				bits = <0 6>;
++			};
++		};
++
++		tsens: thermal-sensor@4a9000 {
++			compatible = "qcom,ipq5018-tsens";
++			reg = <0x4a9000 0x1000>, /* TM */
++			      <0x4a8000 0x1000>; /* SROT */
++
++			nvmem-cells = <&tsens_mode>,
++				      <&tsens_base1>,
++				      <&tsens_base2>,
++				      <&tsens_s0_p1>,
++				      <&tsens_s0_p2>,
++				      <&tsens_s1_p1>,
++				      <&tsens_s1_p2>,
++				      <&tsens_s2_p1>,
++				      <&tsens_s2_p2>,
++				      <&tsens_s3_p1>,
++				      <&tsens_s3_p2>,
++				      <&tsens_s4_p1>,
++				      <&tsens_s4_p2>;
++
++			nvmem-cell-names = "mode",
++					   "base1",
++					   "base2",
++					   "s0_p1",
++					   "s0_p2",
++					   "s1_p1",
++					   "s1_p2",
++					   "s2_p1",
++					   "s2_p2",
++					   "s3_p1",
++					   "s3_p2",
++					   "s4_p1",
++					   "s4_p2";
++
++			interrupts = <GIC_SPI 184 IRQ_TYPE_EDGE_RISING>;
++			interrupt-names = "uplow";
++			#qcom,sensors = <5>;
++			#thermal-sensor-cells = <1>;
++		};
++
+ 		tlmm: pinctrl@1000000 {
+ 			compatible = "qcom,ipq5018-tlmm";
+ 			reg = <0x01000000 0x300000>;
+@@ -391,6 +502,64 @@
+ 			};
+ 		};
+ 	};
++
++	thermal-zones {
++		cpu-thermal {
++			polling-delay-passive = <0>;
++			polling-delay = <0>;
++			thermal-sensors = <&tsens 2>;
++
++			trips {
++				cpu-critical {
++					temperature = <120000>;
++					hysteresis = <2>;
++					type = "critical";
++				};
++			};
++		};
++
++		gephy-thermal {
++			polling-delay-passive = <0>;
++			polling-delay = <0>;
++			thermal-sensors = <&tsens 4>;
++
++			trips {
++				gephy-critical {
++					temperature = <120000>;
++					hysteresis = <2>;
++					type = "critical";
++				};
++			};
++		};
++
++		top-glue-thermal {
++			polling-delay-passive = <0>;
++			polling-delay = <0>;
++			thermal-sensors = <&tsens 3>;
++
++			trips {
++				top_glue-critical {
++					temperature = <120000>;
++					hysteresis = <2>;
++					type = "critical";
++				};
++			};
++		};
++
++		ubi32-thermal {
++			polling-delay-passive = <0>;
++			polling-delay = <0>;
++			thermal-sensors = <&tsens 1>;
++
++			trips {
++				ubi32-critical {
++					temperature = <120000>;
++					hysteresis = <2>;
++					type = "critical";
++				};
++			};
++		};
++	};
+ 
+ 	timer {
+ 		compatible = "arm,armv8-timer";
diff --git a/target/linux/qualcommax/patches-6.6/0155-dt-bindings-phy-qcom-uniphy-pcie-Document-PCIe-uniphy.patch b/target/linux/qualcommax/patches-6.6/0155-dt-bindings-phy-qcom-uniphy-pcie-Document-PCIe-uniphy.patch
new file mode 100644
index 0000000000..7997976d7c
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0155-dt-bindings-phy-qcom-uniphy-pcie-Document-PCIe-uniphy.patch
@@ -0,0 +1,85 @@
+From: Varadarajan Narayanan <quic_varada@quicinc.com>
+Date: Thu, 2 Jan 2025 17:00:15 +0530
+Subject: [PATCH] dt-bindings: phy: qcom,uniphy-pcie: Document PCIe uniphy
+
+From: Nitheesh Sekar <quic_nsekar@quicinc.com>
+
+Document the Qualcomm UNIPHY PCIe 28LP present in IPQ5332.
+
+Signed-off-by: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+---
+--- /dev/null
++++ b/Documentation/devicetree/bindings/phy/qcom,ipq5332-uniphy-pcie-phy.yaml
+@@ -0,0 +1,71 @@
++# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/phy/qcom,ipq5332-uniphy-pcie-phy.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Qualcomm UNIPHY PCIe 28LP PHY
++
++maintainers:
++  - Nitheesh Sekar <quic_nsekar@quicinc.com>
++  - Varadarajan Narayanan <quic_varada@quicinc.com>
++
++description:
++  PCIe and USB combo PHY found in Qualcomm IPQ5332 SoC
++
++properties:
++  compatible:
++    enum:
++      - qcom,ipq5332-uniphy-pcie-phy
++
++  reg:
++    maxItems: 1
++
++  clocks:
++    items:
++      - description: pcie pipe clock
++      - description: pcie ahb clock
++
++  resets:
++    items:
++      - description: phy reset
++      - description: ahb reset
++      - description: cfg reset
++
++  "#phy-cells":
++    const: 0
++
++  "#clock-cells":
++    const: 0
++
++  num-lanes: true
++
++required:
++  - compatible
++  - reg
++  - clocks
++  - resets
++  - "#phy-cells"
++  - "#clock-cells"
++
++additionalProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/clock/qcom,ipq5332-gcc.h>
++
++    pcie0_phy: phy@4b0000 {
++        compatible = "qcom,ipq5332-uniphy-pcie-phy";
++        reg = <0x004b0000 0x800>;
++
++        clocks = <&gcc GCC_PCIE3X1_0_PIPE_CLK>,
++                 <&gcc GCC_PCIE3X1_PHY_AHB_CLK>;
++
++        resets = <&gcc GCC_PCIE3X1_0_PHY_BCR>,
++                 <&gcc GCC_PCIE3X1_PHY_AHB_CLK_ARES>,
++                 <&gcc GCC_PCIE3X1_0_PHY_PHY_BCR>;
++
++        #clock-cells = <0>;
++
++        #phy-cells = <0>;
++    };
diff --git a/target/linux/qualcommax/patches-6.6/0156-phy-qcom-Introduce-PCIe-UNIPHY-28LP-driver.patch b/target/linux/qualcommax/patches-6.6/0156-phy-qcom-Introduce-PCIe-UNIPHY-28LP-driver.patch
new file mode 100644
index 0000000000..f30db1463f
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0156-phy-qcom-Introduce-PCIe-UNIPHY-28LP-driver.patch
@@ -0,0 +1,332 @@
+From: Varadarajan Narayanan <quic_varada@quicinc.com>
+Date: Thu, 2 Jan 2025 17:00:16 +0530
+Subject: [PATCH] phy: qcom: Introduce PCIe UNIPHY 28LP driver
+
+From: Nitheesh Sekar <quic_nsekar@quicinc.com>
+
+Add Qualcomm PCIe UNIPHY 28LP driver support present
+in Qualcomm IPQ5332 SoC and the phy init sequence.
+
+Reviewed-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
+Signed-off-by: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+---
+--- a/drivers/phy/qualcomm/Kconfig
++++ b/drivers/phy/qualcomm/Kconfig
+@@ -154,6 +154,18 @@ config PHY_QCOM_M31_USB
+ 	  management. This driver is required even for peripheral only or
+ 	  host only mode configurations.
+ 
++config PHY_QCOM_UNIPHY_PCIE_28LP
++	bool "PCIE UNIPHY 28LP PHY driver"
++	depends on ARCH_QCOM
++	depends on HAS_IOMEM
++	depends on OF
++	select GENERIC_PHY
++	help
++	  Enable this to support the PCIe UNIPHY 28LP phy transceiver that
++	  is used with PCIe controllers on Qualcomm IPQ5332 chips. It
++	  handles PHY initialization, clock management required after
++	  resetting the hardware and power management.
++
+ config PHY_QCOM_USB_HS
+ 	tristate "Qualcomm USB HS PHY module"
+ 	depends on USB_ULPI_BUS
+--- a/drivers/phy/qualcomm/Makefile
++++ b/drivers/phy/qualcomm/Makefile
+@@ -17,6 +17,7 @@ obj-$(CONFIG_PHY_QCOM_QMP_USB_LEGACY)	+=
+ obj-$(CONFIG_PHY_QCOM_QUSB2)		+= phy-qcom-qusb2.o
+ obj-$(CONFIG_PHY_QCOM_SNPS_EUSB2)	+= phy-qcom-snps-eusb2.o
+ obj-$(CONFIG_PHY_QCOM_EUSB2_REPEATER)	+= phy-qcom-eusb2-repeater.o
++obj-$(CONFIG_PHY_QCOM_UNIPHY_PCIE_28LP)	+= phy-qcom-uniphy-pcie-28lp.o
+ obj-$(CONFIG_PHY_QCOM_USB_HS) 		+= phy-qcom-usb-hs.o
+ obj-$(CONFIG_PHY_QCOM_USB_HSIC) 	+= phy-qcom-usb-hsic.o
+ obj-$(CONFIG_PHY_QCOM_USB_HS_28NM)	+= phy-qcom-usb-hs-28nm.o
+--- /dev/null
++++ b/drivers/phy/qualcomm/phy-qcom-uniphy-pcie-28lp.c
+@@ -0,0 +1,285 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Copyright (c) 2025, The Linux Foundation. All rights reserved.
++ */
++
++#include <linux/clk.h>
++#include <linux/clk-provider.h>
++#include <linux/delay.h>
++#include <linux/err.h>
++#include <linux/io.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/of_device.h>
++#include <linux/of.h>
++#include <linux/phy/phy.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++#include <linux/reset.h>
++
++#define RST_ASSERT_DELAY_MIN_US		100
++#define RST_ASSERT_DELAY_MAX_US		150
++#define PIPE_CLK_DELAY_MIN_US		5000
++#define PIPE_CLK_DELAY_MAX_US		5100
++#define CLK_EN_DELAY_MIN_US		30
++#define CLK_EN_DELAY_MAX_US		50
++#define CDR_CTRL_REG_1		0x80
++#define CDR_CTRL_REG_2		0x84
++#define CDR_CTRL_REG_3		0x88
++#define CDR_CTRL_REG_4		0x8c
++#define CDR_CTRL_REG_5		0x90
++#define CDR_CTRL_REG_6		0x94
++#define CDR_CTRL_REG_7		0x98
++#define SSCG_CTRL_REG_1		0x9c
++#define SSCG_CTRL_REG_2		0xa0
++#define SSCG_CTRL_REG_3		0xa4
++#define SSCG_CTRL_REG_4		0xa8
++#define SSCG_CTRL_REG_5		0xac
++#define SSCG_CTRL_REG_6		0xb0
++#define PCS_INTERNAL_CONTROL_2	0x2d8
++
++#define PHY_CFG_PLLCFG				0x220
++#define PHY_CFG_EIOS_DTCT_REG			0x3e4
++#define PHY_CFG_GEN3_ALIGN_HOLDOFF_TIME		0x3e8
++
++#define PHY_MODE_FIXED		0x1
++
++enum qcom_uniphy_pcie_type {
++	PHY_TYPE_PCIE = 1,
++	PHY_TYPE_PCIE_GEN2,
++	PHY_TYPE_PCIE_GEN3,
++};
++
++struct qcom_uniphy_pcie_regs {
++	u32 offset;
++	u32 val;
++};
++
++struct qcom_uniphy_pcie_data {
++	int lane_offset; /* offset between the lane register bases */
++	u32 phy_type;
++	const struct qcom_uniphy_pcie_regs *init_seq;
++	u32 init_seq_num;
++	u32 pipe_clk_rate;
++};
++
++struct qcom_uniphy_pcie {
++	struct phy phy;
++	struct device *dev;
++	const struct qcom_uniphy_pcie_data *data;
++	struct clk_bulk_data *clks;
++	int num_clks;
++	struct reset_control *resets;
++	void __iomem *base;
++	int lanes;
++};
++
++#define phy_to_dw_phy(x)	container_of((x), struct qca_uni_pcie_phy, phy)
++
++static const struct qcom_uniphy_pcie_regs ipq5332_regs[] = {
++	{
++		.offset = PHY_CFG_PLLCFG,
++		.val = 0x30,
++	}, {
++		.offset = PHY_CFG_EIOS_DTCT_REG,
++		.val = 0x53ef,
++	}, {
++		.offset = PHY_CFG_GEN3_ALIGN_HOLDOFF_TIME,
++		.val = 0xcf,
++	},
++};
++
++static const struct qcom_uniphy_pcie_data ipq5332_data = {
++	.lane_offset	= 0x800,
++	.phy_type	= PHY_TYPE_PCIE_GEN3,
++	.init_seq	= ipq5332_regs,
++	.init_seq_num	= ARRAY_SIZE(ipq5332_regs),
++	.pipe_clk_rate	= 250000000,
++};
++
++static void qcom_uniphy_pcie_init(struct qcom_uniphy_pcie *phy)
++{
++	const struct qcom_uniphy_pcie_data *data = phy->data;
++	const struct qcom_uniphy_pcie_regs *init_seq;
++	void __iomem *base = phy->base;
++	int lane, i;
++
++	for (lane = 0; lane < phy->lanes; lane++) {
++		init_seq = data->init_seq;
++
++		for (i = 0; i < data->init_seq_num; i++)
++			writel(init_seq[i].val, base + init_seq[i].offset);
++
++		base += data->lane_offset;
++	}
++}
++
++static int qcom_uniphy_pcie_power_off(struct phy *x)
++{
++	struct qcom_uniphy_pcie *phy = phy_get_drvdata(x);
++
++	clk_bulk_disable_unprepare(phy->num_clks, phy->clks);
++
++	return reset_control_assert(phy->resets);
++}
++
++static int qcom_uniphy_pcie_power_on(struct phy *x)
++{
++	struct qcom_uniphy_pcie *phy = phy_get_drvdata(x);
++	int ret;
++
++	ret = reset_control_assert(phy->resets);
++	if (ret) {
++		dev_err(phy->dev, "reset assert failed (%d)\n", ret);
++		return ret;
++	}
++
++	usleep_range(RST_ASSERT_DELAY_MIN_US, RST_ASSERT_DELAY_MAX_US);
++
++	ret = reset_control_deassert(phy->resets);
++	if (ret) {
++		dev_err(phy->dev, "reset deassert failed (%d)\n", ret);
++		return ret;
++	}
++
++	usleep_range(PIPE_CLK_DELAY_MIN_US, PIPE_CLK_DELAY_MAX_US);
++
++	ret = clk_bulk_prepare_enable(phy->num_clks, phy->clks);
++	if (ret) {
++		dev_err(phy->dev, "clk prepare and enable failed %d\n", ret);
++		return ret;
++	}
++
++	usleep_range(CLK_EN_DELAY_MIN_US, CLK_EN_DELAY_MAX_US);
++
++	qcom_uniphy_pcie_init(phy);
++	return 0;
++}
++
++static inline int qcom_uniphy_pcie_get_resources(struct platform_device *pdev,
++						 struct qcom_uniphy_pcie *phy)
++{
++	struct resource *res;
++
++	phy->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
++	if (IS_ERR(phy->base))
++		return PTR_ERR(phy->base);
++
++	phy->num_clks = devm_clk_bulk_get_all(phy->dev, &phy->clks);
++	if (phy->num_clks < 0)
++		return phy->num_clks;
++
++	phy->resets = devm_reset_control_array_get_exclusive(phy->dev);
++	if (IS_ERR(phy->resets))
++		return PTR_ERR(phy->resets);
++
++	return 0;
++}
++
++/*
++ * Register a fixed rate pipe clock.
++ *
++ * The <s>_pipe_clksrc generated by PHY goes to the GCC that gate
++ * controls it. The <s>_pipe_clk coming out of the GCC is requested
++ * by the PHY driver for its operations.
++ * We register the <s>_pipe_clksrc here. The gcc driver takes care
++ * of assigning this <s>_pipe_clksrc as parent to <s>_pipe_clk.
++ * Below picture shows this relationship.
++ *
++ *         +---------------+
++ *         |   PHY block   |<<---------------------------------------+
++ *         |               |                                         |
++ *         |   +-------+   |                   +-----+               |
++ *   I/P---^-->|  PLL  |---^--->pipe_clksrc--->| GCC |--->pipe_clk---+
++ *    clk  |   +-------+   |                   +-----+
++ *         +---------------+
++ */
++static inline int phy_pipe_clk_register(struct qcom_uniphy_pcie *phy, int id)
++{
++	const struct qcom_uniphy_pcie_data *data = phy->data;
++	struct clk_hw *hw;
++	char name[64];
++
++	snprintf(name, sizeof(name), "phy%d_pipe_clk_src", id);
++	hw = devm_clk_hw_register_fixed_rate(phy->dev, name, NULL, 0,
++					     data->pipe_clk_rate);
++	if (IS_ERR(hw))
++		return dev_err_probe(phy->dev, PTR_ERR(hw),
++				     "Unable to register %s\n", name);
++
++	return devm_of_clk_add_hw_provider(phy->dev, of_clk_hw_simple_get, hw);
++}
++
++static const struct of_device_id qcom_uniphy_pcie_id_table[] = {
++	{
++		.compatible = "qcom,ipq5332-uniphy-pcie-phy",
++		.data = &ipq5332_data,
++	}, {
++		/* Sentinel */
++	},
++};
++MODULE_DEVICE_TABLE(of, qcom_uniphy_pcie_id_table);
++
++static const struct phy_ops pcie_ops = {
++	.power_on	= qcom_uniphy_pcie_power_on,
++	.power_off	= qcom_uniphy_pcie_power_off,
++	.owner          = THIS_MODULE,
++};
++
++static int qcom_uniphy_pcie_probe(struct platform_device *pdev)
++{
++	struct phy_provider *phy_provider;
++	struct device *dev = &pdev->dev;
++	struct qcom_uniphy_pcie *phy;
++	struct phy *generic_phy;
++	int ret;
++
++	phy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);
++	if (!phy)
++		return -ENOMEM;
++
++	platform_set_drvdata(pdev, phy);
++	phy->dev = &pdev->dev;
++
++	phy->data = of_device_get_match_data(dev);
++	if (!phy->data)
++		return -EINVAL;
++
++	phy->lanes = 1;
++	ret = of_property_read_u32(dev->of_node, "num-lanes", &phy->lanes);
++
++	ret = qcom_uniphy_pcie_get_resources(pdev, phy);
++	if (ret < 0)
++		return dev_err_probe(&pdev->dev, ret,
++				     "failed to get resources: %d\n", ret);
++
++	generic_phy = devm_phy_create(phy->dev, NULL, &pcie_ops);
++	if (IS_ERR(generic_phy))
++		return PTR_ERR(generic_phy);
++
++	phy_set_drvdata(generic_phy, phy);
++
++	ret = phy_pipe_clk_register(phy, generic_phy->id);
++	if (ret)
++		dev_err(&pdev->dev, "failed to register phy pipe clk\n");
++
++	phy_provider = devm_of_phy_provider_register(phy->dev,
++						     of_phy_simple_xlate);
++	if (IS_ERR(phy_provider))
++		return PTR_ERR(phy_provider);
++
++	return 0;
++}
++
++static struct platform_driver qcom_uniphy_pcie_driver = {
++	.probe		= qcom_uniphy_pcie_probe,
++	.driver		= {
++		.name	= "qcom-uniphy-pcie",
++		.of_match_table = qcom_uniphy_pcie_id_table,
++	},
++};
++
++module_platform_driver(qcom_uniphy_pcie_driver);
++
++MODULE_DESCRIPTION("PCIE QCOM UNIPHY driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/qualcommax/patches-6.6/0157-dt-bindings-phy-qcom-uniphy-pcie-add-IPQ5018-compatible.patch b/target/linux/qualcommax/patches-6.6/0157-dt-bindings-phy-qcom-uniphy-pcie-add-IPQ5018-compatible.patch
new file mode 100644
index 0000000000..9951daa8f7
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0157-dt-bindings-phy-qcom-uniphy-pcie-add-IPQ5018-compatible.patch
@@ -0,0 +1,25 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Tue, 07 Jan 2025 17:34:13 +0400
+Subject: [PATCH] phy: qualcomm: qcom-uniphy-pcie add IPQ5018 compatible
+
+The Qualcomm UNIPHY PCIe PHY 28lp part of the IPQ5332 SoC is also present on
+the IPQ5018 SoC, so adding the compatible for IPQ5018.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/Documentation/devicetree/bindings/phy/qcom,ipq5332-uniphy-pcie-phy.yaml
++++ b/Documentation/devicetree/bindings/phy/qcom,ipq5332-uniphy-pcie-phy.yaml
+@@ -11,11 +11,12 @@ maintainers:
+   - Varadarajan Narayanan <quic_varada@quicinc.com>
+ 
+ description:
+-  PCIe and USB combo PHY found in Qualcomm IPQ5332 SoC
++  PCIe and USB combo PHY found in Qualcomm IPQ5018 and IPQ5332 SoCs
+ 
+ properties:
+   compatible:
+     enum:
++      - qcom,ipq5018-uniphy-pcie-phy
+       - qcom,ipq5332-uniphy-pcie-phy
+ 
+   reg:
diff --git a/target/linux/qualcommax/patches-6.6/0158-phy-qcom-uniphy-pcie-28lp-add-support-for-IPQ5018.patch b/target/linux/qualcommax/patches-6.6/0158-phy-qcom-uniphy-pcie-28lp-add-support-for-IPQ5018.patch
new file mode 100644
index 0000000000..aedb959873
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0158-phy-qcom-uniphy-pcie-28lp-add-support-for-IPQ5018.patch
@@ -0,0 +1,77 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Tue, 07 Jan 2025 17:34:13 +0400
+Subject: [PATCH] phy: qualcomm: qcom-uniphy-pcie 28lp add support for IPQ5018
+
+The Qualcomm UNIPHY PCIe PHY 28lp is found on both IPQ5332 and IPQ5018.
+Adding the PHY init sequence, pipe clock rate, and compatible for IPQ5018.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/phy/qualcomm/phy-qcom-uniphy-pcie-28lp.c
++++ b/drivers/phy/qualcomm/phy-qcom-uniphy-pcie-28lp.c
+@@ -76,6 +76,40 @@ struct qcom_uniphy_pcie {
+ 
+ #define phy_to_dw_phy(x)	container_of((x), struct qca_uni_pcie_phy, phy)
+ 
++static const struct qcom_uniphy_pcie_regs ipq5018_regs[] = {
++	{
++		.offset = SSCG_CTRL_REG_4,
++		.val = 0x1cb9,
++	}, {
++		.offset = SSCG_CTRL_REG_5,
++		.val = 0x023a,
++	}, {
++		.offset = SSCG_CTRL_REG_3,
++		.val = 0xd360,
++	}, {
++		.offset = SSCG_CTRL_REG_1,
++		.val = 0x1,
++	}, {
++		.offset = SSCG_CTRL_REG_2,
++		.val = 0xeb,
++	}, {
++		.offset = CDR_CTRL_REG_4,
++		.val = 0x3f9,
++	}, {
++		.offset = CDR_CTRL_REG_5,
++		.val = 0x1c9,
++	}, {
++		.offset = CDR_CTRL_REG_2,
++		.val = 0x419,
++	}, {
++		.offset = CDR_CTRL_REG_1,
++		.val = 0x200,
++	}, {
++		.offset = PCS_INTERNAL_CONTROL_2,
++		.val = 0xf101,
++	},
++};
++
+ static const struct qcom_uniphy_pcie_regs ipq5332_regs[] = {
+ 	{
+ 		.offset = PHY_CFG_PLLCFG,
+@@ -89,6 +123,14 @@ static const struct qcom_uniphy_pcie_reg
+ 	},
+ };
+ 
++static const struct qcom_uniphy_pcie_data ipq5018_data = {
++	.lane_offset	= 0x800,
++	.phy_type	= PHY_TYPE_PCIE_GEN2,
++	.init_seq	= ipq5018_regs,
++	.init_seq_num	= ARRAY_SIZE(ipq5018_regs),
++	.pipe_clk_rate	= 125000000,
++};
++
+ static const struct qcom_uniphy_pcie_data ipq5332_data = {
+ 	.lane_offset	= 0x800,
+ 	.phy_type	= PHY_TYPE_PCIE_GEN3,
+@@ -212,6 +254,9 @@ static inline int phy_pipe_clk_register(
+ 
+ static const struct of_device_id qcom_uniphy_pcie_id_table[] = {
+ 	{
++		.compatible = "qcom,ipq5018-uniphy-pcie-phy",
++		.data = &ipq5018_data,
++	}, {
+ 		.compatible = "qcom,ipq5332-uniphy-pcie-phy",
+ 		.data = &ipq5332_data,
+ 	}, {
diff --git a/target/linux/qualcommax/patches-6.6/0160-dt-bindings-PCI-qcom-Add-IPQ5018-SoC.patch b/target/linux/qualcommax/patches-6.6/0160-dt-bindings-PCI-qcom-Add-IPQ5018-SoC.patch
new file mode 100644
index 0000000000..caa9889109
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0160-dt-bindings-PCI-qcom-Add-IPQ5018-SoC.patch
@@ -0,0 +1,78 @@
+From: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Date: Tue, 3 Oct 2023 17:38:42 +0530
+Subject: [PATCH] dt-bindings: PCI: qcom: Add IPQ5108 SoC
+
+Add support for the PCIe controller on the Qualcomm
+IPQ5108 SoC to the bindings.
+
+Signed-off-by: Nitheesh Sekar <quic_nsekar@quicinc.com>
+---
+ .../devicetree/bindings/pci/qcom,pcie.yaml    | 36 +++++++++++++++++++
+ 1 file changed, 36 insertions(+)
+
+--- a/Documentation/devicetree/bindings/pci/qcom,pcie.yaml
++++ b/Documentation/devicetree/bindings/pci/qcom,pcie.yaml
+@@ -21,6 +21,7 @@ properties:
+           - qcom,pcie-apq8064
+           - qcom,pcie-apq8084
+           - qcom,pcie-ipq4019
++          - qcom,pcie-ipq5018
+           - qcom,pcie-ipq6018
+           - qcom,pcie-ipq8064
+           - qcom,pcie-ipq8064-v2
+@@ -170,6 +171,7 @@ allOf:
+         compatible:
+           contains:
+             enum:
++              - qcom,pcie-ipq5018
+               - qcom,pcie-ipq6018
+               - qcom,pcie-ipq8074-gen3
+     then:
+@@ -337,6 +339,39 @@ allOf:
+         compatible:
+           contains:
+             enum:
++              - qcom,pcie-ipq5018
++    then:
++      properties:
++        clocks:
++          minItems: 6
++          maxItems: 6
++        clock-names:
++          items:
++            - const: iface # PCIe to SysNOC BIU clock
++            - const: axi_m # AXI Master clock
++            - const: axi_s # AXI Slave clock
++            - const: ahb # AHB clock
++            - const: aux # Auxiliary clock
++            - const: axi_bridge # AXI bridge clock
++        resets:
++          minItems: 8
++          maxItems: 8
++        reset-names:
++          items:
++            - const: pipe # PIPE reset
++            - const: sleep # Sleep reset
++            - const: sticky # Core sticky reset
++            - const: axi_m # AXI master reset
++            - const: axi_s # AXI slave reset
++            - const: ahb # AHB reset
++            - const: axi_m_sticky # AXI master sticky reset
++            - const: axi_s_sticky # AXI slave sticky reset
++
++  - if:
++      properties:
++        compatible:
++          contains:
++            enum:
+               - qcom,pcie-msm8996
+     then:
+       properties:
+@@ -875,6 +910,7 @@ allOf:
+               - qcom,pcie-apq8064
+               - qcom,pcie-apq8084
+               - qcom,pcie-ipq4019
++              - qcom,pcie-ipq5018
+               - qcom,pcie-ipq6018
+               - qcom,pcie-ipq8064
+               - qcom,pcie-ipq8064-v2
diff --git a/target/linux/qualcommax/patches-6.6/0161-PCI-qcom-add-support-for-IPQ5018.patch b/target/linux/qualcommax/patches-6.6/0161-PCI-qcom-add-support-for-IPQ5018.patch
new file mode 100644
index 0000000000..bd8f51b84c
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0161-PCI-qcom-add-support-for-IPQ5018.patch
@@ -0,0 +1,77 @@
+From: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Subject: [PATCH] PCI: qcom: Add support for IPQ5018
+Date: Tue, 3 Oct 2023 17:38:44 +0530
+
+Added a new compatible 'qcom,pcie-ipq5018' and modified
+get_resources of 'ops 2_9_0' to get the clocks from the
+device-tree.
+
+Co-developed-by: Anusha Rao <quic_anusha@quicinc.com>
+Signed-off-by: Anusha Rao <quic_anusha@quicinc.com>
+Co-developed-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Devi Priya <quic_devipriy@quicinc.com>
+Signed-off-by: Nitheesh Sekar <quic_nsekar@quicinc.com>
+---
+ drivers/pci/controller/dwc/pcie-qcom.c | 22 ++++++++--------------
+ 1 file changed, 8 insertions(+), 14 deletions(-)
+
+--- a/drivers/pci/controller/dwc/pcie-qcom.c
++++ b/drivers/pci/controller/dwc/pcie-qcom.c
+@@ -202,8 +202,9 @@ struct qcom_pcie_resources_2_7_0 {
+ 
+ #define QCOM_PCIE_2_9_0_MAX_CLOCKS		5
+ struct qcom_pcie_resources_2_9_0 {
+-	struct clk_bulk_data clks[QCOM_PCIE_2_9_0_MAX_CLOCKS];
++	struct clk_bulk_data *clks;
+ 	struct reset_control *rst;
++	int num_clks;
+ };
+ 
+ union qcom_pcie_resources {
+@@ -1073,17 +1074,10 @@ static int qcom_pcie_get_resources_2_9_0
+ 	struct qcom_pcie_resources_2_9_0 *res = &pcie->res.v2_9_0;
+ 	struct dw_pcie *pci = pcie->pci;
+ 	struct device *dev = pci->dev;
+-	int ret;
+-
+-	res->clks[0].id = "iface";
+-	res->clks[1].id = "axi_m";
+-	res->clks[2].id = "axi_s";
+-	res->clks[3].id = "axi_bridge";
+-	res->clks[4].id = "rchng";
+ 
+-	ret = devm_clk_bulk_get(dev, ARRAY_SIZE(res->clks), res->clks);
+-	if (ret < 0)
+-		return ret;
++	res->num_clks = devm_clk_bulk_get_all(dev, &res->clks);
++	if (res->num_clks < 0)
++		return res->num_clks;
+ 
+ 	res->rst = devm_reset_control_array_get_exclusive(dev);
+ 	if (IS_ERR(res->rst))
+@@ -1096,7 +1090,7 @@ static void qcom_pcie_deinit_2_9_0(struc
+ {
+ 	struct qcom_pcie_resources_2_9_0 *res = &pcie->res.v2_9_0;
+ 
+-	clk_bulk_disable_unprepare(ARRAY_SIZE(res->clks), res->clks);
++	clk_bulk_disable_unprepare(res->num_clks, res->clks);
+ }
+ 
+ static int qcom_pcie_init_2_9_0(struct qcom_pcie *pcie)
+@@ -1125,7 +1119,7 @@ static int qcom_pcie_init_2_9_0(struct q
+ 
+ 	usleep_range(2000, 2500);
+ 
+-	return clk_bulk_prepare_enable(ARRAY_SIZE(res->clks), res->clks);
++	return clk_bulk_prepare_enable(res->num_clks, res->clks);
+ }
+ 
+ static int qcom_pcie_post_init_2_9_0(struct qcom_pcie *pcie)
+@@ -1641,6 +1635,7 @@ static const struct of_device_id qcom_pc
+ 	{ .compatible = "qcom,pcie-apq8064", .data = &cfg_2_1_0 },
+ 	{ .compatible = "qcom,pcie-apq8084", .data = &cfg_1_0_0 },
+ 	{ .compatible = "qcom,pcie-ipq4019", .data = &cfg_2_4_0 },
++	{ .compatible = "qcom,pcie-ipq5018", .data = &cfg_2_9_0 },
+ 	{ .compatible = "qcom,pcie-ipq6018", .data = &cfg_2_9_0 },
+ 	{ .compatible = "qcom,pcie-ipq8064", .data = &cfg_2_1_0 },
+ 	{ .compatible = "qcom,pcie-ipq8064-v2", .data = &cfg_2_1_0 },
diff --git a/target/linux/qualcommax/patches-6.6/0162-arm64-dts-qcom-IPQ5018-add-PCIe-related-nodes.patch b/target/linux/qualcommax/patches-6.6/0162-arm64-dts-qcom-IPQ5018-add-PCIe-related-nodes.patch
new file mode 100644
index 0000000000..f51d103508
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0162-arm64-dts-qcom-IPQ5018-add-PCIe-related-nodes.patch
@@ -0,0 +1,216 @@
+From: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add PCIe related nodes
+Date: Tue, 3 Oct 2023 17:38:45 +0530
+
+Add phy and controller nodes for PCIe0 and PCIe1.
+PCIe0 is 2-lane Gen2 and PCIe1 is 1-lane Gen2.
+
+Signed-off-by: Nitheesh Sekar <quic_nsekar@quicinc.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 186 +++++++++++++++++++++++++-
+ 1 file changed, 184 insertions(+), 2 deletions(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -149,6 +149,42 @@
+ 			status = "disabled";
+ 		};
+ 
++		pcie1_phy: phy@7e000{
++			compatible = "qcom,ipq5018-uniphy-pcie-phy";
++			reg = <0x0007e000 0x800>;
++
++			clocks = <&gcc GCC_PCIE1_PIPE_CLK>;
++
++			resets = <&gcc GCC_PCIE1_PHY_BCR>,
++					 <&gcc GCC_PCIE1PHY_PHY_BCR>;
++
++			#clock-cells = <0>;
++
++			#phy-cells = <0>;
++
++			num-lanes = <1>;
++
++			status = "disabled";
++		};
++
++		pcie0_phy: phy@86000{
++			compatible = "qcom,ipq5018-uniphy-pcie-phy";
++			reg = <0x00086000 0x800>;
++
++			clocks = <&gcc GCC_PCIE0_PIPE_CLK>;
++
++			resets = <&gcc GCC_PCIE0_PHY_BCR>,
++					 <&gcc GCC_PCIE0PHY_PHY_BCR>;
++
++			#clock-cells = <0>;
++
++			#phy-cells = <0>;
++
++			num-lanes = <2>;
++
++			status = "disabled";
++		};
++
+ 		qfprom: qfprom@a0000 {
+ 			compatible = "qcom,ipq5018-qfprom", "qcom,qfprom";
+ 			reg = <0xa0000 0x1000>;
+@@ -283,8 +319,8 @@
+ 			reg = <0x01800000 0x80000>;
+ 			clocks = <&xo_board_clk>,
+ 				 <&sleep_clk>,
+-				 <0>,
+-				 <0>,
++				 <&pcie0_phy>,
++				 <&pcie1_phy>,
+ 				 <0>,
+ 				 <0>,
+ 				 <0>,
+@@ -501,6 +537,146 @@
+ 				status = "disabled";
+ 			};
+ 		};
++
++		pcie1: pcie@80000000 {
++			compatible = "qcom,pcie-ipq5018";
++			reg = <0x80000000 0xf1d>,
++				  <0x80000f20 0xa8>,
++				  <0x80001000 0x1000>,
++				  <0x00078000 0x3000>,
++				  <0x80100000 0x1000>;
++			reg-names = "dbi",
++						"elbi",
++						"atu",
++						"parf",
++						"config";
++			device_type = "pci";
++			linux,pci-domain = <0>;
++			bus-range = <0x00 0xff>;
++			num-lanes = <1>;
++			max-link-speed = <2>;
++			#address-cells = <3>;
++			#size-cells = <2>;
++
++			phys = <&pcie1_phy>;
++			phy-names ="pciephy";
++
++			ranges = <0x81000000 0 0x80200000 0x80200000 0 0x00100000>,	/* I/O */
++				  	 <0x82000000 0 0x80300000 0x80300000 0 0x10000000>;	/* MEM */
++
++			#interrupt-cells = <1>;
++			interrupt-map-mask = <0 0 0 0x7>;
++			interrupt-map = <0 0 0 1 &intc 0 142 IRQ_TYPE_LEVEL_HIGH>, /* int_a */
++							<0 0 0 2 &intc 0 143 IRQ_TYPE_LEVEL_HIGH>, /* int_b */
++							<0 0 0 3 &intc 0 144 IRQ_TYPE_LEVEL_HIGH>, /* int_c */
++							<0 0 0 4 &intc 0 145 IRQ_TYPE_LEVEL_HIGH>; /* int_d */
++
++			interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "global_irq";
++
++			clocks = <&gcc GCC_SYS_NOC_PCIE1_AXI_CLK>,
++					 <&gcc GCC_PCIE1_AXI_M_CLK>,
++					 <&gcc GCC_PCIE1_AXI_S_CLK>,
++					 <&gcc GCC_PCIE1_AHB_CLK>,
++					 <&gcc GCC_PCIE1_AUX_CLK>,
++					 <&gcc GCC_PCIE1_AXI_S_BRIDGE_CLK>;
++			clock-names = "iface",
++						  "axi_m",
++						  "axi_s",
++						  "ahb",
++						  "aux",
++						  "axi_bridge";
++
++			resets = <&gcc GCC_PCIE1_PIPE_ARES>,
++					 <&gcc GCC_PCIE1_SLEEP_ARES>,
++					 <&gcc GCC_PCIE1_CORE_STICKY_ARES>,
++					 <&gcc GCC_PCIE1_AXI_MASTER_ARES>,
++					 <&gcc GCC_PCIE1_AXI_SLAVE_ARES>,
++					 <&gcc GCC_PCIE1_AHB_ARES>,
++					 <&gcc GCC_PCIE1_AXI_MASTER_STICKY_ARES>,
++					 <&gcc GCC_PCIE1_AXI_SLAVE_STICKY_ARES>;
++			reset-names = "pipe",
++						  "sleep",
++						  "sticky",
++						  "axi_m",
++						  "axi_s",
++						  "ahb",
++						  "axi_m_sticky",
++						  "axi_s_sticky";
++
++			msi-map = <0x0 &v2m0 0x0 0xff8>;
++			status = "disabled";
++		};
++
++		pcie0: pcie@a0000000 {
++			compatible = "qcom,pcie-ipq5018";
++			reg = <0xa0000000 0xf1d>,
++				  <0xa0000f20 0xa8>,
++				  <0xa0001000 0x1000>,
++				  <0x00080000 0x3000>,
++				  <0xa0100000 0x1000>;
++			reg-names = "dbi",
++						"elbi",
++						"atu",
++						"parf",
++						"config";
++			device_type = "pci";
++			linux,pci-domain = <1>;
++			bus-range = <0x00 0xff>;
++			num-lanes = <2>;
++			max-link-speed = <2>;
++			#address-cells = <3>;
++			#size-cells = <2>;
++
++			phys = <&pcie0_phy>;
++			phy-names ="pciephy";
++
++			ranges = <0x81000000 0 0xa0200000 0xa0200000 0 0x00100000>,	/* I/O */
++				  	 <0x82000000 0 0xa0300000 0xa0300000 0 0x10000000>;	/* MEM */
++
++			#interrupt-cells = <1>;
++			interrupt-map-mask = <0 0 0 0x7>;
++			interrupt-map = <0 0 0 1 &intc 0 75 IRQ_TYPE_LEVEL_HIGH>, /* int_a */
++							<0 0 0 2 &intc 0 78 IRQ_TYPE_LEVEL_HIGH>, /* int_b */
++							<0 0 0 3 &intc 0 79 IRQ_TYPE_LEVEL_HIGH>, /* int_c */
++							<0 0 0 4 &intc 0 83 IRQ_TYPE_LEVEL_HIGH>; /* int_d */
++
++			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "global_irq";
++
++			clocks = <&gcc GCC_SYS_NOC_PCIE0_AXI_CLK>,
++					 <&gcc GCC_PCIE0_AXI_M_CLK>,
++					 <&gcc GCC_PCIE0_AXI_S_CLK>,
++					 <&gcc GCC_PCIE0_AHB_CLK>,
++					 <&gcc GCC_PCIE0_AUX_CLK>,
++					 <&gcc GCC_PCIE0_AXI_S_BRIDGE_CLK>;
++			clock-names = "iface",
++						  "axi_m",
++						  "axi_s",
++						  "ahb",
++						  "aux",
++						  "axi_bridge";
++
++			resets = <&gcc GCC_PCIE0_PIPE_ARES>,
++					 <&gcc GCC_PCIE0_SLEEP_ARES>,
++					 <&gcc GCC_PCIE0_CORE_STICKY_ARES>,
++					 <&gcc GCC_PCIE0_AXI_MASTER_ARES>,
++					 <&gcc GCC_PCIE0_AXI_SLAVE_ARES>,
++					 <&gcc GCC_PCIE0_AHB_ARES>,
++					 <&gcc GCC_PCIE0_AXI_MASTER_STICKY_ARES>,
++					 <&gcc GCC_PCIE0_AXI_SLAVE_STICKY_ARES>;
++			reset-names = "pipe",
++						  "sleep",
++						  "sticky",
++						  "axi_m",
++						  "axi_s",
++						  "ahb",
++						  "axi_m_sticky",
++						  "axi_s_sticky";
++
++			msi-map = <0x0 &v2m0 0x0 0xff8>;
++			status = "disabled";
++		};
+ 	};
+ 
+ 	thermal-zones {
diff --git a/target/linux/qualcommax/patches-6.6/0301-dt-bindings-mfd-qcom-tcsr-add-IPQ5018-compatible.patch b/target/linux/qualcommax/patches-6.6/0301-dt-bindings-mfd-qcom-tcsr-add-IPQ5018-compatible.patch
new file mode 100644
index 0000000000..2faaa1d10e
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0301-dt-bindings-mfd-qcom-tcsr-add-IPQ5018-compatible.patch
@@ -0,0 +1,18 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] dt-bindings: mfd: qcom,tcsr: Add IPQ5018 compatible
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+Document the qcom,tcsr-ipq5018 compatible.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/Documentation/devicetree/bindings/mfd/qcom,tcsr.yaml
++++ b/Documentation/devicetree/bindings/mfd/qcom,tcsr.yaml
+@@ -33,6 +33,7 @@ properties:
+               - qcom,sm8450-tcsr
+               - qcom,tcsr-apq8064
+               - qcom,tcsr-apq8084
++              - qcom,tcsr-ipq5018
+               - qcom,tcsr-ipq5332
+               - qcom,tcsr-ipq8064
+               - qcom,tcsr-ipq8074
diff --git a/target/linux/qualcommax/patches-6.6/0302-arm64-dts-qcom-IPQ5018-add-TCSR-node.patch b/target/linux/qualcommax/patches-6.6/0302-arm64-dts-qcom-IPQ5018-add-TCSR-node.patch
new file mode 100644
index 0000000000..7a0031666d
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0302-arm64-dts-qcom-IPQ5018-add-TCSR-node.patch
@@ -0,0 +1,22 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add TCSR node
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+Add TCSR node.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -337,6 +337,11 @@
+ 			#hwlock-cells = <1>;
+ 		};
+ 
++		tcsr: syscon@1937000 {
++			compatible = "qcom,tcsr-ipq5018", "syscon", "simple-mfd";
++			reg = <0x01937000 0x21000>;
++		};
++
+ 		sdhc_1: mmc@7804000 {
+ 			compatible = "qcom,ipq5018-sdhci", "qcom,sdhci-msm-v5";
+ 			reg = <0x7804000 0x1000>;
diff --git a/target/linux/qualcommax/patches-6.6/0303-arm64-dts-qcom-IPQ5018-enable-the-download-mode-support.patch b/target/linux/qualcommax/patches-6.6/0303-arm64-dts-qcom-IPQ5018-enable-the-download-mode-support.patch
new file mode 100644
index 0000000000..265695d1c4
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0303-arm64-dts-qcom-IPQ5018-enable-the-download-mode-support.patch
@@ -0,0 +1,19 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] arm64: dts: qcom: ipq5018: enable the download mode support
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+IPQ5018 also supports the download mode to collect the RAM dumps if system crashes, to perform
+the post mortem analysis. Add support for the same.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -82,6 +82,7 @@
+ 		scm {
+ 			compatible = "qcom,scm-ipq5018", "qcom,scm";
+ 			qcom,sdi-enabled;
++			qcom,dload-mode = <&tcsr 0x6100>;
+ 		};
+ 	};
+ 
diff --git a/target/linux/qualcommax/patches-6.6/0304-dt-bindings-pwm-add-IPQ5018-compatible.patch b/target/linux/qualcommax/patches-6.6/0304-dt-bindings-pwm-add-IPQ5018-compatible.patch
new file mode 100644
index 0000000000..5705028931
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0304-dt-bindings-pwm-add-IPQ5018-compatible.patch
@@ -0,0 +1,22 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] dt-bindings: mfd: qcom,tcsr: Add IPQ5018 compatible
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+Add compatible for IPQ5018.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/Documentation/devicetree/bindings/pwm/qcom,ipq6018-pwm.yaml
++++ b/Documentation/devicetree/bindings/pwm/qcom,ipq6018-pwm.yaml
+@@ -11,7 +11,10 @@ maintainers:
+ 
+ properties:
+   compatible:
+-    const: qcom,ipq6018-pwm
++    items:
++      - enum:
++          - qcom,ipq5018-pwm
++      - const: qcom,ipq6018-pwm
+ 
+   reg:
+     description: Offset of PWM register in the TCSR block.
diff --git a/target/linux/qualcommax/patches-6.6/0305-pinctrl-qcom-IPQ5018-update-pwm-groups.patch b/target/linux/qualcommax/patches-6.6/0305-pinctrl-qcom-IPQ5018-update-pwm-groups.patch
new file mode 100644
index 0000000000..476e5f6ba1
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0305-pinctrl-qcom-IPQ5018-update-pwm-groups.patch
@@ -0,0 +1,65 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] pinctrl: qcom: IPQ5018: update pwm groups
+Date: Wed, 27 Nov 2024 09:14:11 +0400
+
+GPIO 1, 30, and 46 are used to control PWM1, PWM3, and PWM0 respectively which
+in turn drive the PWM led, so let's update the pwm# and pingroups accordingly.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/pinctrl/qcom/pinctrl-ipq5018.c
++++ b/drivers/pinctrl/qcom/pinctrl-ipq5018.c
+@@ -541,7 +541,7 @@ static const char * const qdss_tracectl_
+ };
+ 
+ static const char * const pwm0_groups[] = {
+-	"gpio42",
++	"gpio42", "gpio46",
+ };
+ 
+ static const char * const qdss_cti_trig_out_b0_groups[] = {
+@@ -549,7 +549,7 @@ static const char * const qdss_cti_trig_
+ };
+ 
+ static const char * const pwm1_groups[] = {
+-	"gpio43",
++	"gpio43", "gpio1",
+ };
+ 
+ static const char * const qdss_cti_trig_in_b0_groups[] = {
+@@ -565,7 +565,7 @@ static const char * const qdss_cti_trig_
+ };
+ 
+ static const char * const pwm3_groups[] = {
+-	"gpio45",
++	"gpio45", "gpio30",
+ };
+ 
+ static const char * const qdss_cti_trig_in_b1_groups[] = {
+@@ -679,7 +679,7 @@ static const struct pinfunction ipq5018_
+ 
+ static const struct msm_pingroup ipq5018_groups[] = {
+ 	PINGROUP(0, atest_char, _, qdss_cti_trig_out_a0, wci_txd, wci_rxd, xfem, _, _, _),
+-	PINGROUP(1, atest_char, _, qdss_cti_trig_in_a0, wci_txd, wci_rxd, xfem, _, _, _),
++	PINGROUP(1, atest_char, pwm1, qdss_cti_trig_in_a0, wci_txd, wci_rxd, xfem, _, _, _),
+ 	PINGROUP(2, atest_char, _, qdss_cti_trig_out_a1, wci_txd, wci_rxd, xfem, _, _, _),
+ 	PINGROUP(3, atest_char, _, qdss_cti_trig_in_a1, wci_txd, wci_rxd, xfem, _, _, _),
+ 	PINGROUP(4, sdc1_data, qspi_data, blsp1_spi1, btss, dbg_out, qdss_traceclk_a, _, burn0, _),
+@@ -708,7 +708,7 @@ static const struct msm_pingroup ipq5018
+ 	PINGROUP(27, audio_txmclk, wsa_swrm, audio_txmclk, blsp2_spi, btss, _, qdss_tracedata_b, _, _),
+ 	PINGROUP(28, audio_txbclk, wsa_swrm, blsp0_uart1, btss, qdss_tracedata_b, _, _, _, _),
+ 	PINGROUP(29, audio_txfsync, _, blsp0_uart1, _, qdss_tracedata_b, _, _, _, _),
+-	PINGROUP(30, audio_txd, led2, led0, _, _, _, _, _, _),
++	PINGROUP(30, audio_txd, led2, led0, pwm3, _, _, _, _, _),
+ 	PINGROUP(31, blsp2_spi0, blsp1_uart1, _, qdss_tracedata_b, eud_gpio, _, _, _, _),
+ 	PINGROUP(32, blsp2_spi0, blsp1_uart1, _, qdss_tracedata_b, eud_gpio, _, _, _, _),
+ 	PINGROUP(33, blsp2_i2c0, blsp2_spi0, blsp1_uart1, _, qdss_tracedata_b, eud_gpio, _, _, _),
+@@ -724,7 +724,7 @@ static const struct msm_pingroup ipq5018
+ 	PINGROUP(43, pwm1, qdss_cti_trig_in_b0, wci_txd, wci_rxd, xfem, _, _, _, _),
+ 	PINGROUP(44, pwm2, qdss_cti_trig_out_b1, wci_txd, wci_rxd, xfem, _, _, _, _),
+ 	PINGROUP(45, pwm3, qdss_cti_trig_in_b1, wci_txd, wci_rxd, xfem, _, _, _, _),
+-	PINGROUP(46, led0, _, _, _, _, _, _, _, _),
++	PINGROUP(46, led0, pwm0, _, _, _, _, _, _, _),
+ };
+ 
+ static const struct msm_pinctrl_soc_data ipq5018_pinctrl = {
diff --git a/target/linux/qualcommax/patches-6.6/0306-arm64-dts-qcom-ipq5018-Add-PWM-node.patch b/target/linux/qualcommax/patches-6.6/0306-arm64-dts-qcom-ipq5018-Add-PWM-node.patch
new file mode 100644
index 0000000000..d60e916971
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0306-arm64-dts-qcom-ipq5018-Add-PWM-node.patch
@@ -0,0 +1,27 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add PWM node
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+Add PWM node.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -343,6 +343,16 @@
+ 			reg = <0x01937000 0x21000>;
+ 		};
+ 
++		pwm: pwm@1941010 {
++			compatible = "qcom,ipq5018-pwm", "qcom,ipq6018-pwm";
++			reg = <0x01941010 0x20>;
++			clocks = <&gcc GCC_ADSS_PWM_CLK>;
++			assigned-clocks = <&gcc GCC_ADSS_PWM_CLK>;
++			assigned-clock-rates = <100000000>;
++			#pwm-cells = <2>;
++			status = "disabled";
++		};
++
+ 		sdhc_1: mmc@7804000 {
+ 			compatible = "qcom,ipq5018-sdhci", "qcom,sdhci-msm-v5";
+ 			reg = <0x7804000 0x1000>;
diff --git a/target/linux/qualcommax/patches-6.6/0324-arm64-dts-qcom-ipq5018-Add-crypto-nodes.patch b/target/linux/qualcommax/patches-6.6/0324-arm64-dts-qcom-ipq5018-Add-crypto-nodes.patch
new file mode 100644
index 0000000000..57d434271f
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0324-arm64-dts-qcom-ipq5018-Add-crypto-nodes.patch
@@ -0,0 +1,41 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add crypto nodes
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+Add dma controller and crypto nodes.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -297,6 +297,30 @@
+ 			#thermal-sensor-cells = <1>;
+ 		};
+ 
++		cryptobam: dma-controller@704000 {
++			compatible = "qcom,bam-v1.7.0";
++			reg = <0x00704000 0x20000>;
++			interrupts = <GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_CRYPTO_AHB_CLK>;
++			clock-names = "bam_clk";
++			#dma-cells = <1>;
++			qcom,ee = <1>;
++			qcom,controlled-remotely;
++			status = "disabled";
++		};
++
++		crypto: crypto@73a000 {
++			compatible = "qcom,crypto-v5.1";
++			reg = <0x0073a000 0x6000>;
++			clocks = <&gcc GCC_CRYPTO_AHB_CLK>,
++				 <&gcc GCC_CRYPTO_AXI_CLK>,
++				 <&gcc GCC_CRYPTO_CLK>;
++			clock-names = "iface", "bus", "core";
++			dmas = <&cryptobam 2>, <&cryptobam 3>;
++			dma-names = "rx", "tx";
++			status = "disabled";
++		};
++
+ 		tlmm: pinctrl@1000000 {
+ 			compatible = "qcom,ipq5018-tlmm";
+ 			reg = <0x01000000 0x300000>;
diff --git a/target/linux/qualcommax/patches-6.6/0337-arm64-dts-qcom-ipq5018-Add-PRNG-node.patch b/target/linux/qualcommax/patches-6.6/0337-arm64-dts-qcom-ipq5018-Add-PRNG-node.patch
new file mode 100644
index 0000000000..87d9bdb270
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0337-arm64-dts-qcom-ipq5018-Add-PRNG-node.patch
@@ -0,0 +1,25 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add PRNG node
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+Add PRNG node.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -258,6 +258,14 @@
+ 			};
+ 		};
+ 
++		prng: rng@e3000 {
++			compatible = "qcom,prng-ee";
++			reg = <0x000e3000 0x1000>;
++			clocks = <&gcc GCC_PRNG_AHB_CLK>;
++			clock-names = "core";
++			status = "disabled";
++		};
++
+ 		tsens: thermal-sensor@4a9000 {
+ 			compatible = "qcom,ipq5018-tsens";
+ 			reg = <0x4a9000 0x1000>, /* TM */
diff --git a/target/linux/qualcommax/patches-6.6/0339-arm64-dts-qcom-ipq5018-Add-QUP1-UART2-node.patch b/target/linux/qualcommax/patches-6.6/0339-arm64-dts-qcom-ipq5018-Add-QUP1-UART2-node.patch
new file mode 100644
index 0000000000..72085061f8
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0339-arm64-dts-qcom-ipq5018-Add-QUP1-UART2-node.patch
@@ -0,0 +1,27 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add QUP1-UART2 node
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+Add QUP1-UART2 node.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -422,6 +422,16 @@
+ 			status = "disabled";
+ 		};
+ 
++		blsp1_uart2: serial@78b0000 {
++			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
++			reg = <0x078b0000 0x200>;
++			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_UART2_APPS_CLK>,
++					<&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			status = "disabled";
++		};
++
+ 		blsp1_spi1: spi@78b5000 {
+ 			compatible = "qcom,spi-qup-v2.2.1";
+ 			#address-cells = <1>;
diff --git a/target/linux/qualcommax/patches-6.6/0340-arm64-dts-qcom-ipq5018-Add-QUP3-I2C-node.patch b/target/linux/qualcommax/patches-6.6/0340-arm64-dts-qcom-ipq5018-Add-QUP3-I2C-node.patch
new file mode 100644
index 0000000000..5447e78fab
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0340-arm64-dts-qcom-ipq5018-Add-QUP3-I2C-node.patch
@@ -0,0 +1,32 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add QUP3 I2C node
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+Add QUP3-I2C node.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -446,6 +446,21 @@
+ 			status = "disabled";
+ 		};
+ 
++		blsp1_i2c3: i2c@78b7000 {
++			compatible = "qcom,i2c-qup-v2.2.1";
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <0x078b7000 0x600>;
++			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_BLSP1_QUP3_I2C_APPS_CLK>,
++				 <&gcc GCC_BLSP1_AHB_CLK>;
++			clock-names = "core", "iface";
++			clock-frequency = <400000>;
++			dmas = <&blsp_dma 9>, <&blsp_dma 8>;
++			dma-names = "tx", "rx";
++			status = "disabled";
++		};
++
+ 		usb: usb@8af8800 {
+ 			compatible = "qcom,ipq5018-dwc3", "qcom,dwc3";
+ 			reg = <0x08af8800 0x400>;
diff --git a/target/linux/qualcommax/patches-6.6/0401-spi-dt-bindings-Introduce-qcom-spi-qpic-snand.patch b/target/linux/qualcommax/patches-6.6/0401-spi-dt-bindings-Introduce-qcom-spi-qpic-snand.patch
new file mode 100644
index 0000000000..433db36871
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0401-spi-dt-bindings-Introduce-qcom-spi-qpic-snand.patch
@@ -0,0 +1,97 @@
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Sun, 22 Sep 2024 17:03:44 +0530
+Subject: [PATCH] spi: dt-bindings: Introduce qcom,spi-qpic-snand
+
+Document the QPIC-SPI-NAND flash controller present in the IPQ SoCs.
+It can work both in serial and parallel mode and supports typical
+SPI-NAND page cache operations.
+
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+---
+--- /dev/null
++++ b/Documentation/devicetree/bindings/spi/qcom,spi-qpic-snand.yaml
+@@ -0,0 +1,83 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/spi/qcom,spi-qpic-snand.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Qualcomm QPIC NAND controller
++
++maintainers:
++  - Md sadre Alam <quic_mdalam@quicinc.com>
++
++description:
++  The QCOM QPIC-SPI-NAND flash controller is an extended version of
++  the QCOM QPIC NAND flash controller. It can work both in serial
++  and parallel mode. It supports typical SPI-NAND page cache
++  operations in single, dual or quad IO mode with pipelined ECC
++  encoding/decoding using the QPIC ECC HW engine.
++
++allOf:
++  - $ref: /schemas/spi/spi-controller.yaml#
++
++properties:
++  compatible:
++    enum:
++      - qcom,spi-qpic-snand
++
++  reg:
++    maxItems: 1
++
++  clocks:
++    maxItems: 3
++
++  clock-names:
++    items:
++      - const: core
++      - const: aon
++      - const: iom
++
++  dmas:
++    items:
++      - description: tx DMA channel
++      - description: rx DMA channel
++      - description: cmd DMA channel
++
++  dma-names:
++    items:
++      - const: tx
++      - const: rx
++      - const: cmd
++
++required:
++  - compatible
++  - reg
++  - clocks
++  - clock-names
++
++unevaluatedProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/clock/qcom,ipq9574-gcc.h>
++    spi@79b0000 {
++        compatible = "qcom,spi-qpic-snand";
++        reg = <0x1ac00000 0x800>;
++
++        clocks = <&gcc GCC_QPIC_CLK>,
++                 <&gcc GCC_QPIC_AHB_CLK>,
++                 <&gcc GCC_QPIC_IO_MACRO_CLK>;
++        clock-names = "core", "aon", "iom";
++
++        #address-cells = <1>;
++        #size-cells = <0>;
++
++        flash@0 {
++            compatible = "spi-nand";
++            reg = <0>;
++            #address-cells = <1>;
++            #size-cells = <1>;
++            nand-ecc-engine = <&qpic_nand>;
++            nand-ecc-strength = <4>;
++            nand-ecc-step-size = <512>;
++        };
++    };
diff --git a/target/linux/qualcommax/patches-6.6/0402-mtd-rawnand-qcom-cleanup-qcom_nandc-driver.patch b/target/linux/qualcommax/patches-6.6/0402-mtd-rawnand-qcom-cleanup-qcom_nandc-driver.patch
new file mode 100644
index 0000000000..91dceaa3a6
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0402-mtd-rawnand-qcom-cleanup-qcom_nandc-driver.patch
@@ -0,0 +1,983 @@
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Sun, 22 Sep 2024 17:03:45 +0530
+Subject: [PATCH] mtd: rawnand: qcom: cleanup qcom_nandc driver
+
+cleanup qcom_nandc driver as below
+
+- Remove register value indirection api
+
+- Remove set_reg() api
+
+- Convert read_loc_first & read_loc_last macro to function
+
+- Renamed multiple variables
+
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+---
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -189,17 +189,6 @@
+ #define	ECC_BCH_4BIT	BIT(2)
+ #define	ECC_BCH_8BIT	BIT(3)
+ 
+-#define nandc_set_read_loc_first(chip, reg, cw_offset, read_size, is_last_read_loc)	\
+-nandc_set_reg(chip, reg,			\
+-	      ((cw_offset) << READ_LOCATION_OFFSET) |		\
+-	      ((read_size) << READ_LOCATION_SIZE) |			\
+-	      ((is_last_read_loc) << READ_LOCATION_LAST))
+-
+-#define nandc_set_read_loc_last(chip, reg, cw_offset, read_size, is_last_read_loc)	\
+-nandc_set_reg(chip, reg,			\
+-	      ((cw_offset) << READ_LOCATION_OFFSET) |		\
+-	      ((read_size) << READ_LOCATION_SIZE) |			\
+-	      ((is_last_read_loc) << READ_LOCATION_LAST))
+ /*
+  * Returns the actual register address for all NAND_DEV_ registers
+  * (i.e. NAND_DEV_CMD0, NAND_DEV_CMD1, NAND_DEV_CMD2 and NAND_DEV_CMD_VLD)
+@@ -257,8 +246,6 @@ nandc_set_reg(chip, reg,			\
+  * @tx_sgl_start - start index in data sgl for tx.
+  * @rx_sgl_pos - current index in data sgl for rx.
+  * @rx_sgl_start - start index in data sgl for rx.
+- * @wait_second_completion - wait for second DMA desc completion before making
+- *			     the NAND transfer completion.
+  */
+ struct bam_transaction {
+ 	struct bam_cmd_element *bam_ce;
+@@ -275,7 +262,6 @@ struct bam_transaction {
+ 	u32 tx_sgl_start;
+ 	u32 rx_sgl_pos;
+ 	u32 rx_sgl_start;
+-	bool wait_second_completion;
+ };
+ 
+ /*
+@@ -471,9 +457,9 @@ struct qcom_op {
+ 	unsigned int data_instr_idx;
+ 	unsigned int rdy_timeout_ms;
+ 	unsigned int rdy_delay_ns;
+-	u32 addr1_reg;
+-	u32 addr2_reg;
+-	u32 cmd_reg;
++	__le32 addr1_reg;
++	__le32 addr2_reg;
++	__le32 cmd_reg;
+ 	u8 flag;
+ };
+ 
+@@ -549,17 +535,17 @@ struct qcom_nand_host {
+  * among different NAND controllers.
+  * @ecc_modes - ecc mode for NAND
+  * @dev_cmd_reg_start - NAND_DEV_CMD_* registers starting offset
+- * @is_bam - whether NAND controller is using BAM
+- * @is_qpic - whether NAND CTRL is part of qpic IP
+- * @qpic_v2 - flag to indicate QPIC IP version 2
++ * @supports_bam - whether NAND controller is using BAM
++ * @nandc_part_of_qpic - whether NAND controller is part of qpic IP
++ * @qpic_version2 - flag to indicate QPIC IP version 2
+  * @use_codeword_fixup - whether NAND has different layout for boot partitions
+  */
+ struct qcom_nandc_props {
+ 	u32 ecc_modes;
+ 	u32 dev_cmd_reg_start;
+-	bool is_bam;
+-	bool is_qpic;
+-	bool qpic_v2;
++	bool supports_bam;
++	bool nandc_part_of_qpic;
++	bool qpic_version2;
+ 	bool use_codeword_fixup;
+ };
+ 
+@@ -613,19 +599,11 @@ static void clear_bam_transaction(struct
+ {
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+ 
+-	if (!nandc->props->is_bam)
++	if (!nandc->props->supports_bam)
+ 		return;
+ 
+-	bam_txn->bam_ce_pos = 0;
+-	bam_txn->bam_ce_start = 0;
+-	bam_txn->cmd_sgl_pos = 0;
+-	bam_txn->cmd_sgl_start = 0;
+-	bam_txn->tx_sgl_pos = 0;
+-	bam_txn->tx_sgl_start = 0;
+-	bam_txn->rx_sgl_pos = 0;
+-	bam_txn->rx_sgl_start = 0;
++	memset(&bam_txn->bam_ce_pos, 0, sizeof(u32) * 8);
+ 	bam_txn->last_data_desc = NULL;
+-	bam_txn->wait_second_completion = false;
+ 
+ 	sg_init_table(bam_txn->cmd_sgl, nandc->max_cwperpage *
+ 		      QPIC_PER_CW_CMD_SGL);
+@@ -640,17 +618,7 @@ static void qpic_bam_dma_done(void *data
+ {
+ 	struct bam_transaction *bam_txn = data;
+ 
+-	/*
+-	 * In case of data transfer with NAND, 2 callbacks will be generated.
+-	 * One for command channel and another one for data channel.
+-	 * If current transaction has data descriptors
+-	 * (i.e. wait_second_completion is true), then set this to false
+-	 * and wait for second DMA descriptor completion.
+-	 */
+-	if (bam_txn->wait_second_completion)
+-		bam_txn->wait_second_completion = false;
+-	else
+-		complete(&bam_txn->txn_done);
++	complete(&bam_txn->txn_done);
+ }
+ 
+ static inline struct qcom_nand_host *to_qcom_nand_host(struct nand_chip *chip)
+@@ -676,10 +644,9 @@ static inline void nandc_write(struct qc
+ 	iowrite32(val, nandc->base + offset);
+ }
+ 
+-static inline void nandc_read_buffer_sync(struct qcom_nand_controller *nandc,
+-					  bool is_cpu)
++static inline void nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
+ {
+-	if (!nandc->props->is_bam)
++	if (!nandc->props->supports_bam)
+ 		return;
+ 
+ 	if (is_cpu)
+@@ -694,93 +661,90 @@ static inline void nandc_read_buffer_syn
+ 					   DMA_FROM_DEVICE);
+ }
+ 
+-static __le32 *offset_to_nandc_reg(struct nandc_regs *regs, int offset)
+-{
+-	switch (offset) {
+-	case NAND_FLASH_CMD:
+-		return &regs->cmd;
+-	case NAND_ADDR0:
+-		return &regs->addr0;
+-	case NAND_ADDR1:
+-		return &regs->addr1;
+-	case NAND_FLASH_CHIP_SELECT:
+-		return &regs->chip_sel;
+-	case NAND_EXEC_CMD:
+-		return &regs->exec;
+-	case NAND_FLASH_STATUS:
+-		return &regs->clrflashstatus;
+-	case NAND_DEV0_CFG0:
+-		return &regs->cfg0;
+-	case NAND_DEV0_CFG1:
+-		return &regs->cfg1;
+-	case NAND_DEV0_ECC_CFG:
+-		return &regs->ecc_bch_cfg;
+-	case NAND_READ_STATUS:
+-		return &regs->clrreadstatus;
+-	case NAND_DEV_CMD1:
+-		return &regs->cmd1;
+-	case NAND_DEV_CMD1_RESTORE:
+-		return &regs->orig_cmd1;
+-	case NAND_DEV_CMD_VLD:
+-		return &regs->vld;
+-	case NAND_DEV_CMD_VLD_RESTORE:
+-		return &regs->orig_vld;
+-	case NAND_EBI2_ECC_BUF_CFG:
+-		return &regs->ecc_buf_cfg;
+-	case NAND_READ_LOCATION_0:
+-		return &regs->read_location0;
+-	case NAND_READ_LOCATION_1:
+-		return &regs->read_location1;
+-	case NAND_READ_LOCATION_2:
+-		return &regs->read_location2;
+-	case NAND_READ_LOCATION_3:
+-		return &regs->read_location3;
+-	case NAND_READ_LOCATION_LAST_CW_0:
+-		return &regs->read_location_last0;
+-	case NAND_READ_LOCATION_LAST_CW_1:
+-		return &regs->read_location_last1;
+-	case NAND_READ_LOCATION_LAST_CW_2:
+-		return &regs->read_location_last2;
+-	case NAND_READ_LOCATION_LAST_CW_3:
+-		return &regs->read_location_last3;
+-	default:
+-		return NULL;
+-	}
+-}
+-
+-static void nandc_set_reg(struct nand_chip *chip, int offset,
+-			  u32 val)
+-{
+-	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+-	struct nandc_regs *regs = nandc->regs;
+-	__le32 *reg;
+-
+-	reg = offset_to_nandc_reg(regs, offset);
+-
+-	if (reg)
+-		*reg = cpu_to_le32(val);
+-}
+-
+ /* Helper to check the code word, whether it is last cw or not */
+ static bool qcom_nandc_is_last_cw(struct nand_ecc_ctrl *ecc, int cw)
+ {
+ 	return cw == (ecc->steps - 1);
+ }
+ 
++/**
++ * nandc_set_read_loc_first() - to set read location first register
++ * @chip:		NAND Private Flash Chip Data
++ * @reg_base:		location register base
++ * @cw_offset:		code word offset
++ * @read_size:		code word read length
++ * @is_last_read_loc:	is this the last read location
++ *
++ * This function will set location register value
++ */
++static void nandc_set_read_loc_first(struct nand_chip *chip,
++				     int reg_base, u32 cw_offset,
++				     u32 read_size, u32 is_last_read_loc)
++{
++	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
++	__le32 locreg_val;
++	u32 val = (((cw_offset) << READ_LOCATION_OFFSET) |
++		  ((read_size) << READ_LOCATION_SIZE) |
++		  ((is_last_read_loc) << READ_LOCATION_LAST));
++
++	locreg_val = cpu_to_le32(val);
++
++	if (reg_base == NAND_READ_LOCATION_0)
++		nandc->regs->read_location0 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_1)
++		nandc->regs->read_location1 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_2)
++		nandc->regs->read_location2 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_3)
++		nandc->regs->read_location3 = locreg_val;
++}
++
++/**
++ * nandc_set_read_loc_last - to set read location last register
++ * @chip:		NAND Private Flash Chip Data
++ * @reg_base:		location register base
++ * @cw_offset:		code word offset
++ * @read_size:		code word read length
++ * @is_last_read_loc:	is this the last read location
++ *
++ * This function will set location last register value
++ */
++static void nandc_set_read_loc_last(struct nand_chip *chip,
++				    int reg_base, u32 cw_offset,
++				    u32 read_size, u32 is_last_read_loc)
++{
++	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
++	__le32 locreg_val;
++	u32 val = (((cw_offset) << READ_LOCATION_OFFSET) |
++		  ((read_size) << READ_LOCATION_SIZE) |
++		  ((is_last_read_loc) << READ_LOCATION_LAST));
++
++	locreg_val = cpu_to_le32(val);
++
++	if (reg_base == NAND_READ_LOCATION_LAST_CW_0)
++		nandc->regs->read_location_last0 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_LAST_CW_1)
++		nandc->regs->read_location_last1 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_LAST_CW_2)
++		nandc->regs->read_location_last2 = locreg_val;
++	else if (reg_base == NAND_READ_LOCATION_LAST_CW_3)
++		nandc->regs->read_location_last3 = locreg_val;
++}
++
+ /* helper to configure location register values */
+ static void nandc_set_read_loc(struct nand_chip *chip, int cw, int reg,
+-			       int cw_offset, int read_size, int is_last_read_loc)
++			       u32 cw_offset, u32 read_size, u32 is_last_read_loc)
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 	struct nand_ecc_ctrl *ecc = &chip->ecc;
+ 	int reg_base = NAND_READ_LOCATION_0;
+ 
+-	if (nandc->props->qpic_v2 && qcom_nandc_is_last_cw(ecc, cw))
++	if (nandc->props->qpic_version2 && qcom_nandc_is_last_cw(ecc, cw))
+ 		reg_base = NAND_READ_LOCATION_LAST_CW_0;
+ 
+ 	reg_base += reg * 4;
+ 
+-	if (nandc->props->qpic_v2 && qcom_nandc_is_last_cw(ecc, cw))
++	if (nandc->props->qpic_version2 && qcom_nandc_is_last_cw(ecc, cw))
+ 		return nandc_set_read_loc_last(chip, reg_base, cw_offset,
+ 				read_size, is_last_read_loc);
+ 	else
+@@ -792,12 +756,13 @@ static void nandc_set_read_loc(struct na
+ static void set_address(struct qcom_nand_host *host, u16 column, int page)
+ {
+ 	struct nand_chip *chip = &host->chip;
++	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+ 	if (chip->options & NAND_BUSWIDTH_16)
+ 		column >>= 1;
+ 
+-	nandc_set_reg(chip, NAND_ADDR0, page << 16 | column);
+-	nandc_set_reg(chip, NAND_ADDR1, page >> 16 & 0xff);
++	nandc->regs->addr0 = cpu_to_le32(page << 16 | column);
++	nandc->regs->addr1 = cpu_to_le32(page >> 16 & 0xff);
+ }
+ 
+ /*
+@@ -811,41 +776,43 @@ static void set_address(struct qcom_nand
+ static void update_rw_regs(struct qcom_nand_host *host, int num_cw, bool read, int cw)
+ {
+ 	struct nand_chip *chip = &host->chip;
+-	u32 cmd, cfg0, cfg1, ecc_bch_cfg;
++	__le32 cmd, cfg0, cfg1, ecc_bch_cfg;
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+ 	if (read) {
+ 		if (host->use_ecc)
+-			cmd = OP_PAGE_READ_WITH_ECC | PAGE_ACC | LAST_PAGE;
++			cmd = cpu_to_le32(OP_PAGE_READ_WITH_ECC | PAGE_ACC | LAST_PAGE);
+ 		else
+-			cmd = OP_PAGE_READ | PAGE_ACC | LAST_PAGE;
++			cmd = cpu_to_le32(OP_PAGE_READ | PAGE_ACC | LAST_PAGE);
+ 	} else {
+-		cmd = OP_PROGRAM_PAGE | PAGE_ACC | LAST_PAGE;
++		cmd = cpu_to_le32(OP_PROGRAM_PAGE | PAGE_ACC | LAST_PAGE);
+ 	}
+ 
+ 	if (host->use_ecc) {
+-		cfg0 = (host->cfg0 & ~(7U << CW_PER_PAGE)) |
+-				(num_cw - 1) << CW_PER_PAGE;
++		cfg0 = cpu_to_le32((host->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE);
+ 
+-		cfg1 = host->cfg1;
+-		ecc_bch_cfg = host->ecc_bch_cfg;
++		cfg1 = cpu_to_le32(host->cfg1);
++		ecc_bch_cfg = cpu_to_le32(host->ecc_bch_cfg);
+ 	} else {
+-		cfg0 = (host->cfg0_raw & ~(7U << CW_PER_PAGE)) |
+-				(num_cw - 1) << CW_PER_PAGE;
++		cfg0 = cpu_to_le32((host->cfg0_raw & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE);
+ 
+-		cfg1 = host->cfg1_raw;
+-		ecc_bch_cfg = 1 << ECC_CFG_ECC_DISABLE;
++		cfg1 = cpu_to_le32(host->cfg1_raw);
++		ecc_bch_cfg = cpu_to_le32(1 << ECC_CFG_ECC_DISABLE);
+ 	}
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, cmd);
+-	nandc_set_reg(chip, NAND_DEV0_CFG0, cfg0);
+-	nandc_set_reg(chip, NAND_DEV0_CFG1, cfg1);
+-	nandc_set_reg(chip, NAND_DEV0_ECC_CFG, ecc_bch_cfg);
+-	if (!nandc->props->qpic_v2)
+-		nandc_set_reg(chip, NAND_EBI2_ECC_BUF_CFG, host->ecc_buf_cfg);
+-	nandc_set_reg(chip, NAND_FLASH_STATUS, host->clrflashstatus);
+-	nandc_set_reg(chip, NAND_READ_STATUS, host->clrreadstatus);
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
++	nandc->regs->cmd = cmd;
++	nandc->regs->cfg0 = cfg0;
++	nandc->regs->cfg1 = cfg1;
++	nandc->regs->ecc_bch_cfg = ecc_bch_cfg;
++
++	if (!nandc->props->qpic_version2)
++		nandc->regs->ecc_buf_cfg = cpu_to_le32(host->ecc_buf_cfg);
++
++	nandc->regs->clrflashstatus = cpu_to_le32(host->clrflashstatus);
++	nandc->regs->clrreadstatus = cpu_to_le32(host->clrreadstatus);
++	nandc->regs->exec = cpu_to_le32(1);
+ 
+ 	if (read)
+ 		nandc_set_read_loc(chip, cw, 0, 0, host->use_ecc ?
+@@ -1121,7 +1088,7 @@ static int read_reg_dma(struct qcom_nand
+ 	if (first == NAND_DEV_CMD_VLD || first == NAND_DEV_CMD1)
+ 		first = dev_cmd_reg_addr(nandc, first);
+ 
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		return prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
+ 					     num_regs, flags);
+ 
+@@ -1136,25 +1103,16 @@ static int read_reg_dma(struct qcom_nand
+  * write_reg_dma:	prepares a descriptor to write a given number of
+  *			contiguous registers
+  *
++ * @vaddr:		contnigeous memory from where register value will
++ *			be written
+  * @first:		offset of the first register in the contiguous block
+  * @num_regs:		number of registers to write
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int write_reg_dma(struct qcom_nand_controller *nandc, int first,
+-			 int num_regs, unsigned int flags)
++static int write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
++			 int first, int num_regs, unsigned int flags)
+ {
+ 	bool flow_control = false;
+-	struct nandc_regs *regs = nandc->regs;
+-	void *vaddr;
+-
+-	vaddr = offset_to_nandc_reg(regs, first);
+-
+-	if (first == NAND_ERASED_CW_DETECT_CFG) {
+-		if (flags & NAND_ERASED_CW_SET)
+-			vaddr = &regs->erased_cw_detect_cfg_set;
+-		else
+-			vaddr = &regs->erased_cw_detect_cfg_clr;
+-	}
+ 
+ 	if (first == NAND_EXEC_CMD)
+ 		flags |= NAND_BAM_NWD;
+@@ -1165,7 +1123,7 @@ static int write_reg_dma(struct qcom_nan
+ 	if (first == NAND_DEV_CMD_VLD_RESTORE || first == NAND_DEV_CMD_VLD)
+ 		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD);
+ 
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		return prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
+ 					     num_regs, flags);
+ 
+@@ -1188,7 +1146,7 @@ static int write_reg_dma(struct qcom_nan
+ static int read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+ 			 const u8 *vaddr, int size, unsigned int flags)
+ {
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		return prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
+ 
+ 	return prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
+@@ -1206,7 +1164,7 @@ static int read_data_dma(struct qcom_nan
+ static int write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+ 			  const u8 *vaddr, int size, unsigned int flags)
+ {
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		return prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
+ 
+ 	return prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
+@@ -1220,13 +1178,14 @@ static void config_nand_page_read(struct
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, NAND_ADDR0, 2, 0);
+-	write_reg_dma(nandc, NAND_DEV0_CFG0, 3, 0);
+-	if (!nandc->props->qpic_v2)
+-		write_reg_dma(nandc, NAND_EBI2_ECC_BUF_CFG, 1, 0);
+-	write_reg_dma(nandc, NAND_ERASED_CW_DETECT_CFG, 1, 0);
+-	write_reg_dma(nandc, NAND_ERASED_CW_DETECT_CFG, 1,
+-		      NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
++	write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	if (!nandc->props->qpic_version2)
++		write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1, 0);
++	write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_clr,
++		      NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_set,
++		      NAND_ERASED_CW_DETECT_CFG, 1, NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
+ }
+ 
+ /*
+@@ -1239,16 +1198,16 @@ config_nand_cw_read(struct nand_chip *ch
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 	struct nand_ecc_ctrl *ecc = &chip->ecc;
+ 
+-	int reg = NAND_READ_LOCATION_0;
++	__le32 *reg = &nandc->regs->read_location0;
+ 
+-	if (nandc->props->qpic_v2 && qcom_nandc_is_last_cw(ecc, cw))
+-		reg = NAND_READ_LOCATION_LAST_CW_0;
++	if (nandc->props->qpic_version2 && qcom_nandc_is_last_cw(ecc, cw))
++		reg = &nandc->regs->read_location_last0;
+ 
+-	if (nandc->props->is_bam)
+-		write_reg_dma(nandc, reg, 4, NAND_BAM_NEXT_SGL);
++	if (nandc->props->supports_bam)
++		write_reg_dma(nandc, reg, NAND_READ_LOCATION_0, 4, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	if (use_ecc) {
+ 		read_reg_dma(nandc, NAND_FLASH_STATUS, 2, 0);
+@@ -1279,10 +1238,10 @@ static void config_nand_page_write(struc
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, NAND_ADDR0, 2, 0);
+-	write_reg_dma(nandc, NAND_DEV0_CFG0, 3, 0);
+-	if (!nandc->props->qpic_v2)
+-		write_reg_dma(nandc, NAND_EBI2_ECC_BUF_CFG, 1,
++	write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
++	write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	if (!nandc->props->qpic_version2)
++		write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1,
+ 			      NAND_BAM_NEXT_SGL);
+ }
+ 
+@@ -1294,13 +1253,13 @@ static void config_nand_cw_write(struct
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_STATUS, 1, 0);
+-	write_reg_dma(nandc, NAND_READ_STATUS, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->clrflashstatus, NAND_FLASH_STATUS, 1, 0);
++	write_reg_dma(nandc, &nandc->regs->clrreadstatus, NAND_READ_STATUS, 1, NAND_BAM_NEXT_SGL);
+ }
+ 
+ /* helpers to submit/free our list of dma descriptors */
+@@ -1311,7 +1270,7 @@ static int submit_descs(struct qcom_nand
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+ 	int ret = 0;
+ 
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		if (bam_txn->rx_sgl_pos > bam_txn->rx_sgl_start) {
+ 			ret = prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
+ 			if (ret)
+@@ -1336,14 +1295,9 @@ static int submit_descs(struct qcom_nand
+ 	list_for_each_entry(desc, &nandc->desc_list, node)
+ 		cookie = dmaengine_submit(desc->dma_desc);
+ 
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		bam_txn->last_cmd_desc->callback = qpic_bam_dma_done;
+ 		bam_txn->last_cmd_desc->callback_param = bam_txn;
+-		if (bam_txn->last_data_desc) {
+-			bam_txn->last_data_desc->callback = qpic_bam_dma_done;
+-			bam_txn->last_data_desc->callback_param = bam_txn;
+-			bam_txn->wait_second_completion = true;
+-		}
+ 
+ 		dma_async_issue_pending(nandc->tx_chan);
+ 		dma_async_issue_pending(nandc->rx_chan);
+@@ -1365,7 +1319,7 @@ err_unmap_free_desc:
+ 	list_for_each_entry_safe(desc, n, &nandc->desc_list, node) {
+ 		list_del(&desc->node);
+ 
+-		if (nandc->props->is_bam)
++		if (nandc->props->supports_bam)
+ 			dma_unmap_sg(nandc->dev, desc->bam_sgl,
+ 				     desc->sgl_cnt, desc->dir);
+ 		else
+@@ -1382,7 +1336,7 @@ err_unmap_free_desc:
+ static void clear_read_regs(struct qcom_nand_controller *nandc)
+ {
+ 	nandc->reg_read_pos = 0;
+-	nandc_read_buffer_sync(nandc, false);
++	nandc_dev_to_mem(nandc, false);
+ }
+ 
+ /*
+@@ -1446,7 +1400,7 @@ static int check_flash_errors(struct qco
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 	int i;
+ 
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < cw_cnt; i++) {
+ 		u32 flash = le32_to_cpu(nandc->reg_read_buf[i]);
+@@ -1476,7 +1430,7 @@ qcom_nandc_read_cw_raw(struct mtd_info *
+ 	clear_read_regs(nandc);
+ 	host->use_ecc = false;
+ 
+-	if (nandc->props->qpic_v2)
++	if (nandc->props->qpic_version2)
+ 		raw_cw = ecc->steps - 1;
+ 
+ 	clear_bam_transaction(nandc);
+@@ -1497,7 +1451,7 @@ qcom_nandc_read_cw_raw(struct mtd_info *
+ 		oob_size2 = host->ecc_bytes_hw + host->spare_bytes;
+ 	}
+ 
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		nandc_set_read_loc(chip, cw, 0, read_loc, data_size1, 0);
+ 		read_loc += data_size1;
+ 
+@@ -1621,7 +1575,7 @@ static int parse_read_errors(struct qcom
+ 	u8 *data_buf_start = data_buf, *oob_buf_start = oob_buf;
+ 
+ 	buf = (struct read_stats *)nandc->reg_read_buf;
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < ecc->steps; i++, buf++) {
+ 		u32 flash, buffer, erased_cw;
+@@ -1734,7 +1688,7 @@ static int read_page_ecc(struct qcom_nan
+ 			oob_size = host->ecc_bytes_hw + host->spare_bytes;
+ 		}
+ 
+-		if (nandc->props->is_bam) {
++		if (nandc->props->supports_bam) {
+ 			if (data_buf && oob_buf) {
+ 				nandc_set_read_loc(chip, i, 0, 0, data_size, 0);
+ 				nandc_set_read_loc(chip, i, 1, data_size,
+@@ -2455,14 +2409,14 @@ static int qcom_nand_attach_chip(struct
+ 
+ 	mtd_set_ooblayout(mtd, &qcom_nand_ooblayout_ops);
+ 	/* Free the initially allocated BAM transaction for reading the ONFI params */
+-	if (nandc->props->is_bam)
++	if (nandc->props->supports_bam)
+ 		free_bam_transaction(nandc);
+ 
+ 	nandc->max_cwperpage = max_t(unsigned int, nandc->max_cwperpage,
+ 				     cwperpage);
+ 
+ 	/* Now allocate the BAM transaction based on updated max_cwperpage */
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		nandc->bam_txn = alloc_bam_transaction(nandc);
+ 		if (!nandc->bam_txn) {
+ 			dev_err(nandc->dev,
+@@ -2522,7 +2476,7 @@ static int qcom_nand_attach_chip(struct
+ 				| ecc_mode << ECC_MODE
+ 				| host->ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_BCH;
+ 
+-	if (!nandc->props->qpic_v2)
++	if (!nandc->props->qpic_version2)
+ 		host->ecc_buf_cfg = 0x203 << NUM_STEPS;
+ 
+ 	host->clrflashstatus = FS_READY_BSY_N;
+@@ -2556,7 +2510,7 @@ static int qcom_op_cmd_mapping(struct na
+ 		cmd = OP_FETCH_ID;
+ 		break;
+ 	case NAND_CMD_PARAM:
+-		if (nandc->props->qpic_v2)
++		if (nandc->props->qpic_version2)
+ 			cmd = OP_PAGE_READ_ONFI_READ;
+ 		else
+ 			cmd = OP_PAGE_READ;
+@@ -2609,7 +2563,7 @@ static int qcom_parse_instructions(struc
+ 			if (ret < 0)
+ 				return ret;
+ 
+-			q_op->cmd_reg = ret;
++			q_op->cmd_reg = cpu_to_le32(ret);
+ 			q_op->rdy_delay_ns = instr->delay_ns;
+ 			break;
+ 
+@@ -2619,10 +2573,10 @@ static int qcom_parse_instructions(struc
+ 			addrs = &instr->ctx.addr.addrs[offset];
+ 
+ 			for (i = 0; i < min_t(unsigned int, 4, naddrs); i++)
+-				q_op->addr1_reg |= addrs[i] << (i * 8);
++				q_op->addr1_reg |= cpu_to_le32(addrs[i] << (i * 8));
+ 
+ 			if (naddrs > 4)
+-				q_op->addr2_reg |= addrs[4];
++				q_op->addr2_reg |= cpu_to_le32(addrs[4]);
+ 
+ 			q_op->rdy_delay_ns = instr->delay_ns;
+ 			break;
+@@ -2663,7 +2617,7 @@ static int qcom_wait_rdy_poll(struct nan
+ 	unsigned long start = jiffies + msecs_to_jiffies(time_ms);
+ 	u32 flash;
+ 
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 
+ 	do {
+ 		flash = le32_to_cpu(nandc->reg_read_buf[0]);
+@@ -2706,11 +2660,11 @@ static int qcom_read_status_exec(struct
+ 	clear_read_regs(nandc);
+ 	clear_bam_transaction(nandc);
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, q_op.cmd_reg);
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
++	nandc->regs->cmd = q_op.cmd_reg;
++	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	ret = submit_descs(nandc);
+@@ -2719,7 +2673,7 @@ static int qcom_read_status_exec(struct
+ 		goto err_out;
+ 	}
+ 
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < num_cw; i++) {
+ 		flash_status = le32_to_cpu(nandc->reg_read_buf[i]);
+@@ -2763,16 +2717,14 @@ static int qcom_read_id_type_exec(struct
+ 	clear_read_regs(nandc);
+ 	clear_bam_transaction(nandc);
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, q_op.cmd_reg);
+-	nandc_set_reg(chip, NAND_ADDR0, q_op.addr1_reg);
+-	nandc_set_reg(chip, NAND_ADDR1, q_op.addr2_reg);
+-	nandc_set_reg(chip, NAND_FLASH_CHIP_SELECT,
+-		      nandc->props->is_bam ? 0 : DM_EN);
++	nandc->regs->cmd = q_op.cmd_reg;
++	nandc->regs->addr0 = q_op.addr1_reg;
++	nandc->regs->addr1 = q_op.addr2_reg;
++	nandc->regs->chip_sel = cpu_to_le32(nandc->props->supports_bam ? 0 : DM_EN);
++	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
+-
+-	write_reg_dma(nandc, NAND_FLASH_CMD, 4, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 4, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	read_reg_dma(nandc, NAND_READ_ID, 1, NAND_BAM_NEXT_SGL);
+ 
+@@ -2786,7 +2738,7 @@ static int qcom_read_id_type_exec(struct
+ 	op_id = q_op.data_instr_idx;
+ 	len = nand_subop_get_data_len(subop, op_id);
+ 
+-	nandc_read_buffer_sync(nandc, true);
++	nandc_dev_to_mem(nandc, true);
+ 	memcpy(instr->ctx.data.buf.in, nandc->reg_read_buf, len);
+ 
+ err_out:
+@@ -2807,15 +2759,14 @@ static int qcom_misc_cmd_type_exec(struc
+ 
+ 	if (q_op.flag == OP_PROGRAM_PAGE) {
+ 		goto wait_rdy;
+-	} else if (q_op.cmd_reg == OP_BLOCK_ERASE) {
+-		q_op.cmd_reg |= PAGE_ACC | LAST_PAGE;
+-		nandc_set_reg(chip, NAND_ADDR0, q_op.addr1_reg);
+-		nandc_set_reg(chip, NAND_ADDR1, q_op.addr2_reg);
+-		nandc_set_reg(chip, NAND_DEV0_CFG0,
+-			      host->cfg0_raw & ~(7 << CW_PER_PAGE));
+-		nandc_set_reg(chip, NAND_DEV0_CFG1, host->cfg1_raw);
++	} else if (q_op.cmd_reg == cpu_to_le32(OP_BLOCK_ERASE)) {
++		q_op.cmd_reg |= cpu_to_le32(PAGE_ACC | LAST_PAGE);
++		nandc->regs->addr0 = q_op.addr1_reg;
++		nandc->regs->addr1 = q_op.addr2_reg;
++		nandc->regs->cfg0 = cpu_to_le32(host->cfg0_raw & ~(7 << CW_PER_PAGE));
++		nandc->regs->cfg1 = cpu_to_le32(host->cfg1_raw);
+ 		instrs = 3;
+-	} else if (q_op.cmd_reg != OP_RESET_DEVICE) {
++	} else if (q_op.cmd_reg != cpu_to_le32(OP_RESET_DEVICE)) {
+ 		return 0;
+ 	}
+ 
+@@ -2826,14 +2777,14 @@ static int qcom_misc_cmd_type_exec(struc
+ 	clear_read_regs(nandc);
+ 	clear_bam_transaction(nandc);
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, q_op.cmd_reg);
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
++	nandc->regs->cmd = q_op.cmd_reg;
++	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, NAND_FLASH_CMD, instrs, NAND_BAM_NEXT_SGL);
+-	if (q_op.cmd_reg == OP_BLOCK_ERASE)
+-		write_reg_dma(nandc, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, instrs, NAND_BAM_NEXT_SGL);
++	if (q_op.cmd_reg == cpu_to_le32(OP_BLOCK_ERASE))
++		write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	ret = submit_descs(nandc);
+@@ -2864,7 +2815,7 @@ static int qcom_param_page_type_exec(str
+ 	if (ret)
+ 		return ret;
+ 
+-	q_op.cmd_reg |= PAGE_ACC | LAST_PAGE;
++	q_op.cmd_reg |= cpu_to_le32(PAGE_ACC | LAST_PAGE);
+ 
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+@@ -2872,38 +2823,38 @@ static int qcom_param_page_type_exec(str
+ 	clear_read_regs(nandc);
+ 	clear_bam_transaction(nandc);
+ 
+-	nandc_set_reg(chip, NAND_FLASH_CMD, q_op.cmd_reg);
++	nandc->regs->cmd = q_op.cmd_reg;
++	nandc->regs->addr0 = 0;
++	nandc->regs->addr1 = 0;
++
++	nandc->regs->cfg0 = cpu_to_le32(0 << CW_PER_PAGE
++			    | 512 << UD_SIZE_BYTES
++			    | 5 << NUM_ADDR_CYCLES
++			    | 0 << SPARE_SIZE_BYTES);
++
++	nandc->regs->cfg1 = cpu_to_le32(7 << NAND_RECOVERY_CYCLES
++			    | 0 << CS_ACTIVE_BSY
++			    | 17 << BAD_BLOCK_BYTE_NUM
++			    | 1 << BAD_BLOCK_IN_SPARE_AREA
++			    | 2 << WR_RD_BSY_GAP
++			    | 0 << WIDE_FLASH
++			    | 1 << DEV0_CFG1_ECC_DISABLE);
+ 
+-	nandc_set_reg(chip, NAND_ADDR0, 0);
+-	nandc_set_reg(chip, NAND_ADDR1, 0);
+-	nandc_set_reg(chip, NAND_DEV0_CFG0, 0 << CW_PER_PAGE
+-					| 512 << UD_SIZE_BYTES
+-					| 5 << NUM_ADDR_CYCLES
+-					| 0 << SPARE_SIZE_BYTES);
+-	nandc_set_reg(chip, NAND_DEV0_CFG1, 7 << NAND_RECOVERY_CYCLES
+-					| 0 << CS_ACTIVE_BSY
+-					| 17 << BAD_BLOCK_BYTE_NUM
+-					| 1 << BAD_BLOCK_IN_SPARE_AREA
+-					| 2 << WR_RD_BSY_GAP
+-					| 0 << WIDE_FLASH
+-					| 1 << DEV0_CFG1_ECC_DISABLE);
+-	if (!nandc->props->qpic_v2)
+-		nandc_set_reg(chip, NAND_EBI2_ECC_BUF_CFG, 1 << ECC_CFG_ECC_DISABLE);
++	if (!nandc->props->qpic_version2)
++		nandc->regs->ecc_buf_cfg = cpu_to_le32(1 << ECC_CFG_ECC_DISABLE);
+ 
+ 	/* configure CMD1 and VLD for ONFI param probing in QPIC v1 */
+-	if (!nandc->props->qpic_v2) {
+-		nandc_set_reg(chip, NAND_DEV_CMD_VLD,
+-			      (nandc->vld & ~READ_START_VLD));
+-		nandc_set_reg(chip, NAND_DEV_CMD1,
+-			      (nandc->cmd1 & ~(0xFF << READ_ADDR))
+-			      | NAND_CMD_PARAM << READ_ADDR);
++	if (!nandc->props->qpic_version2) {
++		nandc->regs->vld = cpu_to_le32((nandc->vld & ~READ_START_VLD));
++		nandc->regs->cmd1 = cpu_to_le32((nandc->cmd1 & ~(0xFF << READ_ADDR))
++				    | NAND_CMD_PARAM << READ_ADDR);
+ 	}
+ 
+-	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
+-
+-	if (!nandc->props->qpic_v2) {
+-		nandc_set_reg(chip, NAND_DEV_CMD1_RESTORE, nandc->cmd1);
+-		nandc_set_reg(chip, NAND_DEV_CMD_VLD_RESTORE, nandc->vld);
++	nandc->regs->exec = cpu_to_le32(1);
++
++	if (!nandc->props->qpic_version2) {
++		nandc->regs->orig_cmd1 = cpu_to_le32(nandc->cmd1);
++		nandc->regs->orig_vld = cpu_to_le32(nandc->vld);
+ 	}
+ 
+ 	instr = q_op.data_instr;
+@@ -2912,9 +2863,9 @@ static int qcom_param_page_type_exec(str
+ 
+ 	nandc_set_read_loc(chip, 0, 0, 0, len, 1);
+ 
+-	if (!nandc->props->qpic_v2) {
+-		write_reg_dma(nandc, NAND_DEV_CMD_VLD, 1, 0);
+-		write_reg_dma(nandc, NAND_DEV_CMD1, 1, NAND_BAM_NEXT_SGL);
++	if (!nandc->props->qpic_version2) {
++		write_reg_dma(nandc, &nandc->regs->vld, NAND_DEV_CMD_VLD, 1, 0);
++		write_reg_dma(nandc, &nandc->regs->cmd1, NAND_DEV_CMD1, 1, NAND_BAM_NEXT_SGL);
+ 	}
+ 
+ 	nandc->buf_count = len;
+@@ -2926,9 +2877,10 @@ static int qcom_param_page_type_exec(str
+ 		      nandc->buf_count, 0);
+ 
+ 	/* restore CMD1 and VLD regs */
+-	if (!nandc->props->qpic_v2) {
+-		write_reg_dma(nandc, NAND_DEV_CMD1_RESTORE, 1, 0);
+-		write_reg_dma(nandc, NAND_DEV_CMD_VLD_RESTORE, 1, NAND_BAM_NEXT_SGL);
++	if (!nandc->props->qpic_version2) {
++		write_reg_dma(nandc, &nandc->regs->orig_cmd1, NAND_DEV_CMD1_RESTORE, 1, 0);
++		write_reg_dma(nandc, &nandc->regs->orig_vld, NAND_DEV_CMD_VLD_RESTORE, 1,
++			      NAND_BAM_NEXT_SGL);
+ 	}
+ 
+ 	ret = submit_descs(nandc);
+@@ -3017,7 +2969,7 @@ static const struct nand_controller_ops
+ 
+ static void qcom_nandc_unalloc(struct qcom_nand_controller *nandc)
+ {
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		if (!dma_mapping_error(nandc->dev, nandc->reg_read_dma))
+ 			dma_unmap_single(nandc->dev, nandc->reg_read_dma,
+ 					 MAX_REG_RD *
+@@ -3070,7 +3022,7 @@ static int qcom_nandc_alloc(struct qcom_
+ 	if (!nandc->reg_read_buf)
+ 		return -ENOMEM;
+ 
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		nandc->reg_read_dma =
+ 			dma_map_single(nandc->dev, nandc->reg_read_buf,
+ 				       MAX_REG_RD *
+@@ -3151,15 +3103,15 @@ static int qcom_nandc_setup(struct qcom_
+ 	u32 nand_ctrl;
+ 
+ 	/* kill onenand */
+-	if (!nandc->props->is_qpic)
++	if (!nandc->props->nandc_part_of_qpic)
+ 		nandc_write(nandc, SFLASHC_BURST_CFG, 0);
+ 
+-	if (!nandc->props->qpic_v2)
++	if (!nandc->props->qpic_version2)
+ 		nandc_write(nandc, dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD),
+ 			    NAND_DEV_CMD_VLD_VAL);
+ 
+ 	/* enable ADM or BAM DMA */
+-	if (nandc->props->is_bam) {
++	if (nandc->props->supports_bam) {
+ 		nand_ctrl = nandc_read(nandc, NAND_CTRL);
+ 
+ 		/*
+@@ -3176,7 +3128,7 @@ static int qcom_nandc_setup(struct qcom_
+ 	}
+ 
+ 	/* save the original values of these registers */
+-	if (!nandc->props->qpic_v2) {
++	if (!nandc->props->qpic_version2) {
+ 		nandc->cmd1 = nandc_read(nandc, dev_cmd_reg_addr(nandc, NAND_DEV_CMD1));
+ 		nandc->vld = NAND_DEV_CMD_VLD_VAL;
+ 	}
+@@ -3349,7 +3301,7 @@ static int qcom_nandc_parse_dt(struct pl
+ 	struct device_node *np = nandc->dev->of_node;
+ 	int ret;
+ 
+-	if (!nandc->props->is_bam) {
++	if (!nandc->props->supports_bam) {
+ 		ret = of_property_read_u32(np, "qcom,cmd-crci",
+ 					   &nandc->cmd_crci);
+ 		if (ret) {
+@@ -3474,30 +3426,30 @@ static void qcom_nandc_remove(struct pla
+ 
+ static const struct qcom_nandc_props ipq806x_nandc_props = {
+ 	.ecc_modes = (ECC_RS_4BIT | ECC_BCH_8BIT),
+-	.is_bam = false,
++	.supports_bam = false,
+ 	.use_codeword_fixup = true,
+ 	.dev_cmd_reg_start = 0x0,
+ };
+ 
+ static const struct qcom_nandc_props ipq4019_nandc_props = {
+ 	.ecc_modes = (ECC_BCH_4BIT | ECC_BCH_8BIT),
+-	.is_bam = true,
+-	.is_qpic = true,
++	.supports_bam = true,
++	.nandc_part_of_qpic = true,
+ 	.dev_cmd_reg_start = 0x0,
+ };
+ 
+ static const struct qcom_nandc_props ipq8074_nandc_props = {
+ 	.ecc_modes = (ECC_BCH_4BIT | ECC_BCH_8BIT),
+-	.is_bam = true,
+-	.is_qpic = true,
++	.supports_bam = true,
++	.nandc_part_of_qpic = true,
+ 	.dev_cmd_reg_start = 0x7000,
+ };
+ 
+ static const struct qcom_nandc_props sdx55_nandc_props = {
+ 	.ecc_modes = (ECC_BCH_4BIT | ECC_BCH_8BIT),
+-	.is_bam = true,
+-	.is_qpic = true,
+-	.qpic_v2 = true,
++	.supports_bam = true,
++	.nandc_part_of_qpic = true,
++	.qpic_version2 = true,
+ 	.dev_cmd_reg_start = 0x7000,
+ };
+ 
diff --git a/target/linux/qualcommax/patches-6.6/0403-mtd-rawnand-qcom-Add-qcom-prefix-to-common-api.patch b/target/linux/qualcommax/patches-6.6/0403-mtd-rawnand-qcom-Add-qcom-prefix-to-common-api.patch
new file mode 100644
index 0000000000..0bce70c175
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0403-mtd-rawnand-qcom-Add-qcom-prefix-to-common-api.patch
@@ -0,0 +1,874 @@
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Sun, 22 Sep 2024 17:03:46 +0530
+Subject: [PATCH] mtd: rawnand: qcom: Add qcom prefix to common api
+
+Add qcom prefix to all the api which will be commonly
+used by spi nand driver and raw nand driver.
+
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+---
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -53,7 +53,7 @@
+ #define	NAND_READ_LOCATION_LAST_CW_2	0xf48
+ #define	NAND_READ_LOCATION_LAST_CW_3	0xf4c
+ 
+-/* dummy register offsets, used by write_reg_dma */
++/* dummy register offsets, used by qcom_write_reg_dma */
+ #define	NAND_DEV_CMD1_RESTORE		0xdead
+ #define	NAND_DEV_CMD_VLD_RESTORE	0xbeef
+ 
+@@ -211,7 +211,7 @@
+ 
+ /*
+  * Flags used in DMA descriptor preparation helper functions
+- * (i.e. read_reg_dma/write_reg_dma/read_data_dma/write_data_dma)
++ * (i.e. qcom_read_reg_dma/qcom_write_reg_dma/qcom_read_data_dma/qcom_write_data_dma)
+  */
+ /* Don't set the EOT in current tx BAM sgl */
+ #define NAND_BAM_NO_EOT			BIT(0)
+@@ -550,7 +550,7 @@ struct qcom_nandc_props {
+ };
+ 
+ /* Frees the BAM transaction memory */
+-static void free_bam_transaction(struct qcom_nand_controller *nandc)
++static void qcom_free_bam_transaction(struct qcom_nand_controller *nandc)
+ {
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+ 
+@@ -559,7 +559,7 @@ static void free_bam_transaction(struct
+ 
+ /* Allocates and Initializes the BAM transaction */
+ static struct bam_transaction *
+-alloc_bam_transaction(struct qcom_nand_controller *nandc)
++qcom_alloc_bam_transaction(struct qcom_nand_controller *nandc)
+ {
+ 	struct bam_transaction *bam_txn;
+ 	size_t bam_txn_size;
+@@ -595,7 +595,7 @@ alloc_bam_transaction(struct qcom_nand_c
+ }
+ 
+ /* Clears the BAM transaction indexes */
+-static void clear_bam_transaction(struct qcom_nand_controller *nandc)
++static void qcom_clear_bam_transaction(struct qcom_nand_controller *nandc)
+ {
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+ 
+@@ -614,7 +614,7 @@ static void clear_bam_transaction(struct
+ }
+ 
+ /* Callback for DMA descriptor completion */
+-static void qpic_bam_dma_done(void *data)
++static void qcom_qpic_bam_dma_done(void *data)
+ {
+ 	struct bam_transaction *bam_txn = data;
+ 
+@@ -644,7 +644,7 @@ static inline void nandc_write(struct qc
+ 	iowrite32(val, nandc->base + offset);
+ }
+ 
+-static inline void nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
++static inline void qcom_nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
+ {
+ 	if (!nandc->props->supports_bam)
+ 		return;
+@@ -824,9 +824,9 @@ static void update_rw_regs(struct qcom_n
+  * for BAM. This descriptor will be added in the NAND DMA descriptor queue
+  * which will be submitted to DMA engine.
+  */
+-static int prepare_bam_async_desc(struct qcom_nand_controller *nandc,
+-				  struct dma_chan *chan,
+-				  unsigned long flags)
++static int qcom_prepare_bam_async_desc(struct qcom_nand_controller *nandc,
++				       struct dma_chan *chan,
++				       unsigned long flags)
+ {
+ 	struct desc_info *desc;
+ 	struct scatterlist *sgl;
+@@ -903,9 +903,9 @@ static int prepare_bam_async_desc(struct
+  * NAND_BAM_NEXT_SGL will be used for starting the separate SGL
+  * after the current command element.
+  */
+-static int prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
+-				 int reg_off, const void *vaddr,
+-				 int size, unsigned int flags)
++static int qcom_prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
++				      int reg_off, const void *vaddr,
++				      int size, unsigned int flags)
+ {
+ 	int bam_ce_size;
+ 	int i, ret;
+@@ -943,9 +943,9 @@ static int prep_bam_dma_desc_cmd(struct
+ 		bam_txn->bam_ce_start = bam_txn->bam_ce_pos;
+ 
+ 		if (flags & NAND_BAM_NWD) {
+-			ret = prepare_bam_async_desc(nandc, nandc->cmd_chan,
+-						     DMA_PREP_FENCE |
+-						     DMA_PREP_CMD);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
++							  DMA_PREP_FENCE |
++							  DMA_PREP_CMD);
+ 			if (ret)
+ 				return ret;
+ 		}
+@@ -958,9 +958,8 @@ static int prep_bam_dma_desc_cmd(struct
+  * Prepares the data descriptor for BAM DMA which will be used for NAND
+  * data reads and writes.
+  */
+-static int prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
+-				  const void *vaddr,
+-				  int size, unsigned int flags)
++static int qcom_prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
++				       const void *vaddr, int size, unsigned int flags)
+ {
+ 	int ret;
+ 	struct bam_transaction *bam_txn = nandc->bam_txn;
+@@ -979,8 +978,8 @@ static int prep_bam_dma_desc_data(struct
+ 		 * is not set, form the DMA descriptor
+ 		 */
+ 		if (!(flags & NAND_BAM_NO_EOT)) {
+-			ret = prepare_bam_async_desc(nandc, nandc->tx_chan,
+-						     DMA_PREP_INTERRUPT);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
++							  DMA_PREP_INTERRUPT);
+ 			if (ret)
+ 				return ret;
+ 		}
+@@ -989,9 +988,9 @@ static int prep_bam_dma_desc_data(struct
+ 	return 0;
+ }
+ 
+-static int prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read,
+-			     int reg_off, const void *vaddr, int size,
+-			     bool flow_control)
++static int qcom_prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read,
++				  int reg_off, const void *vaddr, int size,
++				  bool flow_control)
+ {
+ 	struct desc_info *desc;
+ 	struct dma_async_tx_descriptor *dma_desc;
+@@ -1069,15 +1068,15 @@ err:
+ }
+ 
+ /*
+- * read_reg_dma:	prepares a descriptor to read a given number of
++ * qcom_read_reg_dma:	prepares a descriptor to read a given number of
+  *			contiguous registers to the reg_read_buf pointer
+  *
+  * @first:		offset of the first register in the contiguous block
+  * @num_regs:		number of registers to read
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int read_reg_dma(struct qcom_nand_controller *nandc, int first,
+-			int num_regs, unsigned int flags)
++static int qcom_read_reg_dma(struct qcom_nand_controller *nandc, int first,
++			     int num_regs, unsigned int flags)
+ {
+ 	bool flow_control = false;
+ 	void *vaddr;
+@@ -1089,18 +1088,18 @@ static int read_reg_dma(struct qcom_nand
+ 		first = dev_cmd_reg_addr(nandc, first);
+ 
+ 	if (nandc->props->supports_bam)
+-		return prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
++		return qcom_prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
+ 					     num_regs, flags);
+ 
+ 	if (first == NAND_READ_ID || first == NAND_FLASH_STATUS)
+ 		flow_control = true;
+ 
+-	return prep_adm_dma_desc(nandc, true, first, vaddr,
++	return qcom_prep_adm_dma_desc(nandc, true, first, vaddr,
+ 				 num_regs * sizeof(u32), flow_control);
+ }
+ 
+ /*
+- * write_reg_dma:	prepares a descriptor to write a given number of
++ * qcom_write_reg_dma:	prepares a descriptor to write a given number of
+  *			contiguous registers
+  *
+  * @vaddr:		contnigeous memory from where register value will
+@@ -1109,8 +1108,8 @@ static int read_reg_dma(struct qcom_nand
+  * @num_regs:		number of registers to write
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
+-			 int first, int num_regs, unsigned int flags)
++static int qcom_write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
++			      int first, int num_regs, unsigned int flags)
+ {
+ 	bool flow_control = false;
+ 
+@@ -1124,18 +1123,18 @@ static int write_reg_dma(struct qcom_nan
+ 		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD);
+ 
+ 	if (nandc->props->supports_bam)
+-		return prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
++		return qcom_prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
+ 					     num_regs, flags);
+ 
+ 	if (first == NAND_FLASH_CMD)
+ 		flow_control = true;
+ 
+-	return prep_adm_dma_desc(nandc, false, first, vaddr,
++	return qcom_prep_adm_dma_desc(nandc, false, first, vaddr,
+ 				 num_regs * sizeof(u32), flow_control);
+ }
+ 
+ /*
+- * read_data_dma:	prepares a DMA descriptor to transfer data from the
++ * qcom_read_data_dma:	prepares a DMA descriptor to transfer data from the
+  *			controller's internal buffer to the buffer 'vaddr'
+  *
+  * @reg_off:		offset within the controller's data buffer
+@@ -1143,17 +1142,17 @@ static int write_reg_dma(struct qcom_nan
+  * @size:		DMA transaction size in bytes
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+-			 const u8 *vaddr, int size, unsigned int flags)
++static int qcom_read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
++			      const u8 *vaddr, int size, unsigned int flags)
+ {
+ 	if (nandc->props->supports_bam)
+-		return prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
++		return qcom_prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
+ 
+-	return prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
++	return qcom_prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
+ }
+ 
+ /*
+- * write_data_dma:	prepares a DMA descriptor to transfer data from
++ * qcom_write_data_dma:	prepares a DMA descriptor to transfer data from
+  *			'vaddr' to the controller's internal buffer
+  *
+  * @reg_off:		offset within the controller's data buffer
+@@ -1161,13 +1160,13 @@ static int read_data_dma(struct qcom_nan
+  * @size:		DMA transaction size in bytes
+  * @flags:		flags to control DMA descriptor preparation
+  */
+-static int write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+-			  const u8 *vaddr, int size, unsigned int flags)
++static int qcom_write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
++			       const u8 *vaddr, int size, unsigned int flags)
+ {
+ 	if (nandc->props->supports_bam)
+-		return prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
++		return qcom_prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
+ 
+-	return prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
++	return qcom_prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
+ }
+ 
+ /*
+@@ -1178,14 +1177,14 @@ static void config_nand_page_read(struct
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
+-	write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
+ 	if (!nandc->props->qpic_version2)
+-		write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1, 0);
+-	write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_clr,
+-		      NAND_ERASED_CW_DETECT_CFG, 1, 0);
+-	write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_set,
+-		      NAND_ERASED_CW_DETECT_CFG, 1, NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1, NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
+ }
+ 
+ /*
+@@ -1204,17 +1203,17 @@ config_nand_cw_read(struct nand_chip *ch
+ 		reg = &nandc->regs->read_location_last0;
+ 
+ 	if (nandc->props->supports_bam)
+-		write_reg_dma(nandc, reg, NAND_READ_LOCATION_0, 4, NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, reg, NAND_READ_LOCATION_0, 4, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+ 	if (use_ecc) {
+-		read_reg_dma(nandc, NAND_FLASH_STATUS, 2, 0);
+-		read_reg_dma(nandc, NAND_ERASED_CW_DETECT_STATUS, 1,
+-			     NAND_BAM_NEXT_SGL);
++		qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 2, 0);
++		qcom_read_reg_dma(nandc, NAND_ERASED_CW_DETECT_STATUS, 1,
++				  NAND_BAM_NEXT_SGL);
+ 	} else {
+-		read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++		qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 	}
+ }
+ 
+@@ -1238,11 +1237,11 @@ static void config_nand_page_write(struc
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
+-	write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
+ 	if (!nandc->props->qpic_version2)
+-		write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1,
+-			      NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1,
++				   NAND_BAM_NEXT_SGL);
+ }
+ 
+ /*
+@@ -1253,17 +1252,18 @@ static void config_nand_cw_write(struct
+ {
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+-	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, &nandc->regs->clrflashstatus, NAND_FLASH_STATUS, 1, 0);
+-	write_reg_dma(nandc, &nandc->regs->clrreadstatus, NAND_READ_STATUS, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->clrflashstatus, NAND_FLASH_STATUS, 1, 0);
++	qcom_write_reg_dma(nandc, &nandc->regs->clrreadstatus, NAND_READ_STATUS, 1,
++			   NAND_BAM_NEXT_SGL);
+ }
+ 
+ /* helpers to submit/free our list of dma descriptors */
+-static int submit_descs(struct qcom_nand_controller *nandc)
++static int qcom_submit_descs(struct qcom_nand_controller *nandc)
+ {
+ 	struct desc_info *desc, *n;
+ 	dma_cookie_t cookie = 0;
+@@ -1272,21 +1272,21 @@ static int submit_descs(struct qcom_nand
+ 
+ 	if (nandc->props->supports_bam) {
+ 		if (bam_txn->rx_sgl_pos > bam_txn->rx_sgl_start) {
+-			ret = prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
+ 			if (ret)
+ 				goto err_unmap_free_desc;
+ 		}
+ 
+ 		if (bam_txn->tx_sgl_pos > bam_txn->tx_sgl_start) {
+-			ret = prepare_bam_async_desc(nandc, nandc->tx_chan,
+-						   DMA_PREP_INTERRUPT);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
++							  DMA_PREP_INTERRUPT);
+ 			if (ret)
+ 				goto err_unmap_free_desc;
+ 		}
+ 
+ 		if (bam_txn->cmd_sgl_pos > bam_txn->cmd_sgl_start) {
+-			ret = prepare_bam_async_desc(nandc, nandc->cmd_chan,
+-						   DMA_PREP_CMD);
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
++							  DMA_PREP_CMD);
+ 			if (ret)
+ 				goto err_unmap_free_desc;
+ 		}
+@@ -1296,7 +1296,7 @@ static int submit_descs(struct qcom_nand
+ 		cookie = dmaengine_submit(desc->dma_desc);
+ 
+ 	if (nandc->props->supports_bam) {
+-		bam_txn->last_cmd_desc->callback = qpic_bam_dma_done;
++		bam_txn->last_cmd_desc->callback = qcom_qpic_bam_dma_done;
+ 		bam_txn->last_cmd_desc->callback_param = bam_txn;
+ 
+ 		dma_async_issue_pending(nandc->tx_chan);
+@@ -1314,7 +1314,7 @@ static int submit_descs(struct qcom_nand
+ err_unmap_free_desc:
+ 	/*
+ 	 * Unmap the dma sg_list and free the desc allocated by both
+-	 * prepare_bam_async_desc() and prep_adm_dma_desc() functions.
++	 * qcom_prepare_bam_async_desc() and qcom_prep_adm_dma_desc() functions.
+ 	 */
+ 	list_for_each_entry_safe(desc, n, &nandc->desc_list, node) {
+ 		list_del(&desc->node);
+@@ -1333,10 +1333,10 @@ err_unmap_free_desc:
+ }
+ 
+ /* reset the register read buffer for next NAND operation */
+-static void clear_read_regs(struct qcom_nand_controller *nandc)
++static void qcom_clear_read_regs(struct qcom_nand_controller *nandc)
+ {
+ 	nandc->reg_read_pos = 0;
+-	nandc_dev_to_mem(nandc, false);
++	qcom_nandc_dev_to_mem(nandc, false);
+ }
+ 
+ /*
+@@ -1400,7 +1400,7 @@ static int check_flash_errors(struct qco
+ 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+ 	int i;
+ 
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < cw_cnt; i++) {
+ 		u32 flash = le32_to_cpu(nandc->reg_read_buf[i]);
+@@ -1427,13 +1427,13 @@ qcom_nandc_read_cw_raw(struct mtd_info *
+ 	nand_read_page_op(chip, page, 0, NULL, 0);
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+-	clear_read_regs(nandc);
++	qcom_clear_read_regs(nandc);
+ 	host->use_ecc = false;
+ 
+ 	if (nandc->props->qpic_version2)
+ 		raw_cw = ecc->steps - 1;
+ 
+-	clear_bam_transaction(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 	set_address(host, host->cw_size * cw, page);
+ 	update_rw_regs(host, 1, true, raw_cw);
+ 	config_nand_page_read(chip);
+@@ -1466,18 +1466,18 @@ qcom_nandc_read_cw_raw(struct mtd_info *
+ 
+ 	config_nand_cw_read(chip, false, raw_cw);
+ 
+-	read_data_dma(nandc, reg_off, data_buf, data_size1, 0);
++	qcom_read_data_dma(nandc, reg_off, data_buf, data_size1, 0);
+ 	reg_off += data_size1;
+ 
+-	read_data_dma(nandc, reg_off, oob_buf, oob_size1, 0);
++	qcom_read_data_dma(nandc, reg_off, oob_buf, oob_size1, 0);
+ 	reg_off += oob_size1;
+ 
+-	read_data_dma(nandc, reg_off, data_buf + data_size1, data_size2, 0);
++	qcom_read_data_dma(nandc, reg_off, data_buf + data_size1, data_size2, 0);
+ 	reg_off += data_size2;
+ 
+-	read_data_dma(nandc, reg_off, oob_buf + oob_size1, oob_size2, 0);
++	qcom_read_data_dma(nandc, reg_off, oob_buf + oob_size1, oob_size2, 0);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to read raw cw %d\n", cw);
+ 		return ret;
+@@ -1575,7 +1575,7 @@ static int parse_read_errors(struct qcom
+ 	u8 *data_buf_start = data_buf, *oob_buf_start = oob_buf;
+ 
+ 	buf = (struct read_stats *)nandc->reg_read_buf;
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < ecc->steps; i++, buf++) {
+ 		u32 flash, buffer, erased_cw;
+@@ -1704,8 +1704,8 @@ static int read_page_ecc(struct qcom_nan
+ 		config_nand_cw_read(chip, true, i);
+ 
+ 		if (data_buf)
+-			read_data_dma(nandc, FLASH_BUF_ACC, data_buf,
+-				      data_size, 0);
++			qcom_read_data_dma(nandc, FLASH_BUF_ACC, data_buf,
++					   data_size, 0);
+ 
+ 		/*
+ 		 * when ecc is enabled, the controller doesn't read the real
+@@ -1720,8 +1720,8 @@ static int read_page_ecc(struct qcom_nan
+ 			for (j = 0; j < host->bbm_size; j++)
+ 				*oob_buf++ = 0xff;
+ 
+-			read_data_dma(nandc, FLASH_BUF_ACC + data_size,
+-				      oob_buf, oob_size, 0);
++			qcom_read_data_dma(nandc, FLASH_BUF_ACC + data_size,
++					   oob_buf, oob_size, 0);
+ 		}
+ 
+ 		if (data_buf)
+@@ -1730,7 +1730,7 @@ static int read_page_ecc(struct qcom_nan
+ 			oob_buf += oob_size;
+ 	}
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to read page/oob\n");
+ 		return ret;
+@@ -1751,7 +1751,7 @@ static int copy_last_cw(struct qcom_nand
+ 	int size;
+ 	int ret;
+ 
+-	clear_read_regs(nandc);
++	qcom_clear_read_regs(nandc);
+ 
+ 	size = host->use_ecc ? host->cw_data : host->cw_size;
+ 
+@@ -1763,9 +1763,9 @@ static int copy_last_cw(struct qcom_nand
+ 
+ 	config_nand_single_cw_page_read(chip, host->use_ecc, ecc->steps - 1);
+ 
+-	read_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer, size, 0);
++	qcom_read_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer, size, 0);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret)
+ 		dev_err(nandc->dev, "failed to copy last codeword\n");
+ 
+@@ -1851,14 +1851,14 @@ static int qcom_nandc_read_page(struct n
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = true;
+-	clear_read_regs(nandc);
++	qcom_clear_read_regs(nandc);
+ 	set_address(host, 0, page);
+ 	update_rw_regs(host, ecc->steps, true, 0);
+ 
+ 	data_buf = buf;
+ 	oob_buf = oob_required ? chip->oob_poi : NULL;
+ 
+-	clear_bam_transaction(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	return read_page_ecc(host, data_buf, oob_buf, page);
+ }
+@@ -1899,8 +1899,8 @@ static int qcom_nandc_read_oob(struct na
+ 	if (host->nr_boot_partitions)
+ 		qcom_nandc_codeword_fixup(host, page);
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	host->use_ecc = true;
+ 	set_address(host, 0, page);
+@@ -1927,8 +1927,8 @@ static int qcom_nandc_write_page(struct
+ 	set_address(host, 0, page);
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	data_buf = (u8 *)buf;
+ 	oob_buf = chip->oob_poi;
+@@ -1949,8 +1949,8 @@ static int qcom_nandc_write_page(struct
+ 			oob_size = ecc->bytes;
+ 		}
+ 
+-		write_data_dma(nandc, FLASH_BUF_ACC, data_buf, data_size,
+-			       i == (ecc->steps - 1) ? NAND_BAM_NO_EOT : 0);
++		qcom_write_data_dma(nandc, FLASH_BUF_ACC, data_buf, data_size,
++				    i == (ecc->steps - 1) ? NAND_BAM_NO_EOT : 0);
+ 
+ 		/*
+ 		 * when ECC is enabled, we don't really need to write anything
+@@ -1962,8 +1962,8 @@ static int qcom_nandc_write_page(struct
+ 		if (qcom_nandc_is_last_cw(ecc, i)) {
+ 			oob_buf += host->bbm_size;
+ 
+-			write_data_dma(nandc, FLASH_BUF_ACC + data_size,
+-				       oob_buf, oob_size, 0);
++			qcom_write_data_dma(nandc, FLASH_BUF_ACC + data_size,
++					    oob_buf, oob_size, 0);
+ 		}
+ 
+ 		config_nand_cw_write(chip);
+@@ -1972,7 +1972,7 @@ static int qcom_nandc_write_page(struct
+ 		oob_buf += oob_size;
+ 	}
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to write page\n");
+ 		return ret;
+@@ -1997,8 +1997,8 @@ static int qcom_nandc_write_page_raw(str
+ 		qcom_nandc_codeword_fixup(host, page);
+ 
+ 	nand_prog_page_begin_op(chip, page, 0, NULL, 0);
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	data_buf = (u8 *)buf;
+ 	oob_buf = chip->oob_poi;
+@@ -2024,28 +2024,28 @@ static int qcom_nandc_write_page_raw(str
+ 			oob_size2 = host->ecc_bytes_hw + host->spare_bytes;
+ 		}
+ 
+-		write_data_dma(nandc, reg_off, data_buf, data_size1,
+-			       NAND_BAM_NO_EOT);
++		qcom_write_data_dma(nandc, reg_off, data_buf, data_size1,
++				    NAND_BAM_NO_EOT);
+ 		reg_off += data_size1;
+ 		data_buf += data_size1;
+ 
+-		write_data_dma(nandc, reg_off, oob_buf, oob_size1,
+-			       NAND_BAM_NO_EOT);
++		qcom_write_data_dma(nandc, reg_off, oob_buf, oob_size1,
++				    NAND_BAM_NO_EOT);
+ 		reg_off += oob_size1;
+ 		oob_buf += oob_size1;
+ 
+-		write_data_dma(nandc, reg_off, data_buf, data_size2,
+-			       NAND_BAM_NO_EOT);
++		qcom_write_data_dma(nandc, reg_off, data_buf, data_size2,
++				    NAND_BAM_NO_EOT);
+ 		reg_off += data_size2;
+ 		data_buf += data_size2;
+ 
+-		write_data_dma(nandc, reg_off, oob_buf, oob_size2, 0);
++		qcom_write_data_dma(nandc, reg_off, oob_buf, oob_size2, 0);
+ 		oob_buf += oob_size2;
+ 
+ 		config_nand_cw_write(chip);
+ 	}
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to write raw page\n");
+ 		return ret;
+@@ -2075,7 +2075,7 @@ static int qcom_nandc_write_oob(struct n
+ 		qcom_nandc_codeword_fixup(host, page);
+ 
+ 	host->use_ecc = true;
+-	clear_bam_transaction(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	/* calculate the data and oob size for the last codeword/step */
+ 	data_size = ecc->size - ((ecc->steps - 1) << 2);
+@@ -2090,11 +2090,11 @@ static int qcom_nandc_write_oob(struct n
+ 	update_rw_regs(host, 1, false, 0);
+ 
+ 	config_nand_page_write(chip);
+-	write_data_dma(nandc, FLASH_BUF_ACC,
+-		       nandc->data_buffer, data_size + oob_size, 0);
++	qcom_write_data_dma(nandc, FLASH_BUF_ACC,
++			    nandc->data_buffer, data_size + oob_size, 0);
+ 	config_nand_cw_write(chip);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to write oob\n");
+ 		return ret;
+@@ -2121,7 +2121,7 @@ static int qcom_nandc_block_bad(struct n
+ 	 */
+ 	host->use_ecc = false;
+ 
+-	clear_bam_transaction(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 	ret = copy_last_cw(host, page);
+ 	if (ret)
+ 		goto err;
+@@ -2148,8 +2148,8 @@ static int qcom_nandc_block_markbad(stru
+ 	struct nand_ecc_ctrl *ecc = &chip->ecc;
+ 	int page, ret;
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	/*
+ 	 * to mark the BBM as bad, we flash the entire last codeword with 0s.
+@@ -2166,11 +2166,11 @@ static int qcom_nandc_block_markbad(stru
+ 	update_rw_regs(host, 1, false, ecc->steps - 1);
+ 
+ 	config_nand_page_write(chip);
+-	write_data_dma(nandc, FLASH_BUF_ACC,
+-		       nandc->data_buffer, host->cw_size, 0);
++	qcom_write_data_dma(nandc, FLASH_BUF_ACC,
++			    nandc->data_buffer, host->cw_size, 0);
+ 	config_nand_cw_write(chip);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure to update BBM\n");
+ 		return ret;
+@@ -2410,14 +2410,14 @@ static int qcom_nand_attach_chip(struct
+ 	mtd_set_ooblayout(mtd, &qcom_nand_ooblayout_ops);
+ 	/* Free the initially allocated BAM transaction for reading the ONFI params */
+ 	if (nandc->props->supports_bam)
+-		free_bam_transaction(nandc);
++		qcom_free_bam_transaction(nandc);
+ 
+ 	nandc->max_cwperpage = max_t(unsigned int, nandc->max_cwperpage,
+ 				     cwperpage);
+ 
+ 	/* Now allocate the BAM transaction based on updated max_cwperpage */
+ 	if (nandc->props->supports_bam) {
+-		nandc->bam_txn = alloc_bam_transaction(nandc);
++		nandc->bam_txn = qcom_alloc_bam_transaction(nandc);
+ 		if (!nandc->bam_txn) {
+ 			dev_err(nandc->dev,
+ 				"failed to allocate bam transaction\n");
+@@ -2617,7 +2617,7 @@ static int qcom_wait_rdy_poll(struct nan
+ 	unsigned long start = jiffies + msecs_to_jiffies(time_ms);
+ 	u32 flash;
+ 
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 
+ 	do {
+ 		flash = le32_to_cpu(nandc->reg_read_buf[0]);
+@@ -2657,23 +2657,23 @@ static int qcom_read_status_exec(struct
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = false;
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	nandc->regs->cmd = q_op.cmd_reg;
+ 	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+-	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure in submitting status descriptor\n");
+ 		goto err_out;
+ 	}
+ 
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 
+ 	for (i = 0; i < num_cw; i++) {
+ 		flash_status = le32_to_cpu(nandc->reg_read_buf[i]);
+@@ -2714,8 +2714,8 @@ static int qcom_read_id_type_exec(struct
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = false;
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	nandc->regs->cmd = q_op.cmd_reg;
+ 	nandc->regs->addr0 = q_op.addr1_reg;
+@@ -2723,12 +2723,12 @@ static int qcom_read_id_type_exec(struct
+ 	nandc->regs->chip_sel = cpu_to_le32(nandc->props->supports_bam ? 0 : DM_EN);
+ 	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 4, NAND_BAM_NEXT_SGL);
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, 4, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+ 
+-	read_reg_dma(nandc, NAND_READ_ID, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(nandc, NAND_READ_ID, 1, NAND_BAM_NEXT_SGL);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure in submitting read id descriptor\n");
+ 		goto err_out;
+@@ -2738,7 +2738,7 @@ static int qcom_read_id_type_exec(struct
+ 	op_id = q_op.data_instr_idx;
+ 	len = nand_subop_get_data_len(subop, op_id);
+ 
+-	nandc_dev_to_mem(nandc, true);
++	qcom_nandc_dev_to_mem(nandc, true);
+ 	memcpy(instr->ctx.data.buf.in, nandc->reg_read_buf, len);
+ 
+ err_out:
+@@ -2774,20 +2774,20 @@ static int qcom_misc_cmd_type_exec(struc
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = false;
+ 
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	nandc->regs->cmd = q_op.cmd_reg;
+ 	nandc->regs->exec = cpu_to_le32(1);
+ 
+-	write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, instrs, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->cmd, NAND_FLASH_CMD, instrs, NAND_BAM_NEXT_SGL);
+ 	if (q_op.cmd_reg == cpu_to_le32(OP_BLOCK_ERASE))
+-		write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->cfg0, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
+ 
+-	write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+-	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(nandc, &nandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure in submitting misc descriptor\n");
+ 		goto err_out;
+@@ -2820,8 +2820,8 @@ static int qcom_param_page_type_exec(str
+ 	nandc->buf_count = 0;
+ 	nandc->buf_start = 0;
+ 	host->use_ecc = false;
+-	clear_read_regs(nandc);
+-	clear_bam_transaction(nandc);
++	qcom_clear_read_regs(nandc);
++	qcom_clear_bam_transaction(nandc);
+ 
+ 	nandc->regs->cmd = q_op.cmd_reg;
+ 	nandc->regs->addr0 = 0;
+@@ -2864,8 +2864,8 @@ static int qcom_param_page_type_exec(str
+ 	nandc_set_read_loc(chip, 0, 0, 0, len, 1);
+ 
+ 	if (!nandc->props->qpic_version2) {
+-		write_reg_dma(nandc, &nandc->regs->vld, NAND_DEV_CMD_VLD, 1, 0);
+-		write_reg_dma(nandc, &nandc->regs->cmd1, NAND_DEV_CMD1, 1, NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->vld, NAND_DEV_CMD_VLD, 1, 0);
++		qcom_write_reg_dma(nandc, &nandc->regs->cmd1, NAND_DEV_CMD1, 1, NAND_BAM_NEXT_SGL);
+ 	}
+ 
+ 	nandc->buf_count = len;
+@@ -2873,17 +2873,17 @@ static int qcom_param_page_type_exec(str
+ 
+ 	config_nand_single_cw_page_read(chip, false, 0);
+ 
+-	read_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer,
+-		      nandc->buf_count, 0);
++	qcom_read_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer,
++			   nandc->buf_count, 0);
+ 
+ 	/* restore CMD1 and VLD regs */
+ 	if (!nandc->props->qpic_version2) {
+-		write_reg_dma(nandc, &nandc->regs->orig_cmd1, NAND_DEV_CMD1_RESTORE, 1, 0);
+-		write_reg_dma(nandc, &nandc->regs->orig_vld, NAND_DEV_CMD_VLD_RESTORE, 1,
+-			      NAND_BAM_NEXT_SGL);
++		qcom_write_reg_dma(nandc, &nandc->regs->orig_cmd1, NAND_DEV_CMD1_RESTORE, 1, 0);
++		qcom_write_reg_dma(nandc, &nandc->regs->orig_vld, NAND_DEV_CMD_VLD_RESTORE, 1,
++				   NAND_BAM_NEXT_SGL);
+ 	}
+ 
+-	ret = submit_descs(nandc);
++	ret = qcom_submit_descs(nandc);
+ 	if (ret) {
+ 		dev_err(nandc->dev, "failure in submitting param page descriptor\n");
+ 		goto err_out;
+@@ -3067,7 +3067,7 @@ static int qcom_nandc_alloc(struct qcom_
+ 		 * maximum codeword size
+ 		 */
+ 		nandc->max_cwperpage = 1;
+-		nandc->bam_txn = alloc_bam_transaction(nandc);
++		nandc->bam_txn = qcom_alloc_bam_transaction(nandc);
+ 		if (!nandc->bam_txn) {
+ 			dev_err(nandc->dev,
+ 				"failed to allocate bam transaction\n");
diff --git a/target/linux/qualcommax/patches-6.6/0404-mtd-nand-Add-qpic_common-API-file.patch b/target/linux/qualcommax/patches-6.6/0404-mtd-nand-Add-qpic_common-API-file.patch
new file mode 100644
index 0000000000..e992e261af
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0404-mtd-nand-Add-qpic_common-API-file.patch
@@ -0,0 +1,2418 @@
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Sun, 22 Sep 2024 17:03:47 +0530
+Subject: [PATCH] mtd: nand: Add qpic_common API file
+
+Add qpic_common.c file which hold all the common
+qpic APIs which will be used by both qpic raw nand
+driver and qpic spi nand driver.
+
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+---
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -5,6 +5,10 @@ obj-$(CONFIG_MTD_NAND_CORE) += nandcore.
+ obj-$(CONFIG_MTD_NAND_ECC_MEDIATEK) += ecc-mtk.o
+ obj-$(CONFIG_MTD_NAND_MTK_BMT)	+= mtk_bmt.o mtk_bmt_v2.o mtk_bmt_bbt.o mtk_bmt_nmbm.o
+ 
++ifeq ($(CONFIG_MTD_NAND_QCOM),y)
++obj-y	+= qpic_common.o
++endif
++
+ obj-y	+= onenand/
+ obj-y	+= raw/
+ obj-y	+= spi/
+--- /dev/null
++++ b/drivers/mtd/nand/qpic_common.c
+@@ -0,0 +1,738 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2016, The Linux Foundation. All rights reserved.
++ */
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/dmaengine.h>
++#include <linux/dma-mapping.h>
++#include <linux/dma/qcom_adm.h>
++#include <linux/dma/qcom_bam_dma.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/mtd/nand-qpic-common.h>
++
++/**
++ * qcom_free_bam_transaction() - Frees the BAM transaction memory
++ * @nandc: qpic nand controller
++ *
++ * This function frees the bam transaction memory
++ */
++void qcom_free_bam_transaction(struct qcom_nand_controller *nandc)
++{
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++
++	kfree(bam_txn);
++}
++
++/**
++ * qcom_alloc_bam_transaction() - allocate BAM transaction
++ * @nandc: qpic nand controller
++ *
++ * This function will allocate and initialize the BAM transaction structure
++ */
++struct bam_transaction *
++qcom_alloc_bam_transaction(struct qcom_nand_controller *nandc)
++{
++	struct bam_transaction *bam_txn;
++	size_t bam_txn_size;
++	unsigned int num_cw = nandc->max_cwperpage;
++	void *bam_txn_buf;
++
++	bam_txn_size =
++		sizeof(*bam_txn) + num_cw *
++		((sizeof(*bam_txn->bam_ce) * QPIC_PER_CW_CMD_ELEMENTS) +
++		(sizeof(*bam_txn->cmd_sgl) * QPIC_PER_CW_CMD_SGL) +
++		(sizeof(*bam_txn->data_sgl) * QPIC_PER_CW_DATA_SGL));
++
++	bam_txn_buf = kzalloc(bam_txn_size, GFP_KERNEL);
++	if (!bam_txn_buf)
++		return NULL;
++
++	bam_txn = bam_txn_buf;
++	bam_txn_buf += sizeof(*bam_txn);
++
++	bam_txn->bam_ce = bam_txn_buf;
++	bam_txn_buf +=
++		sizeof(*bam_txn->bam_ce) * QPIC_PER_CW_CMD_ELEMENTS * num_cw;
++
++	bam_txn->cmd_sgl = bam_txn_buf;
++	bam_txn_buf +=
++		sizeof(*bam_txn->cmd_sgl) * QPIC_PER_CW_CMD_SGL * num_cw;
++
++	bam_txn->data_sgl = bam_txn_buf;
++
++	init_completion(&bam_txn->txn_done);
++
++	return bam_txn;
++}
++
++/**
++ * qcom_clear_bam_transaction() - Clears the BAM transaction
++ * @nandc: qpic nand controller
++ *
++ * This function will clear the BAM transaction indexes.
++ */
++void qcom_clear_bam_transaction(struct qcom_nand_controller *nandc)
++{
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++
++	if (!nandc->props->supports_bam)
++		return;
++
++	memset(&bam_txn->bam_ce_pos, 0, sizeof(u32) * 8);
++	bam_txn->last_data_desc = NULL;
++
++	sg_init_table(bam_txn->cmd_sgl, nandc->max_cwperpage *
++		      QPIC_PER_CW_CMD_SGL);
++	sg_init_table(bam_txn->data_sgl, nandc->max_cwperpage *
++		      QPIC_PER_CW_DATA_SGL);
++
++	reinit_completion(&bam_txn->txn_done);
++}
++
++/**
++ * qcom_qpic_bam_dma_done() - Callback for DMA descriptor completion
++ * @data: data pointer
++ *
++ * This function is a callback for DMA descriptor completion
++ */
++void qcom_qpic_bam_dma_done(void *data)
++{
++	struct bam_transaction *bam_txn = data;
++
++	complete(&bam_txn->txn_done);
++}
++
++/**
++ * qcom_nandc_dev_to_mem() - Check for dma sync for cpu or device
++ * @nandc: qpic nand controller
++ * @is_cpu: cpu or Device
++ *
++ * This function will check for dma sync for cpu or device
++ */
++inline void qcom_nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
++{
++	if (!nandc->props->supports_bam)
++		return;
++
++	if (is_cpu)
++		dma_sync_single_for_cpu(nandc->dev, nandc->reg_read_dma,
++					MAX_REG_RD *
++					sizeof(*nandc->reg_read_buf),
++					DMA_FROM_DEVICE);
++	else
++		dma_sync_single_for_device(nandc->dev, nandc->reg_read_dma,
++					   MAX_REG_RD *
++					   sizeof(*nandc->reg_read_buf),
++					   DMA_FROM_DEVICE);
++}
++
++/**
++ * qcom_prepare_bam_async_desc() - Prepare DMA descriptor
++ * @nandc: qpic nand controller
++ * @chan: dma channel
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function maps the scatter gather list for DMA transfer and forms the
++ * DMA descriptor for BAM.This descriptor will be added in the NAND DMA
++ * descriptor queue which will be submitted to DMA engine.
++ */
++int qcom_prepare_bam_async_desc(struct qcom_nand_controller *nandc,
++				struct dma_chan *chan, unsigned long flags)
++{
++	struct desc_info *desc;
++	struct scatterlist *sgl;
++	unsigned int sgl_cnt;
++	int ret;
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++	enum dma_transfer_direction dir_eng;
++	struct dma_async_tx_descriptor *dma_desc;
++
++	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
++	if (!desc)
++		return -ENOMEM;
++
++	if (chan == nandc->cmd_chan) {
++		sgl = &bam_txn->cmd_sgl[bam_txn->cmd_sgl_start];
++		sgl_cnt = bam_txn->cmd_sgl_pos - bam_txn->cmd_sgl_start;
++		bam_txn->cmd_sgl_start = bam_txn->cmd_sgl_pos;
++		dir_eng = DMA_MEM_TO_DEV;
++		desc->dir = DMA_TO_DEVICE;
++	} else if (chan == nandc->tx_chan) {
++		sgl = &bam_txn->data_sgl[bam_txn->tx_sgl_start];
++		sgl_cnt = bam_txn->tx_sgl_pos - bam_txn->tx_sgl_start;
++		bam_txn->tx_sgl_start = bam_txn->tx_sgl_pos;
++		dir_eng = DMA_MEM_TO_DEV;
++		desc->dir = DMA_TO_DEVICE;
++	} else {
++		sgl = &bam_txn->data_sgl[bam_txn->rx_sgl_start];
++		sgl_cnt = bam_txn->rx_sgl_pos - bam_txn->rx_sgl_start;
++		bam_txn->rx_sgl_start = bam_txn->rx_sgl_pos;
++		dir_eng = DMA_DEV_TO_MEM;
++		desc->dir = DMA_FROM_DEVICE;
++	}
++
++	sg_mark_end(sgl + sgl_cnt - 1);
++	ret = dma_map_sg(nandc->dev, sgl, sgl_cnt, desc->dir);
++	if (ret == 0) {
++		dev_err(nandc->dev, "failure in mapping desc\n");
++		kfree(desc);
++		return -ENOMEM;
++	}
++
++	desc->sgl_cnt = sgl_cnt;
++	desc->bam_sgl = sgl;
++
++	dma_desc = dmaengine_prep_slave_sg(chan, sgl, sgl_cnt, dir_eng,
++					   flags);
++
++	if (!dma_desc) {
++		dev_err(nandc->dev, "failure in prep desc\n");
++		dma_unmap_sg(nandc->dev, sgl, sgl_cnt, desc->dir);
++		kfree(desc);
++		return -EINVAL;
++	}
++
++	desc->dma_desc = dma_desc;
++
++	/* update last data/command descriptor */
++	if (chan == nandc->cmd_chan)
++		bam_txn->last_cmd_desc = dma_desc;
++	else
++		bam_txn->last_data_desc = dma_desc;
++
++	list_add_tail(&desc->node, &nandc->desc_list);
++
++	return 0;
++}
++
++/**
++ * qcom_prep_bam_dma_desc_cmd() - Prepares the command descriptor for BAM DMA
++ * @nandc: qpic nand controller
++ * @read: read or write type
++ * @reg_off: offset within the controller's data buffer
++ * @vaddr: virtual address of the buffer we want to write to
++ * @size: DMA transaction size in bytes
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares the command descriptor for BAM DMA
++ * which will be used for NAND register reads and writes.
++ */
++int qcom_prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
++			       int reg_off, const void *vaddr,
++			       int size, unsigned int flags)
++{
++	int bam_ce_size;
++	int i, ret;
++	struct bam_cmd_element *bam_ce_buffer;
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++
++	bam_ce_buffer = &bam_txn->bam_ce[bam_txn->bam_ce_pos];
++
++	/* fill the command desc */
++	for (i = 0; i < size; i++) {
++		if (read)
++			bam_prep_ce(&bam_ce_buffer[i],
++				    nandc_reg_phys(nandc, reg_off + 4 * i),
++				    BAM_READ_COMMAND,
++				    reg_buf_dma_addr(nandc,
++						     (__le32 *)vaddr + i));
++		else
++			bam_prep_ce_le32(&bam_ce_buffer[i],
++					 nandc_reg_phys(nandc, reg_off + 4 * i),
++					 BAM_WRITE_COMMAND,
++					 *((__le32 *)vaddr + i));
++	}
++
++	bam_txn->bam_ce_pos += size;
++
++	/* use the separate sgl after this command */
++	if (flags & NAND_BAM_NEXT_SGL) {
++		bam_ce_buffer = &bam_txn->bam_ce[bam_txn->bam_ce_start];
++		bam_ce_size = (bam_txn->bam_ce_pos -
++				bam_txn->bam_ce_start) *
++				sizeof(struct bam_cmd_element);
++		sg_set_buf(&bam_txn->cmd_sgl[bam_txn->cmd_sgl_pos],
++			   bam_ce_buffer, bam_ce_size);
++		bam_txn->cmd_sgl_pos++;
++		bam_txn->bam_ce_start = bam_txn->bam_ce_pos;
++
++		if (flags & NAND_BAM_NWD) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
++							  DMA_PREP_FENCE | DMA_PREP_CMD);
++			if (ret)
++				return ret;
++		}
++	}
++
++	return 0;
++}
++
++/**
++ * qcom_prep_bam_dma_desc_data() - Prepares the data descriptor for BAM DMA
++ * @nandc: qpic nand controller
++ * @read: read or write type
++ * @vaddr: virtual address of the buffer we want to write to
++ * @size: DMA transaction size in bytes
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares the data descriptor for BAM DMA which
++ * will be used for NAND data reads and writes.
++ */
++int qcom_prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
++				const void *vaddr, int size, unsigned int flags)
++{
++	int ret;
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++
++	if (read) {
++		sg_set_buf(&bam_txn->data_sgl[bam_txn->rx_sgl_pos],
++			   vaddr, size);
++		bam_txn->rx_sgl_pos++;
++	} else {
++		sg_set_buf(&bam_txn->data_sgl[bam_txn->tx_sgl_pos],
++			   vaddr, size);
++		bam_txn->tx_sgl_pos++;
++
++		/*
++		 * BAM will only set EOT for DMA_PREP_INTERRUPT so if this flag
++		 * is not set, form the DMA descriptor
++		 */
++		if (!(flags & NAND_BAM_NO_EOT)) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
++							  DMA_PREP_INTERRUPT);
++			if (ret)
++				return ret;
++		}
++	}
++
++	return 0;
++}
++
++/**
++ * qcom_prep_adm_dma_desc() - Prepare descriptor for adma
++ * @nandc: qpic nand controller
++ * @read: read or write type
++ * @reg_off: offset within the controller's data buffer
++ * @vaddr: virtual address of the buffer we want to write to
++ * @size: adm dma transaction size in bytes
++ * @flow_control: flow controller
++ *
++ * This function will prepare descriptor for adma
++ */
++int qcom_prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read,
++			   int reg_off, const void *vaddr, int size,
++			   bool flow_control)
++{
++	struct qcom_adm_peripheral_config periph_conf = {};
++	struct dma_async_tx_descriptor *dma_desc;
++	struct dma_slave_config slave_conf = {0};
++	enum dma_transfer_direction dir_eng;
++	struct desc_info *desc;
++	struct scatterlist *sgl;
++	int ret;
++
++	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
++	if (!desc)
++		return -ENOMEM;
++
++	sgl = &desc->adm_sgl;
++
++	sg_init_one(sgl, vaddr, size);
++
++	if (read) {
++		dir_eng = DMA_DEV_TO_MEM;
++		desc->dir = DMA_FROM_DEVICE;
++	} else {
++		dir_eng = DMA_MEM_TO_DEV;
++		desc->dir = DMA_TO_DEVICE;
++	}
++
++	ret = dma_map_sg(nandc->dev, sgl, 1, desc->dir);
++	if (!ret) {
++		ret = -ENOMEM;
++		goto err;
++	}
++
++	slave_conf.device_fc = flow_control;
++	if (read) {
++		slave_conf.src_maxburst = 16;
++		slave_conf.src_addr = nandc->base_dma + reg_off;
++		if (nandc->data_crci) {
++			periph_conf.crci = nandc->data_crci;
++			slave_conf.peripheral_config = &periph_conf;
++			slave_conf.peripheral_size = sizeof(periph_conf);
++		}
++	} else {
++		slave_conf.dst_maxburst = 16;
++		slave_conf.dst_addr = nandc->base_dma + reg_off;
++		if (nandc->cmd_crci) {
++			periph_conf.crci = nandc->cmd_crci;
++			slave_conf.peripheral_config = &periph_conf;
++			slave_conf.peripheral_size = sizeof(periph_conf);
++		}
++	}
++
++	ret = dmaengine_slave_config(nandc->chan, &slave_conf);
++	if (ret) {
++		dev_err(nandc->dev, "failed to configure dma channel\n");
++		goto err;
++	}
++
++	dma_desc = dmaengine_prep_slave_sg(nandc->chan, sgl, 1, dir_eng, 0);
++	if (!dma_desc) {
++		dev_err(nandc->dev, "failed to prepare desc\n");
++		ret = -EINVAL;
++		goto err;
++	}
++
++	desc->dma_desc = dma_desc;
++
++	list_add_tail(&desc->node, &nandc->desc_list);
++
++	return 0;
++err:
++	kfree(desc);
++
++	return ret;
++}
++
++/**
++ * qcom_read_reg_dma() - read a given number of registers to the reg_read_buf pointer
++ * @nandc: qpic nand controller
++ * @first: offset of the first register in the contiguous block
++ * @num_regs: number of registers to read
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares a descriptor to read a given number of
++ * contiguous registers to the reg_read_buf pointer.
++ */
++int qcom_read_reg_dma(struct qcom_nand_controller *nandc, int first,
++		      int num_regs, unsigned int flags)
++{
++	bool flow_control = false;
++	void *vaddr;
++
++	vaddr = nandc->reg_read_buf + nandc->reg_read_pos;
++	nandc->reg_read_pos += num_regs;
++
++	if (first == NAND_DEV_CMD_VLD || first == NAND_DEV_CMD1)
++		first = dev_cmd_reg_addr(nandc, first);
++
++	if (nandc->props->supports_bam)
++		return qcom_prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
++					     num_regs, flags);
++
++	if (first == NAND_READ_ID || first == NAND_FLASH_STATUS)
++		flow_control = true;
++
++	return qcom_prep_adm_dma_desc(nandc, true, first, vaddr,
++				      num_regs * sizeof(u32), flow_control);
++}
++
++/**
++ * qcom_write_reg_dma() - write a given number of registers
++ * @nandc: qpic nand controller
++ * @vaddr: contnigeous memory from where register value will
++ *	   be written
++ * @first: offset of the first register in the contiguous block
++ * @num_regs: number of registers to write
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares a descriptor to write a given number of
++ * contiguous registers
++ */
++int qcom_write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
++		       int first, int num_regs, unsigned int flags)
++{
++	bool flow_control = false;
++
++	if (first == NAND_EXEC_CMD)
++		flags |= NAND_BAM_NWD;
++
++	if (first == NAND_DEV_CMD1_RESTORE || first == NAND_DEV_CMD1)
++		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD1);
++
++	if (first == NAND_DEV_CMD_VLD_RESTORE || first == NAND_DEV_CMD_VLD)
++		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD);
++
++	if (nandc->props->supports_bam)
++		return qcom_prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
++						  num_regs, flags);
++
++	if (first == NAND_FLASH_CMD)
++		flow_control = true;
++
++	return qcom_prep_adm_dma_desc(nandc, false, first, vaddr,
++				      num_regs * sizeof(u32), flow_control);
++}
++
++/**
++ * qcom_read_data_dma() - transfer data
++ * @nandc: qpic nand controller
++ * @reg_off: offset within the controller's data buffer
++ * @vaddr: virtual address of the buffer we want to write to
++ * @size: DMA transaction size in bytes
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares a DMA descriptor to transfer data from the
++ * controller's internal buffer to the buffer 'vaddr'
++ */
++int qcom_read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
++		       const u8 *vaddr, int size, unsigned int flags)
++{
++	if (nandc->props->supports_bam)
++		return qcom_prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
++
++	return qcom_prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
++}
++
++/**
++ * qcom_write_data_dma() - transfer data
++ * @nandc: qpic nand controller
++ * @reg_off: offset within the controller's data buffer
++ * @vaddr: virtual address of the buffer we want to read from
++ * @size: DMA transaction size in bytes
++ * @flags: flags to control DMA descriptor preparation
++ *
++ * This function will prepares a DMA descriptor to transfer data from
++ * 'vaddr' to the controller's internal buffer
++ */
++int qcom_write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
++			const u8 *vaddr, int size, unsigned int flags)
++{
++	if (nandc->props->supports_bam)
++		return qcom_prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
++
++	return qcom_prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
++}
++
++/**
++ * qcom_submit_descs() - submit dma descriptor
++ * @nandc: qpic nand controller
++ *
++ * This function will submit all the prepared dma descriptor
++ * cmd or data descriptor
++ */
++int qcom_submit_descs(struct qcom_nand_controller *nandc)
++{
++	struct desc_info *desc, *n;
++	dma_cookie_t cookie = 0;
++	struct bam_transaction *bam_txn = nandc->bam_txn;
++	int ret = 0;
++
++	if (nandc->props->supports_bam) {
++		if (bam_txn->rx_sgl_pos > bam_txn->rx_sgl_start) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
++			if (ret)
++				goto err_unmap_free_desc;
++		}
++
++		if (bam_txn->tx_sgl_pos > bam_txn->tx_sgl_start) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
++							  DMA_PREP_INTERRUPT);
++			if (ret)
++				goto err_unmap_free_desc;
++		}
++
++		if (bam_txn->cmd_sgl_pos > bam_txn->cmd_sgl_start) {
++			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
++							  DMA_PREP_CMD);
++			if (ret)
++				goto err_unmap_free_desc;
++		}
++	}
++
++	list_for_each_entry(desc, &nandc->desc_list, node)
++		cookie = dmaengine_submit(desc->dma_desc);
++
++	if (nandc->props->supports_bam) {
++		bam_txn->last_cmd_desc->callback = qcom_qpic_bam_dma_done;
++		bam_txn->last_cmd_desc->callback_param = bam_txn;
++
++		dma_async_issue_pending(nandc->tx_chan);
++		dma_async_issue_pending(nandc->rx_chan);
++		dma_async_issue_pending(nandc->cmd_chan);
++
++		if (!wait_for_completion_timeout(&bam_txn->txn_done,
++						 QPIC_NAND_COMPLETION_TIMEOUT))
++			ret = -ETIMEDOUT;
++	} else {
++		if (dma_sync_wait(nandc->chan, cookie) != DMA_COMPLETE)
++			ret = -ETIMEDOUT;
++	}
++
++err_unmap_free_desc:
++	/*
++	 * Unmap the dma sg_list and free the desc allocated by both
++	 * qcom_prepare_bam_async_desc() and qcom_prep_adm_dma_desc() functions.
++	 */
++	list_for_each_entry_safe(desc, n, &nandc->desc_list, node) {
++		list_del(&desc->node);
++
++		if (nandc->props->supports_bam)
++			dma_unmap_sg(nandc->dev, desc->bam_sgl,
++				     desc->sgl_cnt, desc->dir);
++		else
++			dma_unmap_sg(nandc->dev, &desc->adm_sgl, 1,
++				     desc->dir);
++
++		kfree(desc);
++	}
++
++	return ret;
++}
++
++/**
++ * qcom_clear_read_regs() - reset the read register buffer
++ * @nandc: qpic nand controller
++ *
++ * This function reset the register read buffer for next NAND operation
++ */
++void qcom_clear_read_regs(struct qcom_nand_controller *nandc)
++{
++	nandc->reg_read_pos = 0;
++	qcom_nandc_dev_to_mem(nandc, false);
++}
++
++/**
++ * qcom_nandc_unalloc() - unallocate qpic nand controller
++ * @nandc: qpic nand controller
++ *
++ * This function will unallocate memory alloacted for qpic nand controller
++ */
++void qcom_nandc_unalloc(struct qcom_nand_controller *nandc)
++{
++	if (nandc->props->supports_bam) {
++		if (!dma_mapping_error(nandc->dev, nandc->reg_read_dma))
++			dma_unmap_single(nandc->dev, nandc->reg_read_dma,
++					 MAX_REG_RD *
++					 sizeof(*nandc->reg_read_buf),
++					 DMA_FROM_DEVICE);
++
++		if (nandc->tx_chan)
++			dma_release_channel(nandc->tx_chan);
++
++		if (nandc->rx_chan)
++			dma_release_channel(nandc->rx_chan);
++
++		if (nandc->cmd_chan)
++			dma_release_channel(nandc->cmd_chan);
++	} else {
++		if (nandc->chan)
++			dma_release_channel(nandc->chan);
++	}
++}
++
++/**
++ * qcom_nandc_alloc() - Allocate qpic nand controller
++ * @nandc: qpic nand controller
++ *
++ * This function will allocate memory for qpic nand controller
++ */
++int qcom_nandc_alloc(struct qcom_nand_controller *nandc)
++{
++	int ret;
++
++	ret = dma_set_coherent_mask(nandc->dev, DMA_BIT_MASK(32));
++	if (ret) {
++		dev_err(nandc->dev, "failed to set DMA mask\n");
++		return ret;
++	}
++
++	/*
++	 * we use the internal buffer for reading ONFI params, reading small
++	 * data like ID and status, and preforming read-copy-write operations
++	 * when writing to a codeword partially. 532 is the maximum possible
++	 * size of a codeword for our nand controller
++	 */
++	nandc->buf_size = 532;
++
++	nandc->data_buffer = devm_kzalloc(nandc->dev, nandc->buf_size, GFP_KERNEL);
++	if (!nandc->data_buffer)
++		return -ENOMEM;
++
++	nandc->regs = devm_kzalloc(nandc->dev, sizeof(*nandc->regs), GFP_KERNEL);
++	if (!nandc->regs)
++		return -ENOMEM;
++
++	nandc->reg_read_buf = devm_kcalloc(nandc->dev, MAX_REG_RD,
++					   sizeof(*nandc->reg_read_buf),
++					   GFP_KERNEL);
++	if (!nandc->reg_read_buf)
++		return -ENOMEM;
++
++	if (nandc->props->supports_bam) {
++		nandc->reg_read_dma =
++			dma_map_single(nandc->dev, nandc->reg_read_buf,
++				       MAX_REG_RD *
++				       sizeof(*nandc->reg_read_buf),
++				       DMA_FROM_DEVICE);
++		if (dma_mapping_error(nandc->dev, nandc->reg_read_dma)) {
++			dev_err(nandc->dev, "failed to DMA MAP reg buffer\n");
++			return -EIO;
++		}
++
++		nandc->tx_chan = dma_request_chan(nandc->dev, "tx");
++		if (IS_ERR(nandc->tx_chan)) {
++			ret = PTR_ERR(nandc->tx_chan);
++			nandc->tx_chan = NULL;
++			dev_err_probe(nandc->dev, ret,
++				      "tx DMA channel request failed\n");
++			goto unalloc;
++		}
++
++		nandc->rx_chan = dma_request_chan(nandc->dev, "rx");
++		if (IS_ERR(nandc->rx_chan)) {
++			ret = PTR_ERR(nandc->rx_chan);
++			nandc->rx_chan = NULL;
++			dev_err_probe(nandc->dev, ret,
++				      "rx DMA channel request failed\n");
++			goto unalloc;
++		}
++
++		nandc->cmd_chan = dma_request_chan(nandc->dev, "cmd");
++		if (IS_ERR(nandc->cmd_chan)) {
++			ret = PTR_ERR(nandc->cmd_chan);
++			nandc->cmd_chan = NULL;
++			dev_err_probe(nandc->dev, ret,
++				      "cmd DMA channel request failed\n");
++			goto unalloc;
++		}
++
++		/*
++		 * Initially allocate BAM transaction to read ONFI param page.
++		 * After detecting all the devices, this BAM transaction will
++		 * be freed and the next BAM transaction will be allocated with
++		 * maximum codeword size
++		 */
++		nandc->max_cwperpage = 1;
++		nandc->bam_txn = qcom_alloc_bam_transaction(nandc);
++		if (!nandc->bam_txn) {
++			dev_err(nandc->dev,
++				"failed to allocate bam transaction\n");
++			ret = -ENOMEM;
++			goto unalloc;
++		}
++	} else {
++		nandc->chan = dma_request_chan(nandc->dev, "rxtx");
++		if (IS_ERR(nandc->chan)) {
++			ret = PTR_ERR(nandc->chan);
++			nandc->chan = NULL;
++			dev_err_probe(nandc->dev, ret,
++				      "rxtx DMA channel request failed\n");
++			return ret;
++		}
++	}
++
++	INIT_LIST_HEAD(&nandc->desc_list);
++	INIT_LIST_HEAD(&nandc->host_list);
++
++	return 0;
++unalloc:
++	qcom_nandc_unalloc(nandc);
++	return ret;
++}
+--- a/drivers/mtd/nand/raw/Kconfig
++++ b/drivers/mtd/nand/raw/Kconfig
+@@ -330,7 +330,7 @@ config MTD_NAND_HISI504
+ 	  Enables support for NAND controller on Hisilicon SoC Hip04.
+ 
+ config MTD_NAND_QCOM
+-	tristate "QCOM NAND controller"
++	bool "QCOM NAND controller"
+ 	depends on ARCH_QCOM || COMPILE_TEST
+ 	depends on HAS_IOMEM
+ 	help
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -15,417 +15,7 @@
+ #include <linux/of.h>
+ #include <linux/platform_device.h>
+ #include <linux/slab.h>
+-
+-/* NANDc reg offsets */
+-#define	NAND_FLASH_CMD			0x00
+-#define	NAND_ADDR0			0x04
+-#define	NAND_ADDR1			0x08
+-#define	NAND_FLASH_CHIP_SELECT		0x0c
+-#define	NAND_EXEC_CMD			0x10
+-#define	NAND_FLASH_STATUS		0x14
+-#define	NAND_BUFFER_STATUS		0x18
+-#define	NAND_DEV0_CFG0			0x20
+-#define	NAND_DEV0_CFG1			0x24
+-#define	NAND_DEV0_ECC_CFG		0x28
+-#define	NAND_AUTO_STATUS_EN		0x2c
+-#define	NAND_DEV1_CFG0			0x30
+-#define	NAND_DEV1_CFG1			0x34
+-#define	NAND_READ_ID			0x40
+-#define	NAND_READ_STATUS		0x44
+-#define	NAND_DEV_CMD0			0xa0
+-#define	NAND_DEV_CMD1			0xa4
+-#define	NAND_DEV_CMD2			0xa8
+-#define	NAND_DEV_CMD_VLD		0xac
+-#define	SFLASHC_BURST_CFG		0xe0
+-#define	NAND_ERASED_CW_DETECT_CFG	0xe8
+-#define	NAND_ERASED_CW_DETECT_STATUS	0xec
+-#define	NAND_EBI2_ECC_BUF_CFG		0xf0
+-#define	FLASH_BUF_ACC			0x100
+-
+-#define	NAND_CTRL			0xf00
+-#define	NAND_VERSION			0xf08
+-#define	NAND_READ_LOCATION_0		0xf20
+-#define	NAND_READ_LOCATION_1		0xf24
+-#define	NAND_READ_LOCATION_2		0xf28
+-#define	NAND_READ_LOCATION_3		0xf2c
+-#define	NAND_READ_LOCATION_LAST_CW_0	0xf40
+-#define	NAND_READ_LOCATION_LAST_CW_1	0xf44
+-#define	NAND_READ_LOCATION_LAST_CW_2	0xf48
+-#define	NAND_READ_LOCATION_LAST_CW_3	0xf4c
+-
+-/* dummy register offsets, used by qcom_write_reg_dma */
+-#define	NAND_DEV_CMD1_RESTORE		0xdead
+-#define	NAND_DEV_CMD_VLD_RESTORE	0xbeef
+-
+-/* NAND_FLASH_CMD bits */
+-#define	PAGE_ACC			BIT(4)
+-#define	LAST_PAGE			BIT(5)
+-
+-/* NAND_FLASH_CHIP_SELECT bits */
+-#define	NAND_DEV_SEL			0
+-#define	DM_EN				BIT(2)
+-
+-/* NAND_FLASH_STATUS bits */
+-#define	FS_OP_ERR			BIT(4)
+-#define	FS_READY_BSY_N			BIT(5)
+-#define	FS_MPU_ERR			BIT(8)
+-#define	FS_DEVICE_STS_ERR		BIT(16)
+-#define	FS_DEVICE_WP			BIT(23)
+-
+-/* NAND_BUFFER_STATUS bits */
+-#define	BS_UNCORRECTABLE_BIT		BIT(8)
+-#define	BS_CORRECTABLE_ERR_MSK		0x1f
+-
+-/* NAND_DEVn_CFG0 bits */
+-#define	DISABLE_STATUS_AFTER_WRITE	4
+-#define	CW_PER_PAGE			6
+-#define	UD_SIZE_BYTES			9
+-#define	UD_SIZE_BYTES_MASK		GENMASK(18, 9)
+-#define	ECC_PARITY_SIZE_BYTES_RS	19
+-#define	SPARE_SIZE_BYTES		23
+-#define	SPARE_SIZE_BYTES_MASK		GENMASK(26, 23)
+-#define	NUM_ADDR_CYCLES			27
+-#define	STATUS_BFR_READ			30
+-#define	SET_RD_MODE_AFTER_STATUS	31
+-
+-/* NAND_DEVn_CFG0 bits */
+-#define	DEV0_CFG1_ECC_DISABLE		0
+-#define	WIDE_FLASH			1
+-#define	NAND_RECOVERY_CYCLES		2
+-#define	CS_ACTIVE_BSY			5
+-#define	BAD_BLOCK_BYTE_NUM		6
+-#define	BAD_BLOCK_IN_SPARE_AREA		16
+-#define	WR_RD_BSY_GAP			17
+-#define	ENABLE_BCH_ECC			27
+-
+-/* NAND_DEV0_ECC_CFG bits */
+-#define	ECC_CFG_ECC_DISABLE		0
+-#define	ECC_SW_RESET			1
+-#define	ECC_MODE			4
+-#define	ECC_PARITY_SIZE_BYTES_BCH	8
+-#define	ECC_NUM_DATA_BYTES		16
+-#define	ECC_NUM_DATA_BYTES_MASK		GENMASK(25, 16)
+-#define	ECC_FORCE_CLK_OPEN		30
+-
+-/* NAND_DEV_CMD1 bits */
+-#define	READ_ADDR			0
+-
+-/* NAND_DEV_CMD_VLD bits */
+-#define	READ_START_VLD			BIT(0)
+-#define	READ_STOP_VLD			BIT(1)
+-#define	WRITE_START_VLD			BIT(2)
+-#define	ERASE_START_VLD			BIT(3)
+-#define	SEQ_READ_START_VLD		BIT(4)
+-
+-/* NAND_EBI2_ECC_BUF_CFG bits */
+-#define	NUM_STEPS			0
+-
+-/* NAND_ERASED_CW_DETECT_CFG bits */
+-#define	ERASED_CW_ECC_MASK		1
+-#define	AUTO_DETECT_RES			0
+-#define	MASK_ECC			BIT(ERASED_CW_ECC_MASK)
+-#define	RESET_ERASED_DET		BIT(AUTO_DETECT_RES)
+-#define	ACTIVE_ERASED_DET		(0 << AUTO_DETECT_RES)
+-#define	CLR_ERASED_PAGE_DET		(RESET_ERASED_DET | MASK_ECC)
+-#define	SET_ERASED_PAGE_DET		(ACTIVE_ERASED_DET | MASK_ECC)
+-
+-/* NAND_ERASED_CW_DETECT_STATUS bits */
+-#define	PAGE_ALL_ERASED			BIT(7)
+-#define	CODEWORD_ALL_ERASED		BIT(6)
+-#define	PAGE_ERASED			BIT(5)
+-#define	CODEWORD_ERASED			BIT(4)
+-#define	ERASED_PAGE			(PAGE_ALL_ERASED | PAGE_ERASED)
+-#define	ERASED_CW			(CODEWORD_ALL_ERASED | CODEWORD_ERASED)
+-
+-/* NAND_READ_LOCATION_n bits */
+-#define READ_LOCATION_OFFSET		0
+-#define READ_LOCATION_SIZE		16
+-#define READ_LOCATION_LAST		31
+-
+-/* Version Mask */
+-#define	NAND_VERSION_MAJOR_MASK		0xf0000000
+-#define	NAND_VERSION_MAJOR_SHIFT	28
+-#define	NAND_VERSION_MINOR_MASK		0x0fff0000
+-#define	NAND_VERSION_MINOR_SHIFT	16
+-
+-/* NAND OP_CMDs */
+-#define	OP_PAGE_READ			0x2
+-#define	OP_PAGE_READ_WITH_ECC		0x3
+-#define	OP_PAGE_READ_WITH_ECC_SPARE	0x4
+-#define	OP_PAGE_READ_ONFI_READ		0x5
+-#define	OP_PROGRAM_PAGE			0x6
+-#define	OP_PAGE_PROGRAM_WITH_ECC	0x7
+-#define	OP_PROGRAM_PAGE_SPARE		0x9
+-#define	OP_BLOCK_ERASE			0xa
+-#define	OP_CHECK_STATUS			0xc
+-#define	OP_FETCH_ID			0xb
+-#define	OP_RESET_DEVICE			0xd
+-
+-/* Default Value for NAND_DEV_CMD_VLD */
+-#define NAND_DEV_CMD_VLD_VAL		(READ_START_VLD | WRITE_START_VLD | \
+-					 ERASE_START_VLD | SEQ_READ_START_VLD)
+-
+-/* NAND_CTRL bits */
+-#define	BAM_MODE_EN			BIT(0)
+-
+-/*
+- * the NAND controller performs reads/writes with ECC in 516 byte chunks.
+- * the driver calls the chunks 'step' or 'codeword' interchangeably
+- */
+-#define	NANDC_STEP_SIZE			512
+-
+-/*
+- * the largest page size we support is 8K, this will have 16 steps/codewords
+- * of 512 bytes each
+- */
+-#define	MAX_NUM_STEPS			(SZ_8K / NANDC_STEP_SIZE)
+-
+-/* we read at most 3 registers per codeword scan */
+-#define	MAX_REG_RD			(3 * MAX_NUM_STEPS)
+-
+-/* ECC modes supported by the controller */
+-#define	ECC_NONE	BIT(0)
+-#define	ECC_RS_4BIT	BIT(1)
+-#define	ECC_BCH_4BIT	BIT(2)
+-#define	ECC_BCH_8BIT	BIT(3)
+-
+-/*
+- * Returns the actual register address for all NAND_DEV_ registers
+- * (i.e. NAND_DEV_CMD0, NAND_DEV_CMD1, NAND_DEV_CMD2 and NAND_DEV_CMD_VLD)
+- */
+-#define dev_cmd_reg_addr(nandc, reg) ((nandc)->props->dev_cmd_reg_start + (reg))
+-
+-/* Returns the NAND register physical address */
+-#define nandc_reg_phys(chip, offset) ((chip)->base_phys + (offset))
+-
+-/* Returns the dma address for reg read buffer */
+-#define reg_buf_dma_addr(chip, vaddr) \
+-	((chip)->reg_read_dma + \
+-	((u8 *)(vaddr) - (u8 *)(chip)->reg_read_buf))
+-
+-#define QPIC_PER_CW_CMD_ELEMENTS	32
+-#define QPIC_PER_CW_CMD_SGL		32
+-#define QPIC_PER_CW_DATA_SGL		8
+-
+-#define QPIC_NAND_COMPLETION_TIMEOUT	msecs_to_jiffies(2000)
+-
+-/*
+- * Flags used in DMA descriptor preparation helper functions
+- * (i.e. qcom_read_reg_dma/qcom_write_reg_dma/qcom_read_data_dma/qcom_write_data_dma)
+- */
+-/* Don't set the EOT in current tx BAM sgl */
+-#define NAND_BAM_NO_EOT			BIT(0)
+-/* Set the NWD flag in current BAM sgl */
+-#define NAND_BAM_NWD			BIT(1)
+-/* Finish writing in the current BAM sgl and start writing in another BAM sgl */
+-#define NAND_BAM_NEXT_SGL		BIT(2)
+-/*
+- * Erased codeword status is being used two times in single transfer so this
+- * flag will determine the current value of erased codeword status register
+- */
+-#define NAND_ERASED_CW_SET		BIT(4)
+-
+-#define MAX_ADDRESS_CYCLE		5
+-
+-/*
+- * This data type corresponds to the BAM transaction which will be used for all
+- * NAND transfers.
+- * @bam_ce - the array of BAM command elements
+- * @cmd_sgl - sgl for NAND BAM command pipe
+- * @data_sgl - sgl for NAND BAM consumer/producer pipe
+- * @last_data_desc - last DMA desc in data channel (tx/rx).
+- * @last_cmd_desc - last DMA desc in command channel.
+- * @txn_done - completion for NAND transfer.
+- * @bam_ce_pos - the index in bam_ce which is available for next sgl
+- * @bam_ce_start - the index in bam_ce which marks the start position ce
+- *		   for current sgl. It will be used for size calculation
+- *		   for current sgl
+- * @cmd_sgl_pos - current index in command sgl.
+- * @cmd_sgl_start - start index in command sgl.
+- * @tx_sgl_pos - current index in data sgl for tx.
+- * @tx_sgl_start - start index in data sgl for tx.
+- * @rx_sgl_pos - current index in data sgl for rx.
+- * @rx_sgl_start - start index in data sgl for rx.
+- */
+-struct bam_transaction {
+-	struct bam_cmd_element *bam_ce;
+-	struct scatterlist *cmd_sgl;
+-	struct scatterlist *data_sgl;
+-	struct dma_async_tx_descriptor *last_data_desc;
+-	struct dma_async_tx_descriptor *last_cmd_desc;
+-	struct completion txn_done;
+-	u32 bam_ce_pos;
+-	u32 bam_ce_start;
+-	u32 cmd_sgl_pos;
+-	u32 cmd_sgl_start;
+-	u32 tx_sgl_pos;
+-	u32 tx_sgl_start;
+-	u32 rx_sgl_pos;
+-	u32 rx_sgl_start;
+-};
+-
+-/*
+- * This data type corresponds to the nand dma descriptor
+- * @dma_desc - low level DMA engine descriptor
+- * @list - list for desc_info
+- *
+- * @adm_sgl - sgl which will be used for single sgl dma descriptor. Only used by
+- *	      ADM
+- * @bam_sgl - sgl which will be used for dma descriptor. Only used by BAM
+- * @sgl_cnt - number of SGL in bam_sgl. Only used by BAM
+- * @dir - DMA transfer direction
+- */
+-struct desc_info {
+-	struct dma_async_tx_descriptor *dma_desc;
+-	struct list_head node;
+-
+-	union {
+-		struct scatterlist adm_sgl;
+-		struct {
+-			struct scatterlist *bam_sgl;
+-			int sgl_cnt;
+-		};
+-	};
+-	enum dma_data_direction dir;
+-};
+-
+-/*
+- * holds the current register values that we want to write. acts as a contiguous
+- * chunk of memory which we use to write the controller registers through DMA.
+- */
+-struct nandc_regs {
+-	__le32 cmd;
+-	__le32 addr0;
+-	__le32 addr1;
+-	__le32 chip_sel;
+-	__le32 exec;
+-
+-	__le32 cfg0;
+-	__le32 cfg1;
+-	__le32 ecc_bch_cfg;
+-
+-	__le32 clrflashstatus;
+-	__le32 clrreadstatus;
+-
+-	__le32 cmd1;
+-	__le32 vld;
+-
+-	__le32 orig_cmd1;
+-	__le32 orig_vld;
+-
+-	__le32 ecc_buf_cfg;
+-	__le32 read_location0;
+-	__le32 read_location1;
+-	__le32 read_location2;
+-	__le32 read_location3;
+-	__le32 read_location_last0;
+-	__le32 read_location_last1;
+-	__le32 read_location_last2;
+-	__le32 read_location_last3;
+-
+-	__le32 erased_cw_detect_cfg_clr;
+-	__le32 erased_cw_detect_cfg_set;
+-};
+-
+-/*
+- * NAND controller data struct
+- *
+- * @dev:			parent device
+- *
+- * @base:			MMIO base
+- *
+- * @core_clk:			controller clock
+- * @aon_clk:			another controller clock
+- *
+- * @regs:			a contiguous chunk of memory for DMA register
+- *				writes. contains the register values to be
+- *				written to controller
+- *
+- * @props:			properties of current NAND controller,
+- *				initialized via DT match data
+- *
+- * @controller:			base controller structure
+- * @host_list:			list containing all the chips attached to the
+- *				controller
+- *
+- * @chan:			dma channel
+- * @cmd_crci:			ADM DMA CRCI for command flow control
+- * @data_crci:			ADM DMA CRCI for data flow control
+- *
+- * @desc_list:			DMA descriptor list (list of desc_infos)
+- *
+- * @data_buffer:		our local DMA buffer for page read/writes,
+- *				used when we can't use the buffer provided
+- *				by upper layers directly
+- * @reg_read_buf:		local buffer for reading back registers via DMA
+- *
+- * @base_phys:			physical base address of controller registers
+- * @base_dma:			dma base address of controller registers
+- * @reg_read_dma:		contains dma address for register read buffer
+- *
+- * @buf_size/count/start:	markers for chip->legacy.read_buf/write_buf
+- *				functions
+- * @max_cwperpage:		maximum QPIC codewords required. calculated
+- *				from all connected NAND devices pagesize
+- *
+- * @reg_read_pos:		marker for data read in reg_read_buf
+- *
+- * @cmd1/vld:			some fixed controller register values
+- *
+- * @exec_opwrite:		flag to select correct number of code word
+- *				while reading status
+- */
+-struct qcom_nand_controller {
+-	struct device *dev;
+-
+-	void __iomem *base;
+-
+-	struct clk *core_clk;
+-	struct clk *aon_clk;
+-
+-	struct nandc_regs *regs;
+-	struct bam_transaction *bam_txn;
+-
+-	const struct qcom_nandc_props *props;
+-
+-	struct nand_controller controller;
+-	struct list_head host_list;
+-
+-	union {
+-		/* will be used only by QPIC for BAM DMA */
+-		struct {
+-			struct dma_chan *tx_chan;
+-			struct dma_chan *rx_chan;
+-			struct dma_chan *cmd_chan;
+-		};
+-
+-		/* will be used only by EBI2 for ADM DMA */
+-		struct {
+-			struct dma_chan *chan;
+-			unsigned int cmd_crci;
+-			unsigned int data_crci;
+-		};
+-	};
+-
+-	struct list_head desc_list;
+-
+-	u8		*data_buffer;
+-	__le32		*reg_read_buf;
+-
+-	phys_addr_t base_phys;
+-	dma_addr_t base_dma;
+-	dma_addr_t reg_read_dma;
+-
+-	int		buf_size;
+-	int		buf_count;
+-	int		buf_start;
+-	unsigned int	max_cwperpage;
+-
+-	int reg_read_pos;
+-
+-	u32 cmd1, vld;
+-	bool exec_opwrite;
+-};
++#include <linux/mtd/nand-qpic-common.h>
+ 
+ /*
+  * NAND special boot partitions
+@@ -530,97 +120,6 @@ struct qcom_nand_host {
+ 	bool bch_enabled;
+ };
+ 
+-/*
+- * This data type corresponds to the NAND controller properties which varies
+- * among different NAND controllers.
+- * @ecc_modes - ecc mode for NAND
+- * @dev_cmd_reg_start - NAND_DEV_CMD_* registers starting offset
+- * @supports_bam - whether NAND controller is using BAM
+- * @nandc_part_of_qpic - whether NAND controller is part of qpic IP
+- * @qpic_version2 - flag to indicate QPIC IP version 2
+- * @use_codeword_fixup - whether NAND has different layout for boot partitions
+- */
+-struct qcom_nandc_props {
+-	u32 ecc_modes;
+-	u32 dev_cmd_reg_start;
+-	bool supports_bam;
+-	bool nandc_part_of_qpic;
+-	bool qpic_version2;
+-	bool use_codeword_fixup;
+-};
+-
+-/* Frees the BAM transaction memory */
+-static void qcom_free_bam_transaction(struct qcom_nand_controller *nandc)
+-{
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-
+-	devm_kfree(nandc->dev, bam_txn);
+-}
+-
+-/* Allocates and Initializes the BAM transaction */
+-static struct bam_transaction *
+-qcom_alloc_bam_transaction(struct qcom_nand_controller *nandc)
+-{
+-	struct bam_transaction *bam_txn;
+-	size_t bam_txn_size;
+-	unsigned int num_cw = nandc->max_cwperpage;
+-	void *bam_txn_buf;
+-
+-	bam_txn_size =
+-		sizeof(*bam_txn) + num_cw *
+-		((sizeof(*bam_txn->bam_ce) * QPIC_PER_CW_CMD_ELEMENTS) +
+-		(sizeof(*bam_txn->cmd_sgl) * QPIC_PER_CW_CMD_SGL) +
+-		(sizeof(*bam_txn->data_sgl) * QPIC_PER_CW_DATA_SGL));
+-
+-	bam_txn_buf = devm_kzalloc(nandc->dev, bam_txn_size, GFP_KERNEL);
+-	if (!bam_txn_buf)
+-		return NULL;
+-
+-	bam_txn = bam_txn_buf;
+-	bam_txn_buf += sizeof(*bam_txn);
+-
+-	bam_txn->bam_ce = bam_txn_buf;
+-	bam_txn_buf +=
+-		sizeof(*bam_txn->bam_ce) * QPIC_PER_CW_CMD_ELEMENTS * num_cw;
+-
+-	bam_txn->cmd_sgl = bam_txn_buf;
+-	bam_txn_buf +=
+-		sizeof(*bam_txn->cmd_sgl) * QPIC_PER_CW_CMD_SGL * num_cw;
+-
+-	bam_txn->data_sgl = bam_txn_buf;
+-
+-	init_completion(&bam_txn->txn_done);
+-
+-	return bam_txn;
+-}
+-
+-/* Clears the BAM transaction indexes */
+-static void qcom_clear_bam_transaction(struct qcom_nand_controller *nandc)
+-{
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-
+-	if (!nandc->props->supports_bam)
+-		return;
+-
+-	memset(&bam_txn->bam_ce_pos, 0, sizeof(u32) * 8);
+-	bam_txn->last_data_desc = NULL;
+-
+-	sg_init_table(bam_txn->cmd_sgl, nandc->max_cwperpage *
+-		      QPIC_PER_CW_CMD_SGL);
+-	sg_init_table(bam_txn->data_sgl, nandc->max_cwperpage *
+-		      QPIC_PER_CW_DATA_SGL);
+-
+-	reinit_completion(&bam_txn->txn_done);
+-}
+-
+-/* Callback for DMA descriptor completion */
+-static void qcom_qpic_bam_dma_done(void *data)
+-{
+-	struct bam_transaction *bam_txn = data;
+-
+-	complete(&bam_txn->txn_done);
+-}
+-
+ static inline struct qcom_nand_host *to_qcom_nand_host(struct nand_chip *chip)
+ {
+ 	return container_of(chip, struct qcom_nand_host, chip);
+@@ -629,8 +128,8 @@ static inline struct qcom_nand_host *to_
+ static inline struct qcom_nand_controller *
+ get_qcom_nand_controller(struct nand_chip *chip)
+ {
+-	return container_of(chip->controller, struct qcom_nand_controller,
+-			    controller);
++	return (struct qcom_nand_controller *)
++		((u8 *)chip->controller - sizeof(struct qcom_nand_controller));
+ }
+ 
+ static inline u32 nandc_read(struct qcom_nand_controller *nandc, int offset)
+@@ -644,23 +143,6 @@ static inline void nandc_write(struct qc
+ 	iowrite32(val, nandc->base + offset);
+ }
+ 
+-static inline void qcom_nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu)
+-{
+-	if (!nandc->props->supports_bam)
+-		return;
+-
+-	if (is_cpu)
+-		dma_sync_single_for_cpu(nandc->dev, nandc->reg_read_dma,
+-					MAX_REG_RD *
+-					sizeof(*nandc->reg_read_buf),
+-					DMA_FROM_DEVICE);
+-	else
+-		dma_sync_single_for_device(nandc->dev, nandc->reg_read_dma,
+-					   MAX_REG_RD *
+-					   sizeof(*nandc->reg_read_buf),
+-					   DMA_FROM_DEVICE);
+-}
+-
+ /* Helper to check the code word, whether it is last cw or not */
+ static bool qcom_nandc_is_last_cw(struct nand_ecc_ctrl *ecc, int cw)
+ {
+@@ -820,356 +302,6 @@ static void update_rw_regs(struct qcom_n
+ }
+ 
+ /*
+- * Maps the scatter gather list for DMA transfer and forms the DMA descriptor
+- * for BAM. This descriptor will be added in the NAND DMA descriptor queue
+- * which will be submitted to DMA engine.
+- */
+-static int qcom_prepare_bam_async_desc(struct qcom_nand_controller *nandc,
+-				       struct dma_chan *chan,
+-				       unsigned long flags)
+-{
+-	struct desc_info *desc;
+-	struct scatterlist *sgl;
+-	unsigned int sgl_cnt;
+-	int ret;
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-	enum dma_transfer_direction dir_eng;
+-	struct dma_async_tx_descriptor *dma_desc;
+-
+-	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+-	if (!desc)
+-		return -ENOMEM;
+-
+-	if (chan == nandc->cmd_chan) {
+-		sgl = &bam_txn->cmd_sgl[bam_txn->cmd_sgl_start];
+-		sgl_cnt = bam_txn->cmd_sgl_pos - bam_txn->cmd_sgl_start;
+-		bam_txn->cmd_sgl_start = bam_txn->cmd_sgl_pos;
+-		dir_eng = DMA_MEM_TO_DEV;
+-		desc->dir = DMA_TO_DEVICE;
+-	} else if (chan == nandc->tx_chan) {
+-		sgl = &bam_txn->data_sgl[bam_txn->tx_sgl_start];
+-		sgl_cnt = bam_txn->tx_sgl_pos - bam_txn->tx_sgl_start;
+-		bam_txn->tx_sgl_start = bam_txn->tx_sgl_pos;
+-		dir_eng = DMA_MEM_TO_DEV;
+-		desc->dir = DMA_TO_DEVICE;
+-	} else {
+-		sgl = &bam_txn->data_sgl[bam_txn->rx_sgl_start];
+-		sgl_cnt = bam_txn->rx_sgl_pos - bam_txn->rx_sgl_start;
+-		bam_txn->rx_sgl_start = bam_txn->rx_sgl_pos;
+-		dir_eng = DMA_DEV_TO_MEM;
+-		desc->dir = DMA_FROM_DEVICE;
+-	}
+-
+-	sg_mark_end(sgl + sgl_cnt - 1);
+-	ret = dma_map_sg(nandc->dev, sgl, sgl_cnt, desc->dir);
+-	if (ret == 0) {
+-		dev_err(nandc->dev, "failure in mapping desc\n");
+-		kfree(desc);
+-		return -ENOMEM;
+-	}
+-
+-	desc->sgl_cnt = sgl_cnt;
+-	desc->bam_sgl = sgl;
+-
+-	dma_desc = dmaengine_prep_slave_sg(chan, sgl, sgl_cnt, dir_eng,
+-					   flags);
+-
+-	if (!dma_desc) {
+-		dev_err(nandc->dev, "failure in prep desc\n");
+-		dma_unmap_sg(nandc->dev, sgl, sgl_cnt, desc->dir);
+-		kfree(desc);
+-		return -EINVAL;
+-	}
+-
+-	desc->dma_desc = dma_desc;
+-
+-	/* update last data/command descriptor */
+-	if (chan == nandc->cmd_chan)
+-		bam_txn->last_cmd_desc = dma_desc;
+-	else
+-		bam_txn->last_data_desc = dma_desc;
+-
+-	list_add_tail(&desc->node, &nandc->desc_list);
+-
+-	return 0;
+-}
+-
+-/*
+- * Prepares the command descriptor for BAM DMA which will be used for NAND
+- * register reads and writes. The command descriptor requires the command
+- * to be formed in command element type so this function uses the command
+- * element from bam transaction ce array and fills the same with required
+- * data. A single SGL can contain multiple command elements so
+- * NAND_BAM_NEXT_SGL will be used for starting the separate SGL
+- * after the current command element.
+- */
+-static int qcom_prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
+-				      int reg_off, const void *vaddr,
+-				      int size, unsigned int flags)
+-{
+-	int bam_ce_size;
+-	int i, ret;
+-	struct bam_cmd_element *bam_ce_buffer;
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-
+-	bam_ce_buffer = &bam_txn->bam_ce[bam_txn->bam_ce_pos];
+-
+-	/* fill the command desc */
+-	for (i = 0; i < size; i++) {
+-		if (read)
+-			bam_prep_ce(&bam_ce_buffer[i],
+-				    nandc_reg_phys(nandc, reg_off + 4 * i),
+-				    BAM_READ_COMMAND,
+-				    reg_buf_dma_addr(nandc,
+-						     (__le32 *)vaddr + i));
+-		else
+-			bam_prep_ce_le32(&bam_ce_buffer[i],
+-					 nandc_reg_phys(nandc, reg_off + 4 * i),
+-					 BAM_WRITE_COMMAND,
+-					 *((__le32 *)vaddr + i));
+-	}
+-
+-	bam_txn->bam_ce_pos += size;
+-
+-	/* use the separate sgl after this command */
+-	if (flags & NAND_BAM_NEXT_SGL) {
+-		bam_ce_buffer = &bam_txn->bam_ce[bam_txn->bam_ce_start];
+-		bam_ce_size = (bam_txn->bam_ce_pos -
+-				bam_txn->bam_ce_start) *
+-				sizeof(struct bam_cmd_element);
+-		sg_set_buf(&bam_txn->cmd_sgl[bam_txn->cmd_sgl_pos],
+-			   bam_ce_buffer, bam_ce_size);
+-		bam_txn->cmd_sgl_pos++;
+-		bam_txn->bam_ce_start = bam_txn->bam_ce_pos;
+-
+-		if (flags & NAND_BAM_NWD) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
+-							  DMA_PREP_FENCE |
+-							  DMA_PREP_CMD);
+-			if (ret)
+-				return ret;
+-		}
+-	}
+-
+-	return 0;
+-}
+-
+-/*
+- * Prepares the data descriptor for BAM DMA which will be used for NAND
+- * data reads and writes.
+- */
+-static int qcom_prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
+-				       const void *vaddr, int size, unsigned int flags)
+-{
+-	int ret;
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-
+-	if (read) {
+-		sg_set_buf(&bam_txn->data_sgl[bam_txn->rx_sgl_pos],
+-			   vaddr, size);
+-		bam_txn->rx_sgl_pos++;
+-	} else {
+-		sg_set_buf(&bam_txn->data_sgl[bam_txn->tx_sgl_pos],
+-			   vaddr, size);
+-		bam_txn->tx_sgl_pos++;
+-
+-		/*
+-		 * BAM will only set EOT for DMA_PREP_INTERRUPT so if this flag
+-		 * is not set, form the DMA descriptor
+-		 */
+-		if (!(flags & NAND_BAM_NO_EOT)) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
+-							  DMA_PREP_INTERRUPT);
+-			if (ret)
+-				return ret;
+-		}
+-	}
+-
+-	return 0;
+-}
+-
+-static int qcom_prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read,
+-				  int reg_off, const void *vaddr, int size,
+-				  bool flow_control)
+-{
+-	struct desc_info *desc;
+-	struct dma_async_tx_descriptor *dma_desc;
+-	struct scatterlist *sgl;
+-	struct dma_slave_config slave_conf;
+-	struct qcom_adm_peripheral_config periph_conf = {};
+-	enum dma_transfer_direction dir_eng;
+-	int ret;
+-
+-	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+-	if (!desc)
+-		return -ENOMEM;
+-
+-	sgl = &desc->adm_sgl;
+-
+-	sg_init_one(sgl, vaddr, size);
+-
+-	if (read) {
+-		dir_eng = DMA_DEV_TO_MEM;
+-		desc->dir = DMA_FROM_DEVICE;
+-	} else {
+-		dir_eng = DMA_MEM_TO_DEV;
+-		desc->dir = DMA_TO_DEVICE;
+-	}
+-
+-	ret = dma_map_sg(nandc->dev, sgl, 1, desc->dir);
+-	if (ret == 0) {
+-		ret = -ENOMEM;
+-		goto err;
+-	}
+-
+-	memset(&slave_conf, 0x00, sizeof(slave_conf));
+-
+-	slave_conf.device_fc = flow_control;
+-	if (read) {
+-		slave_conf.src_maxburst = 16;
+-		slave_conf.src_addr = nandc->base_dma + reg_off;
+-		if (nandc->data_crci) {
+-			periph_conf.crci = nandc->data_crci;
+-			slave_conf.peripheral_config = &periph_conf;
+-			slave_conf.peripheral_size = sizeof(periph_conf);
+-		}
+-	} else {
+-		slave_conf.dst_maxburst = 16;
+-		slave_conf.dst_addr = nandc->base_dma + reg_off;
+-		if (nandc->cmd_crci) {
+-			periph_conf.crci = nandc->cmd_crci;
+-			slave_conf.peripheral_config = &periph_conf;
+-			slave_conf.peripheral_size = sizeof(periph_conf);
+-		}
+-	}
+-
+-	ret = dmaengine_slave_config(nandc->chan, &slave_conf);
+-	if (ret) {
+-		dev_err(nandc->dev, "failed to configure dma channel\n");
+-		goto err;
+-	}
+-
+-	dma_desc = dmaengine_prep_slave_sg(nandc->chan, sgl, 1, dir_eng, 0);
+-	if (!dma_desc) {
+-		dev_err(nandc->dev, "failed to prepare desc\n");
+-		ret = -EINVAL;
+-		goto err;
+-	}
+-
+-	desc->dma_desc = dma_desc;
+-
+-	list_add_tail(&desc->node, &nandc->desc_list);
+-
+-	return 0;
+-err:
+-	kfree(desc);
+-
+-	return ret;
+-}
+-
+-/*
+- * qcom_read_reg_dma:	prepares a descriptor to read a given number of
+- *			contiguous registers to the reg_read_buf pointer
+- *
+- * @first:		offset of the first register in the contiguous block
+- * @num_regs:		number of registers to read
+- * @flags:		flags to control DMA descriptor preparation
+- */
+-static int qcom_read_reg_dma(struct qcom_nand_controller *nandc, int first,
+-			     int num_regs, unsigned int flags)
+-{
+-	bool flow_control = false;
+-	void *vaddr;
+-
+-	vaddr = nandc->reg_read_buf + nandc->reg_read_pos;
+-	nandc->reg_read_pos += num_regs;
+-
+-	if (first == NAND_DEV_CMD_VLD || first == NAND_DEV_CMD1)
+-		first = dev_cmd_reg_addr(nandc, first);
+-
+-	if (nandc->props->supports_bam)
+-		return qcom_prep_bam_dma_desc_cmd(nandc, true, first, vaddr,
+-					     num_regs, flags);
+-
+-	if (first == NAND_READ_ID || first == NAND_FLASH_STATUS)
+-		flow_control = true;
+-
+-	return qcom_prep_adm_dma_desc(nandc, true, first, vaddr,
+-				 num_regs * sizeof(u32), flow_control);
+-}
+-
+-/*
+- * qcom_write_reg_dma:	prepares a descriptor to write a given number of
+- *			contiguous registers
+- *
+- * @vaddr:		contnigeous memory from where register value will
+- *			be written
+- * @first:		offset of the first register in the contiguous block
+- * @num_regs:		number of registers to write
+- * @flags:		flags to control DMA descriptor preparation
+- */
+-static int qcom_write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr,
+-			      int first, int num_regs, unsigned int flags)
+-{
+-	bool flow_control = false;
+-
+-	if (first == NAND_EXEC_CMD)
+-		flags |= NAND_BAM_NWD;
+-
+-	if (first == NAND_DEV_CMD1_RESTORE || first == NAND_DEV_CMD1)
+-		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD1);
+-
+-	if (first == NAND_DEV_CMD_VLD_RESTORE || first == NAND_DEV_CMD_VLD)
+-		first = dev_cmd_reg_addr(nandc, NAND_DEV_CMD_VLD);
+-
+-	if (nandc->props->supports_bam)
+-		return qcom_prep_bam_dma_desc_cmd(nandc, false, first, vaddr,
+-					     num_regs, flags);
+-
+-	if (first == NAND_FLASH_CMD)
+-		flow_control = true;
+-
+-	return qcom_prep_adm_dma_desc(nandc, false, first, vaddr,
+-				 num_regs * sizeof(u32), flow_control);
+-}
+-
+-/*
+- * qcom_read_data_dma:	prepares a DMA descriptor to transfer data from the
+- *			controller's internal buffer to the buffer 'vaddr'
+- *
+- * @reg_off:		offset within the controller's data buffer
+- * @vaddr:		virtual address of the buffer we want to write to
+- * @size:		DMA transaction size in bytes
+- * @flags:		flags to control DMA descriptor preparation
+- */
+-static int qcom_read_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+-			      const u8 *vaddr, int size, unsigned int flags)
+-{
+-	if (nandc->props->supports_bam)
+-		return qcom_prep_bam_dma_desc_data(nandc, true, vaddr, size, flags);
+-
+-	return qcom_prep_adm_dma_desc(nandc, true, reg_off, vaddr, size, false);
+-}
+-
+-/*
+- * qcom_write_data_dma:	prepares a DMA descriptor to transfer data from
+- *			'vaddr' to the controller's internal buffer
+- *
+- * @reg_off:		offset within the controller's data buffer
+- * @vaddr:		virtual address of the buffer we want to read from
+- * @size:		DMA transaction size in bytes
+- * @flags:		flags to control DMA descriptor preparation
+- */
+-static int qcom_write_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+-			       const u8 *vaddr, int size, unsigned int flags)
+-{
+-	if (nandc->props->supports_bam)
+-		return qcom_prep_bam_dma_desc_data(nandc, false, vaddr, size, flags);
+-
+-	return qcom_prep_adm_dma_desc(nandc, false, reg_off, vaddr, size, false);
+-}
+-
+-/*
+  * Helper to prepare DMA descriptors for configuring registers
+  * before reading a NAND page.
+  */
+@@ -1262,83 +394,6 @@ static void config_nand_cw_write(struct
+ 			   NAND_BAM_NEXT_SGL);
+ }
+ 
+-/* helpers to submit/free our list of dma descriptors */
+-static int qcom_submit_descs(struct qcom_nand_controller *nandc)
+-{
+-	struct desc_info *desc, *n;
+-	dma_cookie_t cookie = 0;
+-	struct bam_transaction *bam_txn = nandc->bam_txn;
+-	int ret = 0;
+-
+-	if (nandc->props->supports_bam) {
+-		if (bam_txn->rx_sgl_pos > bam_txn->rx_sgl_start) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->rx_chan, 0);
+-			if (ret)
+-				goto err_unmap_free_desc;
+-		}
+-
+-		if (bam_txn->tx_sgl_pos > bam_txn->tx_sgl_start) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->tx_chan,
+-							  DMA_PREP_INTERRUPT);
+-			if (ret)
+-				goto err_unmap_free_desc;
+-		}
+-
+-		if (bam_txn->cmd_sgl_pos > bam_txn->cmd_sgl_start) {
+-			ret = qcom_prepare_bam_async_desc(nandc, nandc->cmd_chan,
+-							  DMA_PREP_CMD);
+-			if (ret)
+-				goto err_unmap_free_desc;
+-		}
+-	}
+-
+-	list_for_each_entry(desc, &nandc->desc_list, node)
+-		cookie = dmaengine_submit(desc->dma_desc);
+-
+-	if (nandc->props->supports_bam) {
+-		bam_txn->last_cmd_desc->callback = qcom_qpic_bam_dma_done;
+-		bam_txn->last_cmd_desc->callback_param = bam_txn;
+-
+-		dma_async_issue_pending(nandc->tx_chan);
+-		dma_async_issue_pending(nandc->rx_chan);
+-		dma_async_issue_pending(nandc->cmd_chan);
+-
+-		if (!wait_for_completion_timeout(&bam_txn->txn_done,
+-						 QPIC_NAND_COMPLETION_TIMEOUT))
+-			ret = -ETIMEDOUT;
+-	} else {
+-		if (dma_sync_wait(nandc->chan, cookie) != DMA_COMPLETE)
+-			ret = -ETIMEDOUT;
+-	}
+-
+-err_unmap_free_desc:
+-	/*
+-	 * Unmap the dma sg_list and free the desc allocated by both
+-	 * qcom_prepare_bam_async_desc() and qcom_prep_adm_dma_desc() functions.
+-	 */
+-	list_for_each_entry_safe(desc, n, &nandc->desc_list, node) {
+-		list_del(&desc->node);
+-
+-		if (nandc->props->supports_bam)
+-			dma_unmap_sg(nandc->dev, desc->bam_sgl,
+-				     desc->sgl_cnt, desc->dir);
+-		else
+-			dma_unmap_sg(nandc->dev, &desc->adm_sgl, 1,
+-				     desc->dir);
+-
+-		kfree(desc);
+-	}
+-
+-	return ret;
+-}
+-
+-/* reset the register read buffer for next NAND operation */
+-static void qcom_clear_read_regs(struct qcom_nand_controller *nandc)
+-{
+-	nandc->reg_read_pos = 0;
+-	qcom_nandc_dev_to_mem(nandc, false);
+-}
+-
+ /*
+  * when using BCH ECC, the HW flags an error in NAND_FLASH_STATUS if it read
+  * an erased CW, and reports an erased CW in NAND_ERASED_CW_DETECT_STATUS.
+@@ -2967,141 +2022,14 @@ static const struct nand_controller_ops
+ 	.exec_op = qcom_nand_exec_op,
+ };
+ 
+-static void qcom_nandc_unalloc(struct qcom_nand_controller *nandc)
+-{
+-	if (nandc->props->supports_bam) {
+-		if (!dma_mapping_error(nandc->dev, nandc->reg_read_dma))
+-			dma_unmap_single(nandc->dev, nandc->reg_read_dma,
+-					 MAX_REG_RD *
+-					 sizeof(*nandc->reg_read_buf),
+-					 DMA_FROM_DEVICE);
+-
+-		if (nandc->tx_chan)
+-			dma_release_channel(nandc->tx_chan);
+-
+-		if (nandc->rx_chan)
+-			dma_release_channel(nandc->rx_chan);
+-
+-		if (nandc->cmd_chan)
+-			dma_release_channel(nandc->cmd_chan);
+-	} else {
+-		if (nandc->chan)
+-			dma_release_channel(nandc->chan);
+-	}
+-}
+-
+-static int qcom_nandc_alloc(struct qcom_nand_controller *nandc)
+-{
+-	int ret;
+-
+-	ret = dma_set_coherent_mask(nandc->dev, DMA_BIT_MASK(32));
+-	if (ret) {
+-		dev_err(nandc->dev, "failed to set DMA mask\n");
+-		return ret;
+-	}
+-
+-	/*
+-	 * we use the internal buffer for reading ONFI params, reading small
+-	 * data like ID and status, and preforming read-copy-write operations
+-	 * when writing to a codeword partially. 532 is the maximum possible
+-	 * size of a codeword for our nand controller
+-	 */
+-	nandc->buf_size = 532;
+-
+-	nandc->data_buffer = devm_kzalloc(nandc->dev, nandc->buf_size, GFP_KERNEL);
+-	if (!nandc->data_buffer)
+-		return -ENOMEM;
+-
+-	nandc->regs = devm_kzalloc(nandc->dev, sizeof(*nandc->regs), GFP_KERNEL);
+-	if (!nandc->regs)
+-		return -ENOMEM;
+-
+-	nandc->reg_read_buf = devm_kcalloc(nandc->dev, MAX_REG_RD,
+-					   sizeof(*nandc->reg_read_buf),
+-					   GFP_KERNEL);
+-	if (!nandc->reg_read_buf)
+-		return -ENOMEM;
+-
+-	if (nandc->props->supports_bam) {
+-		nandc->reg_read_dma =
+-			dma_map_single(nandc->dev, nandc->reg_read_buf,
+-				       MAX_REG_RD *
+-				       sizeof(*nandc->reg_read_buf),
+-				       DMA_FROM_DEVICE);
+-		if (dma_mapping_error(nandc->dev, nandc->reg_read_dma)) {
+-			dev_err(nandc->dev, "failed to DMA MAP reg buffer\n");
+-			return -EIO;
+-		}
+-
+-		nandc->tx_chan = dma_request_chan(nandc->dev, "tx");
+-		if (IS_ERR(nandc->tx_chan)) {
+-			ret = PTR_ERR(nandc->tx_chan);
+-			nandc->tx_chan = NULL;
+-			dev_err_probe(nandc->dev, ret,
+-				      "tx DMA channel request failed\n");
+-			goto unalloc;
+-		}
+-
+-		nandc->rx_chan = dma_request_chan(nandc->dev, "rx");
+-		if (IS_ERR(nandc->rx_chan)) {
+-			ret = PTR_ERR(nandc->rx_chan);
+-			nandc->rx_chan = NULL;
+-			dev_err_probe(nandc->dev, ret,
+-				      "rx DMA channel request failed\n");
+-			goto unalloc;
+-		}
+-
+-		nandc->cmd_chan = dma_request_chan(nandc->dev, "cmd");
+-		if (IS_ERR(nandc->cmd_chan)) {
+-			ret = PTR_ERR(nandc->cmd_chan);
+-			nandc->cmd_chan = NULL;
+-			dev_err_probe(nandc->dev, ret,
+-				      "cmd DMA channel request failed\n");
+-			goto unalloc;
+-		}
+-
+-		/*
+-		 * Initially allocate BAM transaction to read ONFI param page.
+-		 * After detecting all the devices, this BAM transaction will
+-		 * be freed and the next BAM transaction will be allocated with
+-		 * maximum codeword size
+-		 */
+-		nandc->max_cwperpage = 1;
+-		nandc->bam_txn = qcom_alloc_bam_transaction(nandc);
+-		if (!nandc->bam_txn) {
+-			dev_err(nandc->dev,
+-				"failed to allocate bam transaction\n");
+-			ret = -ENOMEM;
+-			goto unalloc;
+-		}
+-	} else {
+-		nandc->chan = dma_request_chan(nandc->dev, "rxtx");
+-		if (IS_ERR(nandc->chan)) {
+-			ret = PTR_ERR(nandc->chan);
+-			nandc->chan = NULL;
+-			dev_err_probe(nandc->dev, ret,
+-				      "rxtx DMA channel request failed\n");
+-			return ret;
+-		}
+-	}
+-
+-	INIT_LIST_HEAD(&nandc->desc_list);
+-	INIT_LIST_HEAD(&nandc->host_list);
+-
+-	nand_controller_init(&nandc->controller);
+-	nandc->controller.ops = &qcom_nandc_ops;
+-
+-	return 0;
+-unalloc:
+-	qcom_nandc_unalloc(nandc);
+-	return ret;
+-}
+-
+ /* one time setup of a few nand controller registers */
+ static int qcom_nandc_setup(struct qcom_nand_controller *nandc)
+ {
+ 	u32 nand_ctrl;
+ 
++	nand_controller_init(nandc->controller);
++	nandc->controller->ops = &qcom_nandc_ops;
++
+ 	/* kill onenand */
+ 	if (!nandc->props->nandc_part_of_qpic)
+ 		nandc_write(nandc, SFLASHC_BURST_CFG, 0);
+@@ -3240,7 +2168,7 @@ static int qcom_nand_host_init_and_regis
+ 	chip->legacy.block_bad		= qcom_nandc_block_bad;
+ 	chip->legacy.block_markbad	= qcom_nandc_block_markbad;
+ 
+-	chip->controller = &nandc->controller;
++	chip->controller = nandc->controller;
+ 	chip->options |= NAND_NO_SUBPAGE_WRITE | NAND_USES_DMA |
+ 			 NAND_SKIP_BBTSCAN;
+ 
+@@ -3323,17 +2251,21 @@ static int qcom_nandc_parse_dt(struct pl
+ static int qcom_nandc_probe(struct platform_device *pdev)
+ {
+ 	struct qcom_nand_controller *nandc;
++	struct nand_controller *controller;
+ 	const void *dev_data;
+ 	struct device *dev = &pdev->dev;
+ 	struct resource *res;
+ 	int ret;
+ 
+-	nandc = devm_kzalloc(&pdev->dev, sizeof(*nandc), GFP_KERNEL);
++	nandc = devm_kzalloc(&pdev->dev, sizeof(*nandc) + sizeof(*controller),
++			     GFP_KERNEL);
+ 	if (!nandc)
+ 		return -ENOMEM;
++	controller = (struct nand_controller *)&nandc[1];
+ 
+ 	platform_set_drvdata(pdev, nandc);
+ 	nandc->dev = dev;
++	nandc->controller = controller;
+ 
+ 	dev_data = of_device_get_match_data(dev);
+ 	if (!dev_data) {
+--- /dev/null
++++ b/include/linux/mtd/nand-qpic-common.h
+@@ -0,0 +1,468 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * QCOM QPIC common APIs header file
++ *
++ * Copyright (c) 2023 Qualcomm Inc.
++ * Authors:	Md sadre Alam	<quic_mdalam@quicinc.com>
++ *
++ */
++#ifndef __MTD_NAND_QPIC_COMMON_H__
++#define __MTD_NAND_QPIC_COMMON_H__
++
++/* NANDc reg offsets */
++#define	NAND_FLASH_CMD			0x00
++#define	NAND_ADDR0			0x04
++#define	NAND_ADDR1			0x08
++#define	NAND_FLASH_CHIP_SELECT		0x0c
++#define	NAND_EXEC_CMD			0x10
++#define	NAND_FLASH_STATUS		0x14
++#define	NAND_BUFFER_STATUS		0x18
++#define	NAND_DEV0_CFG0			0x20
++#define	NAND_DEV0_CFG1			0x24
++#define	NAND_DEV0_ECC_CFG		0x28
++#define	NAND_AUTO_STATUS_EN		0x2c
++#define	NAND_DEV1_CFG0			0x30
++#define	NAND_DEV1_CFG1			0x34
++#define	NAND_READ_ID			0x40
++#define	NAND_READ_STATUS		0x44
++#define	NAND_DEV_CMD0			0xa0
++#define	NAND_DEV_CMD1			0xa4
++#define	NAND_DEV_CMD2			0xa8
++#define	NAND_DEV_CMD_VLD		0xac
++#define	SFLASHC_BURST_CFG		0xe0
++#define	NAND_ERASED_CW_DETECT_CFG	0xe8
++#define	NAND_ERASED_CW_DETECT_STATUS	0xec
++#define	NAND_EBI2_ECC_BUF_CFG		0xf0
++#define	FLASH_BUF_ACC			0x100
++
++#define	NAND_CTRL			0xf00
++#define	NAND_VERSION			0xf08
++#define	NAND_READ_LOCATION_0		0xf20
++#define	NAND_READ_LOCATION_1		0xf24
++#define	NAND_READ_LOCATION_2		0xf28
++#define	NAND_READ_LOCATION_3		0xf2c
++#define	NAND_READ_LOCATION_LAST_CW_0	0xf40
++#define	NAND_READ_LOCATION_LAST_CW_1	0xf44
++#define	NAND_READ_LOCATION_LAST_CW_2	0xf48
++#define	NAND_READ_LOCATION_LAST_CW_3	0xf4c
++
++/* dummy register offsets, used by qcom_write_reg_dma */
++#define	NAND_DEV_CMD1_RESTORE		0xdead
++#define	NAND_DEV_CMD_VLD_RESTORE	0xbeef
++
++/* NAND_FLASH_CMD bits */
++#define	PAGE_ACC			BIT(4)
++#define	LAST_PAGE			BIT(5)
++
++/* NAND_FLASH_CHIP_SELECT bits */
++#define	NAND_DEV_SEL			0
++#define	DM_EN				BIT(2)
++
++/* NAND_FLASH_STATUS bits */
++#define	FS_OP_ERR			BIT(4)
++#define	FS_READY_BSY_N			BIT(5)
++#define	FS_MPU_ERR			BIT(8)
++#define	FS_DEVICE_STS_ERR		BIT(16)
++#define	FS_DEVICE_WP			BIT(23)
++
++/* NAND_BUFFER_STATUS bits */
++#define	BS_UNCORRECTABLE_BIT		BIT(8)
++#define	BS_CORRECTABLE_ERR_MSK		0x1f
++
++/* NAND_DEVn_CFG0 bits */
++#define	DISABLE_STATUS_AFTER_WRITE	4
++#define	CW_PER_PAGE			6
++#define	UD_SIZE_BYTES			9
++#define	UD_SIZE_BYTES_MASK		GENMASK(18, 9)
++#define	ECC_PARITY_SIZE_BYTES_RS	19
++#define	SPARE_SIZE_BYTES		23
++#define	SPARE_SIZE_BYTES_MASK		GENMASK(26, 23)
++#define	NUM_ADDR_CYCLES			27
++#define	STATUS_BFR_READ			30
++#define	SET_RD_MODE_AFTER_STATUS	31
++
++/* NAND_DEVn_CFG0 bits */
++#define	DEV0_CFG1_ECC_DISABLE		0
++#define	WIDE_FLASH			1
++#define	NAND_RECOVERY_CYCLES		2
++#define	CS_ACTIVE_BSY			5
++#define	BAD_BLOCK_BYTE_NUM		6
++#define	BAD_BLOCK_IN_SPARE_AREA		16
++#define	WR_RD_BSY_GAP			17
++#define	ENABLE_BCH_ECC			27
++
++/* NAND_DEV0_ECC_CFG bits */
++#define	ECC_CFG_ECC_DISABLE		0
++#define	ECC_SW_RESET			1
++#define	ECC_MODE			4
++#define	ECC_PARITY_SIZE_BYTES_BCH	8
++#define	ECC_NUM_DATA_BYTES		16
++#define	ECC_NUM_DATA_BYTES_MASK		GENMASK(25, 16)
++#define	ECC_FORCE_CLK_OPEN		30
++
++/* NAND_DEV_CMD1 bits */
++#define	READ_ADDR			0
++
++/* NAND_DEV_CMD_VLD bits */
++#define	READ_START_VLD			BIT(0)
++#define	READ_STOP_VLD			BIT(1)
++#define	WRITE_START_VLD			BIT(2)
++#define	ERASE_START_VLD			BIT(3)
++#define	SEQ_READ_START_VLD		BIT(4)
++
++/* NAND_EBI2_ECC_BUF_CFG bits */
++#define	NUM_STEPS			0
++
++/* NAND_ERASED_CW_DETECT_CFG bits */
++#define	ERASED_CW_ECC_MASK		1
++#define	AUTO_DETECT_RES			0
++#define	MASK_ECC			BIT(ERASED_CW_ECC_MASK)
++#define	RESET_ERASED_DET		BIT(AUTO_DETECT_RES)
++#define	ACTIVE_ERASED_DET		(0 << AUTO_DETECT_RES)
++#define	CLR_ERASED_PAGE_DET		(RESET_ERASED_DET | MASK_ECC)
++#define	SET_ERASED_PAGE_DET		(ACTIVE_ERASED_DET | MASK_ECC)
++
++/* NAND_ERASED_CW_DETECT_STATUS bits */
++#define	PAGE_ALL_ERASED			BIT(7)
++#define	CODEWORD_ALL_ERASED		BIT(6)
++#define	PAGE_ERASED			BIT(5)
++#define	CODEWORD_ERASED			BIT(4)
++#define	ERASED_PAGE			(PAGE_ALL_ERASED | PAGE_ERASED)
++#define	ERASED_CW			(CODEWORD_ALL_ERASED | CODEWORD_ERASED)
++
++/* NAND_READ_LOCATION_n bits */
++#define READ_LOCATION_OFFSET		0
++#define READ_LOCATION_SIZE		16
++#define READ_LOCATION_LAST		31
++
++/* Version Mask */
++#define	NAND_VERSION_MAJOR_MASK		0xf0000000
++#define	NAND_VERSION_MAJOR_SHIFT	28
++#define	NAND_VERSION_MINOR_MASK		0x0fff0000
++#define	NAND_VERSION_MINOR_SHIFT	16
++
++/* NAND OP_CMDs */
++#define	OP_PAGE_READ			0x2
++#define	OP_PAGE_READ_WITH_ECC		0x3
++#define	OP_PAGE_READ_WITH_ECC_SPARE	0x4
++#define	OP_PAGE_READ_ONFI_READ		0x5
++#define	OP_PROGRAM_PAGE			0x6
++#define	OP_PAGE_PROGRAM_WITH_ECC	0x7
++#define	OP_PROGRAM_PAGE_SPARE		0x9
++#define	OP_BLOCK_ERASE			0xa
++#define	OP_CHECK_STATUS			0xc
++#define	OP_FETCH_ID			0xb
++#define	OP_RESET_DEVICE			0xd
++
++/* Default Value for NAND_DEV_CMD_VLD */
++#define NAND_DEV_CMD_VLD_VAL		(READ_START_VLD | WRITE_START_VLD | \
++					 ERASE_START_VLD | SEQ_READ_START_VLD)
++
++/* NAND_CTRL bits */
++#define	BAM_MODE_EN			BIT(0)
++
++/*
++ * the NAND controller performs reads/writes with ECC in 516 byte chunks.
++ * the driver calls the chunks 'step' or 'codeword' interchangeably
++ */
++#define	NANDC_STEP_SIZE			512
++
++/*
++ * the largest page size we support is 8K, this will have 16 steps/codewords
++ * of 512 bytes each
++ */
++#define	MAX_NUM_STEPS			(SZ_8K / NANDC_STEP_SIZE)
++
++/* we read at most 3 registers per codeword scan */
++#define	MAX_REG_RD			(3 * MAX_NUM_STEPS)
++
++/* ECC modes supported by the controller */
++#define	ECC_NONE	BIT(0)
++#define	ECC_RS_4BIT	BIT(1)
++#define	ECC_BCH_4BIT	BIT(2)
++#define	ECC_BCH_8BIT	BIT(3)
++
++/*
++ * Returns the actual register address for all NAND_DEV_ registers
++ * (i.e. NAND_DEV_CMD0, NAND_DEV_CMD1, NAND_DEV_CMD2 and NAND_DEV_CMD_VLD)
++ */
++#define dev_cmd_reg_addr(nandc, reg) ((nandc)->props->dev_cmd_reg_start + (reg))
++
++/* Returns the NAND register physical address */
++#define nandc_reg_phys(chip, offset) ((chip)->base_phys + (offset))
++
++/* Returns the dma address for reg read buffer */
++#define reg_buf_dma_addr(chip, vaddr) \
++	((chip)->reg_read_dma + \
++	((u8 *)(vaddr) - (u8 *)(chip)->reg_read_buf))
++
++#define QPIC_PER_CW_CMD_ELEMENTS	32
++#define QPIC_PER_CW_CMD_SGL		32
++#define QPIC_PER_CW_DATA_SGL		8
++
++#define QPIC_NAND_COMPLETION_TIMEOUT	msecs_to_jiffies(2000)
++
++/*
++ * Flags used in DMA descriptor preparation helper functions
++ * (i.e. qcom_read_reg_dma/qcom_write_reg_dma/qcom_read_data_dma/qcom_write_data_dma)
++ */
++/* Don't set the EOT in current tx BAM sgl */
++#define NAND_BAM_NO_EOT			BIT(0)
++/* Set the NWD flag in current BAM sgl */
++#define NAND_BAM_NWD			BIT(1)
++/* Finish writing in the current BAM sgl and start writing in another BAM sgl */
++#define NAND_BAM_NEXT_SGL		BIT(2)
++/*
++ * Erased codeword status is being used two times in single transfer so this
++ * flag will determine the current value of erased codeword status register
++ */
++#define NAND_ERASED_CW_SET		BIT(4)
++
++#define MAX_ADDRESS_CYCLE		5
++
++/*
++ * This data type corresponds to the BAM transaction which will be used for all
++ * NAND transfers.
++ * @bam_ce - the array of BAM command elements
++ * @cmd_sgl - sgl for NAND BAM command pipe
++ * @data_sgl - sgl for NAND BAM consumer/producer pipe
++ * @last_data_desc - last DMA desc in data channel (tx/rx).
++ * @last_cmd_desc - last DMA desc in command channel.
++ * @txn_done - completion for NAND transfer.
++ * @bam_ce_pos - the index in bam_ce which is available for next sgl
++ * @bam_ce_start - the index in bam_ce which marks the start position ce
++ *		   for current sgl. It will be used for size calculation
++ *		   for current sgl
++ * @cmd_sgl_pos - current index in command sgl.
++ * @cmd_sgl_start - start index in command sgl.
++ * @tx_sgl_pos - current index in data sgl for tx.
++ * @tx_sgl_start - start index in data sgl for tx.
++ * @rx_sgl_pos - current index in data sgl for rx.
++ * @rx_sgl_start - start index in data sgl for rx.
++ */
++struct bam_transaction {
++	struct bam_cmd_element *bam_ce;
++	struct scatterlist *cmd_sgl;
++	struct scatterlist *data_sgl;
++	struct dma_async_tx_descriptor *last_data_desc;
++	struct dma_async_tx_descriptor *last_cmd_desc;
++	struct completion txn_done;
++	u32 bam_ce_pos;
++	u32 bam_ce_start;
++	u32 cmd_sgl_pos;
++	u32 cmd_sgl_start;
++	u32 tx_sgl_pos;
++	u32 tx_sgl_start;
++	u32 rx_sgl_pos;
++	u32 rx_sgl_start;
++};
++
++/*
++ * This data type corresponds to the nand dma descriptor
++ * @dma_desc - low level DMA engine descriptor
++ * @list - list for desc_info
++ *
++ * @adm_sgl - sgl which will be used for single sgl dma descriptor. Only used by
++ *	      ADM
++ * @bam_sgl - sgl which will be used for dma descriptor. Only used by BAM
++ * @sgl_cnt - number of SGL in bam_sgl. Only used by BAM
++ * @dir - DMA transfer direction
++ */
++struct desc_info {
++	struct dma_async_tx_descriptor *dma_desc;
++	struct list_head node;
++
++	union {
++		struct scatterlist adm_sgl;
++		struct {
++			struct scatterlist *bam_sgl;
++			int sgl_cnt;
++		};
++	};
++	enum dma_data_direction dir;
++};
++
++/*
++ * holds the current register values that we want to write. acts as a contiguous
++ * chunk of memory which we use to write the controller registers through DMA.
++ */
++struct nandc_regs {
++	__le32 cmd;
++	__le32 addr0;
++	__le32 addr1;
++	__le32 chip_sel;
++	__le32 exec;
++
++	__le32 cfg0;
++	__le32 cfg1;
++	__le32 ecc_bch_cfg;
++
++	__le32 clrflashstatus;
++	__le32 clrreadstatus;
++
++	__le32 cmd1;
++	__le32 vld;
++
++	__le32 orig_cmd1;
++	__le32 orig_vld;
++
++	__le32 ecc_buf_cfg;
++	__le32 read_location0;
++	__le32 read_location1;
++	__le32 read_location2;
++	__le32 read_location3;
++	__le32 read_location_last0;
++	__le32 read_location_last1;
++	__le32 read_location_last2;
++	__le32 read_location_last3;
++
++	__le32 erased_cw_detect_cfg_clr;
++	__le32 erased_cw_detect_cfg_set;
++};
++
++/*
++ * NAND controller data struct
++ *
++ * @dev:			parent device
++ *
++ * @base:			MMIO base
++ *
++ * @core_clk:			controller clock
++ * @aon_clk:			another controller clock
++ *
++ * @regs:			a contiguous chunk of memory for DMA register
++ *				writes. contains the register values to be
++ *				written to controller
++ *
++ * @props:			properties of current NAND controller,
++ *				initialized via DT match data
++ *
++ * @controller:			base controller structure
++ * @host_list:			list containing all the chips attached to the
++ *				controller
++ *
++ * @chan:			dma channel
++ * @cmd_crci:			ADM DMA CRCI for command flow control
++ * @data_crci:			ADM DMA CRCI for data flow control
++ *
++ * @desc_list:			DMA descriptor list (list of desc_infos)
++ *
++ * @data_buffer:		our local DMA buffer for page read/writes,
++ *				used when we can't use the buffer provided
++ *				by upper layers directly
++ * @reg_read_buf:		local buffer for reading back registers via DMA
++ *
++ * @base_phys:			physical base address of controller registers
++ * @base_dma:			dma base address of controller registers
++ * @reg_read_dma:		contains dma address for register read buffer
++ *
++ * @buf_size/count/start:	markers for chip->legacy.read_buf/write_buf
++ *				functions
++ * @max_cwperpage:		maximum QPIC codewords required. calculated
++ *				from all connected NAND devices pagesize
++ *
++ * @reg_read_pos:		marker for data read in reg_read_buf
++ *
++ * @cmd1/vld:			some fixed controller register values
++ *
++ * @exec_opwrite:		flag to select correct number of code word
++ *				while reading status
++ */
++struct qcom_nand_controller {
++	struct device *dev;
++
++	void __iomem *base;
++
++	struct clk *core_clk;
++	struct clk *aon_clk;
++
++	struct nandc_regs *regs;
++	struct bam_transaction *bam_txn;
++
++	const struct qcom_nandc_props *props;
++
++	struct nand_controller *controller;
++	struct list_head host_list;
++
++	union {
++		/* will be used only by QPIC for BAM DMA */
++		struct {
++			struct dma_chan *tx_chan;
++			struct dma_chan *rx_chan;
++			struct dma_chan *cmd_chan;
++		};
++
++		/* will be used only by EBI2 for ADM DMA */
++		struct {
++			struct dma_chan *chan;
++			unsigned int cmd_crci;
++			unsigned int data_crci;
++		};
++	};
++
++	struct list_head desc_list;
++
++	u8		*data_buffer;
++	__le32		*reg_read_buf;
++
++	phys_addr_t base_phys;
++	dma_addr_t base_dma;
++	dma_addr_t reg_read_dma;
++
++	int		buf_size;
++	int		buf_count;
++	int		buf_start;
++	unsigned int	max_cwperpage;
++
++	int reg_read_pos;
++
++	u32 cmd1, vld;
++	bool exec_opwrite;
++};
++
++/*
++ * This data type corresponds to the NAND controller properties which varies
++ * among different NAND controllers.
++ * @ecc_modes - ecc mode for NAND
++ * @dev_cmd_reg_start - NAND_DEV_CMD_* registers starting offset
++ * @supports_bam - whether NAND controller is using BAM
++ * @nandc_part_of_qpic - whether NAND controller is part of qpic IP
++ * @qpic_version2 - flag to indicate QPIC IP version 2
++ * @use_codeword_fixup - whether NAND has different layout for boot partitions
++ */
++struct qcom_nandc_props {
++	u32 ecc_modes;
++	u32 dev_cmd_reg_start;
++	bool supports_bam;
++	bool nandc_part_of_qpic;
++	bool qpic_version2;
++	bool use_codeword_fixup;
++};
++
++void qcom_free_bam_transaction(struct qcom_nand_controller *nandc);
++struct bam_transaction *qcom_alloc_bam_transaction(struct qcom_nand_controller *nandc);
++void qcom_clear_bam_transaction(struct qcom_nand_controller *nandc);
++void qcom_qpic_bam_dma_done(void *data);
++void qcom_nandc_dev_to_mem(struct qcom_nand_controller *nandc, bool is_cpu);
++int qcom_prepare_bam_async_desc(struct qcom_nand_controller *nandc,
++				struct dma_chan *chan, unsigned long flags);
++int qcom_prep_bam_dma_desc_cmd(struct qcom_nand_controller *nandc, bool read,
++			       int reg_off, const void *vaddr, int size, unsigned int flags);
++int qcom_prep_bam_dma_desc_data(struct qcom_nand_controller *nandc, bool read,
++				const void *vaddr, int size, unsigned int flags);
++int qcom_prep_adm_dma_desc(struct qcom_nand_controller *nandc, bool read, int reg_off,
++			   const void *vaddr, int size, bool flow_control);
++int qcom_read_reg_dma(struct qcom_nand_controller *nandc, int first, int num_regs,
++		      unsigned int flags);
++int qcom_write_reg_dma(struct qcom_nand_controller *nandc, __le32 *vaddr, int first,
++		       int num_regs, unsigned int flags);
++int qcom_read_data_dma(struct qcom_nand_controller *nandc, int reg_off, const u8 *vaddr,
++		       int size, unsigned int flags);
++int qcom_write_data_dma(struct qcom_nand_controller *nandc, int reg_off, const u8 *vaddr,
++			int size, unsigned int flags);
++int qcom_submit_descs(struct qcom_nand_controller *nandc);
++void qcom_clear_read_regs(struct qcom_nand_controller *nandc);
++void qcom_nandc_unalloc(struct qcom_nand_controller *nandc);
++int qcom_nandc_alloc(struct qcom_nand_controller *nandc);
++#endif
++
diff --git a/target/linux/qualcommax/patches-6.6/0405-mtd-rawnand-qcom-use-FIELD_PREP-and-GENMASK.patch b/target/linux/qualcommax/patches-6.6/0405-mtd-rawnand-qcom-use-FIELD_PREP-and-GENMASK.patch
new file mode 100644
index 0000000000..5f8ff3ed56
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0405-mtd-rawnand-qcom-use-FIELD_PREP-and-GENMASK.patch
@@ -0,0 +1,191 @@
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Sun, 22 Sep 2024 17:03:48 +0530
+Subject: [PATCH] mtd: rawnand: qcom: use FIELD_PREP and GENMASK
+
+Use the bitfield macro FIELD_PREP, and GENMASK to
+do the shift and mask in one go. This makes the code
+more readable.
+
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+---
+--- a/drivers/mtd/nand/raw/qcom_nandc.c
++++ b/drivers/mtd/nand/raw/qcom_nandc.c
+@@ -281,7 +281,7 @@ static void update_rw_regs(struct qcom_n
+ 				(num_cw - 1) << CW_PER_PAGE);
+ 
+ 		cfg1 = cpu_to_le32(host->cfg1_raw);
+-		ecc_bch_cfg = cpu_to_le32(1 << ECC_CFG_ECC_DISABLE);
++		ecc_bch_cfg = cpu_to_le32(ECC_CFG_ECC_DISABLE);
+ 	}
+ 
+ 	nandc->regs->cmd = cmd;
+@@ -1494,42 +1494,41 @@ static int qcom_nand_attach_chip(struct
+ 	host->cw_size = host->cw_data + ecc->bytes;
+ 	bad_block_byte = mtd->writesize - host->cw_size * (cwperpage - 1) + 1;
+ 
+-	host->cfg0 = (cwperpage - 1) << CW_PER_PAGE
+-				| host->cw_data << UD_SIZE_BYTES
+-				| 0 << DISABLE_STATUS_AFTER_WRITE
+-				| 5 << NUM_ADDR_CYCLES
+-				| host->ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_RS
+-				| 0 << STATUS_BFR_READ
+-				| 1 << SET_RD_MODE_AFTER_STATUS
+-				| host->spare_bytes << SPARE_SIZE_BYTES;
+-
+-	host->cfg1 = 7 << NAND_RECOVERY_CYCLES
+-				| 0 <<  CS_ACTIVE_BSY
+-				| bad_block_byte << BAD_BLOCK_BYTE_NUM
+-				| 0 << BAD_BLOCK_IN_SPARE_AREA
+-				| 2 << WR_RD_BSY_GAP
+-				| wide_bus << WIDE_FLASH
+-				| host->bch_enabled << ENABLE_BCH_ECC;
+-
+-	host->cfg0_raw = (cwperpage - 1) << CW_PER_PAGE
+-				| host->cw_size << UD_SIZE_BYTES
+-				| 5 << NUM_ADDR_CYCLES
+-				| 0 << SPARE_SIZE_BYTES;
+-
+-	host->cfg1_raw = 7 << NAND_RECOVERY_CYCLES
+-				| 0 << CS_ACTIVE_BSY
+-				| 17 << BAD_BLOCK_BYTE_NUM
+-				| 1 << BAD_BLOCK_IN_SPARE_AREA
+-				| 2 << WR_RD_BSY_GAP
+-				| wide_bus << WIDE_FLASH
+-				| 1 << DEV0_CFG1_ECC_DISABLE;
+-
+-	host->ecc_bch_cfg = !host->bch_enabled << ECC_CFG_ECC_DISABLE
+-				| 0 << ECC_SW_RESET
+-				| host->cw_data << ECC_NUM_DATA_BYTES
+-				| 1 << ECC_FORCE_CLK_OPEN
+-				| ecc_mode << ECC_MODE
+-				| host->ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_BCH;
++	host->cfg0 = FIELD_PREP(CW_PER_PAGE_MASK, (cwperpage - 1)) |
++		     FIELD_PREP(UD_SIZE_BYTES_MASK, host->cw_data) |
++		     FIELD_PREP(DISABLE_STATUS_AFTER_WRITE, 0) |
++		     FIELD_PREP(NUM_ADDR_CYCLES_MASK, 5) |
++		     FIELD_PREP(ECC_PARITY_SIZE_BYTES_RS, host->ecc_bytes_hw) |
++		     FIELD_PREP(STATUS_BFR_READ, 0) |
++		     FIELD_PREP(SET_RD_MODE_AFTER_STATUS, 1) |
++		     FIELD_PREP(SPARE_SIZE_BYTES_MASK, host->spare_bytes);
++
++	host->cfg1 = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 7) |
++		     FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, bad_block_byte) |
++		     FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 0) |
++		     FIELD_PREP(WR_RD_BSY_GAP_MASK, 2) |
++		     FIELD_PREP(WIDE_FLASH, wide_bus) |
++		     FIELD_PREP(ENABLE_BCH_ECC, host->bch_enabled);
++
++	host->cfg0_raw = FIELD_PREP(CW_PER_PAGE_MASK, (cwperpage - 1)) |
++			 FIELD_PREP(UD_SIZE_BYTES_MASK, host->cw_size) |
++			 FIELD_PREP(NUM_ADDR_CYCLES_MASK, 5) |
++			 FIELD_PREP(SPARE_SIZE_BYTES_MASK, 0);
++
++	host->cfg1_raw = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 7) |
++			 FIELD_PREP(CS_ACTIVE_BSY, 0) |
++			 FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, 17) |
++			 FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 1) |
++			 FIELD_PREP(WR_RD_BSY_GAP_MASK, 2) |
++			 FIELD_PREP(WIDE_FLASH, wide_bus) |
++			 FIELD_PREP(DEV0_CFG1_ECC_DISABLE, 1);
++
++	host->ecc_bch_cfg = FIELD_PREP(ECC_CFG_ECC_DISABLE, !host->bch_enabled) |
++			    FIELD_PREP(ECC_SW_RESET, 0) |
++			    FIELD_PREP(ECC_NUM_DATA_BYTES_MASK, host->cw_data) |
++			    FIELD_PREP(ECC_FORCE_CLK_OPEN, 1) |
++			    FIELD_PREP(ECC_MODE_MASK, ecc_mode) |
++			    FIELD_PREP(ECC_PARITY_SIZE_BYTES_BCH_MASK, host->ecc_bytes_hw);
+ 
+ 	if (!nandc->props->qpic_version2)
+ 		host->ecc_buf_cfg = 0x203 << NUM_STEPS;
+@@ -1882,21 +1881,21 @@ static int qcom_param_page_type_exec(str
+ 	nandc->regs->addr0 = 0;
+ 	nandc->regs->addr1 = 0;
+ 
+-	nandc->regs->cfg0 = cpu_to_le32(0 << CW_PER_PAGE
+-			    | 512 << UD_SIZE_BYTES
+-			    | 5 << NUM_ADDR_CYCLES
+-			    | 0 << SPARE_SIZE_BYTES);
+-
+-	nandc->regs->cfg1 = cpu_to_le32(7 << NAND_RECOVERY_CYCLES
+-			    | 0 << CS_ACTIVE_BSY
+-			    | 17 << BAD_BLOCK_BYTE_NUM
+-			    | 1 << BAD_BLOCK_IN_SPARE_AREA
+-			    | 2 << WR_RD_BSY_GAP
+-			    | 0 << WIDE_FLASH
+-			    | 1 << DEV0_CFG1_ECC_DISABLE);
++	host->cfg0 = FIELD_PREP(CW_PER_PAGE_MASK, 0) |
++		     FIELD_PREP(UD_SIZE_BYTES_MASK, 512) |
++		     FIELD_PREP(NUM_ADDR_CYCLES_MASK, 5) |
++		     FIELD_PREP(SPARE_SIZE_BYTES_MASK, 0);
++
++	host->cfg1 = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 7) |
++		     FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, 17) |
++		     FIELD_PREP(CS_ACTIVE_BSY, 0) |
++		     FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 1) |
++		     FIELD_PREP(WR_RD_BSY_GAP_MASK, 2) |
++		     FIELD_PREP(WIDE_FLASH, 0) |
++		     FIELD_PREP(DEV0_CFG1_ECC_DISABLE, 1);
+ 
+ 	if (!nandc->props->qpic_version2)
+-		nandc->regs->ecc_buf_cfg = cpu_to_le32(1 << ECC_CFG_ECC_DISABLE);
++		nandc->regs->ecc_buf_cfg = cpu_to_le32(ECC_CFG_ECC_DISABLE);
+ 
+ 	/* configure CMD1 and VLD for ONFI param probing in QPIC v1 */
+ 	if (!nandc->props->qpic_version2) {
+--- a/include/linux/mtd/nand-qpic-common.h
++++ b/include/linux/mtd/nand-qpic-common.h
+@@ -70,35 +70,42 @@
+ #define	BS_CORRECTABLE_ERR_MSK		0x1f
+ 
+ /* NAND_DEVn_CFG0 bits */
+-#define	DISABLE_STATUS_AFTER_WRITE	4
++#define	DISABLE_STATUS_AFTER_WRITE	BIT(4)
+ #define	CW_PER_PAGE			6
++#define	CW_PER_PAGE_MASK		GENMASK(8, 6)
+ #define	UD_SIZE_BYTES			9
+ #define	UD_SIZE_BYTES_MASK		GENMASK(18, 9)
+-#define	ECC_PARITY_SIZE_BYTES_RS	19
++#define	ECC_PARITY_SIZE_BYTES_RS	GENMASK(22, 19)
+ #define	SPARE_SIZE_BYTES		23
+ #define	SPARE_SIZE_BYTES_MASK		GENMASK(26, 23)
+ #define	NUM_ADDR_CYCLES			27
+-#define	STATUS_BFR_READ			30
+-#define	SET_RD_MODE_AFTER_STATUS	31
++#define	NUM_ADDR_CYCLES_MASK		GENMASK(29, 27)
++#define	STATUS_BFR_READ			BIT(30)
++#define	SET_RD_MODE_AFTER_STATUS	BIT(31)
+ 
+ /* NAND_DEVn_CFG0 bits */
+-#define	DEV0_CFG1_ECC_DISABLE		0
+-#define	WIDE_FLASH			1
++#define	DEV0_CFG1_ECC_DISABLE		BIT(0)
++#define	WIDE_FLASH			BIT(1)
+ #define	NAND_RECOVERY_CYCLES		2
+-#define	CS_ACTIVE_BSY			5
++#define	NAND_RECOVERY_CYCLES_MASK	GENMASK(4, 2)
++#define	CS_ACTIVE_BSY			BIT(5)
+ #define	BAD_BLOCK_BYTE_NUM		6
+-#define	BAD_BLOCK_IN_SPARE_AREA		16
++#define	BAD_BLOCK_BYTE_NUM_MASK		GENMASK(15, 6)
++#define	BAD_BLOCK_IN_SPARE_AREA		BIT(16)
+ #define	WR_RD_BSY_GAP			17
+-#define	ENABLE_BCH_ECC			27
++#define	WR_RD_BSY_GAP_MASK		GENMASK(22, 17)
++#define	ENABLE_BCH_ECC			BIT(27)
+ 
+ /* NAND_DEV0_ECC_CFG bits */
+-#define	ECC_CFG_ECC_DISABLE		0
+-#define	ECC_SW_RESET			1
++#define	ECC_CFG_ECC_DISABLE		BIT(0)
++#define	ECC_SW_RESET			BIT(1)
+ #define	ECC_MODE			4
++#define	ECC_MODE_MASK			GENMASK(5, 4)
+ #define	ECC_PARITY_SIZE_BYTES_BCH	8
++#define	ECC_PARITY_SIZE_BYTES_BCH_MASK	GENMASK(12, 8)
+ #define	ECC_NUM_DATA_BYTES		16
+ #define	ECC_NUM_DATA_BYTES_MASK		GENMASK(25, 16)
+-#define	ECC_FORCE_CLK_OPEN		30
++#define	ECC_FORCE_CLK_OPEN		BIT(30)
+ 
+ /* NAND_DEV_CMD1 bits */
+ #define	READ_ADDR			0
diff --git a/target/linux/qualcommax/patches-6.6/0406-spi-spi-qpic-add-driver-for-QCOM-SPI-NAND-flash-Interface.patch b/target/linux/qualcommax/patches-6.6/0406-spi-spi-qpic-add-driver-for-QCOM-SPI-NAND-flash-Interface.patch
new file mode 100644
index 0000000000..95188529c4
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0406-spi-spi-qpic-add-driver-for-QCOM-SPI-NAND-flash-Interface.patch
@@ -0,0 +1,1729 @@
+From: Md Sadre Alam <quic_mdalam@quicinc.com>
+Date: Sun, 22 Sep 2024 17:03:49 +0530
+Subject: [PATCH] spi: spi-qpic: add driver for QCOM SPI NAND flash Interface
+
+This driver implements support for the SPI-NAND mode of QCOM NAND Flash
+Interface as a SPI-MEM controller with pipelined ECC capability.
+
+Co-developed-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Signed-off-by: Sricharan Ramabadhran <quic_srichara@quicinc.com>
+Co-developed-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+Signed-off-by: Varadarajan Narayanan <quic_varada@quicinc.com>
+Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
+---
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -7,8 +7,11 @@ obj-$(CONFIG_MTD_NAND_MTK_BMT)	+= mtk_bm
+ 
+ ifeq ($(CONFIG_MTD_NAND_QCOM),y)
+ obj-y	+= qpic_common.o
++else
++ifeq ($(CONFIG_SPI_QPIC_SNAND),y)
++obj-y   += qpic_common.o
++endif
+ endif
+-
+ obj-y	+= onenand/
+ obj-y	+= raw/
+ obj-y	+= spi/
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -870,6 +870,14 @@ config SPI_QCOM_QSPI
+ 	help
+ 	  QSPI(Quad SPI) driver for Qualcomm QSPI controller.
+ 
++config SPI_QPIC_SNAND
++	bool "QPIC SNAND controller"
++	depends on ARCH_QCOM || COMPILE_TEST
++	help
++	  QPIC_SNAND (QPIC SPI NAND) driver for Qualcomm QPIC controller.
++	  QPIC controller supports both parallel nand and serial nand.
++	  This config will enable serial nand driver for QPIC controller.
++
+ config SPI_QUP
+ 	tristate "Qualcomm SPI controller with QUP interface"
+ 	depends on ARCH_QCOM || COMPILE_TEST
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -110,6 +110,7 @@ obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-
+ obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
+ obj-$(CONFIG_SPI_QCOM_GENI)		+= spi-geni-qcom.o
+ obj-$(CONFIG_SPI_QCOM_QSPI)		+= spi-qcom-qspi.o
++obj-$(CONFIG_SPI_QPIC_SNAND)            += spi-qpic-snand.o
+ obj-$(CONFIG_SPI_QUP)			+= spi-qup.o
+ obj-$(CONFIG_SPI_ROCKCHIP)		+= spi-rockchip.o
+ obj-$(CONFIG_SPI_ROCKCHIP_SFC)		+= spi-rockchip-sfc.o
+--- /dev/null
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -0,0 +1,1634 @@
++/*
++ * SPDX-License-Identifier: GPL-2.0
++ *
++ * Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
++ *
++ * Authors:
++ *	Md Sadre Alam <quic_mdalam@quicinc.com>
++ *	Sricharan R <quic_srichara@quicinc.com>
++ *	Varadarajan Narayanan <quic_varada@quicinc.com>
++ */
++#include <linux/bitops.h>
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/dmaengine.h>
++#include <linux/dma-mapping.h>
++#include <linux/dma/qcom_adm.h>
++#include <linux/dma/qcom_bam_dma.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/mtd/nand-qpic-common.h>
++#include <linux/mtd/spinand.h>
++#include <linux/bitfield.h>
++
++#define NAND_FLASH_SPI_CFG		0xc0
++#define NAND_NUM_ADDR_CYCLES		0xc4
++#define NAND_BUSY_CHECK_WAIT_CNT	0xc8
++#define NAND_FLASH_FEATURES		0xf64
++
++/* QSPI NAND config reg bits */
++#define LOAD_CLK_CNTR_INIT_EN		BIT(28)
++#define CLK_CNTR_INIT_VAL_VEC		0x924
++#define CLK_CNTR_INIT_VAL_VEC_MASK	GENMASK(27, 16)
++#define FEA_STATUS_DEV_ADDR		0xc0
++#define FEA_STATUS_DEV_ADDR_MASK	GENMASK(15, 8)
++#define SPI_CFG				BIT(0)
++#define SPI_NUM_ADDR			0xDA4DB
++#define SPI_WAIT_CNT			0x10
++#define QPIC_QSPI_NUM_CS		1
++#define SPI_TRANSFER_MODE_x1		BIT(29)
++#define SPI_TRANSFER_MODE_x4		(3 << 29)
++#define SPI_WP				BIT(28)
++#define SPI_HOLD			BIT(27)
++#define QPIC_SET_FEATURE		BIT(31)
++
++#define SPINAND_RESET			0xff
++#define SPINAND_READID			0x9f
++#define SPINAND_GET_FEATURE		0x0f
++#define SPINAND_SET_FEATURE		0x1f
++#define SPINAND_READ			0x13
++#define SPINAND_ERASE			0xd8
++#define SPINAND_WRITE_EN		0x06
++#define SPINAND_PROGRAM_EXECUTE		0x10
++#define SPINAND_PROGRAM_LOAD		0x84
++
++#define ACC_FEATURE			0xe
++#define BAD_BLOCK_MARKER_SIZE		0x2
++#define OOB_BUF_SIZE			128
++#define ecceng_to_qspi(eng)		container_of(eng, struct qpic_spi_nand, ecc_eng)
++struct qpic_snand_op {
++	u32 cmd_reg;
++	u32 addr1_reg;
++	u32 addr2_reg;
++};
++
++struct snandc_read_status {
++	__le32 snandc_flash;
++	__le32 snandc_buffer;
++	__le32 snandc_erased_cw;
++};
++
++/*
++ * ECC state struct
++ * @corrected:		ECC corrected
++ * @bitflips:		Max bit flip
++ * @failed:		ECC failed
++ */
++struct qcom_ecc_stats {
++	u32 corrected;
++	u32 bitflips;
++	u32 failed;
++};
++
++struct qpic_ecc {
++	struct device *dev;
++	int ecc_bytes_hw;
++	int spare_bytes;
++	int bbm_size;
++	int ecc_mode;
++	int bytes;
++	int steps;
++	int step_size;
++	int strength;
++	int cw_size;
++	int cw_data;
++	u32 cfg0;
++	u32 cfg1;
++	u32 cfg0_raw;
++	u32 cfg1_raw;
++	u32 ecc_buf_cfg;
++	u32 ecc_bch_cfg;
++	u32 clrflashstatus;
++	u32 clrreadstatus;
++	bool bch_enabled;
++};
++
++struct qpic_spi_nand {
++	struct qcom_nand_controller *snandc;
++	struct spi_controller *ctlr;
++	struct mtd_info *mtd;
++	struct clk *iomacro_clk;
++	struct qpic_ecc *ecc;
++	struct qcom_ecc_stats ecc_stats;
++	struct nand_ecc_engine ecc_eng;
++	u8 *data_buf;
++	u8 *oob_buf;
++	u32 wlen;
++	__le32 addr1;
++	__le32 addr2;
++	__le32 cmd;
++	u32 num_cw;
++	bool oob_rw;
++	bool page_rw;
++	bool raw_rw;
++};
++
++static void qcom_spi_set_read_loc_first(struct qcom_nand_controller *snandc,
++					int reg, int cw_offset, int read_size,
++					int is_last_read_loc)
++{
++	__le32 locreg_val;
++	u32 val = (((cw_offset) << READ_LOCATION_OFFSET) |
++		  ((read_size) << READ_LOCATION_SIZE) | ((is_last_read_loc)
++		  << READ_LOCATION_LAST));
++
++	locreg_val = cpu_to_le32(val);
++
++	if (reg == NAND_READ_LOCATION_0)
++		snandc->regs->read_location0 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_1)
++		snandc->regs->read_location1 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_2)
++		snandc->regs->read_location1 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_3)
++		snandc->regs->read_location3 = locreg_val;
++}
++
++static void qcom_spi_set_read_loc_last(struct qcom_nand_controller *snandc,
++				       int reg, int cw_offset, int read_size,
++				       int is_last_read_loc)
++{
++	__le32 locreg_val;
++	u32 val = (((cw_offset) << READ_LOCATION_OFFSET) |
++		  ((read_size) << READ_LOCATION_SIZE) | ((is_last_read_loc)
++		  << READ_LOCATION_LAST));
++
++	locreg_val = cpu_to_le32(val);
++
++	if (reg == NAND_READ_LOCATION_LAST_CW_0)
++		snandc->regs->read_location_last0 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_LAST_CW_1)
++		snandc->regs->read_location_last1 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_LAST_CW_2)
++		snandc->regs->read_location_last2 = locreg_val;
++	else if (reg == NAND_READ_LOCATION_LAST_CW_3)
++		snandc->regs->read_location_last3 = locreg_val;
++}
++
++static struct qcom_nand_controller *nand_to_qcom_snand(struct nand_device *nand)
++{
++	struct nand_ecc_engine *eng = nand->ecc.engine;
++	struct qpic_spi_nand *qspi = ecceng_to_qspi(eng);
++
++	return qspi->snandc;
++}
++
++static int qcom_spi_init(struct qcom_nand_controller *snandc)
++{
++	u32 snand_cfg_val = 0x0;
++	int ret;
++
++	snand_cfg_val = FIELD_PREP(CLK_CNTR_INIT_VAL_VEC_MASK, CLK_CNTR_INIT_VAL_VEC) |
++			FIELD_PREP(LOAD_CLK_CNTR_INIT_EN, 0) |
++			FIELD_PREP(FEA_STATUS_DEV_ADDR_MASK, FEA_STATUS_DEV_ADDR) |
++			FIELD_PREP(SPI_CFG, 0);
++
++	snandc->regs->spi_cfg = cpu_to_le32(snand_cfg_val);
++	snandc->regs->num_addr_cycle = cpu_to_le32(SPI_NUM_ADDR);
++	snandc->regs->busy_wait_cnt = cpu_to_le32(SPI_WAIT_CNT);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->spi_cfg, NAND_FLASH_SPI_CFG, 1, 0);
++
++	snand_cfg_val &= ~LOAD_CLK_CNTR_INIT_EN;
++	snandc->regs->spi_cfg = cpu_to_le32(snand_cfg_val);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->spi_cfg, NAND_FLASH_SPI_CFG, 1, 0);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->num_addr_cycle, NAND_NUM_ADDR_CYCLES, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->busy_wait_cnt, NAND_BUSY_CHECK_WAIT_CNT, 1,
++			   NAND_BAM_NEXT_SGL);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure in submitting spi init descriptor\n");
++		return ret;
++	}
++
++	return ret;
++}
++
++static int qcom_spi_ooblayout_ecc(struct mtd_info *mtd, int section,
++				  struct mtd_oob_region *oobregion)
++{
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct qpic_ecc *qecc = snandc->qspi->ecc;
++
++	if (section > 1)
++		return -ERANGE;
++
++	oobregion->length = qecc->ecc_bytes_hw + qecc->spare_bytes;
++	oobregion->offset = mtd->oobsize - oobregion->length;
++
++	return 0;
++}
++
++static int qcom_spi_ooblayout_free(struct mtd_info *mtd, int section,
++				   struct mtd_oob_region *oobregion)
++{
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct qpic_ecc *qecc = snandc->qspi->ecc;
++
++	if (section)
++		return -ERANGE;
++
++	oobregion->length = qecc->steps * 4;
++	oobregion->offset = ((qecc->steps - 1) * qecc->bytes) + qecc->bbm_size;
++
++	return 0;
++}
++
++static const struct mtd_ooblayout_ops qcom_spi_ooblayout = {
++	.ecc = qcom_spi_ooblayout_ecc,
++	.free = qcom_spi_ooblayout_free,
++};
++
++static int qcom_spi_ecc_init_ctx_pipelined(struct nand_device *nand)
++{
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct nand_ecc_props *conf = &nand->ecc.ctx.conf;
++	struct mtd_info *mtd = nanddev_to_mtd(nand);
++	int cwperpage, bad_block_byte;
++	struct qpic_ecc *ecc_cfg;
++
++	cwperpage = mtd->writesize / NANDC_STEP_SIZE;
++	snandc->qspi->num_cw = cwperpage;
++
++	ecc_cfg = kzalloc(sizeof(*ecc_cfg), GFP_KERNEL);
++	if (!ecc_cfg)
++		return -ENOMEM;
++	snandc->qspi->oob_buf = kzalloc(mtd->writesize + mtd->oobsize,
++					GFP_KERNEL);
++	if (!snandc->qspi->oob_buf)
++		return -ENOMEM;
++
++	memset(snandc->qspi->oob_buf, 0xff, mtd->writesize + mtd->oobsize);
++
++	nand->ecc.ctx.priv = ecc_cfg;
++	snandc->qspi->mtd = mtd;
++
++	ecc_cfg->ecc_bytes_hw = 7;
++	ecc_cfg->spare_bytes = 4;
++	ecc_cfg->bbm_size = 1;
++	ecc_cfg->bch_enabled = true;
++	ecc_cfg->bytes = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes + ecc_cfg->bbm_size;
++
++	ecc_cfg->steps = 4;
++	ecc_cfg->strength = 4;
++	ecc_cfg->step_size = 512;
++	ecc_cfg->cw_data = 516;
++	ecc_cfg->cw_size = ecc_cfg->cw_data + ecc_cfg->bytes;
++	bad_block_byte = mtd->writesize - ecc_cfg->cw_size * (cwperpage - 1) + 1;
++
++	mtd_set_ooblayout(mtd, &qcom_spi_ooblayout);
++
++	ecc_cfg->cfg0 = FIELD_PREP(CW_PER_PAGE_MASK, (cwperpage - 1)) |
++			FIELD_PREP(UD_SIZE_BYTES_MASK, ecc_cfg->cw_data) |
++			FIELD_PREP(DISABLE_STATUS_AFTER_WRITE, 1) |
++			FIELD_PREP(NUM_ADDR_CYCLES_MASK, 3) |
++			FIELD_PREP(ECC_PARITY_SIZE_BYTES_RS, ecc_cfg->ecc_bytes_hw) |
++			FIELD_PREP(STATUS_BFR_READ, 0) |
++			FIELD_PREP(SET_RD_MODE_AFTER_STATUS, 1) |
++			FIELD_PREP(SPARE_SIZE_BYTES_MASK, ecc_cfg->spare_bytes);
++
++	ecc_cfg->cfg1 = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 0) |
++			FIELD_PREP(CS_ACTIVE_BSY, 0) |
++			FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, bad_block_byte) |
++			FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 0) |
++			FIELD_PREP(WR_RD_BSY_GAP_MASK, 20) |
++			FIELD_PREP(WIDE_FLASH, 0) |
++			FIELD_PREP(ENABLE_BCH_ECC, ecc_cfg->bch_enabled);
++
++	ecc_cfg->cfg0_raw = FIELD_PREP(CW_PER_PAGE_MASK, (cwperpage - 1)) |
++			    FIELD_PREP(NUM_ADDR_CYCLES_MASK, 3) |
++			    FIELD_PREP(UD_SIZE_BYTES_MASK, ecc_cfg->cw_size) |
++			    FIELD_PREP(SPARE_SIZE_BYTES_MASK, 0);
++
++	ecc_cfg->cfg1_raw = FIELD_PREP(NAND_RECOVERY_CYCLES_MASK, 0) |
++			    FIELD_PREP(CS_ACTIVE_BSY, 0) |
++			    FIELD_PREP(BAD_BLOCK_BYTE_NUM_MASK, 17) |
++			    FIELD_PREP(BAD_BLOCK_IN_SPARE_AREA, 1) |
++			    FIELD_PREP(WR_RD_BSY_GAP_MASK, 20) |
++			    FIELD_PREP(WIDE_FLASH, 0) |
++			    FIELD_PREP(DEV0_CFG1_ECC_DISABLE, 1);
++
++	ecc_cfg->ecc_bch_cfg = FIELD_PREP(ECC_CFG_ECC_DISABLE, !ecc_cfg->bch_enabled) |
++			       FIELD_PREP(ECC_SW_RESET, 0) |
++			       FIELD_PREP(ECC_NUM_DATA_BYTES_MASK, ecc_cfg->cw_data) |
++			       FIELD_PREP(ECC_FORCE_CLK_OPEN, 1) |
++			       FIELD_PREP(ECC_MODE_MASK, 0) |
++			       FIELD_PREP(ECC_PARITY_SIZE_BYTES_BCH_MASK, ecc_cfg->ecc_bytes_hw);
++
++	ecc_cfg->ecc_buf_cfg = 0x203 << NUM_STEPS;
++	ecc_cfg->clrflashstatus = FS_READY_BSY_N;
++	ecc_cfg->clrreadstatus = 0xc0;
++
++	conf->step_size = ecc_cfg->step_size;
++	conf->strength = ecc_cfg->strength;
++
++	snandc->regs->erased_cw_detect_cfg_clr = cpu_to_le32(CLR_ERASED_PAGE_DET);
++	snandc->regs->erased_cw_detect_cfg_set = cpu_to_le32(SET_ERASED_PAGE_DET);
++
++	dev_dbg(snandc->dev, "ECC strength: %u bits per %u bytes\n",
++		ecc_cfg->strength, ecc_cfg->step_size);
++
++	return 0;
++}
++
++static void qcom_spi_ecc_cleanup_ctx_pipelined(struct nand_device *nand)
++{
++	struct qpic_ecc *ecc_cfg = nand_to_ecc_ctx(nand);
++
++	kfree(ecc_cfg);
++}
++
++static int qcom_spi_ecc_prepare_io_req_pipelined(struct nand_device *nand,
++						 struct nand_page_io_req *req)
++{
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct qpic_ecc *ecc_cfg = nand_to_ecc_ctx(nand);
++
++	snandc->qspi->ecc = ecc_cfg;
++	snandc->qspi->raw_rw = false;
++	snandc->qspi->oob_rw = false;
++	snandc->qspi->page_rw = false;
++
++	if (req->datalen)
++		snandc->qspi->page_rw = true;
++
++	if (req->ooblen)
++		snandc->qspi->oob_rw = true;
++
++	if (req->mode == MTD_OPS_RAW)
++		snandc->qspi->raw_rw = true;
++
++	return 0;
++}
++
++static int qcom_spi_ecc_finish_io_req_pipelined(struct nand_device *nand,
++						struct nand_page_io_req *req)
++{
++	struct qcom_nand_controller *snandc = nand_to_qcom_snand(nand);
++	struct mtd_info *mtd = nanddev_to_mtd(nand);
++
++	if (req->mode == MTD_OPS_RAW || req->type != NAND_PAGE_READ)
++		return 0;
++
++	if (snandc->qspi->ecc_stats.failed)
++		mtd->ecc_stats.failed += snandc->qspi->ecc_stats.failed;
++	else
++		mtd->ecc_stats.corrected += snandc->qspi->ecc_stats.corrected;
++
++	if (snandc->qspi->ecc_stats.failed)
++		return -EBADMSG;
++	else
++		return snandc->qspi->ecc_stats.bitflips;
++}
++
++static struct nand_ecc_engine_ops qcom_spi_ecc_engine_ops_pipelined = {
++	.init_ctx = qcom_spi_ecc_init_ctx_pipelined,
++	.cleanup_ctx = qcom_spi_ecc_cleanup_ctx_pipelined,
++	.prepare_io_req = qcom_spi_ecc_prepare_io_req_pipelined,
++	.finish_io_req = qcom_spi_ecc_finish_io_req_pipelined,
++};
++
++/* helper to configure location register values */
++static void qcom_spi_set_read_loc(struct qcom_nand_controller *snandc, int cw, int reg,
++				  int cw_offset, int read_size, int is_last_read_loc)
++{
++	int reg_base = NAND_READ_LOCATION_0;
++	int num_cw = snandc->qspi->num_cw;
++
++	if (cw == (num_cw - 1))
++		reg_base = NAND_READ_LOCATION_LAST_CW_0;
++
++	reg_base += reg * 4;
++
++	if (cw == (num_cw - 1))
++		return qcom_spi_set_read_loc_last(snandc, reg_base, cw_offset,
++						  read_size, is_last_read_loc);
++	else
++		return qcom_spi_set_read_loc_first(snandc, reg_base, cw_offset,
++						   read_size, is_last_read_loc);
++}
++
++static void
++qcom_spi_config_cw_read(struct qcom_nand_controller *snandc, bool use_ecc, int cw)
++{
++	__le32 *reg = &snandc->regs->read_location0;
++	int num_cw = snandc->qspi->num_cw;
++
++	qcom_write_reg_dma(snandc, reg, NAND_READ_LOCATION_0, 4, NAND_BAM_NEXT_SGL);
++	if (cw == (num_cw - 1)) {
++		reg = &snandc->regs->read_location_last0;
++		qcom_write_reg_dma(snandc, reg, NAND_READ_LOCATION_LAST_CW_0, 4,
++				   NAND_BAM_NEXT_SGL);
++	}
++
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++
++	qcom_read_reg_dma(snandc, NAND_FLASH_STATUS, 2, 0);
++	qcom_read_reg_dma(snandc, NAND_ERASED_CW_DETECT_STATUS, 1,
++			  NAND_BAM_NEXT_SGL);
++}
++
++static int qcom_spi_block_erase(struct qcom_nand_controller *snandc)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	int ret;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cfg0 = cpu_to_le32(ecc_cfg->cfg0_raw & ~(7 << CW_PER_PAGE));
++	snandc->regs->cfg1 = cpu_to_le32(ecc_cfg->cfg1_raw);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 3, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 2, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to erase block\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static void qcom_spi_config_single_cw_page_read(struct qcom_nand_controller *snandc,
++						bool use_ecc, int cw)
++{
++	__le32 *reg = &snandc->regs->read_location0;
++	int num_cw = snandc->qspi->num_cw;
++
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1,
++			   NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++
++	if (cw == (num_cw - 1)) {
++		reg = &snandc->regs->read_location_last0;
++		qcom_write_reg_dma(snandc, reg, NAND_READ_LOCATION_LAST_CW_0, 4, NAND_BAM_NEXT_SGL);
++	}
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++
++	qcom_read_reg_dma(snandc, NAND_FLASH_STATUS, 1, 0);
++}
++
++static int qcom_spi_read_last_cw(struct qcom_nand_controller *snandc,
++				 const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	struct mtd_info *mtd = snandc->qspi->mtd;
++	int size, ret = 0;
++	int col,  bbpos;
++	u32 cfg0, cfg1, ecc_bch_cfg;
++	u32 num_cw = snandc->qspi->num_cw;
++
++	qcom_clear_bam_transaction(snandc);
++	qcom_clear_read_regs(snandc);
++
++	size = ecc_cfg->cw_size;
++	col = ecc_cfg->cw_size * (num_cw - 1);
++
++	memset(snandc->data_buffer, 0xff, size);
++	snandc->regs->addr0 = (snandc->qspi->addr1 | cpu_to_le32(col));
++	snandc->regs->addr1 = snandc->qspi->addr2;
++
++	cfg0 = (ecc_cfg->cfg0_raw & ~(7U << CW_PER_PAGE)) |
++		0 << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1_raw;
++	ecc_bch_cfg = 1 << ECC_CFG_ECC_DISABLE;
++
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_set_read_loc(snandc, num_cw - 1, 0, 0, ecc_cfg->cw_size, 1);
++
++	qcom_spi_config_single_cw_page_read(snandc, false, num_cw - 1);
++
++	qcom_read_data_dma(snandc, FLASH_BUF_ACC, snandc->data_buffer, size, 0);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failed to read last cw\n");
++		return ret;
++	}
++
++	qcom_nandc_dev_to_mem(snandc, true);
++	u32 flash = le32_to_cpu(snandc->reg_read_buf[0]);
++
++	if (flash & (FS_OP_ERR | FS_MPU_ERR))
++		return -EIO;
++
++	bbpos = mtd->writesize - ecc_cfg->cw_size * (num_cw - 1);
++
++	if (snandc->data_buffer[bbpos] == 0xff)
++		snandc->data_buffer[bbpos + 1] = 0xff;
++	if (snandc->data_buffer[bbpos] != 0xff)
++		snandc->data_buffer[bbpos + 1] = snandc->data_buffer[bbpos];
++
++	memcpy(op->data.buf.in, snandc->data_buffer + bbpos, op->data.nbytes);
++
++	return ret;
++}
++
++static int qcom_spi_check_error(struct qcom_nand_controller *snandc, u8 *data_buf, u8 *oob_buf)
++{
++	struct snandc_read_status *buf;
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	int i, num_cw = snandc->qspi->num_cw;
++	bool flash_op_err = false, erased;
++	unsigned int max_bitflips = 0;
++	unsigned int uncorrectable_cws = 0;
++
++	snandc->qspi->ecc_stats.failed = 0;
++	snandc->qspi->ecc_stats.corrected = 0;
++
++	qcom_nandc_dev_to_mem(snandc, true);
++	buf = (struct snandc_read_status *)snandc->reg_read_buf;
++
++	for (i = 0; i < num_cw; i++, buf++) {
++		u32 flash, buffer, erased_cw;
++		int data_len, oob_len;
++
++		if (i == (num_cw - 1)) {
++			data_len = NANDC_STEP_SIZE - ((num_cw - 1) << 2);
++			oob_len = num_cw << 2;
++		} else {
++			data_len = ecc_cfg->cw_data;
++			oob_len = 0;
++		}
++
++		flash = le32_to_cpu(buf->snandc_flash);
++		buffer = le32_to_cpu(buf->snandc_buffer);
++		erased_cw = le32_to_cpu(buf->snandc_erased_cw);
++
++		if ((flash & FS_OP_ERR) && (buffer & BS_UNCORRECTABLE_BIT)) {
++			if (ecc_cfg->bch_enabled)
++				erased = (erased_cw & ERASED_CW) == ERASED_CW;
++			else
++				erased = false;
++
++			if (!erased)
++				uncorrectable_cws |= BIT(i);
++
++		} else if (flash & (FS_OP_ERR | FS_MPU_ERR)) {
++			flash_op_err = true;
++		} else {
++			unsigned int stat;
++
++			stat = buffer & BS_CORRECTABLE_ERR_MSK;
++			snandc->qspi->ecc_stats.corrected += stat;
++			max_bitflips = max(max_bitflips, stat);
++		}
++
++		if (data_buf)
++			data_buf += data_len;
++		if (oob_buf)
++			oob_buf += oob_len + ecc_cfg->bytes;
++	}
++
++	if (flash_op_err)
++		return -EIO;
++
++	if (!uncorrectable_cws)
++		snandc->qspi->ecc_stats.bitflips = max_bitflips;
++	else
++		snandc->qspi->ecc_stats.failed++;
++
++	return 0;
++}
++
++static int qcom_spi_check_raw_flash_errors(struct qcom_nand_controller *snandc, int cw_cnt)
++{
++	int i;
++
++	qcom_nandc_dev_to_mem(snandc, true);
++
++	for (i = 0; i < cw_cnt; i++) {
++		u32 flash = le32_to_cpu(snandc->reg_read_buf[i]);
++
++		if (flash & (FS_OP_ERR | FS_MPU_ERR))
++			return -EIO;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_read_cw_raw(struct qcom_nand_controller *snandc, u8 *data_buf,
++				u8 *oob_buf, int cw)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	struct mtd_info *mtd = snandc->qspi->mtd;
++	int data_size1, data_size2, oob_size1, oob_size2;
++	int ret, reg_off = FLASH_BUF_ACC, read_loc = 0;
++	int raw_cw = cw;
++	u32 cfg0, cfg1, ecc_bch_cfg, num_cw = snandc->qspi->num_cw;
++	int col;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++	raw_cw = num_cw - 1;
++
++	cfg0 = (ecc_cfg->cfg0_raw & ~(7U << CW_PER_PAGE)) |
++				0 << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1_raw;
++	ecc_bch_cfg = ECC_CFG_ECC_DISABLE;
++
++	col = ecc_cfg->cw_size * cw;
++
++	snandc->regs->addr0 = (snandc->qspi->addr1 | cpu_to_le32(col));
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_set_read_loc(snandc, raw_cw, 0, 0, ecc_cfg->cw_size, 1);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG, 1, 0);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1,
++			   NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++
++	data_size1 = mtd->writesize - ecc_cfg->cw_size * (num_cw - 1);
++	oob_size1 = ecc_cfg->bbm_size;
++
++	if (cw == (num_cw - 1)) {
++		data_size2 = NANDC_STEP_SIZE - data_size1 -
++			     ((num_cw - 1) * 4);
++		oob_size2 = (num_cw * 4) + ecc_cfg->ecc_bytes_hw +
++			    ecc_cfg->spare_bytes;
++	} else {
++		data_size2 = ecc_cfg->cw_data - data_size1;
++		oob_size2 = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes;
++	}
++
++	qcom_spi_set_read_loc(snandc, cw, 0, read_loc, data_size1, 0);
++	read_loc += data_size1;
++
++	qcom_spi_set_read_loc(snandc, cw, 1, read_loc, oob_size1, 0);
++	read_loc += oob_size1;
++
++	qcom_spi_set_read_loc(snandc, cw, 2, read_loc, data_size2, 0);
++	read_loc += data_size2;
++
++	qcom_spi_set_read_loc(snandc, cw, 3, read_loc, oob_size2, 1);
++
++	qcom_spi_config_cw_read(snandc, false, raw_cw);
++
++	qcom_read_data_dma(snandc, reg_off, data_buf, data_size1, 0);
++	reg_off += data_size1;
++
++	qcom_read_data_dma(snandc, reg_off, oob_buf, oob_size1, 0);
++	reg_off += oob_size1;
++
++	qcom_read_data_dma(snandc, reg_off, data_buf + data_size1, data_size2, 0);
++	reg_off += data_size2;
++
++	qcom_read_data_dma(snandc, reg_off, oob_buf + oob_size1, oob_size2, 0);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to read raw cw %d\n", cw);
++		return ret;
++	}
++
++	return qcom_spi_check_raw_flash_errors(snandc, 1);
++}
++
++static int qcom_spi_read_page_raw(struct qcom_nand_controller *snandc,
++				  const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *data_buf = NULL, *oob_buf = NULL;
++	int ret, cw;
++	u32 num_cw = snandc->qspi->num_cw;
++
++	if (snandc->qspi->page_rw)
++		data_buf = op->data.buf.in;
++
++	oob_buf = snandc->qspi->oob_buf;
++	memset(oob_buf, 0xff, OOB_BUF_SIZE);
++
++	for (cw = 0; cw < num_cw; cw++) {
++		ret = qcom_spi_read_cw_raw(snandc, data_buf, oob_buf, cw);
++		if (ret)
++			return ret;
++
++		if (data_buf)
++			data_buf += ecc_cfg->cw_data;
++		if (oob_buf)
++			oob_buf += ecc_cfg->bytes;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_read_page_ecc(struct qcom_nand_controller *snandc,
++				  const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *data_buf = NULL, *data_buf_start, *oob_buf = NULL, *oob_buf_start;
++	int ret, i;
++	u32 cfg0, cfg1, ecc_bch_cfg, num_cw = snandc->qspi->num_cw;
++
++	data_buf = op->data.buf.in;
++	data_buf_start = data_buf;
++
++	oob_buf = snandc->qspi->oob_buf;
++	oob_buf_start = oob_buf;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++
++	cfg0 = (ecc_cfg->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1;
++	ecc_bch_cfg = ecc_cfg->ecc_bch_cfg;
++
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_set_read_loc(snandc, 0, 0, 0, ecc_cfg->cw_data, 1);
++
++	qcom_clear_bam_transaction(snandc);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1,
++			   NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++
++	for (i = 0; i < num_cw; i++) {
++		int data_size, oob_size;
++
++		if (i == (num_cw - 1)) {
++			data_size = 512 - ((num_cw - 1) << 2);
++			oob_size = (num_cw << 2) + ecc_cfg->ecc_bytes_hw +
++				    ecc_cfg->spare_bytes;
++		} else {
++			data_size = ecc_cfg->cw_data;
++			oob_size = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes;
++		}
++
++		if (data_buf && oob_buf) {
++			qcom_spi_set_read_loc(snandc, i, 0, 0, data_size, 0);
++			qcom_spi_set_read_loc(snandc, i, 1, data_size, oob_size, 1);
++		} else if (data_buf) {
++			qcom_spi_set_read_loc(snandc, i, 0, 0, data_size, 1);
++		} else {
++			qcom_spi_set_read_loc(snandc, i, 0, data_size, oob_size, 1);
++		}
++
++		qcom_spi_config_cw_read(snandc, true, i);
++
++		if (data_buf)
++			qcom_read_data_dma(snandc, FLASH_BUF_ACC, data_buf,
++					   data_size, 0);
++		if (oob_buf) {
++			int j;
++
++			for (j = 0; j < ecc_cfg->bbm_size; j++)
++				*oob_buf++ = 0xff;
++
++			qcom_read_data_dma(snandc, FLASH_BUF_ACC + data_size,
++					   oob_buf, oob_size, 0);
++		}
++
++		if (data_buf)
++			data_buf += data_size;
++		if (oob_buf)
++			oob_buf += oob_size;
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to read page\n");
++		return ret;
++	}
++
++	return qcom_spi_check_error(snandc, data_buf_start, oob_buf_start);
++}
++
++static int qcom_spi_read_page_oob(struct qcom_nand_controller *snandc,
++				  const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *data_buf = NULL, *data_buf_start, *oob_buf = NULL, *oob_buf_start;
++	int ret, i;
++	u32 cfg0, cfg1, ecc_bch_cfg, num_cw = snandc->qspi->num_cw;
++
++	oob_buf = op->data.buf.in;
++	oob_buf_start = oob_buf;
++
++	data_buf_start = data_buf;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	cfg0 = (ecc_cfg->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1;
++	ecc_bch_cfg = ecc_cfg->ecc_bch_cfg;
++
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_set_read_loc(snandc, 0, 0, 0, ecc_cfg->cw_data, 1);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_clr,
++			   NAND_ERASED_CW_DETECT_CFG, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->erased_cw_detect_cfg_set,
++			   NAND_ERASED_CW_DETECT_CFG, 1,
++			   NAND_ERASED_CW_SET | NAND_BAM_NEXT_SGL);
++
++	for (i = 0; i < num_cw; i++) {
++		int data_size, oob_size;
++
++		if (i == (num_cw - 1)) {
++			data_size = NANDC_STEP_SIZE - ((num_cw - 1) << 2);
++			oob_size = (num_cw << 2) + ecc_cfg->ecc_bytes_hw +
++				    ecc_cfg->spare_bytes;
++		} else {
++			data_size = ecc_cfg->cw_data;
++			oob_size = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes;
++		}
++
++		qcom_spi_set_read_loc(snandc, i, 0, data_size, oob_size, 1);
++
++		qcom_spi_config_cw_read(snandc, true, i);
++
++		if (oob_buf) {
++			int j;
++
++			for (j = 0; j < ecc_cfg->bbm_size; j++)
++				*oob_buf++ = 0xff;
++
++			qcom_read_data_dma(snandc, FLASH_BUF_ACC + data_size,
++					   oob_buf, oob_size, 0);
++		}
++
++		if (oob_buf)
++			oob_buf += oob_size;
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to read oob\n");
++		return ret;
++	}
++
++	return qcom_spi_check_error(snandc, data_buf_start, oob_buf_start);
++}
++
++static int qcom_spi_read_page(struct qcom_nand_controller *snandc,
++			      const struct spi_mem_op *op)
++{
++	if (snandc->qspi->page_rw && snandc->qspi->raw_rw)
++		return qcom_spi_read_page_raw(snandc, op);
++
++	if (snandc->qspi->page_rw)
++		return qcom_spi_read_page_ecc(snandc, op);
++
++	if (snandc->qspi->oob_rw && snandc->qspi->raw_rw)
++		return qcom_spi_read_last_cw(snandc, op);
++
++	if (snandc->qspi->oob_rw)
++		return qcom_spi_read_page_oob(snandc, op);
++
++	return 0;
++}
++
++static void qcom_spi_config_page_write(struct qcom_nand_controller *snandc)
++{
++	qcom_write_reg_dma(snandc, &snandc->regs->addr0, NAND_ADDR0, 2, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->cfg0, NAND_DEV0_CFG0, 3, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->ecc_buf_cfg, NAND_EBI2_ECC_BUF_CFG,
++			   1, NAND_BAM_NEXT_SGL);
++}
++
++static void qcom_spi_config_cw_write(struct qcom_nand_controller *snandc)
++{
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++	qcom_read_reg_dma(snandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->clrflashstatus, NAND_FLASH_STATUS, 1, 0);
++	qcom_write_reg_dma(snandc, &snandc->regs->clrreadstatus, NAND_READ_STATUS, 1,
++			   NAND_BAM_NEXT_SGL);
++}
++
++static int qcom_spi_program_raw(struct qcom_nand_controller *snandc,
++				const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	struct mtd_info *mtd = snandc->qspi->mtd;
++	u8 *data_buf = NULL, *oob_buf = NULL;
++	int i, ret;
++	int num_cw = snandc->qspi->num_cw;
++	u32 cfg0, cfg1, ecc_bch_cfg;
++
++	cfg0 = (ecc_cfg->cfg0_raw & ~(7U << CW_PER_PAGE)) |
++			(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1_raw;
++	ecc_bch_cfg = ECC_CFG_ECC_DISABLE;
++
++	data_buf = snandc->qspi->data_buf;
++
++	oob_buf = snandc->qspi->oob_buf;
++	memset(oob_buf, 0xff, OOB_BUF_SIZE);
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->clrflashstatus = cpu_to_le32(ecc_cfg->clrflashstatus);
++	snandc->regs->clrreadstatus = cpu_to_le32(ecc_cfg->clrreadstatus);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_config_page_write(snandc);
++
++	for (i = 0; i < num_cw; i++) {
++		int data_size1, data_size2, oob_size1, oob_size2;
++		int reg_off = FLASH_BUF_ACC;
++
++		data_size1 = mtd->writesize - ecc_cfg->cw_size * (num_cw - 1);
++		oob_size1 = ecc_cfg->bbm_size;
++
++		if ((i == (num_cw - 1))) {
++			data_size2 = NANDC_STEP_SIZE - data_size1 -
++				     ((num_cw - 1) << 2);
++			oob_size2 = (num_cw << 2) + ecc_cfg->ecc_bytes_hw +
++				    ecc_cfg->spare_bytes;
++		} else {
++			data_size2 = ecc_cfg->cw_data - data_size1;
++			oob_size2 = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes;
++		}
++
++		qcom_write_data_dma(snandc, reg_off, data_buf, data_size1,
++				    NAND_BAM_NO_EOT);
++		reg_off += data_size1;
++		data_buf += data_size1;
++
++		qcom_write_data_dma(snandc, reg_off, oob_buf, oob_size1,
++				    NAND_BAM_NO_EOT);
++		oob_buf += oob_size1;
++		reg_off += oob_size1;
++
++		qcom_write_data_dma(snandc, reg_off, data_buf, data_size2,
++				    NAND_BAM_NO_EOT);
++		reg_off += data_size2;
++		data_buf += data_size2;
++
++		qcom_write_data_dma(snandc, reg_off, oob_buf, oob_size2, 0);
++		oob_buf += oob_size2;
++
++		qcom_spi_config_cw_write(snandc);
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to write raw page\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_program_ecc(struct qcom_nand_controller *snandc,
++				const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *data_buf = NULL, *oob_buf = NULL;
++	int i, ret;
++	int num_cw = snandc->qspi->num_cw;
++	u32 cfg0, cfg1, ecc_bch_cfg, ecc_buf_cfg;
++
++	cfg0 = (ecc_cfg->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1;
++	ecc_bch_cfg = ecc_cfg->ecc_bch_cfg;
++	ecc_buf_cfg = ecc_cfg->ecc_buf_cfg;
++
++	if (snandc->qspi->data_buf)
++		data_buf = snandc->qspi->data_buf;
++
++	oob_buf = snandc->qspi->oob_buf;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	snandc->regs->addr0 = snandc->qspi->addr1;
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->ecc_buf_cfg = cpu_to_le32(ecc_buf_cfg);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	qcom_spi_config_page_write(snandc);
++
++	for (i = 0; i < num_cw; i++) {
++		int data_size, oob_size;
++
++		if (i == (num_cw - 1)) {
++			data_size = NANDC_STEP_SIZE - ((num_cw - 1) << 2);
++			oob_size = (num_cw << 2) + ecc_cfg->ecc_bytes_hw +
++				    ecc_cfg->spare_bytes;
++		} else {
++			data_size = ecc_cfg->cw_data;
++			oob_size = ecc_cfg->bytes;
++		}
++
++		if (data_buf)
++			qcom_write_data_dma(snandc, FLASH_BUF_ACC, data_buf, data_size,
++					    i == (num_cw - 1) ? NAND_BAM_NO_EOT : 0);
++
++		if (i == (num_cw - 1)) {
++			if (oob_buf) {
++				oob_buf += ecc_cfg->bbm_size;
++				qcom_write_data_dma(snandc, FLASH_BUF_ACC + data_size,
++						    oob_buf, oob_size, 0);
++			}
++		}
++
++		qcom_spi_config_cw_write(snandc);
++
++		if (data_buf)
++			data_buf += data_size;
++		if (oob_buf)
++			oob_buf += oob_size;
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to write page\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_program_oob(struct qcom_nand_controller *snandc,
++				const struct spi_mem_op *op)
++{
++	struct qpic_ecc *ecc_cfg = snandc->qspi->ecc;
++	u8 *oob_buf = NULL;
++	int ret, col, data_size, oob_size;
++	int num_cw = snandc->qspi->num_cw;
++	u32 cfg0, cfg1, ecc_bch_cfg, ecc_buf_cfg;
++
++	cfg0 = (ecc_cfg->cfg0 & ~(7U << CW_PER_PAGE)) |
++				(num_cw - 1) << CW_PER_PAGE;
++	cfg1 = ecc_cfg->cfg1;
++	ecc_bch_cfg = ecc_cfg->ecc_bch_cfg;
++	ecc_buf_cfg = ecc_cfg->ecc_buf_cfg;
++
++	col = ecc_cfg->cw_size * (num_cw - 1);
++
++	oob_buf = snandc->qspi->data_buf;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++	snandc->regs->addr0 = (snandc->qspi->addr1 | cpu_to_le32(col));
++	snandc->regs->addr1 = snandc->qspi->addr2;
++	snandc->regs->cmd = snandc->qspi->cmd;
++	snandc->regs->cfg0 = cpu_to_le32(cfg0);
++	snandc->regs->cfg1 = cpu_to_le32(cfg1);
++	snandc->regs->ecc_bch_cfg = cpu_to_le32(ecc_bch_cfg);
++	snandc->regs->ecc_buf_cfg = cpu_to_le32(ecc_buf_cfg);
++	snandc->regs->exec = cpu_to_le32(1);
++
++	/* calculate the data and oob size for the last codeword/step */
++	data_size = NANDC_STEP_SIZE - ((num_cw - 1) << 2);
++	oob_size = snandc->qspi->mtd->oobavail;
++
++	memset(snandc->data_buffer, 0xff, ecc_cfg->cw_data);
++	/* override new oob content to last codeword */
++	mtd_ooblayout_get_databytes(snandc->qspi->mtd, snandc->data_buffer + data_size,
++				    oob_buf, 0, snandc->qspi->mtd->oobavail);
++	qcom_spi_config_page_write(snandc);
++	qcom_write_data_dma(snandc, FLASH_BUF_ACC, snandc->data_buffer, data_size + oob_size, 0);
++	qcom_spi_config_cw_write(snandc);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret) {
++		dev_err(snandc->dev, "failure to write oob\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static int qcom_spi_program_execute(struct qcom_nand_controller *snandc,
++				    const struct spi_mem_op *op)
++{
++	if (snandc->qspi->page_rw && snandc->qspi->raw_rw)
++		return qcom_spi_program_raw(snandc, op);
++
++	if (snandc->qspi->page_rw)
++		return qcom_spi_program_ecc(snandc, op);
++
++	if (snandc->qspi->oob_rw)
++		return qcom_spi_program_oob(snandc, op);
++
++	return 0;
++}
++
++static u32 qcom_spi_cmd_mapping(struct qcom_nand_controller *snandc, u32 opcode)
++{
++	u32 cmd = 0x0;
++
++	switch (opcode) {
++	case SPINAND_RESET:
++		cmd = (SPI_WP | SPI_HOLD | SPI_TRANSFER_MODE_x1 | OP_RESET_DEVICE);
++		break;
++	case SPINAND_READID:
++		cmd = (SPI_WP | SPI_HOLD | SPI_TRANSFER_MODE_x1 | OP_FETCH_ID);
++		break;
++	case SPINAND_GET_FEATURE:
++		cmd = (SPI_TRANSFER_MODE_x1 | SPI_WP | SPI_HOLD | ACC_FEATURE);
++		break;
++	case SPINAND_SET_FEATURE:
++		cmd = (SPI_TRANSFER_MODE_x1 | SPI_WP | SPI_HOLD | ACC_FEATURE |
++			QPIC_SET_FEATURE);
++		break;
++	case SPINAND_READ:
++		if (snandc->qspi->raw_rw) {
++			cmd = (PAGE_ACC | LAST_PAGE | SPI_TRANSFER_MODE_x1 |
++					SPI_WP | SPI_HOLD | OP_PAGE_READ);
++		} else {
++			cmd = (PAGE_ACC | LAST_PAGE | SPI_TRANSFER_MODE_x1 |
++					SPI_WP | SPI_HOLD | OP_PAGE_READ_WITH_ECC);
++		}
++
++		break;
++	case SPINAND_ERASE:
++		cmd = OP_BLOCK_ERASE | PAGE_ACC | LAST_PAGE | SPI_WP |
++			SPI_HOLD | SPI_TRANSFER_MODE_x1;
++		break;
++	case SPINAND_WRITE_EN:
++		cmd = SPINAND_WRITE_EN;
++		break;
++	case SPINAND_PROGRAM_EXECUTE:
++		cmd = (PAGE_ACC | LAST_PAGE | SPI_TRANSFER_MODE_x1 |
++				SPI_WP | SPI_HOLD | OP_PROGRAM_PAGE);
++		break;
++	case SPINAND_PROGRAM_LOAD:
++		cmd = SPINAND_PROGRAM_LOAD;
++		break;
++	default:
++		dev_err(snandc->dev, "Opcode not supported: %u\n", opcode);
++		return -EOPNOTSUPP;
++	}
++
++	return cmd;
++}
++
++static int qcom_spi_write_page(struct qcom_nand_controller *snandc,
++			       const struct spi_mem_op *op)
++{
++	struct qpic_snand_op s_op = {};
++	u32 cmd;
++
++	cmd = qcom_spi_cmd_mapping(snandc, op->cmd.opcode);
++	if (cmd < 0)
++		return cmd;
++
++	s_op.cmd_reg = cmd;
++
++	if (op->cmd.opcode == SPINAND_PROGRAM_LOAD)
++		snandc->qspi->data_buf = (u8 *)op->data.buf.out;
++
++	return 0;
++}
++
++static int qcom_spi_send_cmdaddr(struct qcom_nand_controller *snandc,
++				 const struct spi_mem_op *op)
++{
++	struct qpic_snand_op s_op = {};
++	u32 cmd;
++	int ret, opcode;
++
++	cmd = qcom_spi_cmd_mapping(snandc, op->cmd.opcode);
++	if (cmd < 0)
++		return cmd;
++
++	s_op.cmd_reg = cmd;
++	s_op.addr1_reg = op->addr.val;
++	s_op.addr2_reg = 0;
++
++	opcode = op->cmd.opcode;
++
++	switch (opcode) {
++	case SPINAND_WRITE_EN:
++		return 0;
++	case SPINAND_PROGRAM_EXECUTE:
++		s_op.addr1_reg = op->addr.val << 16;
++		s_op.addr2_reg = op->addr.val >> 16 & 0xff;
++		snandc->qspi->addr1 = cpu_to_le32(s_op.addr1_reg);
++		snandc->qspi->addr2 = cpu_to_le32(s_op.addr2_reg);
++		snandc->qspi->cmd = cpu_to_le32(cmd);
++		return qcom_spi_program_execute(snandc, op);
++	case SPINAND_READ:
++		s_op.addr1_reg = (op->addr.val << 16);
++		s_op.addr2_reg = op->addr.val >> 16 & 0xff;
++		snandc->qspi->addr1 = cpu_to_le32(s_op.addr1_reg);
++		snandc->qspi->addr2 = cpu_to_le32(s_op.addr2_reg);
++		snandc->qspi->cmd = cpu_to_le32(cmd);
++		return 0;
++	case SPINAND_ERASE:
++		s_op.addr2_reg = (op->addr.val >> 16) & 0xffff;
++		s_op.addr1_reg = op->addr.val;
++		snandc->qspi->addr1 = cpu_to_le32(s_op.addr1_reg << 16);
++		snandc->qspi->addr2 = cpu_to_le32(s_op.addr2_reg);
++		snandc->qspi->cmd = cpu_to_le32(cmd);
++		qcom_spi_block_erase(snandc);
++		return 0;
++	default:
++		break;
++	}
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++
++	snandc->regs->cmd = cpu_to_le32(s_op.cmd_reg);
++	snandc->regs->exec = cpu_to_le32(1);
++	snandc->regs->addr0 = cpu_to_le32(s_op.addr1_reg);
++	snandc->regs->addr1 = cpu_to_le32(s_op.addr2_reg);
++
++	qcom_write_reg_dma(snandc, &snandc->regs->cmd, NAND_FLASH_CMD, 3, NAND_BAM_NEXT_SGL);
++	qcom_write_reg_dma(snandc, &snandc->regs->exec, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
++
++	ret = qcom_submit_descs(snandc);
++	if (ret)
++		dev_err(snandc->dev, "failure in submitting cmd descriptor\n");
++
++	return ret;
++}
++
++static int qcom_spi_io_op(struct qcom_nand_controller *snandc, const struct spi_mem_op *op)
++{
++	int ret, val, opcode;
++	bool copy = false, copy_ftr = false;
++
++	ret = qcom_spi_send_cmdaddr(snandc, op);
++	if (ret)
++		return ret;
++
++	snandc->buf_count = 0;
++	snandc->buf_start = 0;
++	qcom_clear_read_regs(snandc);
++	qcom_clear_bam_transaction(snandc);
++	opcode = op->cmd.opcode;
++
++	switch (opcode) {
++	case SPINAND_READID:
++		snandc->buf_count = 4;
++		qcom_read_reg_dma(snandc, NAND_READ_ID, 1, NAND_BAM_NEXT_SGL);
++		copy = true;
++		break;
++	case SPINAND_GET_FEATURE:
++		snandc->buf_count = 4;
++		qcom_read_reg_dma(snandc, NAND_FLASH_FEATURES, 1, NAND_BAM_NEXT_SGL);
++		copy_ftr = true;
++		break;
++	case SPINAND_SET_FEATURE:
++		snandc->regs->flash_feature = cpu_to_le32(*(u32 *)op->data.buf.out);
++		qcom_write_reg_dma(snandc, &snandc->regs->flash_feature,
++				   NAND_FLASH_FEATURES, 1, NAND_BAM_NEXT_SGL);
++		break;
++	case SPINAND_PROGRAM_EXECUTE:
++	case SPINAND_WRITE_EN:
++	case SPINAND_RESET:
++	case SPINAND_ERASE:
++	case SPINAND_READ:
++		return 0;
++	default:
++		return -EOPNOTSUPP;
++	}
++
++	ret = qcom_submit_descs(snandc);
++	if (ret)
++		dev_err(snandc->dev, "failure in submitting descriptor for:%d\n", opcode);
++
++	if (copy) {
++		qcom_nandc_dev_to_mem(snandc, true);
++		memcpy(op->data.buf.in, snandc->reg_read_buf, snandc->buf_count);
++	}
++
++	if (copy_ftr) {
++		qcom_nandc_dev_to_mem(snandc, true);
++		val = le32_to_cpu(*(__le32 *)snandc->reg_read_buf);
++		val >>= 8;
++		memcpy(op->data.buf.in, &val, snandc->buf_count);
++	}
++
++	return ret;
++}
++
++static bool qcom_spi_is_page_op(const struct spi_mem_op *op)
++{
++	if (op->addr.buswidth != 1 && op->addr.buswidth != 2 && op->addr.buswidth != 4)
++		return false;
++
++	if (op->data.dir == SPI_MEM_DATA_IN) {
++		if (op->addr.buswidth == 4 && op->data.buswidth == 4)
++			return true;
++
++		if (op->addr.nbytes == 2 && op->addr.buswidth == 1)
++			return true;
++
++	} else if (op->data.dir == SPI_MEM_DATA_OUT) {
++		if (op->data.buswidth == 4)
++			return true;
++		if (op->addr.nbytes == 2 && op->addr.buswidth == 1)
++			return true;
++	}
++
++	return false;
++}
++
++static bool qcom_spi_supports_op(struct spi_mem *mem, const struct spi_mem_op *op)
++{
++	if (!spi_mem_default_supports_op(mem, op))
++		return false;
++
++	if (op->cmd.nbytes != 1 || op->cmd.buswidth != 1)
++		return false;
++
++	if (qcom_spi_is_page_op(op))
++		return true;
++
++	return ((!op->addr.nbytes || op->addr.buswidth == 1) &&
++		(!op->dummy.nbytes || op->dummy.buswidth == 1) &&
++		(!op->data.nbytes || op->data.buswidth == 1));
++}
++
++static int qcom_spi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
++{
++	struct qcom_nand_controller *snandc = spi_controller_get_devdata(mem->spi->controller);
++
++	dev_dbg(snandc->dev, "OP %02x ADDR %08llX@%d:%u DATA %d:%u", op->cmd.opcode,
++		op->addr.val, op->addr.buswidth, op->addr.nbytes,
++		op->data.buswidth, op->data.nbytes);
++
++	if (qcom_spi_is_page_op(op)) {
++		if (op->data.dir == SPI_MEM_DATA_IN)
++			return qcom_spi_read_page(snandc, op);
++		if (op->data.dir == SPI_MEM_DATA_OUT)
++			return qcom_spi_write_page(snandc, op);
++	} else {
++		return qcom_spi_io_op(snandc, op);
++	}
++
++	return 0;
++}
++
++static const struct spi_controller_mem_ops qcom_spi_mem_ops = {
++	.supports_op = qcom_spi_supports_op,
++	.exec_op = qcom_spi_exec_op,
++};
++
++static const struct spi_controller_mem_caps qcom_spi_mem_caps = {
++	.ecc = true,
++};
++
++static int qcom_spi_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct spi_controller *ctlr;
++	struct qcom_nand_controller *snandc;
++	struct qpic_spi_nand *qspi;
++	struct qpic_ecc *ecc;
++	struct resource *res;
++	const void *dev_data;
++	int ret;
++
++	ecc = devm_kzalloc(dev, sizeof(*ecc), GFP_KERNEL);
++	if (!ecc)
++		return -ENOMEM;
++
++	qspi = devm_kzalloc(dev, sizeof(*qspi), GFP_KERNEL);
++	if (!qspi)
++		return -ENOMEM;
++
++	ctlr = __devm_spi_alloc_controller(dev, sizeof(*snandc), false);
++	if (!ctlr)
++		return -ENOMEM;
++
++	platform_set_drvdata(pdev, ctlr);
++
++	snandc = spi_controller_get_devdata(ctlr);
++	qspi->snandc = snandc;
++
++	snandc->dev = dev;
++	snandc->qspi = qspi;
++	snandc->qspi->ctlr = ctlr;
++	snandc->qspi->ecc = ecc;
++
++	dev_data = of_device_get_match_data(dev);
++	if (!dev_data) {
++		dev_err(&pdev->dev, "failed to get device data\n");
++		return -ENODEV;
++	}
++
++	snandc->props = dev_data;
++	snandc->dev = &pdev->dev;
++
++	snandc->core_clk = devm_clk_get(dev, "core");
++	if (IS_ERR(snandc->core_clk))
++		return PTR_ERR(snandc->core_clk);
++
++	snandc->aon_clk = devm_clk_get(dev, "aon");
++	if (IS_ERR(snandc->aon_clk))
++		return PTR_ERR(snandc->aon_clk);
++
++	snandc->qspi->iomacro_clk = devm_clk_get(dev, "iom");
++	if (IS_ERR(snandc->qspi->iomacro_clk))
++		return PTR_ERR(snandc->qspi->iomacro_clk);
++
++	snandc->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
++	if (IS_ERR(snandc->base))
++		return PTR_ERR(snandc->base);
++
++	snandc->base_phys = res->start;
++	snandc->base_dma = dma_map_resource(dev, res->start, resource_size(res),
++					    DMA_BIDIRECTIONAL, 0);
++	if (dma_mapping_error(dev, snandc->base_dma))
++		return -ENXIO;
++
++	ret = clk_prepare_enable(snandc->core_clk);
++	if (ret)
++		goto err_dis_core_clk;
++
++	ret = clk_prepare_enable(snandc->aon_clk);
++	if (ret)
++		goto err_dis_aon_clk;
++
++	ret = clk_prepare_enable(snandc->qspi->iomacro_clk);
++	if (ret)
++		goto err_dis_iom_clk;
++
++	ret = qcom_nandc_alloc(snandc);
++	if (ret)
++		goto err_snand_alloc;
++
++	ret = qcom_spi_init(snandc);
++	if (ret)
++		goto err_spi_init;
++
++	/* setup ECC engine */
++	snandc->qspi->ecc_eng.dev = &pdev->dev;
++	snandc->qspi->ecc_eng.integration = NAND_ECC_ENGINE_INTEGRATION_PIPELINED;
++	snandc->qspi->ecc_eng.ops = &qcom_spi_ecc_engine_ops_pipelined;
++	snandc->qspi->ecc_eng.priv = snandc;
++
++	ret = nand_ecc_register_on_host_hw_engine(&snandc->qspi->ecc_eng);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to register ecc engine:%d\n", ret);
++		goto err_spi_init;
++	}
++
++	ctlr->num_chipselect = QPIC_QSPI_NUM_CS;
++	ctlr->mem_ops = &qcom_spi_mem_ops;
++	ctlr->mem_caps = &qcom_spi_mem_caps;
++	ctlr->dev.of_node = pdev->dev.of_node;
++	ctlr->mode_bits = SPI_TX_DUAL | SPI_RX_DUAL |
++			    SPI_TX_QUAD | SPI_RX_QUAD;
++
++	ret = spi_register_controller(ctlr);
++	if (ret) {
++		dev_err(&pdev->dev, "spi_register_controller failed.\n");
++		goto err_spi_init;
++	}
++
++	return 0;
++
++err_spi_init:
++	qcom_nandc_unalloc(snandc);
++err_snand_alloc:
++	clk_disable_unprepare(snandc->qspi->iomacro_clk);
++err_dis_iom_clk:
++	clk_disable_unprepare(snandc->aon_clk);
++err_dis_aon_clk:
++	clk_disable_unprepare(snandc->core_clk);
++err_dis_core_clk:
++	dma_unmap_resource(dev, res->start, resource_size(res),
++			   DMA_BIDIRECTIONAL, 0);
++	return ret;
++}
++
++static void qcom_spi_remove(struct platform_device *pdev)
++{
++	struct spi_controller *ctlr = platform_get_drvdata(pdev);
++	struct qcom_nand_controller *snandc = spi_controller_get_devdata(ctlr);
++	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	spi_unregister_controller(ctlr);
++
++	qcom_nandc_unalloc(snandc);
++
++	clk_disable_unprepare(snandc->aon_clk);
++	clk_disable_unprepare(snandc->core_clk);
++	clk_disable_unprepare(snandc->qspi->iomacro_clk);
++
++	dma_unmap_resource(&pdev->dev, snandc->base_dma, resource_size(res),
++			   DMA_BIDIRECTIONAL, 0);
++}
++
++static const struct qcom_nandc_props ipq9574_snandc_props = {
++	.dev_cmd_reg_start = 0x7000,
++	.supports_bam = true,
++};
++
++static const struct of_device_id qcom_snandc_of_match[] = {
++	{
++		.compatible = "qcom,spi-qpic-snand",
++		.data = &ipq9574_snandc_props,
++	},
++	{}
++}
++MODULE_DEVICE_TABLE(of, qcom_snandc_of_match);
++
++static struct platform_driver qcom_spi_driver = {
++	.driver = {
++		.name		= "qcom_snand",
++		.of_match_table = qcom_snandc_of_match,
++	},
++	.probe = qcom_spi_probe,
++	.remove = qcom_spi_remove,
++};
++module_platform_driver(qcom_spi_driver);
++
++MODULE_DESCRIPTION("SPI driver for QPIC QSPI cores");
++MODULE_AUTHOR("Md Sadre Alam <quic_mdalam@quicinc.com>");
++MODULE_LICENSE("GPL");
++
+--- a/include/linux/mtd/nand-qpic-common.h
++++ b/include/linux/mtd/nand-qpic-common.h
+@@ -322,6 +322,10 @@ struct nandc_regs {
+ 	__le32 read_location_last1;
+ 	__le32 read_location_last2;
+ 	__le32 read_location_last3;
++	__le32 spi_cfg;
++	__le32 num_addr_cycle;
++	__le32 busy_wait_cnt;
++	__le32 flash_feature;
+ 
+ 	__le32 erased_cw_detect_cfg_clr;
+ 	__le32 erased_cw_detect_cfg_set;
+@@ -336,6 +340,7 @@ struct nandc_regs {
+  *
+  * @core_clk:			controller clock
+  * @aon_clk:			another controller clock
++ * @iomacro_clk:		io macro clock
+  *
+  * @regs:			a contiguous chunk of memory for DMA register
+  *				writes. contains the register values to be
+@@ -345,6 +350,7 @@ struct nandc_regs {
+  *				initialized via DT match data
+  *
+  * @controller:			base controller structure
++ * @qspi:			qpic spi structure
+  * @host_list:			list containing all the chips attached to the
+  *				controller
+  *
+@@ -389,6 +395,7 @@ struct qcom_nand_controller {
+ 	const struct qcom_nandc_props *props;
+ 
+ 	struct nand_controller *controller;
++	struct qpic_spi_nand *qspi;
+ 	struct list_head host_list;
+ 
+ 	union {
diff --git a/target/linux/qualcommax/patches-6.6/0408-spi-spi-qpic-fix-compilation-issues.patch b/target/linux/qualcommax/patches-6.6/0408-spi-spi-qpic-fix-compilation-issues.patch
new file mode 100644
index 0000000000..03b18e0829
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0408-spi-spi-qpic-fix-compilation-issues.patch
@@ -0,0 +1,45 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Subject: [PATCH] spi: spi-qpic: fix compilation issues
+Date: Sun, 06 Oct 2024 16:34:11 +0400
+
+The compiler will throw a warning when freeing a variable, setting values 
+of u32 to zero using memset, when the number of bytes is greater than the 
+size of the variable passed, so let's set each of the 8 variables 
+contiguously set in memory as part of the structure to zero.
+
+The output type of the remove function is void while it should return an 
+integer indicating success (0) or a negative number as an error. So let's
+switch to use the new .remove_new function which expects nothing to be 
+returned
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/mtd/nand/qpic_common.c
++++ b/drivers/mtd/nand/qpic_common.c
+@@ -82,7 +82,14 @@ void qcom_clear_bam_transaction(struct q
+ 	if (!nandc->props->supports_bam)
+ 		return;
+ 
+-	memset(&bam_txn->bam_ce_pos, 0, sizeof(u32) * 8);
++	bam_txn->bam_ce_pos = 0;
++	bam_txn->bam_ce_start = 0;
++	bam_txn->cmd_sgl_pos = 0;
++	bam_txn->cmd_sgl_start = 0;
++	bam_txn->tx_sgl_pos = 0;
++	bam_txn->tx_sgl_start = 0;
++	bam_txn->rx_sgl_pos = 0;
++	bam_txn->rx_sgl_start = 0;
+ 	bam_txn->last_data_desc = NULL;
+ 
+ 	sg_init_table(bam_txn->cmd_sgl, nandc->max_cwperpage *
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -1624,7 +1624,7 @@ static struct platform_driver qcom_spi_d
+ 		.of_match_table = qcom_snandc_of_match,
+ 	},
+ 	.probe = qcom_spi_probe,
+-	.remove = qcom_spi_remove,
++	.remove_new = qcom_spi_remove,
+ };
+ module_platform_driver(qcom_spi_driver);
+ 
diff --git a/target/linux/qualcommax/patches-6.6/0411-spi-spi-qpic-snand-support-BCH8.patch b/target/linux/qualcommax/patches-6.6/0411-spi-spi-qpic-snand-support-BCH8.patch
new file mode 100644
index 0000000000..6442361b0a
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0411-spi-spi-qpic-snand-support-BCH8.patch
@@ -0,0 +1,53 @@
+From 396886e8644d5b601126b97e0b36c40c5fb5cecf Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:11 +0800
+Subject: [PATCH 1/2] spi: spi-qpic-snand: support BCH8
+
+Add BCH8 error-correcting code support for QPIC SPI Nand controller.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ drivers/spi/spi-qpic-snand.c | 12 ++++++++----
+ 1 file changed, 8 insertions(+), 4 deletions(-)
+
+--- a/drivers/spi/spi-qpic-snand.c
++++ b/drivers/spi/spi-qpic-snand.c
+@@ -252,6 +252,7 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 	struct nand_ecc_props *conf = &nand->ecc.ctx.conf;
+ 	struct mtd_info *mtd = nanddev_to_mtd(nand);
+ 	int cwperpage, bad_block_byte;
++	int ecc_mode;
+ 	struct qpic_ecc *ecc_cfg;
+ 
+ 	cwperpage = mtd->writesize / NANDC_STEP_SIZE;
+@@ -270,14 +271,17 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 	nand->ecc.ctx.priv = ecc_cfg;
+ 	snandc->qspi->mtd = mtd;
+ 
+-	ecc_cfg->ecc_bytes_hw = 7;
+-	ecc_cfg->spare_bytes = 4;
++	/* BCH8 or BCH4 */
++	ecc_mode = mtd->oobsize > 64 ? 1 : 0;
++
++	ecc_cfg->ecc_bytes_hw = ecc_mode ? 13 : 7;
++	ecc_cfg->spare_bytes = ecc_mode ? 2 : 4;
+ 	ecc_cfg->bbm_size = 1;
+ 	ecc_cfg->bch_enabled = true;
+ 	ecc_cfg->bytes = ecc_cfg->ecc_bytes_hw + ecc_cfg->spare_bytes + ecc_cfg->bbm_size;
+ 
+ 	ecc_cfg->steps = 4;
+-	ecc_cfg->strength = 4;
++	ecc_cfg->strength = ecc_mode ? 8 : 4;
+ 	ecc_cfg->step_size = 512;
+ 	ecc_cfg->cw_data = 516;
+ 	ecc_cfg->cw_size = ecc_cfg->cw_data + ecc_cfg->bytes;
+@@ -319,7 +323,7 @@ static int qcom_spi_ecc_init_ctx_pipelin
+ 			       FIELD_PREP(ECC_SW_RESET, 0) |
+ 			       FIELD_PREP(ECC_NUM_DATA_BYTES_MASK, ecc_cfg->cw_data) |
+ 			       FIELD_PREP(ECC_FORCE_CLK_OPEN, 1) |
+-			       FIELD_PREP(ECC_MODE_MASK, 0) |
++			       FIELD_PREP(ECC_MODE_MASK, ecc_mode) |
+ 			       FIELD_PREP(ECC_PARITY_SIZE_BYTES_BCH_MASK, ecc_cfg->ecc_bytes_hw);
+ 
+ 	ecc_cfg->ecc_buf_cfg = 0x203 << NUM_STEPS;
diff --git a/target/linux/qualcommax/patches-6.6/0412-mtd-spinand-qpic-only-support-max-4-bytes-ID.patch b/target/linux/qualcommax/patches-6.6/0412-mtd-spinand-qpic-only-support-max-4-bytes-ID.patch
new file mode 100644
index 0000000000..3f50be2574
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0412-mtd-spinand-qpic-only-support-max-4-bytes-ID.patch
@@ -0,0 +1,25 @@
+From 3d550dc3eb4eaa2fe1d0668ed67e835c91487d61 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:11 +0800
+Subject: [PATCH 2/2] mtd: spinand: qpic only support max 4 bytes ID
+
+The QPIC SPI NAND controller supports a max of 4 bytes of device ID.
+As such, set a maximum of 4 bytes.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ drivers/mtd/nand/spi/core.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/mtd/nand/spi/core.c
++++ b/drivers/mtd/nand/spi/core.c
+@@ -1087,7 +1087,7 @@ int spinand_match_and_init(struct spinan
+ 		if (rdid_method != info->devid.method)
+ 			continue;
+ 
+-		if (memcmp(id + 1, info->devid.id, info->devid.len))
++		if (memcmp(id + 1, info->devid.id, min(3, info->devid.len)))
+ 			continue;
+ 
+ 		nand->memorg = table[i].memorg;
diff --git a/target/linux/qualcommax/patches-6.6/0421-arm64-dts-qcom-ipq5018-Add-SPI-nand-node.patch b/target/linux/qualcommax/patches-6.6/0421-arm64-dts-qcom-ipq5018-Add-SPI-nand-node.patch
new file mode 100644
index 0000000000..2de155637f
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0421-arm64-dts-qcom-ipq5018-Add-SPI-nand-node.patch
@@ -0,0 +1,52 @@
+From c2019f64539dd24e6e0da3cea2219d6f9e6b03e4 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:11 +0800
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add SPI nand node
+
+Add SPI NAND support for IPQ5018 SoC.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 40 +++++++++++++++++++++++++++
+ 1 file changed, 40 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -461,6 +461,36 @@
+ 			status = "disabled";
+ 		};
+ 
++		qpic_bam: dma@7984000 {
++			compatible = "qcom,bam-v1.7.0";
++			reg = <0x07984000 0x1c000>;
++			interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&gcc GCC_QPIC_AHB_CLK>;
++			clock-names = "bam_clk";
++			#dma-cells = <1>;
++			qcom,ee = <0>;
++			status = "disabled";
++		};
++
++		qpic_nand: qpic-nand@79b0000 {
++			compatible = "qcom,spi-qpic-snand";
++			reg = <0x079b0000 0x10000>;
++			#address-cells = <1>;
++			#size-cells = <0>;
++			clocks = <&gcc GCC_QPIC_CLK>,
++				 <&gcc GCC_QPIC_AHB_CLK>,
++				 <&gcc GCC_QPIC_IO_MACRO_CLK>;
++			clock-names = "core", "aon", "iom";
++
++			dmas = <&qpic_bam 0>,
++			       <&qpic_bam 1>,
++			       <&qpic_bam 2>,
++			       <&qpic_bam 3>;
++			dma-names = "tx", "rx", "cmd", "status";
++
++			status = "disabled";
++		};
++
+ 		usb: usb@8af8800 {
+ 			compatible = "qcom,ipq5018-dwc3", "qcom,dwc3";
+ 			reg = <0x08af8800 0x400>;
diff --git a/target/linux/qualcommax/patches-6.6/0431-arm64-dts-qcom-ipq5018-Add-more-nand-compatible-for-.patch b/target/linux/qualcommax/patches-6.6/0431-arm64-dts-qcom-ipq5018-Add-more-nand-compatible-for-.patch
new file mode 100644
index 0000000000..fdbea3cf62
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0431-arm64-dts-qcom-ipq5018-Add-more-nand-compatible-for-.patch
@@ -0,0 +1,23 @@
+From b76a7649402d3eb1245ab463832133fc7efda194 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:11 +0800
+Subject: [PATCH] arm64: dts: qcom: ipq5018: Add more nand compatible for
+ uboot to fix partitions
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -473,7 +473,7 @@
+ 		};
+ 
+ 		qpic_nand: qpic-nand@79b0000 {
+-			compatible = "qcom,spi-qpic-snand";
++			compatible = "qcom,spi-qpic-snand", "qcom,ebi2-nandc-bam-v2.1.1";
+ 			reg = <0x079b0000 0x10000>;
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
diff --git a/target/linux/qualcommax/patches-6.6/0701-dt-bindings-clock-qcom-Add-CMN-PLL-clock-controller-.patch b/target/linux/qualcommax/patches-6.6/0701-dt-bindings-clock-qcom-Add-CMN-PLL-clock-controller-.patch
new file mode 100644
index 0000000000..ad7e08c895
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0701-dt-bindings-clock-qcom-Add-CMN-PLL-clock-controller-.patch
@@ -0,0 +1,113 @@
+From 7b89dbf5c7dcd8a9c131721e93c1292e5993968b Mon Sep 17 00:00:00 2001
+From: Luo Jie <quic_luoj@quicinc.com>
+Date: Tue, 20 Aug 2024 22:02:42 +0800
+Subject: [PATCH] dt-bindings: clock: qcom: Add CMN PLL clock controller
+ for IPQ SoC
+
+The CMN PLL controller provides clocks to networking hardware blocks
+on Qualcomm IPQ9574 SoC. It receives input clock from the on-chip Wi-Fi,
+and produces output clocks at fixed rates. These output rates are
+predetermined, and are unrelated to the input clock rate. The output
+clocks are supplied to the Ethernet hardware such as PPE (packet
+process engine) and the externally connected switch or PHY device.
+
+Signed-off-by: Luo Jie <quic_luoj@quicinc.com>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+---
+ .../bindings/clock/qcom,ipq9574-cmn-pll.yaml  | 70 +++++++++++++++++++
+ include/dt-bindings/clock/qcom,ipq-cmn-pll.h  | 15 ++++
+ 2 files changed, 85 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/clock/qcom,ipq9574-cmn-pll.yaml
+ create mode 100644 include/dt-bindings/clock/qcom,ipq-cmn-pll.h
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/clock/qcom,ipq9574-cmn-pll.yaml
+@@ -0,0 +1,70 @@
++# SPDX-License-Identifier: GPL-2.0-only OR BSD-2-Clause
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/clock/qcom,ipq9574-cmn-pll.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Qualcomm CMN PLL Clock Controller on IPQ SoC
++
++maintainers:
++  - Bjorn Andersson <andersson@kernel.org>
++  - Luo Jie <quic_luoj@quicinc.com>
++
++description:
++  The CMN PLL clock controller expects a reference input clock.
++  This reference clock is from the on-board Wi-Fi. The CMN PLL
++  supplies a number of fixed rate output clocks to the Ethernet
++  devices including PPE (packet process engine) and the connected
++  switch or PHY device.
++
++properties:
++  compatible:
++    enum:
++      - qcom,ipq9574-cmn-pll
++
++  reg:
++    maxItems: 1
++
++  clocks:
++    items:
++      - description: The reference clock. The supported clock rates include
++          25000000, 31250000, 40000000, 48000000, 50000000 and 96000000 HZ.
++      - description: The AHB clock
++      - description: The SYS clock
++    description:
++      The reference clock is the source clock of CMN PLL, which is from the
++      Wi-Fi. The AHB and SYS clocks must be enabled to access CMN PLL
++      clock registers.
++
++  clock-names:
++    items:
++      - const: ref
++      - const: ahb
++      - const: sys
++
++  "#clock-cells":
++    const: 1
++
++required:
++  - compatible
++  - reg
++  - clocks
++  - clock-names
++  - "#clock-cells"
++
++additionalProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/clock/qcom,ipq9574-gcc.h>
++
++    clock-controller@9b000 {
++        compatible = "qcom,ipq9574-cmn-pll";
++        reg = <0x0009b000 0x800>;
++        clocks = <&cmn_pll_ref_clk>,
++                 <&gcc GCC_CMN_12GPLL_AHB_CLK>,
++                 <&gcc GCC_CMN_12GPLL_SYS_CLK>;
++        clock-names = "ref", "ahb", "sys";
++        #clock-cells = <1>;
++    };
++...
+--- /dev/null
++++ b/include/dt-bindings/clock/qcom,ipq-cmn-pll.h
+@@ -0,0 +1,15 @@
++/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
++/*
++ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
++#ifndef _DT_BINDINGS_CLK_QCOM_IPQ_CMN_PLL_H
++#define _DT_BINDINGS_CLK_QCOM_IPQ_CMN_PLL_H
++
++/* The output clocks from CMN PLL of IPQ9574. */
++#define PPE_353MHZ_CLK			0
++#define ETH0_50MHZ_CLK			1
++#define ETH1_50MHZ_CLK			2
++#define ETH2_50MHZ_CLK			3
++#define ETH_25MHZ_CLK			4
++#endif
diff --git a/target/linux/qualcommax/patches-6.6/0702-clk-qcom-Add-CMN-PLL-clock-controller-driver-for-IPQ.patch b/target/linux/qualcommax/patches-6.6/0702-clk-qcom-Add-CMN-PLL-clock-controller-driver-for-IPQ.patch
new file mode 100644
index 0000000000..afccffa67e
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0702-clk-qcom-Add-CMN-PLL-clock-controller-driver-for-IPQ.patch
@@ -0,0 +1,288 @@
+From a7e8397e2db6133e3435054a3f312dbd9cab05ed Mon Sep 17 00:00:00 2001
+From: Luo Jie <quic_luoj@quicinc.com>
+Date: Tue, 20 Aug 2024 22:02:43 +0800
+Subject: [PATCH] clk: qcom: Add CMN PLL clock controller driver for IPQ
+ SoC
+
+The CMN PLL clock controller supplies clocks to the hardware
+blocks that together make up the Ethernet function on Qualcomm
+IPQ SoCs. The driver is initially supported for IPQ9574 SoC.
+
+The CMN PLL clock controller expects a reference input clock
+from the on-board Wi-Fi block acting as clock source. The input
+reference clock needs to be configured to one of the supported
+clock rates.
+
+The controller supplies a number of fixed-rate output clocks.
+For the IPQ9574, there is one output clock of 353 MHZ to PPE
+(Packet Process Engine) hardware block, three 50 MHZ output
+clocks and an additional 25 MHZ output clock supplied to the
+connected Ethernet devices.
+
+Signed-off-by: Luo Jie <quic_luoj@quicinc.com>
+---
+ drivers/clk/qcom/Kconfig           |  10 ++
+ drivers/clk/qcom/Makefile          |   1 +
+ drivers/clk/qcom/clk-ipq-cmn-pll.c | 227 +++++++++++++++++++++++++++++
+ 3 files changed, 238 insertions(+)
+ create mode 100644 drivers/clk/qcom/clk-ipq-cmn-pll.c
+
+--- a/drivers/clk/qcom/Kconfig
++++ b/drivers/clk/qcom/Kconfig
+@@ -139,6 +139,16 @@ config IPQ_APSS_6018
+ 	  Say Y if you want to support CPU frequency scaling on
+ 	  ipq based devices.
+ 
++config IPQ_CMN_PLL
++	tristate "IPQ CMN PLL Clock Controller"
++	depends on IPQ_GCC_9574
++	help
++	  Support for CMN PLL clock controller on IPQ platform. The
++	  CMN PLL feeds the reference clocks to the Ethernet devices
++	  based on IPQ SoC.
++	  Say Y or M if you want to support CMN PLL clock on the IPQ
++	  based devices.
++
+ config IPQ_GCC_4019
+ 	tristate "IPQ4019 Global Clock Controller"
+ 	help
+--- a/drivers/clk/qcom/Makefile
++++ b/drivers/clk/qcom/Makefile
+@@ -23,6 +23,7 @@ obj-$(CONFIG_APQ_MMCC_8084) += mmcc-apq8
+ obj-$(CONFIG_CLK_GFM_LPASS_SM8250) += lpass-gfm-sm8250.o
+ obj-$(CONFIG_IPQ_APSS_PLL) += apss-ipq-pll.o
+ obj-$(CONFIG_IPQ_APSS_6018) += apss-ipq6018.o
++obj-$(CONFIG_IPQ_CMN_PLL) += clk-ipq-cmn-pll.o
+ obj-$(CONFIG_IPQ_GCC_4019) += gcc-ipq4019.o
+ obj-$(CONFIG_IPQ_GCC_5018) += gcc-ipq5018.o
+ obj-$(CONFIG_IPQ_GCC_5332) += gcc-ipq5332.o
+--- /dev/null
++++ b/drivers/clk/qcom/clk-ipq-cmn-pll.c
+@@ -0,0 +1,227 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2024 Qualcomm Innovation Center, Inc. All rights reserved.
++ */
++
++/*
++ * CMN PLL block expects the reference clock from on-board Wi-Fi block, and
++ * supplies fixed rate clocks as output to the Ethernet hardware blocks.
++ * The Ethernet related blocks include PPE (packet process engine) and the
++ * external connected PHY (or switch) chip receiving clocks from the CMN PLL.
++ *
++ * On the IPQ9574 SoC, There are three clocks with 50 MHZ, one clock with
++ * 25 MHZ which are output from the CMN PLL to Ethernet PHY (or switch),
++ * and one clock with 353 MHZ to PPE.
++ *
++ *               +---------+
++ *               |   GCC   |
++ *               +--+---+--+
++ *           AHB CLK|   |SYS CLK
++ *                  V   V
++ *          +-------+---+------+
++ *          |                  +-------------> eth0-50mhz
++ * REF CLK  |     IPQ9574      |
++ * -------->+                  +-------------> eth1-50mhz
++ *          |  CMN PLL block   |
++ *          |                  +-------------> eth2-50mhz
++ *          |                  |
++ *          +---------+--------+-------------> eth-25mhz
++ *                    |
++ *                    V
++ *                    ppe-353mhz
++ */
++
++#include <dt-bindings/clock/qcom,ipq-cmn-pll.h>
++#include <linux/bitfield.h>
++#include <linux/clk.h>
++#include <linux/clk-provider.h>
++#include <linux/delay.h>
++#include <linux/io.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++
++#define CMN_PLL_REFCLK_SRC_SELECTION		0x28
++#define CMN_PLL_REFCLK_SRC_DIV			GENMASK(9, 8)
++
++#define CMN_PLL_REFCLK_CONFIG			0x784
++#define CMN_PLL_REFCLK_EXTERNAL			BIT(9)
++#define CMN_PLL_REFCLK_DIV			GENMASK(8, 4)
++#define CMN_PLL_REFCLK_INDEX			GENMASK(3, 0)
++
++#define CMN_PLL_POWER_ON_AND_RESET		0x780
++#define CMN_ANA_EN_SW_RSTN			BIT(6)
++
++/**
++ * struct cmn_pll_fixed_output_clk - CMN PLL output clocks information
++ * @id:	Clock specifier to be supplied
++ * @name: Clock name to be registered
++ * @rate: Clock rate
++ */
++struct cmn_pll_fixed_output_clk {
++	unsigned int		id;
++	const char		*name;
++	const unsigned long	rate;
++};
++
++#define CLK_PLL_OUTPUT(_id, _name, _rate) {		\
++	.id = _id,					\
++	.name = _name,					\
++	.rate = _rate,					\
++}
++
++static const struct cmn_pll_fixed_output_clk ipq9574_output_clks[] = {
++	CLK_PLL_OUTPUT(PPE_353MHZ_CLK, "ppe-353mhz", 353000000UL),
++	CLK_PLL_OUTPUT(ETH0_50MHZ_CLK, "eth0-50mhz", 50000000UL),
++	CLK_PLL_OUTPUT(ETH1_50MHZ_CLK, "eth1-50mhz", 50000000UL),
++	CLK_PLL_OUTPUT(ETH2_50MHZ_CLK, "eth2-50mhz", 50000000UL),
++	CLK_PLL_OUTPUT(ETH_25MHZ_CLK, "eth-25mhz", 25000000UL),
++};
++
++static int ipq_cmn_pll_config(struct device *dev, unsigned long parent_rate)
++{
++	void __iomem *base;
++	u32 val;
++
++	base = devm_of_iomap(dev, dev->of_node, 0, NULL);
++	if (IS_ERR(base))
++		return PTR_ERR(base);
++
++	val = readl(base + CMN_PLL_REFCLK_CONFIG);
++	val &= ~(CMN_PLL_REFCLK_EXTERNAL | CMN_PLL_REFCLK_INDEX);
++
++	/*
++	 * Configure the reference input clock selection as per the given rate.
++	 * The output clock rates are always of fixed value.
++	 */
++	switch (parent_rate) {
++	case 25000000:
++		val |= FIELD_PREP(CMN_PLL_REFCLK_INDEX, 3);
++		break;
++	case 31250000:
++		val |= FIELD_PREP(CMN_PLL_REFCLK_INDEX, 4);
++		break;
++	case 40000000:
++		val |= FIELD_PREP(CMN_PLL_REFCLK_INDEX, 6);
++		break;
++	case 48000000:
++		val |= FIELD_PREP(CMN_PLL_REFCLK_INDEX, 7);
++		break;
++	case 50000000:
++		val |= FIELD_PREP(CMN_PLL_REFCLK_INDEX, 8);
++		break;
++	case 96000000:
++		val |= FIELD_PREP(CMN_PLL_REFCLK_INDEX, 7);
++		val &= ~CMN_PLL_REFCLK_DIV;
++		val |= FIELD_PREP(CMN_PLL_REFCLK_DIV, 2);
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	writel(val, base + CMN_PLL_REFCLK_CONFIG);
++
++	/* Update the source clock rate selection. Only 96 MHZ uses 0. */
++	val = readl(base + CMN_PLL_REFCLK_SRC_SELECTION);
++	val &= ~CMN_PLL_REFCLK_SRC_DIV;
++	if (parent_rate != 96000000)
++		val |= FIELD_PREP(CMN_PLL_REFCLK_SRC_DIV, 1);
++
++	writel(val, base + CMN_PLL_REFCLK_SRC_SELECTION);
++
++	/*
++	 * Reset the CMN PLL block by asserting/de-asserting for 100 ms
++	 * each, to ensure the updated configurations take effect.
++	 */
++	val = readl(base + CMN_PLL_POWER_ON_AND_RESET);
++	val &= ~CMN_ANA_EN_SW_RSTN;
++	writel(val, base);
++	msleep(100);
++
++	val |= CMN_ANA_EN_SW_RSTN;
++	writel(val, base + CMN_PLL_POWER_ON_AND_RESET);
++	msleep(100);
++
++	return 0;
++}
++
++static int ipq_cmn_pll_clk_register(struct device *dev, const char *parent)
++{
++	const struct cmn_pll_fixed_output_clk *fixed_clk;
++	struct clk_hw_onecell_data *data;
++	unsigned int num_clks;
++	struct clk_hw *hw;
++	int i;
++
++	num_clks = ARRAY_SIZE(ipq9574_output_clks);
++	fixed_clk = ipq9574_output_clks;
++
++	data = devm_kzalloc(dev, struct_size(data, hws, num_clks), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	for (i = 0; i < num_clks; i++) {
++		hw = devm_clk_hw_register_fixed_rate(dev, fixed_clk[i].name,
++						     parent, 0,
++						     fixed_clk[i].rate);
++		if (IS_ERR(hw))
++			return PTR_ERR(hw);
++
++		data->hws[fixed_clk[i].id] = hw;
++	}
++	data->num = num_clks;
++
++	return devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, data);
++}
++
++static int ipq_cmn_pll_clk_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct clk *clk;
++	int ret;
++
++	/*
++	 * To access the CMN PLL registers, the GCC AHB & SYSY clocks
++	 * for CMN PLL block need to be enabled.
++	 */
++	clk = devm_clk_get_enabled(dev, "ahb");
++	if (IS_ERR(clk))
++		return dev_err_probe(dev, PTR_ERR(clk),
++				     "Enable AHB clock failed\n");
++
++	clk = devm_clk_get_enabled(dev, "sys");
++	if (IS_ERR(clk))
++		return dev_err_probe(dev, PTR_ERR(clk),
++				     "Enable SYS clock failed\n");
++
++	clk = devm_clk_get(dev, "ref");
++	if (IS_ERR(clk))
++		return dev_err_probe(dev, PTR_ERR(clk),
++				     "Get reference clock failed\n");
++
++	/* Configure CMN PLL to apply the reference clock. */
++	ret = ipq_cmn_pll_config(dev, clk_get_rate(clk));
++	if (ret)
++		return dev_err_probe(dev, ret, "Configure CMN PLL failed\n");
++
++	return ipq_cmn_pll_clk_register(dev, __clk_get_name(clk));
++}
++
++static const struct of_device_id ipq_cmn_pll_clk_ids[] = {
++	{ .compatible = "qcom,ipq9574-cmn-pll", },
++	{ }
++};
++
++static struct platform_driver ipq_cmn_pll_clk_driver = {
++	.probe = ipq_cmn_pll_clk_probe,
++	.driver = {
++		.name = "ipq_cmn_pll",
++		.of_match_table = ipq_cmn_pll_clk_ids,
++	},
++};
++
++module_platform_driver(ipq_cmn_pll_clk_driver);
++
++MODULE_DESCRIPTION("Qualcomm Technologies, Inc. IPQ CMN PLL Driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/qualcommax/patches-6.6/0703-clk-qcom-cmn-pll-add-IPQ5018-support.patch b/target/linux/qualcommax/patches-6.6/0703-clk-qcom-cmn-pll-add-IPQ5018-support.patch
new file mode 100644
index 0000000000..9d0d52b8eb
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0703-clk-qcom-cmn-pll-add-IPQ5018-support.patch
@@ -0,0 +1,78 @@
+From a28797563b8c97c9abced82e0cf89302fcd2bf37 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:11 +0800
+Subject: [PATCH 1/2] clk: qcom: cmn-pll: add IPQ5018 support
+
+Add support for IPQ5018 (and removing dependency on the IPQ9574 platform).
+The common network block in IPQ5018 must be enabled first through a 
+specific register at a fixed offset in the TCSR area, set in the DTS.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ drivers/clk/qcom/Kconfig           |  1 -
+ drivers/clk/qcom/clk-ipq-cmn-pll.c | 29 +++++++++++++++++++++++++++++
+ 2 files changed, 29 insertions(+), 1 deletion(-)
+
+--- a/drivers/clk/qcom/Kconfig
++++ b/drivers/clk/qcom/Kconfig
+@@ -141,7 +141,6 @@ config IPQ_APSS_6018
+ 
+ config IPQ_CMN_PLL
+ 	tristate "IPQ CMN PLL Clock Controller"
+-	depends on IPQ_GCC_9574
+ 	help
+ 	  Support for CMN PLL clock controller on IPQ platform. The
+ 	  CMN PLL feeds the reference clocks to the Ethernet devices
+--- a/drivers/clk/qcom/clk-ipq-cmn-pll.c
++++ b/drivers/clk/qcom/clk-ipq-cmn-pll.c
+@@ -42,6 +42,9 @@
+ #include <linux/platform_device.h>
+ #include <linux/slab.h>
+ 
++#define TCSR_ETH_CMN				0x0
++#define  TCSR_ETH_CMN_ENABLE			BIT(0)
++
+ #define CMN_PLL_REFCLK_SRC_SELECTION		0x28
+ #define CMN_PLL_REFCLK_SRC_DIV			GENMASK(9, 8)
+ 
+@@ -79,6 +82,28 @@ static const struct cmn_pll_fixed_output
+ 	CLK_PLL_OUTPUT(ETH_25MHZ_CLK, "eth-25mhz", 25000000UL),
+ };
+ 
++static int ipq_cmn_pll_tcsr_enable(struct platform_device *pdev)
++{
++	struct resource *res;
++	void __iomem *tcsr_base;
++	u32 val;
++
++	/* For IPQ50xx, tcsr is necessary to enable cmn block */
++	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tcsr");
++	if (!res)
++		return 0;
++
++	tcsr_base = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR_OR_NULL(tcsr_base))
++		return PTR_ERR(tcsr_base);
++
++	val = readl(tcsr_base + TCSR_ETH_CMN);
++	val |= TCSR_ETH_CMN_ENABLE;
++	writel(val, (tcsr_base + TCSR_ETH_CMN));
++
++	return 0;
++}
++
+ static int ipq_cmn_pll_config(struct device *dev, unsigned long parent_rate)
+ {
+ 	void __iomem *base;
+@@ -181,6 +206,10 @@ static int ipq_cmn_pll_clk_probe(struct
+ 	struct clk *clk;
+ 	int ret;
+ 
++	ret = ipq_cmn_pll_tcsr_enable(pdev);
++	if (ret)
++		return dev_err_probe(dev, ret, "Enable CMN PLL failed\n");
++
+ 	/*
+ 	 * To access the CMN PLL registers, the GCC AHB & SYSY clocks
+ 	 * for CMN PLL block need to be enabled.
diff --git a/target/linux/qualcommax/patches-6.6/0704-arm64-dts-qcom-ipq5018-Add-ethernet-cmn-node.patch b/target/linux/qualcommax/patches-6.6/0704-arm64-dts-qcom-ipq5018-Add-ethernet-cmn-node.patch
new file mode 100644
index 0000000000..8127656ddd
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0704-arm64-dts-qcom-ipq5018-Add-ethernet-cmn-node.patch
@@ -0,0 +1,45 @@
+From 1b625a37b96b0448aac126d7720eec38de8e5956 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:11 +0800
+Subject: [PATCH 2/2] arm64: dts: qcom: ipq5018: Add ethernet cmn node
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 19 +++++++++++++++++++
+ 1 file changed, 19 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -16,6 +16,12 @@
+ 	#size-cells = <2>;
+ 
+ 	clocks {
++		cmn_pll_ref_clk: cmn-pll-ref-clk {
++			compatible = "fixed-clock";
++			clock-frequency = <96000000>;
++			#clock-cells = <0>;
++		};
++
+ 		sleep_clk: sleep-clk {
+ 			compatible = "fixed-clock";
+ 			#clock-cells = <0>;
+@@ -186,6 +192,19 @@
+ 			status = "disabled";
+ 		};
+ 
++		cmn_pll: clock-controller@9b000 {
++			compatible = "qcom,ipq9574-cmn-pll";
++			reg = <0x0009b000 0x800>,
++			      <0x19475c4 0x4>;
++			reg-names = "cmn",
++				    "tcsr";
++			clocks = <&cmn_pll_ref_clk>,
++				 <&gcc GCC_CMN_BLK_AHB_CLK>,
++				 <&gcc GCC_CMN_BLK_SYS_CLK>;
++			clock-names = "ref", "ahb", "sys";
++			#clock-cells = <1>;
++		};
++
+ 		qfprom: qfprom@a0000 {
+ 			compatible = "qcom,ipq5018-qfprom", "qcom,qfprom";
+ 			reg = <0xa0000 0x1000>;
diff --git a/target/linux/qualcommax/patches-6.6/0711-net-phy-qcom-Introduce-IPQ5018-internal-PHY-driver.patch b/target/linux/qualcommax/patches-6.6/0711-net-phy-qcom-Introduce-IPQ5018-internal-PHY-driver.patch
new file mode 100644
index 0000000000..7764df4219
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0711-net-phy-qcom-Introduce-IPQ5018-internal-PHY-driver.patch
@@ -0,0 +1,184 @@
+From 77ad12b3a5e21cae859247c0b82cf9a5b661e531 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:11 +0800
+Subject: [PATCH 1/3] net: phy: qcom: Introduce IPQ5018 internal PHY driver
+
+Introduce the internal GE PHY driver, part of the Qualcomm IPQ50xx SoC.
+The driver registers two clock providers needed and referenced by the GCC 
+using DT properties and phandles.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ drivers/net/phy/qcom/Kconfig   |   6 ++
+ drivers/net/phy/qcom/Makefile  |   1 +
+ drivers/net/phy/qcom/ipq5018.c | 138 +++++++++++++++++++++++++++++++++
+ 3 files changed, 145 insertions(+)
+ create mode 100644 drivers/net/phy/qcom/ipq5018.c
+
+--- a/drivers/net/phy/qcom/Kconfig
++++ b/drivers/net/phy/qcom/Kconfig
+@@ -9,6 +9,12 @@ config AT803X_PHY
+ 	help
+ 	  Currently supports the AR8030, AR8031, AR8033, AR8035 model
+ 
++config IPQ5018_PHY
++	tristate "Qualcomm IPQ5018 internal PHYs"
++	select QCOM_NET_PHYLIB
++	help
++	  Currently supports the Qualcomm IPQ5018 internal PHY
++
+ config QCA83XX_PHY
+ 	tristate "Qualcomm Atheros QCA833x PHYs"
+ 	select QCOM_NET_PHYLIB
+--- a/drivers/net/phy/qcom/Makefile
++++ b/drivers/net/phy/qcom/Makefile
+@@ -1,6 +1,7 @@
+ # SPDX-License-Identifier: GPL-2.0
+ obj-$(CONFIG_QCOM_NET_PHYLIB)	+= qcom-phy-lib.o
+ obj-$(CONFIG_AT803X_PHY)	+= at803x.o
++obj-$(CONFIG_IPQ5018_PHY)	+= ipq5018.o
+ obj-$(CONFIG_QCA83XX_PHY)	+= qca83xx.o
+ obj-$(CONFIG_QCA808X_PHY)	+= qca808x.o
+ obj-$(CONFIG_QCA807X_PHY)	+= qca807x.o
+--- /dev/null
++++ b/drivers/net/phy/qcom/ipq5018.c
+@@ -0,0 +1,138 @@
++#include <linux/bitfield.h>
++#include <linux/clk.h>
++#include <linux/clk-provider.h>
++#include <linux/phy.h>
++#include <linux/reset.h>
++
++#include "qcom.h"
++
++#define IPQ5018_PHY_ID			0x004dd0c0
++
++#define TX_RX_CLK_RATE			125000000 /* 125M */
++
++#define IPQ5018_PHY_FIFO_CONTROL	0x19
++#define  IPQ5018_PHY_FIFO_RESET		GENMASK(1, 0)
++
++struct ipq5018_phy {
++	int num_clks;
++	struct clk_bulk_data *clks;
++	struct reset_control *rst;
++
++	struct clk_hw *clk_rx, *clk_tx;
++	struct clk_hw_onecell_data *clk_data;
++};
++
++static int ipq5018_probe(struct phy_device *phydev)
++{
++	struct ipq5018_phy *priv;
++	struct device *dev = &phydev->mdio.dev;
++	char name[64];
++	int ret;
++
++	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
++	if (!priv)
++		return dev_err_probe(dev, -ENOMEM,
++				     "failed to allocate priv\n");
++
++	priv->num_clks = devm_clk_bulk_get_all(dev, &priv->clks);
++	if (priv->num_clks < 0)
++		return dev_err_probe(dev, priv->num_clks,
++				     "failed to acquire clocks\n");
++
++	ret = clk_bulk_prepare_enable(priv->num_clks, priv->clks);
++	if (ret)
++		return dev_err_probe(dev, ret,
++				     "failed to enable clocks\n");
++
++	priv->rst = devm_reset_control_array_get_exclusive(dev);
++	if (IS_ERR_OR_NULL(priv->rst))
++		return dev_err_probe(dev, PTR_ERR(priv->rst),
++				     "failed to acquire reset\n");
++
++	ret = reset_control_reset(priv->rst);
++	if (ret)
++		return dev_err_probe(dev, ret,
++				     "failed to reset\n");
++
++	snprintf(name, sizeof(name), "%s#rx", dev_name(dev));
++	priv->clk_rx = clk_hw_register_fixed_rate(dev, name, NULL, 0,
++						  TX_RX_CLK_RATE);
++	if (IS_ERR_OR_NULL(priv->clk_rx))
++		return dev_err_probe(dev, PTR_ERR(priv->clk_rx),
++				     "failed to register rx clock\n");
++
++	snprintf(name, sizeof(name), "%s#tx", dev_name(dev));
++	priv->clk_tx = clk_hw_register_fixed_rate(dev, name, NULL, 0,
++						  TX_RX_CLK_RATE);
++	if (IS_ERR_OR_NULL(priv->clk_tx))
++		return dev_err_probe(dev, PTR_ERR(priv->clk_tx),
++				     "failed to register tx clock\n");
++
++	priv->clk_data = devm_kzalloc(dev,
++				      struct_size(priv->clk_data, hws, 2),
++				      GFP_KERNEL);
++	if (!priv->clk_data)
++		return dev_err_probe(dev, -ENOMEM,
++				     "failed to allocate clk_data\n");
++
++	priv->clk_data->num = 2;
++	priv->clk_data->hws[0] = priv->clk_rx;
++	priv->clk_data->hws[1] = priv->clk_tx;
++	ret = of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,
++				     priv->clk_data);
++	if (ret)
++		return dev_err_probe(dev, ret,
++				     "fail to register clock provider\n");
++
++	return 0;
++}
++
++static int ipq5018_soft_reset(struct phy_device *phydev)
++{
++	int ret;
++
++	ret = phy_modify(phydev, IPQ5018_PHY_FIFO_CONTROL,
++			 IPQ5018_PHY_FIFO_RESET, 0);
++	if (ret < 0)
++		return ret;
++
++	msleep(50);
++
++	ret = phy_modify(phydev, IPQ5018_PHY_FIFO_CONTROL,
++			 IPQ5018_PHY_FIFO_RESET, IPQ5018_PHY_FIFO_RESET);
++	if (ret < 0)
++		return ret;
++
++	return 0;
++}
++
++static int ipq5018_cable_test_start(struct phy_device *phydev)
++{
++	/* we do all the (time consuming) work later */
++	return 0;
++}
++
++static struct phy_driver ipq5018_internal_phy_driver[] = {
++	{
++		PHY_ID_MATCH_EXACT(IPQ5018_PHY_ID),
++		.name		= "Qualcomm IPQ5018 internal PHY",
++		.flags		= PHY_IS_INTERNAL | PHY_POLL_CABLE_TEST,
++		.probe		= ipq5018_probe,
++		.soft_reset	= ipq5018_soft_reset,
++		.read_status	= at803x_read_status,
++		.config_intr	= at803x_config_intr,
++		.handle_interrupt = at803x_handle_interrupt,
++		.cable_test_start	= ipq5018_cable_test_start,
++		.cable_test_get_status	= qca808x_cable_test_get_status,
++	},
++};
++module_phy_driver(ipq5018_internal_phy_driver);
++
++static struct mdio_device_id __maybe_unused ipq5018_internal_phy_ids[] = {
++	{ PHY_ID_MATCH_EXACT(IPQ5018_PHY_ID) },
++	{ }
++};
++MODULE_DEVICE_TABLE(mdio, ipq5018_internal_phy_ids);
++
++MODULE_DESCRIPTION("Qualcomm IPQ5018 internal PHY driver");
++MODULE_AUTHOR("Ziyang Huang <hzyitc@outlook.com>");
diff --git a/target/linux/qualcommax/patches-6.6/0712-arm64-dts-qcom-ipq5018-add-mdio-node.patch b/target/linux/qualcommax/patches-6.6/0712-arm64-dts-qcom-ipq5018-add-mdio-node.patch
new file mode 100644
index 0000000000..ce5367a085
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0712-arm64-dts-qcom-ipq5018-add-mdio-node.patch
@@ -0,0 +1,43 @@
+From d2cdc83fb2c7360856e598810b88211d815fc851 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH 2/3] arm64: dts: qcom: ipq5018: add mdio node
+
+The IPQ5018 SoC contains two MDIO controllers. MDIO0 is used to control 
+its internal GE Phy, while MDIO1 is wired to external PHYs/switch.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 20 ++++++++++++++++++++
+ 1 file changed, 20 insertions(+)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -192,6 +192,26 @@
+ 			status = "disabled";
+ 		};
+ 
++		mdio0: mdio@88000 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			compatible = "qcom,ipq5018-mdio", "qcom,qca-mdio";
++			reg = <0x88000 0x64>;
++			clocks = <&gcc GCC_MDIO0_AHB_CLK>;
++			clock-names = "gcc_mdio_ahb_clk";
++			status = "disabled";
++		};
++
++		mdio1: mdio@90000 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			compatible = "qcom,ipq5018-mdio";
++			reg = <0x90000 0x64>;
++			clocks = <&gcc GCC_MDIO1_AHB_CLK>;
++			clock-names = "gcc_mdio_ahb_clk";
++			status = "disabled";
++		};
++
+ 		cmn_pll: clock-controller@9b000 {
+ 			compatible = "qcom,ipq9574-cmn-pll";
+ 			reg = <0x0009b000 0x800>,
diff --git a/target/linux/qualcommax/patches-6.6/0713-arm64-dts-qcom-ipq5018-add-ge_phy-node.patch b/target/linux/qualcommax/patches-6.6/0713-arm64-dts-qcom-ipq5018-add-ge_phy-node.patch
new file mode 100644
index 0000000000..9ac109858d
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0713-arm64-dts-qcom-ipq5018-add-ge_phy-node.patch
@@ -0,0 +1,45 @@
+From 28490d95fe9e059c5ce74b2289d66e0d7ede2d50 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH 3/3] arm64: dts: qcom: ipq5018: add ge_phy node
+
+Add the GE PHY node and register the output clocks in the GCC node.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ arch/arm64/boot/dts/qcom/ipq5018.dtsi | 16 ++++++++++++++--
+ 1 file changed, 14 insertions(+), 2 deletions(-)
+
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -200,6 +200,18 @@
+ 			clocks = <&gcc GCC_MDIO0_AHB_CLK>;
+ 			clock-names = "gcc_mdio_ahb_clk";
+ 			status = "disabled";
++
++			ge_phy: ethernet-phy@7 {
++				compatible = "ethernet-phy-id004d.d0c0";
++				reg = <7>;
++				resets = <&gcc GCC_GEPHY_BCR>,
++					 <&gcc GCC_GEPHY_MDC_SW_ARES>,
++					 <&gcc GCC_GEPHY_DSP_HW_ARES>,
++					 <&gcc GCC_GEPHY_RX_ARES>,
++					 <&gcc GCC_GEPHY_TX_ARES>;
++				clocks = <&gcc GCC_GEPHY_RX_CLK>,
++					 <&gcc GCC_GEPHY_TX_CLK>;
++			};
+ 		};
+ 
+ 		mdio1: mdio@90000 {
+@@ -394,8 +406,8 @@
+ 				 <&pcie0_phy>,
+ 				 <&pcie1_phy>,
+ 				 <0>,
+-				 <0>,
+-				 <0>,
++				 <&ge_phy 0>,
++				 <&ge_phy 1>,
+ 				 <0>,
+ 				 <0>;
+ 			#clock-cells = <1>;
diff --git a/target/linux/qualcommax/patches-6.6/0714-net-phy-qcom-IPQ5018-enable-configuration-of-DAC-settings.patch b/target/linux/qualcommax/patches-6.6/0714-net-phy-qcom-IPQ5018-enable-configuration-of-DAC-settings.patch
new file mode 100644
index 0000000000..0c773caf38
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0714-net-phy-qcom-IPQ5018-enable-configuration-of-DAC-settings.patch
@@ -0,0 +1,111 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Sun, 19 Jan 2025 11:25:27 +0400
+Subject: [PATCH] net: phy: qcom: ipq5018 enable configuration of DAC settings
+
+Allow setting amplitude and bias current as needed on the IPQ5018 Internal
+GE PHY. When the "qcom,dac" property is set in the DTS, the driver expects
+a pair of u32 values:
+
+(from QCA8337 datasheet)
+11: follow DSP setting
+10: bypass half amplitude and follow DSP half bias current
+01: half amplitude follow DSP and bypass half bias current
+00: full amplitude and full bias current
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/net/phy/qcom/ipq5018.c
++++ b/drivers/net/phy/qcom/ipq5018.c
+@@ -13,6 +13,10 @@
+ #define IPQ5018_PHY_FIFO_CONTROL	0x19
+ #define  IPQ5018_PHY_FIFO_RESET		GENMASK(1, 0)
+ 
++#define IPQ5018_PHY_DEBUG_EDAC			0x4380
++#define IPQ5018_PHY_MMD1_MDAC			0x8100
++#define  IPQ5018_PHY_DAC_MASK			GENMASK(15,8)
++
+ struct ipq5018_phy {
+ 	int num_clks;
+ 	struct clk_bulk_data *clks;
+@@ -20,20 +24,35 @@ struct ipq5018_phy {
+ 
+ 	struct clk_hw *clk_rx, *clk_tx;
+ 	struct clk_hw_onecell_data *clk_data;
++
++	u32 mdac;
++	u32 edac;
+ };
+ 
+ static int ipq5018_probe(struct phy_device *phydev)
+ {
+-	struct ipq5018_phy *priv;
+ 	struct device *dev = &phydev->mdio.dev;
++	struct ipq5018_phy *priv;
++	u32 mdac, edac = 0;
+ 	char name[64];
+-	int ret;
++	int ret, cnt;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return dev_err_probe(dev, -ENOMEM,
+ 				     "failed to allocate priv\n");
+ 
++	cnt = of_property_count_u32_elems(dev->of_node, "qcom,dac");
++	if (cnt == 2) {
++		ret = of_property_read_u32_index(dev->of_node, "qcom,dac", 0, &mdac);
++		if (!ret)
++			priv->mdac = mdac;
++
++		ret = of_property_read_u32_index(dev->of_node, "qcom,dac", 1, &edac);
++		if (!ret)
++			priv->edac = edac;
++	}
++
+ 	priv->num_clks = devm_clk_bulk_get_all(dev, &priv->clks);
+ 	if (priv->num_clks < 0)
+ 		return dev_err_probe(dev, priv->num_clks,
+@@ -84,6 +103,8 @@ static int ipq5018_probe(struct phy_devi
+ 		return dev_err_probe(dev, ret,
+ 				     "fail to register clock provider\n");
+ 
++	phydev->priv = priv;
++
+ 	return 0;
+ }
+ 
+@@ -112,12 +133,34 @@ static int ipq5018_cable_test_start(stru
+ 	return 0;
+ }
+ 
++static int ipq5018_config_init(struct phy_device *phydev)
++{
++	struct ipq5018_phy *priv = phydev->priv;
++	int ret;
++
++	/* setting mdac in MMD1 */
++	if (priv->mdac) {
++		ret = phy_modify_mmd(phydev, MDIO_MMD_PMAPMD, IPQ5018_PHY_MMD1_MDAC,
++							IPQ5018_PHY_DAC_MASK, priv->mdac);
++		if (ret)
++			return ret;
++	}
++
++	/* setting edac in debug register */
++	if (priv->edac)
++		return at803x_debug_reg_mask(phydev, IPQ5018_PHY_DEBUG_EDAC,
++							IPQ5018_PHY_DAC_MASK, priv->edac);
++
++	return 0;
++}
++
+ static struct phy_driver ipq5018_internal_phy_driver[] = {
+ 	{
+ 		PHY_ID_MATCH_EXACT(IPQ5018_PHY_ID),
+ 		.name		= "Qualcomm IPQ5018 internal PHY",
+ 		.flags		= PHY_IS_INTERNAL | PHY_POLL_CABLE_TEST,
+ 		.probe		= ipq5018_probe,
++		.config_init	= ipq5018_config_init,
+ 		.soft_reset	= ipq5018_soft_reset,
+ 		.read_status	= at803x_read_status,
+ 		.config_intr	= at803x_config_intr,
diff --git a/target/linux/qualcommax/patches-6.6/0715-net-phy-qcom-add-IPQ5018-initvals-and-CDT-feature.patch b/target/linux/qualcommax/patches-6.6/0715-net-phy-qcom-add-IPQ5018-initvals-and-CDT-feature.patch
new file mode 100644
index 0000000000..ae4214b0cb
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0715-net-phy-qcom-add-IPQ5018-initvals-and-CDT-feature.patch
@@ -0,0 +1,108 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Fri, 24 Jan 2025 17:18:12 +0400
+Subject: [PATCH] net: phy: qcom: add IPQ5018 initvals and CDT feature
+
+The Cable Diagnostics Test for IPQ5018 follows the same logic as qca808x.
+However, the IPQ5018 GE PHY has its own threshold values. So let's set the
+CDT thresholds for the IPQ5018 internal GE PHY. While add it, add and set
+thesholds for MSE for signal quality measurement and 8023az for EEE.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/net/phy/qcom/ipq5018.c
++++ b/drivers/net/phy/qcom/ipq5018.c
+@@ -17,6 +17,38 @@
+ #define IPQ5018_PHY_MMD1_MDAC			0x8100
+ #define  IPQ5018_PHY_DAC_MASK			GENMASK(15,8)
+ 
++#define IPQ5018_PHY_MMD1_MSE_THRESH1			0x1000
++#define IPQ5018_PHY_MMD1_MSE_THRESH2			0x1001
++#define IPQ5018_PHY_MMD3_AZ_CTRL1				0x8008
++#define IPQ5018_PHY_MMD3_AZ_CTRL2				0x8009
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL3		0x8074
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL4		0x8075
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL5		0x8076
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL6		0x8077
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL7		0x8078
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL9		0x807a
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL13		0x807e
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL14		0x807f
++
++#define IPQ5018_PHY_MMD1_MSE_THRESH1_VAL		0xf1
++#define IPQ5018_PHY_MMD1_MSE_THRESH2_VAL		0x1f6
++#define IPQ5018_PHY_MMD3_AZ_CTRL1_VAL			0x7880
++#define IPQ5018_PHY_MMD3_AZ_CTRL2_VAL			0xc8
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL3_VAL	0xc040
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL4_VAL	0xa060
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL5_VAL	0xc040
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL6_VAL	0xa060
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL7_VAL	0xc24c
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL9_VAL	0xc060
++#define IPQ5018_PHY_MMD3_CDT_THRESH_CTRL13_VAL	0xb060
++#define IPQ5018_PHY_MMD3_NEAR_ECHO_THRESH_VAL	0x90b0
++
++#define IPQ5018_PHY_DEBUG_ANA_LDO_EFUSE				0x1
++#define  IPQ5018_PHY_DEBUG_ANA_LDO_EFUSE_MASK		GENMASK(7,4)
++#define  IPQ5018_PHY_DEBUG_ANA_LDO_EFUSE_DEFAULT	0x50
++
++#define IPQ5018_PHY_DEBUG_ANA_DAC_FILTER		0xa080
++
+ struct ipq5018_phy {
+ 	int num_clks;
+ 	struct clk_bulk_data *clks;
+@@ -129,6 +161,24 @@ static int ipq5018_soft_reset(struct phy
+ 
+ static int ipq5018_cable_test_start(struct phy_device *phydev)
+ {
++	phy_write_mmd(phydev, MDIO_MMD_PCS, IPQ5018_PHY_MMD3_CDT_THRESH_CTRL3,
++				  IPQ5018_PHY_MMD3_CDT_THRESH_CTRL3_VAL);
++	phy_write_mmd(phydev, MDIO_MMD_PCS, IPQ5018_PHY_MMD3_CDT_THRESH_CTRL4,
++				  IPQ5018_PHY_MMD3_CDT_THRESH_CTRL4_VAL);
++	phy_write_mmd(phydev, MDIO_MMD_PCS, IPQ5018_PHY_MMD3_CDT_THRESH_CTRL5,
++				  IPQ5018_PHY_MMD3_CDT_THRESH_CTRL5_VAL);
++	phy_write_mmd(phydev, MDIO_MMD_PCS, IPQ5018_PHY_MMD3_CDT_THRESH_CTRL6,
++				  IPQ5018_PHY_MMD3_CDT_THRESH_CTRL6_VAL);
++	phy_write_mmd(phydev, MDIO_MMD_PCS, IPQ5018_PHY_MMD3_CDT_THRESH_CTRL7,
++				  IPQ5018_PHY_MMD3_CDT_THRESH_CTRL7_VAL);
++	phy_write_mmd(phydev, MDIO_MMD_PCS, IPQ5018_PHY_MMD3_CDT_THRESH_CTRL9,
++				  IPQ5018_PHY_MMD3_CDT_THRESH_CTRL9_VAL);
++	phy_write_mmd(phydev, MDIO_MMD_PCS, 
++				  IPQ5018_PHY_MMD3_CDT_THRESH_CTRL13,
++				  IPQ5018_PHY_MMD3_CDT_THRESH_CTRL13_VAL);
++	phy_write_mmd(phydev, MDIO_MMD_PCS, IPQ5018_PHY_MMD3_CDT_THRESH_CTRL3,
++				  IPQ5018_PHY_MMD3_NEAR_ECHO_THRESH_VAL);
++
+ 	/* we do all the (time consuming) work later */
+ 	return 0;
+ }
+@@ -136,8 +186,30 @@ static int ipq5018_cable_test_start(stru
+ static int ipq5018_config_init(struct phy_device *phydev)
+ {
+ 	struct ipq5018_phy *priv = phydev->priv;
++	u16 val = 0;
+ 	int ret;
+ 
++	/* set LDO efuse: first temporarily store ANA_DAC_FILTER value from 
++	   debug register as it will be reset once the ANA_LDO_EFUSE register
++	   is written to */
++	val = at803x_debug_reg_read(phydev, IPQ5018_PHY_DEBUG_ANA_DAC_FILTER);
++	at803x_debug_reg_mask(phydev, IPQ5018_PHY_DEBUG_ANA_LDO_EFUSE,
++						  IPQ5018_PHY_DEBUG_ANA_LDO_EFUSE_MASK,
++						  IPQ5018_PHY_DEBUG_ANA_LDO_EFUSE_DEFAULT);
++	at803x_debug_reg_write(phydev, IPQ5018_PHY_DEBUG_ANA_DAC_FILTER, val);
++
++	/* set 8023AZ CTRL values */
++	phy_write_mmd(phydev, MDIO_MMD_PCS, IPQ5018_PHY_MMD3_AZ_CTRL1,
++				  IPQ5018_PHY_MMD3_AZ_CTRL1_VAL);
++	phy_write_mmd(phydev, MDIO_MMD_PCS, IPQ5018_PHY_MMD3_AZ_CTRL2,
++				  IPQ5018_PHY_MMD3_AZ_CTRL2_VAL);
++
++	/* set MSE threshold values */
++	phy_write_mmd(phydev, MDIO_MMD_PMAPMD, IPQ5018_PHY_MMD1_MSE_THRESH1,
++				  IPQ5018_PHY_MMD1_MSE_THRESH1_VAL);
++	phy_write_mmd(phydev, MDIO_MMD_PMAPMD, IPQ5018_PHY_MMD1_MSE_THRESH2,
++				  IPQ5018_PHY_MMD1_MSE_THRESH2_VAL);
++
+ 	/* setting mdac in MMD1 */
+ 	if (priv->mdac) {
+ 		ret = phy_modify_mmd(phydev, MDIO_MMD_PMAPMD, IPQ5018_PHY_MMD1_MDAC,
diff --git a/target/linux/qualcommax/patches-6.6/0721-clk-gcc-ipq5018-remove-the-unsupported-clk-combinati.patch b/target/linux/qualcommax/patches-6.6/0721-clk-gcc-ipq5018-remove-the-unsupported-clk-combinati.patch
new file mode 100644
index 0000000000..0a22289d39
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0721-clk-gcc-ipq5018-remove-the-unsupported-clk-combinati.patch
@@ -0,0 +1,35 @@
+From f71366e0530db2c5cecbbbb6edfbf7344bd6f83b Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH 1/2] clk: gcc-ipq5018: remove the unsupported clk
+ combination for gmac
+
+Comment out the unsupported clock combination in the frequency table 
+for GMAC1.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ drivers/clk/qcom/gcc-ipq5018.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/clk/qcom/gcc-ipq5018.c
++++ b/drivers/clk/qcom/gcc-ipq5018.c
+@@ -677,7 +677,7 @@ static const struct freq_tbl ftbl_gmac1_
+ 	F(2500000, P_UNIPHY_RX, 12.5, 0, 0),
+ 	F(24000000, P_XO, 1, 0, 0),
+ 	F(25000000, P_UNIPHY_RX, 2.5, 0, 0),
+-	F(125000000, P_UNIPHY_RX, 2.5, 0, 0),
++	/* F(125000000, P_UNIPHY_RX, 2.5, 0, 0), */
+ 	F(125000000, P_UNIPHY_RX, 1, 0, 0),
+ 	F(312500000, P_UNIPHY_RX, 1, 0, 0),
+ 	{ }
+@@ -717,7 +717,7 @@ static const struct freq_tbl ftbl_gmac1_
+ 	F(2500000, P_UNIPHY_TX, 12.5, 0, 0),
+ 	F(24000000, P_XO, 1, 0, 0),
+ 	F(25000000, P_UNIPHY_TX, 2.5, 0, 0),
+-	F(125000000, P_UNIPHY_TX, 2.5, 0, 0),
++	/* F(125000000, P_UNIPHY_TX, 2.5, 0, 0), */
+ 	F(125000000, P_UNIPHY_TX, 1, 0, 0),
+ 	F(312500000, P_UNIPHY_TX, 1, 0, 0),
+ 	{ }
diff --git a/target/linux/qualcommax/patches-6.6/0722-clk-gcc-ipq5018-refer-to-ge-phy-rx-and-tx-clk-providers-by-name.patch b/target/linux/qualcommax/patches-6.6/0722-clk-gcc-ipq5018-refer-to-ge-phy-rx-and-tx-clk-providers-by-name.patch
new file mode 100644
index 0000000000..6cd1a2a16b
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0722-clk-gcc-ipq5018-refer-to-ge-phy-rx-and-tx-clk-providers-by-name.patch
@@ -0,0 +1,62 @@
+From ce9e56a436e486690097cfbdda2d0c11b60db4c2 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH] clk: gcc-ipq5018: refer to GE PHY rx and tx clk providers by name
+
+QCA-SSDK does not register the output clocks of the onboard GE Phy and 
+uniphy so the GCC and DTS can't reference them by their index.
+The SSDK references them by name, so let's change the GCC driver 
+accordingly.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ drivers/clk/qcom/gcc-ipq5018.c | 16 ++++++++--------
+ 1 file changed, 8 insertions(+), 8 deletions(-)
+
+--- a/drivers/clk/qcom/gcc-ipq5018.c
++++ b/drivers/clk/qcom/gcc-ipq5018.c
+@@ -335,8 +335,8 @@ static const struct parent_map gcc_xo_gp
+ 
+ static const struct clk_parent_data gcc_xo_gephy_gcc_rx_gephy_gcc_tx_ubi32_pll_gpll0[] = {
+ 	{ .index = DT_XO },
+-	{ .index = DT_GEPHY_RX_CLK },
+-	{ .index = DT_GEPHY_TX_CLK },
++	{ .name =  "gephy_gcc_rx", .index = -1 },
++	{ .name =  "gephy_gcc_tx", .index = -1 },
+ 	{ .hw = &ubi32_pll.clkr.hw },
+ 	{ .hw = &gpll0.clkr.hw },
+ };
+@@ -351,8 +351,8 @@ static const struct parent_map gcc_xo_ge
+ 
+ static const struct clk_parent_data gcc_xo_gephy_gcc_tx_gephy_gcc_rx_ubi32_pll_gpll0[] = {
+ 	{ .index = DT_XO },
+-	{ .index = DT_GEPHY_TX_CLK },
+-	{ .index = DT_GEPHY_RX_CLK },
++	{ .name =  "gephy_gcc_tx", .index = -1 },
++	{ .name =  "gephy_gcc_rx", .index = -1 },
+ 	{ .hw = &ubi32_pll.clkr.hw },
+ 	{ .hw = &gpll0.clkr.hw },
+ };
+@@ -367,8 +367,8 @@ static const struct parent_map gcc_xo_ge
+ 
+ static const struct clk_parent_data gcc_xo_uniphy_gcc_rx_uniphy_gcc_tx_ubi32_pll_gpll0[] = {
+ 	{ .index = DT_XO },
+-	{ .index = DT_UNIPHY_RX_CLK },
+-	{ .index = DT_UNIPHY_TX_CLK },
++	{ .name =  "uniphy_gcc_rx", .index = -1 },
++	{ .name =  "uniphy_gcc_tx", .index = -1 },
+ 	{ .hw = &ubi32_pll.clkr.hw },
+ 	{ .hw = &gpll0.clkr.hw },
+ };
+@@ -383,8 +383,8 @@ static const struct parent_map gcc_xo_un
+ 
+ static const struct clk_parent_data gcc_xo_uniphy_gcc_tx_uniphy_gcc_rx_ubi32_pll_gpll0[] = {
+ 	{ .index = DT_XO },
+-	{ .index = DT_UNIPHY_TX_CLK },
+-	{ .index = DT_UNIPHY_RX_CLK },
++	{ .name =  "uniphy_gcc_tx", .index = -1 },
++	{ .name =  "uniphy_gcc_rx", .index = -1 },
+ 	{ .hw = &ubi32_pll.clkr.hw },
+ 	{ .hw = &gpll0.clkr.hw },
+ };
diff --git a/target/linux/qualcommax/patches-6.6/0751-net-dsa-qca8k-always-enable-SGMII-auto-negotiation.patch b/target/linux/qualcommax/patches-6.6/0751-net-dsa-qca8k-always-enable-SGMII-auto-negotiation.patch
new file mode 100644
index 0000000000..bccac8a4eb
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0751-net-dsa-qca8k-always-enable-SGMII-auto-negotiation.patch
@@ -0,0 +1,30 @@
+From d7a41a3ab6b8e3a3158997cda13f1fe28a37268c Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH] net: dsa: qca8k: always enable SGMII auto-negotiation
+
+fixed-link can't work well without this
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+---
+ drivers/net/dsa/qca/qca8k-8xxx.c | 9 ++++-----
+ 1 file changed, 4 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/dsa/qca/qca8k-8xxx.c
++++ b/drivers/net/dsa/qca/qca8k-8xxx.c
+@@ -1545,11 +1545,10 @@ static int qca8k_pcs_config(struct phyli
+ 		return -EINVAL;
+ 	}
+ 
+-	/* Enable/disable SerDes auto-negotiation as necessary */
+-	val = neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED ?
+-		0 : QCA8K_PWS_SERDES_AEN_DIS;
+-
+-	ret = qca8k_rmw(priv, QCA8K_REG_PWS, QCA8K_PWS_SERDES_AEN_DIS, val);
++	/* Enable SerDes auto-negotiation always.
++	 * So fixed-link can work.
++	 */
++	ret = qca8k_rmw(priv, QCA8K_REG_PWS, QCA8K_PWS_SERDES_AEN_DIS, 0);
+ 	if (ret)
+ 		return ret;
+ 
diff --git a/target/linux/qualcommax/patches-6.6/0752-net-dsa-qca8k-support-PHY-to-PHY-CPU-link.patch b/target/linux/qualcommax/patches-6.6/0752-net-dsa-qca8k-support-PHY-to-PHY-CPU-link.patch
new file mode 100644
index 0000000000..e664a717a3
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0752-net-dsa-qca8k-support-PHY-to-PHY-CPU-link.patch
@@ -0,0 +1,49 @@
+From 8a56ac86c2eed13024413aa23a6cda85613d60f9 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sat, 18 Jan 2025 16:18:40 +0800
+Subject: [PATCH 1/2] net: dsa: qca8k: support PHY-to-PHY CPU link
+
+PHY-to-PHY CPU link is a common/demo design in IPQ50xx platform, since it only has a SGMII/SGMII+ link and a MDI link.
+
+For DSA, CPU tag is the only requirement. Fortunately, qca8337 can enable it on any port. So it's ok to trust a PHY-to-PHY link as a CPU link.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+---
+ drivers/net/dsa/qca/qca8k-8xxx.c | 12 +++++++-----
+ 1 file changed, 7 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/dsa/qca/qca8k-8xxx.c
++++ b/drivers/net/dsa/qca/qca8k-8xxx.c
+@@ -1013,7 +1013,7 @@ qca8k_setup_mdio_bus(struct qca8k_priv *
+ 			return err;
+ 		}
+ 
+-		if (!dsa_is_user_port(priv->ds, reg))
++		if (reg == 0 || reg == 6)
+ 			continue;
+ 
+ 		of_get_phy_mode(port, &mode);
+@@ -1088,17 +1088,19 @@ qca8k_setup_mac_pwr_sel(struct qca8k_pri
+ 
+ static int qca8k_find_cpu_port(struct dsa_switch *ds)
+ {
+-	struct qca8k_priv *priv = ds->priv;
++	int i;
+ 
+-	/* Find the connected cpu port. Valid port are 0 or 6 */
+ 	if (dsa_is_cpu_port(ds, 0))
+ 		return 0;
+ 
+-	dev_dbg(priv->dev, "port 0 is not the CPU port. Checking port 6");
+-
+ 	if (dsa_is_cpu_port(ds, 6))
+ 		return 6;
+ 
++	/* PHY-to-PHY link */
++	for (i = 1; i <= 5; i++)
++		if (dsa_is_cpu_port(ds, i))
++			return i;
++
+ 	return -EINVAL;
+ }
+ 
diff --git a/target/linux/qualcommax/patches-6.6/0801-dt-bindings-remoteproc-qcom-Add-support-for-multipd-model.patch b/target/linux/qualcommax/patches-6.6/0801-dt-bindings-remoteproc-qcom-Add-support-for-multipd-model.patch
new file mode 100644
index 0000000000..81248e517a
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0801-dt-bindings-remoteproc-qcom-Add-support-for-multipd-model.patch
@@ -0,0 +1,202 @@
+From: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+Date: Fri, 10 Nov 2023 14:49:29 +0530
+Subject: [PATCH] dt-bindings: remoteproc: qcom: Add support for multipd model
+
+Add new binding document for multipd model remoteproc.
+IPQ5332, IPQ9574 follows multipd model.
+
+Signed-off-by: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+---
+--- /dev/null
++++ b/Documentation/devicetree/bindings/remoteproc/qcom,multipd-pil.yaml
+@@ -0,0 +1,189 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/remoteproc/qcom,multipd-pil.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Qualcomm Multipd Secure Peripheral Image Loader
++
++maintainers:
++  - Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
++
++description:
++  Multipd Peripheral Image Loader loads firmware and boots Q6 protection domain,
++  WCSS protection domain remoteproc's on the Qualcomm IPQ9574, IPQ5332 SoC.
++  Protection domain is similar to process in Linux. Here QDSP6 processor runs
++  each wifi radio functionality on a separate process. One process can't access
++  other process resources, so this is termed as PD i.e protection domain.
++
++properties:
++  compatible:
++    enum:
++      - qcom,ipq5332-q6-mpd
++      - qcom,ipq9574-q6-mpd
++
++  reg:
++    maxItems: 1
++
++  firmware-name:
++    maxItems: 2
++
++  interrupts:
++    items:
++      - description: Watchdog interrupt
++      - description: Fatal interrupt
++      - description: Ready interrupt
++      - description: Handover interrupt
++      - description: Stop acknowledge interrupt
++
++  interrupt-names:
++    items:
++      - const: wdog
++      - const: fatal
++      - const: ready
++      - const: handover
++      - const: stop-ack
++
++  qcom,smem-states:
++    $ref: /schemas/types.yaml#/definitions/phandle-array
++    description: States used by the AP to signal the remote processor
++    items:
++      - description: Shutdown Q6
++      - description: Stop Q6
++
++  qcom,smem-state-names:
++    description:
++      Names of the states used by the AP to signal the remote processor
++    items:
++      - const: shutdown
++      - const: stop
++
++  memory-region:
++    items:
++      - description: Q6 reserved region
++
++  glink-edge:
++    $ref: /schemas/remoteproc/qcom,glink-edge.yaml#
++    description:
++      Qualcomm G-Link subnode which represents communication edge, channels
++      and devices related to the Modem.
++    unevaluatedProperties: false
++
++patternProperties:
++  "^pd-1|pd-2|pd-3":
++    type: object
++    description:
++      WCSS means 'wireless connectivity sub system', in simple words it's a
++      wifi radio block. In multipd model, Q6 root protection domain will
++      provide services to WCSS user protection domain. In other words WCSS
++      protection domains depends on Q6 protection domain i.e  Q6 should be up
++      before WCSS, similarly Q6 should shut down after all WCSS domains are
++      down. It can be achieved by building parent-child topology between Q6
++      and WCSS domain's i.e keeping wcss node as sub node of Q6 device node.
++
++    properties:
++      firmware-name:
++        maxItems: 1
++
++      interrupts:
++        items:
++          - description: Fatal interrupt
++          - description: Ready interrupt
++          - description: Spawn acknowledge interrupt
++          - description: Stop acknowledge interrupt
++
++      interrupt-names:
++        items:
++          - const: fatal
++          - const: ready
++          - const: spawn-ack
++          - const: stop-ack
++
++      qcom,smem-states:
++        $ref: /schemas/types.yaml#/definitions/phandle-array
++        description: States used by the AP to signal the remote processor
++        items:
++          - description: Shutdown WCSS pd
++          - description: Stop WCSS pd
++          - description: Spawn WCSS pd
++
++      qcom,smem-state-names:
++        description:
++          Names of the states used by the AP to signal the remote processor
++        items:
++          - const: shutdown
++          - const: stop
++          - const: spawn
++
++    required:
++      - firmware-name
++      - interrupts
++      - interrupt-names
++      - qcom,smem-states
++      - qcom,smem-state-names
++
++    additionalProperties: false
++
++required:
++  - compatible
++  - firmware-name
++  - reg
++  - interrupts
++  - interrupt-names
++  - qcom,smem-states
++  - qcom,smem-state-names
++  - memory-region
++
++additionalProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/interrupt-controller/arm-gic.h>
++    q6v5_wcss: remoteproc@d100000 {
++      compatible = "qcom,ipq5332-q6-mpd";
++      reg = <0xd100000 0x4040>;
++      firmware-name = "ath11k/IPQ5332/hw1.0/q6_fw0.mdt",
++                      "ath11k/IPQ5332/hw1.0/iu_fw.mdt";
++      interrupts-extended = <&intc GIC_SPI 291 IRQ_TYPE_EDGE_RISING>,
++                            <&wcss_smp2p_in 0 IRQ_TYPE_NONE>,
++                            <&wcss_smp2p_in 1 IRQ_TYPE_NONE>,
++                            <&wcss_smp2p_in 2 IRQ_TYPE_NONE>,
++                            <&wcss_smp2p_in 3 IRQ_TYPE_NONE>;
++      interrupt-names = "wdog",
++                        "fatal",
++                        "ready",
++                        "handover",
++                        "stop-ack";
++
++      qcom,smem-states = <&wcss_smp2p_out 0>,
++                         <&wcss_smp2p_out 1>;
++      qcom,smem-state-names = "shutdown",
++                              "stop";
++
++      memory-region = <&q6_region>;
++
++      glink-edge {
++        interrupts = <GIC_SPI 417 IRQ_TYPE_EDGE_RISING>;
++        label = "rtr";
++        qcom,remote-pid = <1>;
++        mboxes = <&apcs_glb 8>;
++      };
++
++      pd-1 {
++        firmware-name = "ath11k/IPQ5332/hw1.0/q6_fw1.mdt";
++        interrupts-extended = <&wcss_smp2p_in 8 IRQ_TYPE_NONE>,
++                              <&wcss_smp2p_in 9 IRQ_TYPE_NONE>,
++                              <&wcss_smp2p_in 12 IRQ_TYPE_NONE>,
++                              <&wcss_smp2p_in 11 IRQ_TYPE_NONE>;
++        interrupt-names = "fatal",
++                          "ready",
++                          "spawn-ack",
++                          "stop-ack";
++        qcom,smem-states = <&wcss_smp2p_out 8>,
++                           <&wcss_smp2p_out 9>,
++                           <&wcss_smp2p_out 10>;
++        qcom,smem-state-names = "shutdown",
++                                "stop",
++                                "spawn";
++      };
++    };
diff --git a/target/linux/qualcommax/patches-6.6/0802-firmware-qcom_scm-ipq5332-add-support-to-pass-metada.patch b/target/linux/qualcommax/patches-6.6/0802-firmware-qcom_scm-ipq5332-add-support-to-pass-metada.patch
new file mode 100644
index 0000000000..677c61f7ac
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0802-firmware-qcom_scm-ipq5332-add-support-to-pass-metada.patch
@@ -0,0 +1,43 @@
+From 50799703c6c8ec0860e19b102dd7cca3d29028e1 Mon Sep 17 00:00:00 2001
+From: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+Date: Fri, 10 Nov 2023 14:49:34 +0530
+Subject: [PATCH] firmware: qcom_scm: ipq5332: add support to pass
+ metadata size
+
+IPQ5332 security software running under trustzone
+requires metadata size. With V2 cmd, pass metadata
+size as well.
+
+Signed-off-by: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+---
+ drivers/firmware/qcom_scm.c | 8 ++++++++
+ drivers/firmware/qcom_scm.h | 1 +
+ 2 files changed, 9 insertions(+)
+
+--- a/drivers/firmware/qcom_scm.c
++++ b/drivers/firmware/qcom_scm.c
+@@ -592,6 +592,14 @@ int qcom_scm_pas_mem_setup(u32 periphera
+ 	if (ret)
+ 		goto disable_clk;
+ 
++	if (__qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_PIL,
++					 QCOM_SCM_PAS_INIT_IMAGE_V2)) {
++		desc.cmd = QCOM_SCM_PAS_INIT_IMAGE_V2;
++		desc.arginfo =
++			QCOM_SCM_ARGS(3, QCOM_SCM_VAL, QCOM_SCM_RW, QCOM_SCM_VAL);
++		desc.args[2] = size;
++	}
++
+ 	ret = qcom_scm_call(__scm->dev, &desc, &res);
+ 	qcom_scm_bw_disable();
+ 
+--- a/drivers/firmware/qcom_scm.h
++++ b/drivers/firmware/qcom_scm.h
+@@ -92,6 +92,7 @@ extern int scm_legacy_call(struct device
+ 
+ #define QCOM_SCM_SVC_PIL		0x02
+ #define QCOM_SCM_PIL_PAS_INIT_IMAGE	0x01
++#define QCOM_SCM_PAS_INIT_IMAGE_V2	0x1a
+ #define QCOM_SCM_PIL_PAS_MEM_SETUP	0x02
+ #define QCOM_SCM_PIL_PAS_AUTH_AND_RESET	0x05
+ #define QCOM_SCM_PIL_PAS_SHUTDOWN	0x06
diff --git a/target/linux/qualcommax/patches-6.6/0803-firmware-qcom_scm-ipq5332-add-msa-lock-unlock-suppor.patch b/target/linux/qualcommax/patches-6.6/0803-firmware-qcom_scm-ipq5332-add-msa-lock-unlock-suppor.patch
new file mode 100644
index 0000000000..06c6b04756
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0803-firmware-qcom_scm-ipq5332-add-msa-lock-unlock-suppor.patch
@@ -0,0 +1,126 @@
+From 217fbbc122663c5a3dac752cebef44fb3e0cc179 Mon Sep 17 00:00:00 2001
+From: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+Date: Fri, 10 Nov 2023 14:49:35 +0530
+Subject: [PATCH] firmware: qcom_scm: ipq5332: add msa lock/unlock
+ support
+
+IPQ5332 user pd remoteproc firmwares need to be locked
+with MSA(modem secure access) features. This patch add
+support to lock/unlock MSA features.
+
+Signed-off-by: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+---
+ drivers/firmware/qcom_scm.c            | 78 ++++++++++++++++++++++++++
+ drivers/firmware/qcom_scm.h            |  2 +
+ include/linux/firmware/qcom/qcom_scm.h |  2 +
+ 3 files changed, 82 insertions(+)
+
+--- a/drivers/firmware/qcom_scm.c
++++ b/drivers/firmware/qcom_scm.c
+@@ -712,6 +712,84 @@ bool qcom_scm_pas_supported(u32 peripher
+ }
+ EXPORT_SYMBOL_GPL(qcom_scm_pas_supported);
+ 
++/**
++ * qcom_scm_msa_lock() - Lock given peripheral firmware region as MSA
++ *
++ * @peripheral:	peripheral id
++ *
++ * Return 0 on success.
++ */
++int qcom_scm_msa_lock(u32 peripheral)
++{
++	int ret;
++	struct qcom_scm_desc desc = {
++		.svc = QCOM_SCM_SVC_PIL,
++		.cmd = QCOM_SCM_MSA_LOCK,
++		.arginfo = QCOM_SCM_ARGS(1),
++		.args[0] = peripheral,
++		.owner = ARM_SMCCC_OWNER_SIP,
++	};
++	struct qcom_scm_res res;
++
++	if (!__qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_PIL,
++					  QCOM_SCM_MSA_LOCK))
++		return 0;
++
++	ret = qcom_scm_clk_enable();
++	if (ret)
++		return ret;
++
++	ret = qcom_scm_bw_enable();
++	if (ret)
++		return ret;
++
++	ret = qcom_scm_call(__scm->dev, &desc, &res);
++	qcom_scm_bw_disable();
++	qcom_scm_clk_disable();
++
++	return ret ? : res.result[0];
++}
++EXPORT_SYMBOL_GPL(qcom_scm_msa_lock);
++
++/**
++ * qcom_scm_msa_unlock() - Unlock given peripheral MSA firmware region
++ *
++ * @peripheral:	peripheral id
++ *
++ * Return 0 on success.
++ */
++int qcom_scm_msa_unlock(u32 peripheral)
++{
++	int ret;
++	struct qcom_scm_desc desc = {
++		.svc = QCOM_SCM_SVC_PIL,
++		.cmd = QCOM_SCM_MSA_UNLOCK,
++		.arginfo = QCOM_SCM_ARGS(1),
++		.args[0] = peripheral,
++		.owner = ARM_SMCCC_OWNER_SIP,
++	};
++	struct qcom_scm_res res;
++
++	if (!__qcom_scm_is_call_available(__scm->dev, QCOM_SCM_SVC_PIL,
++					  QCOM_SCM_MSA_UNLOCK))
++		return 0;
++
++	ret = qcom_scm_clk_enable();
++	if (ret)
++		return ret;
++
++	ret = qcom_scm_bw_enable();
++	if (ret)
++		return ret;
++
++	ret = qcom_scm_call(__scm->dev, &desc, &res);
++	qcom_scm_bw_disable();
++	qcom_scm_clk_disable();
++
++	return ret ? : res.result[0];
++}
++EXPORT_SYMBOL_GPL(qcom_scm_msa_unlock);
++
+ static int __qcom_scm_pas_mss_reset(struct device *dev, bool reset)
+ {
+ 	struct qcom_scm_desc desc = {
+--- a/drivers/firmware/qcom_scm.h
++++ b/drivers/firmware/qcom_scm.h
+@@ -98,6 +98,8 @@ extern int scm_legacy_call(struct device
+ #define QCOM_SCM_PIL_PAS_SHUTDOWN	0x06
+ #define QCOM_SCM_PIL_PAS_IS_SUPPORTED	0x07
+ #define QCOM_SCM_PIL_PAS_MSS_RESET	0x0a
++#define QCOM_SCM_MSA_LOCK		0x24
++#define QCOM_SCM_MSA_UNLOCK		0x25
+ 
+ #define QCOM_SCM_SVC_IO			0x05
+ #define QCOM_SCM_IO_READ		0x01
+--- a/include/linux/firmware/qcom/qcom_scm.h
++++ b/include/linux/firmware/qcom/qcom_scm.h
+@@ -81,6 +81,8 @@ extern int qcom_scm_pas_mem_setup(u32 pe
+ extern int qcom_scm_pas_auth_and_reset(u32 peripheral);
+ extern int qcom_scm_pas_shutdown(u32 peripheral);
+ extern bool qcom_scm_pas_supported(u32 peripheral);
++extern int qcom_scm_msa_lock(u32 peripheral);
++extern int qcom_scm_msa_unlock(u32 peripheral);
+ 
+ extern int qcom_scm_io_readl(phys_addr_t addr, unsigned int *val);
+ extern int qcom_scm_io_writel(phys_addr_t addr, unsigned int val);
diff --git a/target/linux/qualcommax/patches-6.6/0804-remoteproc-qcom-q6v5-Add-multipd-interrupts-support.patch b/target/linux/qualcommax/patches-6.6/0804-remoteproc-qcom-q6v5-Add-multipd-interrupts-support.patch
new file mode 100644
index 0000000000..4e955435b2
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0804-remoteproc-qcom-q6v5-Add-multipd-interrupts-support.patch
@@ -0,0 +1,148 @@
+From cae691d32306966065df869fa7424728d1b16b14 Mon Sep 17 00:00:00 2001
+From: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+Date: Fri, 10 Nov 2023 14:49:36 +0530
+Subject: [PATCH] remoteproc: qcom: q6v5: Add multipd interrupts support
+
+In multipd model, root & user pd remoteproc's interrupts are
+different. User pd needs additional interrupts like spawn.
+Instead of going with qcom_q6v5_init(), we defined a new
+function to register userpd rproc interrupts in mpd driver.
+Since userpd rproc uses some of common interrupts like fatal,
+ready, static is removed from ISR handler and used in userpd
+interrupt registration.
+
+Signed-off-by: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+---
+ drivers/remoteproc/qcom_q6v5.c | 41 +++++++++++++++++++++++++++++++---
+ drivers/remoteproc/qcom_q6v5.h | 11 +++++++++
+ 2 files changed, 49 insertions(+), 3 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5.c
++++ b/drivers/remoteproc/qcom_q6v5.c
+@@ -112,7 +112,7 @@ static irqreturn_t q6v5_wdog_interrupt(i
+ 	return IRQ_HANDLED;
+ }
+ 
+-static irqreturn_t q6v5_fatal_interrupt(int irq, void *data)
++irqreturn_t q6v5_fatal_interrupt(int irq, void *data)
+ {
+ 	struct qcom_q6v5 *q6v5 = data;
+ 	size_t len;
+@@ -132,8 +132,9 @@ static irqreturn_t q6v5_fatal_interrupt(
+ 
+ 	return IRQ_HANDLED;
+ }
++EXPORT_SYMBOL_GPL(q6v5_fatal_interrupt);
+ 
+-static irqreturn_t q6v5_ready_interrupt(int irq, void *data)
++irqreturn_t q6v5_ready_interrupt(int irq, void *data)
+ {
+ 	struct qcom_q6v5 *q6v5 = data;
+ 
+@@ -141,6 +142,7 @@ static irqreturn_t q6v5_ready_interrupt(
+ 
+ 	return IRQ_HANDLED;
+ }
++EXPORT_SYMBOL_GPL(q6v5_ready_interrupt);
+ 
+ /**
+  * qcom_q6v5_wait_for_start() - wait for remote processor start signal
+@@ -177,7 +179,17 @@ static irqreturn_t q6v5_handover_interru
+ 	return IRQ_HANDLED;
+ }
+ 
+-static irqreturn_t q6v5_stop_interrupt(int irq, void *data)
++irqreturn_t q6v5_spawn_interrupt(int irq, void *data)
++{
++	struct qcom_q6v5 *q6v5 = data;
++
++	complete(&q6v5->spawn_done);
++
++	return IRQ_HANDLED;
++}
++EXPORT_SYMBOL_GPL(q6v5_spawn_interrupt);
++
++irqreturn_t q6v5_stop_interrupt(int irq, void *data)
+ {
+ 	struct qcom_q6v5 *q6v5 = data;
+ 
+@@ -185,6 +197,7 @@ static irqreturn_t q6v5_stop_interrupt(i
+ 
+ 	return IRQ_HANDLED;
+ }
++EXPORT_SYMBOL_GPL(q6v5_stop_interrupt);
+ 
+ /**
+  * qcom_q6v5_request_stop() - request the remote processor to stop
+@@ -215,6 +228,28 @@ int qcom_q6v5_request_stop(struct qcom_q
+ EXPORT_SYMBOL_GPL(qcom_q6v5_request_stop);
+ 
+ /**
++ * qcom_q6v5_request_spawn() - request the remote processor to spawn
++ * @q6v5:      reference to qcom_q6v5 context
++ *
++ * Return: 0 on success, negative errno on failure
++ */
++int qcom_q6v5_request_spawn(struct qcom_q6v5 *q6v5)
++{
++	int ret;
++
++	ret = qcom_smem_state_update_bits(q6v5->spawn_state,
++					  BIT(q6v5->spawn_bit), BIT(q6v5->spawn_bit));
++
++	ret = wait_for_completion_timeout(&q6v5->spawn_done, 5 * HZ);
++
++	qcom_smem_state_update_bits(q6v5->spawn_state,
++				    BIT(q6v5->spawn_bit), 0);
++
++	return ret == 0 ? -ETIMEDOUT : 0;
++}
++EXPORT_SYMBOL_GPL(qcom_q6v5_request_spawn);
++
++/**
+  * qcom_q6v5_panic() - panic handler to invoke a stop on the remote
+  * @q6v5:	reference to qcom_q6v5 context
+  *
+--- a/drivers/remoteproc/qcom_q6v5.h
++++ b/drivers/remoteproc/qcom_q6v5.h
+@@ -18,21 +18,27 @@ struct qcom_q6v5 {
+ 
+ 	struct qcom_smem_state *state;
+ 	struct qmp *qmp;
++	struct qcom_smem_state *shutdown_state;
++	struct qcom_smem_state *spawn_state;
+ 
+ 	struct icc_path *path;
+ 
+ 	unsigned stop_bit;
++	unsigned shutdown_bit;
++	unsigned spawn_bit;
+ 
+ 	int wdog_irq;
+ 	int fatal_irq;
+ 	int ready_irq;
+ 	int handover_irq;
+ 	int stop_irq;
++	int spawn_irq;
+ 
+ 	bool handover_issued;
+ 
+ 	struct completion start_done;
+ 	struct completion stop_done;
++	struct completion spawn_done;
+ 
+ 	int crash_reason;
+ 
+@@ -50,7 +56,12 @@ void qcom_q6v5_deinit(struct qcom_q6v5 *
+ int qcom_q6v5_prepare(struct qcom_q6v5 *q6v5);
+ int qcom_q6v5_unprepare(struct qcom_q6v5 *q6v5);
+ int qcom_q6v5_request_stop(struct qcom_q6v5 *q6v5, struct qcom_sysmon *sysmon);
++int qcom_q6v5_request_spawn(struct qcom_q6v5 *q6v5);
+ int qcom_q6v5_wait_for_start(struct qcom_q6v5 *q6v5, int timeout);
+ unsigned long qcom_q6v5_panic(struct qcom_q6v5 *q6v5);
++irqreturn_t q6v5_fatal_interrupt(int irq, void *data);
++irqreturn_t q6v5_ready_interrupt(int irq, void *data);
++irqreturn_t q6v5_spawn_interrupt(int irq, void *data);
++irqreturn_t q6v5_stop_interrupt(int irq, void *data);
+ 
+ #endif
diff --git a/target/linux/qualcommax/patches-6.6/0805-remoteproc-qcom-Add-Hexagon-based-multipd-rproc-driv.patch b/target/linux/qualcommax/patches-6.6/0805-remoteproc-qcom-Add-Hexagon-based-multipd-rproc-driv.patch
new file mode 100644
index 0000000000..97130b59e4
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0805-remoteproc-qcom-Add-Hexagon-based-multipd-rproc-driv.patch
@@ -0,0 +1,899 @@
+From 3f61ff1fb5c90f8b6c28a3a2b4a29203000ee585 Mon Sep 17 00:00:00 2001
+From: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+Date: Fri, 10 Nov 2023 14:49:37 +0530
+Subject: [PATCH] remoteproc: qcom: Add Hexagon based multipd rproc
+ driver
+
+It adds support to bring up remoteproc's on multipd model.
+Pd means protection domain. It's similar to process in Linux.
+Here QDSP6 processor runs each wifi radio functionality on a
+separate process. One process can't access other process
+resources, so this is termed as PD i.e protection domain.
+
+Here we have two pd's called root and user pd. We can correlate
+Root pd as root and user pd as user in linux. Root pd has more
+privileges than user pd. Root will provide services to user pd.
+
+>From remoteproc driver perspective, root pd corresponds to QDSP6
+processor bring up and user pd corresponds to Wifi radio (WCSS)
+bring up.
+
+Here WCSS(user) PD is dependent on Q6(root) PD, so first
+q6 pd should be up before wcss pd. After wcss pd goes down,
+q6 pd should be turned off.
+
+ APPS				QDSP6
+-------                      -------------
+|     |	 Crash notification  |		|	------
+|     |<---------------------|----------|-------|User|
+|     |			     |		|    |->|PD1 |
+|     |			     |	-------	|    |	------
+|     |			     |	|     |	|    |
+|Root |	 Start/stop  Q6	     |	|  R  | |    |
+|PD   |<---------------------|->|     | |    |
+|rproc|  Crash notification  |	|  O  | |    |
+|     |			     |	|     |	|    |
+|User |Start/stop UserPD1    |  |  O  | |    |
+|PD1  |----------------------|->|     |-|----|
+|rproc|			     |	|  T  |	|    |
+|     |			     |	|     | |    |
+|User |Start/stop UserPD2    |	|  P  | |    |
+|PD2  |----------------------|->|     |-|----|
+|rproc|			     |	|  D  |	|    |
+|     |			     |	-------	|    |	------
+|     |	Crash notification   |		|    |->|User|
+|     |<---------------------|----------|-------|PD2 |
+-------			     |		|	------
+                             ------------
+
+IPQ5332, IPQ9574 supports multipd remoteproc driver.
+
+Signed-off-by: Manikanta Mylavarapu <quic_mmanikan@quicinc.com>
+---
+ drivers/remoteproc/Kconfig         |  19 +
+ drivers/remoteproc/Makefile        |   1 +
+ drivers/remoteproc/qcom_q6v5_mpd.c | 802 +++++++++++++++++++++++++++++
+ 3 files changed, 822 insertions(+)
+ create mode 100644 drivers/remoteproc/qcom_q6v5_mpd.c
+
+--- a/drivers/remoteproc/Kconfig
++++ b/drivers/remoteproc/Kconfig
+@@ -234,6 +234,25 @@ config QCOM_Q6V5_PAS
+ 	  CDSP (Compute DSP), MPSS (Modem Peripheral SubSystem), and
+ 	  SLPI (Sensor Low Power Island).
+ 
++config QCOM_Q6V5_MPD
++	tristate "Qualcomm Hexagon based MPD model Peripheral Image Loader"
++	depends on OF && ARCH_QCOM
++	depends on QCOM_SMEM
++	depends on RPMSG_QCOM_SMD || RPMSG_QCOM_SMD=n
++	depends on RPMSG_QCOM_GLINK_SMEM || RPMSG_QCOM_GLINK_SMEM=n
++	depends on QCOM_SYSMON || QCOM_SYSMON=n
++	depends on RPMSG_QCOM_GLINK || RPMSG_QCOM_GLINK=n
++	depends on QCOM_AOSS_QMP || QCOM_AOSS_QMP=n
++	select QCOM_MDT_LOADER
++	select QCOM_PIL_INFO
++	select QCOM_Q6V5_COMMON
++	select QCOM_RPROC_COMMON
++	select QCOM_SCM
++	help
++	  Say y here to support the Qualcomm Secure Peripheral Image Loader
++	  for the Hexagon based MultiPD model remote processors on e.g. IPQ5018.
++	  This is trustZone wireless subsystem.
++
+ config QCOM_Q6V5_WCSS
+ 	tristate "Qualcomm Hexagon based WCSS Peripheral Image Loader"
+ 	depends on OF && ARCH_QCOM
+--- a/drivers/remoteproc/Makefile
++++ b/drivers/remoteproc/Makefile
+@@ -25,6 +25,7 @@ obj-$(CONFIG_QCOM_PIL_INFO)		+= qcom_pil
+ obj-$(CONFIG_QCOM_RPROC_COMMON)		+= qcom_common.o
+ obj-$(CONFIG_QCOM_Q6V5_COMMON)		+= qcom_q6v5.o
+ obj-$(CONFIG_QCOM_Q6V5_ADSP)		+= qcom_q6v5_adsp.o
++obj-$(CONFIG_QCOM_Q6V5_MPD)		+= qcom_q6v5_mpd.o
+ obj-$(CONFIG_QCOM_Q6V5_MSS)		+= qcom_q6v5_mss.o
+ obj-$(CONFIG_QCOM_Q6V5_PAS)		+= qcom_q6v5_pas.o
+ obj-$(CONFIG_QCOM_Q6V5_WCSS)		+= qcom_q6v5_wcss.o
+--- /dev/null
++++ b/drivers/remoteproc/qcom_q6v5_mpd.c
+@@ -0,0 +1,800 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (C) 2016-2018 Linaro Ltd.
++ * Copyright (C) 2014 Sony Mobile Communications AB
++ * Copyright (c) 2012-2018, 2021 The Linux Foundation. All rights reserved.
++ */
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/firmware/qcom/qcom_scm.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/iopoll.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/of_reserved_mem.h>
++#include <linux/platform_device.h>
++#include <linux/reset.h>
++#include <linux/soc/qcom/mdt_loader.h>
++#include <linux/soc/qcom/smem.h>
++#include <linux/soc/qcom/smem_state.h>
++#include "qcom_common.h"
++#include "qcom_q6v5.h"
++
++#include "remoteproc_internal.h"
++
++#define WCSS_CRASH_REASON		421
++#define WCSS_SMEM_HOST			1
++
++#define WCNSS_PAS_ID			6
++#define MPD_WCNSS_PAS_ID        0xD
++
++#define BUF_SIZE			35
++
++#define MAX_FIRMWARE			3
++
++#define RPD_SWID		MPD_WCNSS_PAS_ID
++#define UPD_SWID		0x12
++#define REMOTE_PID			1
++#define UPD_BOOT_INFO_SMEM_SIZE		4096
++#define UPD_BOOT_INFO_HEADER_TYPE	0x2
++#define UPD_BOOT_INFO_SMEM_ID		507
++#define VERSION2			2
++
++static LIST_HEAD(upd_rproc_list);
++enum {
++	Q6_IPQ,
++	WCSS_IPQ,
++};
++
++/**
++ * struct userpd_boot_info_header - header of user pd bootinfo
++ * @type:		type of bootinfo passing over smem
++ * @length:		length of header in bytes
++ */
++struct userpd_boot_info_header {
++	u8 type;
++	u8 length;
++};
++
++/**
++ * struct userpd_boot_info - holds info required to boot user pd
++ * @header:		pointer to header
++ * @pid:		unique id represents each user pd process
++ * @bootaddr:		load address of user pd firmware
++ * @data_size:		user pd firmware memory size
++ */
++struct userpd_boot_info {
++	struct userpd_boot_info_header header;
++	u8 pid;
++	u32 bootaddr;
++	u32 data_size;
++} __packed;
++
++struct q6_wcss {
++	struct device *dev;
++	struct qcom_rproc_glink glink_subdev;
++	struct qcom_rproc_ssr ssr_subdev;
++	struct qcom_q6v5 q6;
++	phys_addr_t mem_phys;
++	phys_addr_t mem_reloc;
++	void *mem_region;
++	size_t mem_size;
++	u8 pd_asid;
++	const struct wcss_data *desc;
++	const char **firmware;
++	u32 version;
++};
++
++struct wcss_data {
++	u32 pasid;
++	bool share_upd_info_to_q6;
++};
++
++/**
++ * qcom_get_pd_asid() - get the pd asid number from PD spawn bit
++ * @rproc:	rproc handle
++ *
++ * Returns asid on success
++ */
++static u8 qcom_get_pd_asid(struct rproc *rproc)
++{
++	struct q6_wcss *wcss = rproc->priv;
++	u8 bit = wcss->q6.spawn_bit;
++
++	return bit / 8;
++}
++
++static int q6_wcss_start(struct rproc *rproc)
++{
++	struct q6_wcss *wcss = rproc->priv;
++	int ret;
++	const struct wcss_data *desc = wcss->desc;
++
++	qcom_q6v5_prepare(&wcss->q6);
++
++	ret = qcom_scm_pas_auth_and_reset(desc->pasid);
++	if (ret) {
++		dev_err(wcss->dev, "wcss_reset failed\n");
++		return ret;
++	}
++
++	ret = qcom_q6v5_wait_for_start(&wcss->q6, 5 * HZ);
++	if (ret == -ETIMEDOUT)
++		dev_err(wcss->dev, "start timed out\n");
++
++	return ret;
++}
++
++static int q6_wcss_spawn_pd(struct rproc *rproc)
++{
++	int ret;
++	struct q6_wcss *wcss = rproc->priv;
++
++	ret = qcom_q6v5_request_spawn(&wcss->q6);
++	if (ret == -ETIMEDOUT) {
++		dev_err(wcss->dev, "%s spawn timedout\n", rproc->name);
++		return ret;
++	}
++
++	ret = qcom_q6v5_wait_for_start(&wcss->q6, msecs_to_jiffies(10000));
++	if (ret == -ETIMEDOUT) {
++		dev_err(wcss->dev, "%s start timedout\n", rproc->name);
++		wcss->q6.running = false;
++		return ret;
++	}
++	wcss->q6.running = true;
++	return ret;
++}
++
++static int wcss_pd_start(struct rproc *rproc)
++{
++	struct q6_wcss *wcss = rproc->priv;
++	u32 pasid = (wcss->pd_asid << 8) | UPD_SWID;
++	int ret;
++
++	ret = qcom_scm_msa_lock(pasid);
++	if (ret) {
++		dev_err(wcss->dev, "failed to power up pd\n");
++		return ret;
++	}
++
++	if (wcss->q6.spawn_bit) {
++		ret = q6_wcss_spawn_pd(rproc);
++		if (ret)
++			return ret;
++	}
++
++	return ret;
++}
++
++static int q6_wcss_stop(struct rproc *rproc)
++{
++	struct q6_wcss *wcss = rproc->priv;
++	const struct wcss_data *desc = wcss->desc;
++	int ret;
++
++	ret = qcom_scm_pas_shutdown(desc->pasid);
++	if (ret) {
++		dev_err(wcss->dev, "not able to shutdown\n");
++		return ret;
++	}
++	qcom_q6v5_unprepare(&wcss->q6);
++
++	return 0;
++}
++
++/**
++ * wcss_pd_stop() - Stop WCSS user pd
++ * @rproc:	rproc handle
++ *
++ * Stop root pd after user pd down. Root pd
++ * is used to provide services to user pd, so
++ * keeping root pd alive when user pd is down
++ * is invalid.
++ * ---------------------------------------------
++ *
++ *				-----------
++ *		     |-------->| User PD1 |
++ *		     |		-----------
++ *		     |
++ *		     |
++ *	-----	     |		-----------
++ *	| Q6 |---------------->| User Pd2 |
++ *	-----	     |		-----------
++ *		     |
++ *		     |
++ *		     |		-----------
++ *		     |--------->| User Pd3 |
++ *				-----------
++ * ----------------------------------------------
++ */
++static int wcss_pd_stop(struct rproc *rproc)
++{
++	struct q6_wcss *wcss = rproc->priv;
++	struct rproc *rpd_rproc = dev_get_drvdata(wcss->dev->parent);
++	u32 pasid = (wcss->pd_asid << 8) | UPD_SWID;
++	int ret;
++
++	if (rproc->state != RPROC_CRASHED && wcss->q6.stop_bit) {
++		ret = qcom_q6v5_request_stop(&wcss->q6, NULL);
++		if (ret) {
++			dev_err(&rproc->dev, "pd not stopped\n");
++			return ret;
++		}
++	}
++
++	ret = qcom_scm_msa_unlock(pasid);
++	if (ret) {
++		dev_err(wcss->dev, "failed to power down pd\n");
++		return ret;
++	}
++
++	rproc_shutdown(rpd_rproc);
++
++	return 0;
++}
++
++static void *q6_wcss_da_to_va(struct rproc *rproc, u64 da, size_t len,
++			      bool *is_iomem)
++{
++	struct q6_wcss *wcss = rproc->priv;
++	int offset;
++
++	offset = da - wcss->mem_reloc;
++	if (offset < 0 || offset + len > wcss->mem_size)
++		return NULL;
++
++	return wcss->mem_region + offset;
++}
++
++/**
++ * share_upd_bootinfo_to_q6() - Share userpd boot info to Q6 root pd
++ * @rproc:	rproc handle
++ *
++ * Q6 needs user pd parameters like loadaddress and
++ * PIL size to authenticate user pd with underlying
++ * security software. If authenticatoin success then
++ * only Q6 spawns user pd and sends spawn ack to rproc
++ * driver. This API is passing userpd boot info to Q6
++ * over SMEM.
++ *
++ * User pd boot-info format mentioned below
++ * <Version> <No of elements passing over smem> <Header type> <Header Length>
++ * <Process Id> <Load address> <firmware mem Size>
++ *
++ * Returns 0 on success else negative value on failure.
++ */
++static int share_upd_bootinfo_to_q6(struct rproc *rproc)
++{
++	int ret;
++	size_t size;
++	u16 cnt = 0, version;
++	void *ptr;
++	struct q6_wcss *wcss = rproc->priv, *upd_wcss;
++	struct rproc *upd_rproc;
++	struct userpd_boot_info upd_bootinfo = {0};
++	const struct firmware *fw;
++
++	ret = qcom_smem_alloc(REMOTE_PID, UPD_BOOT_INFO_SMEM_ID,
++			      UPD_BOOT_INFO_SMEM_SIZE);
++	if (ret && ret != -EEXIST) {
++		dev_err(wcss->dev,
++			"failed to allocate q6 bootinfo smem segment\n");
++		return ret;
++	}
++
++	ptr = qcom_smem_get(REMOTE_PID, UPD_BOOT_INFO_SMEM_ID, &size);
++	if (IS_ERR(ptr) || size != UPD_BOOT_INFO_SMEM_SIZE) {
++		dev_err(wcss->dev,
++			"Unable to acquire smp2p item(%d) ret:%ld\n",
++			UPD_BOOT_INFO_SMEM_ID, PTR_ERR(ptr));
++		return PTR_ERR(ptr);
++	}
++
++	/*Version*/
++	version = VERSION2;
++	memcpy_toio(ptr, &version, sizeof(version));
++	ptr += sizeof(version);
++
++	list_for_each_entry(upd_rproc, &upd_rproc_list, node)
++		cnt++;
++
++	/* No of elements */
++	cnt = (sizeof(upd_bootinfo) * cnt);
++	memcpy_toio(ptr, &cnt, sizeof(u16));
++	ptr += sizeof(u16);
++
++	list_for_each_entry(upd_rproc, &upd_rproc_list, node) {
++		upd_wcss = upd_rproc->priv;
++
++		/* TYPE */
++		upd_bootinfo.header.type = UPD_BOOT_INFO_HEADER_TYPE;
++
++		/* LENGTH */
++		upd_bootinfo.header.length =
++			sizeof(upd_bootinfo) - sizeof(upd_bootinfo.header);
++
++		/* Process ID */
++		upd_bootinfo.pid = upd_wcss->pd_asid + 1;
++
++		ret = request_firmware(&fw, upd_rproc->firmware, upd_wcss->dev);
++		if (ret < 0) {
++			dev_err(upd_wcss->dev, "request_firmware failed: %d\n",	ret);
++			return ret;
++		}
++
++		/* Load address */
++		upd_bootinfo.bootaddr = rproc_get_boot_addr(upd_rproc, fw);
++
++		/* Firmware mem size */
++		upd_bootinfo.data_size = qcom_mdt_get_size(fw);
++
++		release_firmware(fw);
++
++		/* copy into smem */
++		memcpy_toio(ptr, &upd_bootinfo, sizeof(upd_bootinfo));
++		ptr += sizeof(upd_bootinfo);
++	}
++	return 0;
++}
++
++static int q6_wcss_load(struct rproc *rproc, const struct firmware *fw)
++{
++	struct q6_wcss *wcss = rproc->priv;
++	const struct firmware *fw_hdl;
++	int ret;
++	const struct wcss_data *desc = wcss->desc;
++	int loop;
++
++	/* Share user pd boot info to Q6 remote processor */
++	if (desc->share_upd_info_to_q6) {
++		ret = share_upd_bootinfo_to_q6(rproc);
++		if (ret) {
++			dev_err(wcss->dev,
++				"user pd boot info sharing with q6 failed %d\n",
++				ret);
++			return ret;
++		}
++	}
++
++	ret = qcom_mdt_load(wcss->dev, fw, rproc->firmware,
++			    desc->pasid, wcss->mem_region,
++			    wcss->mem_phys, wcss->mem_size,
++			    &wcss->mem_reloc);
++	if (ret)
++		return ret;
++
++	for (loop = 1; loop < MAX_FIRMWARE; loop++) {
++		if (!wcss->firmware[loop])
++			continue;
++
++		ret = request_firmware(&fw_hdl, wcss->firmware[loop],
++				       wcss->dev);
++		if (ret)
++			continue;
++
++		ret = qcom_mdt_load_no_init(wcss->dev, fw_hdl,
++					    wcss->firmware[loop], 0,
++					    wcss->mem_region,
++					    wcss->mem_phys,
++					    wcss->mem_size,
++					    &wcss->mem_reloc);
++
++		release_firmware(fw_hdl);
++
++		if (ret) {
++			dev_err(wcss->dev,
++				"can't load %s ret:%d\n", wcss->firmware[loop], ret);
++			return ret;
++		}
++	}
++	return 0;
++}
++
++/**
++ * wcss_pd_load() - Load WCSS user pd firmware
++ * @rproc:	rproc handle
++ * @fw:		firmware handle
++ *
++ * User pd get services from root pd. So first
++ * bring up root pd and then load userpd firmware.
++ * ---------------------------------------------
++ *
++ *				-----------
++ *		     |-------->| User PD1 |
++ *		     |		-----------
++ *		     |
++ *		     |
++ *	-----	     |		-----------
++ *	| Q6 |---------------->| User Pd2 |
++ *	-----	     |		-----------
++ *		     |
++ *		     |
++ *		     |		-----------
++ *		     |--------->| User Pd3 |
++ *				-----------
++ * ----------------------------------------------
++ *
++ */
++static int wcss_pd_load(struct rproc *rproc, const struct firmware *fw)
++{
++	struct q6_wcss *wcss = rproc->priv;
++	struct rproc *rpd_rproc = dev_get_drvdata(wcss->dev->parent);
++	u32 pasid = (wcss->pd_asid << 8) | UPD_SWID;
++	int ret;
++
++	ret = rproc_boot(rpd_rproc);
++	if (ret)
++		return ret;
++
++	return qcom_mdt_load(wcss->dev, fw, rproc->firmware,
++			     pasid, wcss->mem_region,
++			     wcss->mem_phys, wcss->mem_size,
++			     &wcss->mem_reloc);
++}
++
++static unsigned long q6_wcss_panic(struct rproc *rproc)
++{
++	struct q6_wcss *wcss = rproc->priv;
++
++	return qcom_q6v5_panic(&wcss->q6);
++}
++
++static const struct rproc_ops wcss_ops = {
++	.start = wcss_pd_start,
++	.stop = wcss_pd_stop,
++	.load = wcss_pd_load,
++	.get_boot_addr = rproc_elf_get_boot_addr,
++};
++
++static const struct rproc_ops q6_wcss_ops = {
++	.start = q6_wcss_start,
++	.stop = q6_wcss_stop,
++	.da_to_va = q6_wcss_da_to_va,
++	.load = q6_wcss_load,
++	.get_boot_addr = rproc_elf_get_boot_addr,
++	.panic = q6_wcss_panic,
++};
++
++static int q6_alloc_memory_region(struct q6_wcss *wcss)
++{
++	struct reserved_mem *rmem = NULL;
++	struct device_node *node;
++	struct device *dev = wcss->dev;
++
++	if (wcss->version == Q6_IPQ) {
++		node = of_parse_phandle(dev->of_node, "memory-region", 0);
++		if (node)
++			rmem = of_reserved_mem_lookup(node);
++
++		of_node_put(node);
++
++		if (!rmem) {
++			dev_err(dev, "unable to acquire memory-region\n");
++			return -EINVAL;
++		}
++	} else {
++		struct rproc *rpd_rproc = dev_get_drvdata(dev->parent);
++		struct q6_wcss *rpd_wcss = rpd_rproc->priv;
++
++		wcss->mem_phys = rpd_wcss->mem_phys;
++		wcss->mem_reloc = rpd_wcss->mem_reloc;
++		wcss->mem_size = rpd_wcss->mem_size;
++		wcss->mem_region = rpd_wcss->mem_region;
++		return 0;
++	}
++
++	wcss->mem_phys = rmem->base;
++	wcss->mem_reloc = rmem->base;
++	wcss->mem_size = rmem->size;
++	wcss->mem_region = devm_ioremap_wc(dev, wcss->mem_phys, wcss->mem_size);
++	if (!wcss->mem_region) {
++		dev_err(dev, "unable to map memory region: %pa+%pa\n",
++			&rmem->base, &rmem->size);
++		return -EBUSY;
++	}
++
++	return 0;
++}
++
++static int q6_get_inbound_irq(struct qcom_q6v5 *q6,
++			      struct platform_device *pdev,
++			      const char *int_name,
++			      int index, int *pirq,
++			      irqreturn_t (*handler)(int irq, void *data))
++{
++	int ret, irq;
++	char *interrupt, *tmp = (char *)int_name;
++	struct q6_wcss *wcss = q6->rproc->priv;
++
++	irq = platform_get_irq(pdev, index);
++	if (irq < 0)
++		return irq;
++
++	*pirq = irq;
++
++	interrupt = devm_kzalloc(&pdev->dev, BUF_SIZE, GFP_KERNEL);
++	if (!interrupt)
++		return -ENOMEM;
++
++	snprintf(interrupt, BUF_SIZE, "q6v5_wcss_userpd%d_%s", wcss->pd_asid, tmp);
++
++	ret = devm_request_threaded_irq(&pdev->dev, *pirq,
++					NULL, handler,
++					IRQF_TRIGGER_RISING | IRQF_ONESHOT,
++					interrupt, q6);
++	if (ret)
++		return dev_err_probe(&pdev->dev, ret,
++				     "failed to acquire %s irq\n", interrupt);
++	return 0;
++}
++
++static int q6_get_outbound_irq(struct qcom_q6v5 *q6,
++			       struct platform_device *pdev,
++			       const char *int_name)
++{
++	struct qcom_smem_state *tmp_state;
++	unsigned  bit;
++
++	tmp_state = qcom_smem_state_get(&pdev->dev, int_name, &bit);
++	if (IS_ERR(tmp_state))
++		return dev_err_probe(&pdev->dev, PTR_ERR(tmp_state),
++				     "failed to acquire %s state\n", int_name);
++
++	if (!strcmp(int_name, "stop")) {
++		q6->state = tmp_state;
++		q6->stop_bit = bit;
++	} else if (!strcmp(int_name, "spawn")) {
++		q6->spawn_state = tmp_state;
++		q6->spawn_bit = bit;
++	}
++
++	return 0;
++}
++
++static int init_irq(struct qcom_q6v5 *q6,
++		    struct platform_device *pdev, struct rproc *rproc,
++		    int crash_reason, const char *load_state,
++		    void (*handover)(struct qcom_q6v5 *q6))
++{
++	int ret;
++	struct q6_wcss *wcss = rproc->priv;
++
++	q6->rproc = rproc;
++	q6->dev = &pdev->dev;
++	q6->crash_reason = crash_reason;
++	q6->handover = handover;
++
++	init_completion(&q6->start_done);
++	init_completion(&q6->stop_done);
++	init_completion(&q6->spawn_done);
++
++	ret = q6_get_outbound_irq(q6, pdev, "stop");
++	if (ret)
++		return ret;
++
++	ret = q6_get_outbound_irq(q6, pdev, "spawn");
++	if (ret)
++		return ret;
++
++	/* Get pd_asid to prepare interrupt names */
++	wcss->pd_asid = qcom_get_pd_asid(rproc);
++
++	ret = q6_get_inbound_irq(q6, pdev, "fatal", 0, &q6->fatal_irq,
++				 q6v5_fatal_interrupt);
++	if (ret)
++		return ret;
++
++	ret = q6_get_inbound_irq(q6, pdev, "ready", 1, &q6->ready_irq,
++				 q6v5_ready_interrupt);
++	if (ret)
++		return ret;
++
++	ret = q6_get_inbound_irq(q6, pdev, "stop-ack", 3, &q6->stop_irq,
++				 q6v5_stop_interrupt);
++	if (ret)
++		return ret;
++
++	ret = q6_get_inbound_irq(q6, pdev, "spawn-ack", 2, &q6->spawn_irq,
++				 q6v5_spawn_interrupt);
++	if (ret)
++		return ret;
++	return 0;
++}
++
++static void q6_release_resources(void)
++{
++	struct rproc *upd_rproc;
++
++	/* Release userpd resources */
++	list_for_each_entry(upd_rproc, &upd_rproc_list, node) {
++		rproc_del(upd_rproc);
++		rproc_free(upd_rproc);
++	}
++}
++
++static int q6_register_userpd(struct platform_device *pdev,
++			      struct device_node *userpd_np)
++{
++	struct q6_wcss *wcss;
++	struct rproc *rproc = NULL;
++	int ret;
++	struct platform_device *userpd_pdev;
++	const char *firmware_name = NULL;
++	const char *label = NULL;
++
++	ret = of_property_read_string(userpd_np, "firmware-name",
++				      &firmware_name);
++	if (ret < 0) {
++		/* All userpd's who want to register as rproc must have firmware.
++		 * Other than userpd like glink they don't need any firmware.
++		 * So for glink child simply return success.
++		 */
++		if (ret == -EINVAL) {
++			/* Confirming userpd_np is glink node or not */
++			if (!of_property_read_string(userpd_np, "label", &label))
++				return 0;
++		}
++		return ret;
++	}
++
++	dev_info(&pdev->dev, "%s node found\n", userpd_np->name);
++
++	userpd_pdev = of_platform_device_create(userpd_np, userpd_np->name,
++						&pdev->dev);
++	if (!userpd_pdev)
++		return dev_err_probe(&pdev->dev, -ENODEV,
++				     "failed to create %s platform device\n",
++				     userpd_np->name);
++
++	userpd_pdev->dev.driver = pdev->dev.driver;
++	rproc = rproc_alloc(&userpd_pdev->dev, userpd_pdev->name, &wcss_ops,
++			    firmware_name, sizeof(*wcss));
++	if (!rproc) {
++		ret = -ENOMEM;
++		goto free_rproc;
++	}
++
++	wcss = rproc->priv;
++	wcss->dev = &userpd_pdev->dev;
++	wcss->version = WCSS_IPQ;
++
++	ret = q6_alloc_memory_region(wcss);
++	if (ret)
++		goto free_rproc;
++
++	ret = init_irq(&wcss->q6, userpd_pdev, rproc,
++		       WCSS_CRASH_REASON, NULL, NULL);
++	if (ret)
++		goto free_rproc;
++
++	rproc->auto_boot = false;
++	ret = rproc_add(rproc);
++	if (ret)
++		goto free_rproc;
++
++	list_add(&rproc->node, &upd_rproc_list);
++	platform_set_drvdata(userpd_pdev, rproc);
++	qcom_add_ssr_subdev(rproc, &wcss->ssr_subdev, userpd_pdev->name);
++	return 0;
++
++free_rproc:
++	kfree(rproc);
++	return ret;
++}
++
++static int q6_wcss_probe(struct platform_device *pdev)
++{
++	const struct wcss_data *desc;
++	struct q6_wcss *wcss;
++	struct rproc *rproc;
++	int ret;
++	const char **firmware;
++	struct device_node *userpd_np;
++	const struct rproc_ops *ops = &q6_wcss_ops;
++
++	desc = of_device_get_match_data(&pdev->dev);
++	if (!desc)
++		return -EINVAL;
++
++	firmware = devm_kcalloc(&pdev->dev, MAX_FIRMWARE,
++				sizeof(*firmware), GFP_KERNEL);
++	if (!firmware)
++		return -ENOMEM;
++
++	ret = of_property_read_string_array(pdev->dev.of_node, "firmware-name",
++					    firmware, MAX_FIRMWARE);
++	if (ret < 0)
++		return ret;
++
++	rproc = rproc_alloc(&pdev->dev, pdev->name, ops,
++			    firmware[0], sizeof(*wcss));
++	if (!rproc)
++		return -ENOMEM;
++
++	wcss = rproc->priv;
++	wcss->dev = &pdev->dev;
++	wcss->desc = desc;
++	wcss->firmware = firmware;
++	wcss->version = Q6_IPQ;
++
++	ret = q6_alloc_memory_region(wcss);
++	if (ret)
++		goto free_rproc;
++
++	ret = qcom_q6v5_init(&wcss->q6, pdev, rproc,
++			     WCSS_CRASH_REASON, NULL, NULL);
++	if (ret)
++		goto free_rproc;
++
++	qcom_add_glink_subdev(rproc, &wcss->glink_subdev, "q6wcss");
++	qcom_add_ssr_subdev(rproc, &wcss->ssr_subdev, "q6wcss");
++
++	rproc->auto_boot = false;
++	ret = rproc_add(rproc);
++	if (ret)
++		goto free_rproc;
++
++	platform_set_drvdata(pdev, rproc);
++
++	/* Iterate over userpd child's and register with rproc */
++	for_each_available_child_of_node(pdev->dev.of_node, userpd_np) {
++		ret = q6_register_userpd(pdev, userpd_np);
++		if (ret) {
++			/* release resources of successfully allocated userpd rproc's */
++			q6_release_resources();
++			return dev_err_probe(&pdev->dev, ret,
++					     "Failed to register userpd(%s)\n",
++					     userpd_np->name);
++		}
++	}
++	return 0;
++
++free_rproc:
++	rproc_free(rproc);
++
++	return ret;
++}
++
++static void q6_wcss_remove(struct platform_device *pdev)
++{
++	struct rproc *rproc = platform_get_drvdata(pdev);
++	struct q6_wcss *wcss = rproc->priv;
++
++	qcom_q6v5_deinit(&wcss->q6);
++
++	rproc_del(rproc);
++	rproc_free(rproc);
++}
++
++static const struct wcss_data q6_ipq5332_res_init = {
++	.pasid = MPD_WCNSS_PAS_ID,
++	.share_upd_info_to_q6 = true,
++};
++
++static const struct wcss_data q6_ipq9574_res_init = {
++	.pasid = WCNSS_PAS_ID,
++};
++
++static const struct of_device_id q6_wcss_of_match[] = {
++	{ .compatible = "qcom,ipq5332-q6-mpd", .data = &q6_ipq5332_res_init },
++	{ .compatible = "qcom,ipq9574-q6-mpd", .data = &q6_ipq9574_res_init },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, q6_wcss_of_match);
++
++static struct platform_driver q6_wcss_driver = {
++	.probe = q6_wcss_probe,
++	.remove_new = q6_wcss_remove,
++	.driver = {
++		.name = "qcom-q6-mpd",
++		.of_match_table = q6_wcss_of_match,
++	},
++};
++module_platform_driver(q6_wcss_driver);
++
++MODULE_DESCRIPTION("Hexagon WCSS Multipd Peripheral Image Loader");
++MODULE_LICENSE("GPL v2");
diff --git a/target/linux/qualcommax/patches-6.6/0806-rproc-qcom_q6v5_mpd-split-q6_wcss-to-rootpd-and-user.patch b/target/linux/qualcommax/patches-6.6/0806-rproc-qcom_q6v5_mpd-split-q6_wcss-to-rootpd-and-user.patch
new file mode 100644
index 0000000000..b3cd492d05
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0806-rproc-qcom_q6v5_mpd-split-q6_wcss-to-rootpd-and-user.patch
@@ -0,0 +1,321 @@
+From 6c66dff196cbba8515380110dd3599cde31dd896 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH 1/2] rproc: qcom_q6v5_mpd: split q6_wcss to rootpd and
+ userpd
+
+Split the q6_wcss structure and create a separate userpd struct to clearly
+differentiate between the process to bring up the QDSP6 processor vs 
+process(es) to bring up the Wifi radio(s) (WCSS) for better readability.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ drivers/remoteproc/qcom_q6v5_mpd.c | 126 +++++++++++++----------------
+ 1 file changed, 56 insertions(+), 70 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_mpd.c
++++ b/drivers/remoteproc/qcom_q6v5_mpd.c
+@@ -44,10 +44,6 @@
+ #define VERSION2			2
+ 
+ static LIST_HEAD(upd_rproc_list);
+-enum {
+-	Q6_IPQ,
+-	WCSS_IPQ,
+-};
+ 
+ /**
+  * struct userpd_boot_info_header - header of user pd bootinfo
+@@ -82,10 +78,15 @@ struct q6_wcss {
+ 	phys_addr_t mem_reloc;
+ 	void *mem_region;
+ 	size_t mem_size;
+-	u8 pd_asid;
+ 	const struct wcss_data *desc;
+ 	const char **firmware;
+-	u32 version;
++};
++
++struct userpd {
++	u8 pd_asid;
++	struct device *dev;
++	struct qcom_rproc_ssr ssr_subdev;
++	struct qcom_q6v5 q6;
+ };
+ 
+ struct wcss_data {
+@@ -101,8 +102,8 @@ struct wcss_data {
+  */
+ static u8 qcom_get_pd_asid(struct rproc *rproc)
+ {
+-	struct q6_wcss *wcss = rproc->priv;
+-	u8 bit = wcss->q6.spawn_bit;
++	struct userpd *upd = rproc->priv;
++	u8 bit = upd->q6.spawn_bit;
+ 
+ 	return bit / 8;
+ }
+@@ -131,37 +132,37 @@ static int q6_wcss_start(struct rproc *r
+ static int q6_wcss_spawn_pd(struct rproc *rproc)
+ {
+ 	int ret;
+-	struct q6_wcss *wcss = rproc->priv;
++	struct userpd *upd = rproc->priv;
+ 
+-	ret = qcom_q6v5_request_spawn(&wcss->q6);
++	ret = qcom_q6v5_request_spawn(&upd->q6);
+ 	if (ret == -ETIMEDOUT) {
+-		dev_err(wcss->dev, "%s spawn timedout\n", rproc->name);
++		dev_err(upd->dev, "%s spawn timedout\n", rproc->name);
+ 		return ret;
+ 	}
+ 
+-	ret = qcom_q6v5_wait_for_start(&wcss->q6, msecs_to_jiffies(10000));
++	ret = qcom_q6v5_wait_for_start(&upd->q6, msecs_to_jiffies(10000));
+ 	if (ret == -ETIMEDOUT) {
+-		dev_err(wcss->dev, "%s start timedout\n", rproc->name);
+-		wcss->q6.running = false;
++		dev_err(upd->dev, "%s start timedout\n", rproc->name);
++		upd->q6.running = false;
+ 		return ret;
+ 	}
+-	wcss->q6.running = true;
++	upd->q6.running = true;
+ 	return ret;
+ }
+ 
+ static int wcss_pd_start(struct rproc *rproc)
+ {
+-	struct q6_wcss *wcss = rproc->priv;
+-	u32 pasid = (wcss->pd_asid << 8) | UPD_SWID;
++	struct userpd *upd = rproc->priv;
++	u32 pasid = (upd->pd_asid << 8) | UPD_SWID;
+ 	int ret;
+ 
+ 	ret = qcom_scm_msa_lock(pasid);
+ 	if (ret) {
+-		dev_err(wcss->dev, "failed to power up pd\n");
++		dev_err(upd->dev, "failed to power up pd\n");
+ 		return ret;
+ 	}
+ 
+-	if (wcss->q6.spawn_bit) {
++	if (upd->q6.spawn_bit) {
+ 		ret = q6_wcss_spawn_pd(rproc);
+ 		if (ret)
+ 			return ret;
+@@ -213,22 +214,22 @@ static int q6_wcss_stop(struct rproc *rp
+  */
+ static int wcss_pd_stop(struct rproc *rproc)
+ {
+-	struct q6_wcss *wcss = rproc->priv;
+-	struct rproc *rpd_rproc = dev_get_drvdata(wcss->dev->parent);
+-	u32 pasid = (wcss->pd_asid << 8) | UPD_SWID;
++	struct userpd *upd = rproc->priv;
++	struct rproc *rpd_rproc = dev_get_drvdata(upd->dev->parent);
++	u32 pasid = (upd->pd_asid << 8) | UPD_SWID;
+ 	int ret;
+ 
+-	if (rproc->state != RPROC_CRASHED && wcss->q6.stop_bit) {
+-		ret = qcom_q6v5_request_stop(&wcss->q6, NULL);
++	if (rproc->state != RPROC_CRASHED && upd->q6.stop_bit) {
++		ret = qcom_q6v5_request_stop(&upd->q6, NULL);
+ 		if (ret) {
+-			dev_err(&rproc->dev, "pd not stopped\n");
++			dev_err(upd->dev, "pd not stopped\n");
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	ret = qcom_scm_msa_unlock(pasid);
+ 	if (ret) {
+-		dev_err(wcss->dev, "failed to power down pd\n");
++		dev_err(upd->dev, "failed to power down pd\n");
+ 		return ret;
+ 	}
+ 
+@@ -273,7 +274,8 @@ static int share_upd_bootinfo_to_q6(stru
+ 	size_t size;
+ 	u16 cnt = 0, version;
+ 	void *ptr;
+-	struct q6_wcss *wcss = rproc->priv, *upd_wcss;
++	struct q6_wcss *wcss = rproc->priv;
++	struct userpd *upd;
+ 	struct rproc *upd_rproc;
+ 	struct userpd_boot_info upd_bootinfo = {0};
+ 	const struct firmware *fw;
+@@ -308,7 +310,7 @@ static int share_upd_bootinfo_to_q6(stru
+ 	ptr += sizeof(u16);
+ 
+ 	list_for_each_entry(upd_rproc, &upd_rproc_list, node) {
+-		upd_wcss = upd_rproc->priv;
++		upd = upd_rproc->priv;
+ 
+ 		/* TYPE */
+ 		upd_bootinfo.header.type = UPD_BOOT_INFO_HEADER_TYPE;
+@@ -318,11 +320,11 @@ static int share_upd_bootinfo_to_q6(stru
+ 			sizeof(upd_bootinfo) - sizeof(upd_bootinfo.header);
+ 
+ 		/* Process ID */
+-		upd_bootinfo.pid = upd_wcss->pd_asid + 1;
++		upd_bootinfo.pid = upd->pd_asid + 1;
+ 
+-		ret = request_firmware(&fw, upd_rproc->firmware, upd_wcss->dev);
++		ret = request_firmware(&fw, upd_rproc->firmware, upd->dev);
+ 		if (ret < 0) {
+-			dev_err(upd_wcss->dev, "request_firmware failed: %d\n",	ret);
++			dev_err(upd->dev, "request_firmware failed: %d\n",	ret);
+ 			return ret;
+ 		}
+ 
+@@ -421,19 +423,20 @@ static int q6_wcss_load(struct rproc *rp
+  */
+ static int wcss_pd_load(struct rproc *rproc, const struct firmware *fw)
+ {
+-	struct q6_wcss *wcss = rproc->priv;
+-	struct rproc *rpd_rproc = dev_get_drvdata(wcss->dev->parent);
+-	u32 pasid = (wcss->pd_asid << 8) | UPD_SWID;
++	struct userpd *upd = rproc->priv;
++	struct rproc *rpd_rproc = dev_get_drvdata(upd->dev->parent);
++	struct q6_wcss *wcss = rpd_rproc->priv;
++	u32 pasid = (upd->pd_asid << 8) | UPD_SWID;
+ 	int ret;
+ 
+ 	ret = rproc_boot(rpd_rproc);
+ 	if (ret)
+ 		return ret;
+ 
+-	return qcom_mdt_load(wcss->dev, fw, rproc->firmware,
++	return qcom_mdt_load(upd->dev, fw, rproc->firmware,
+ 			     pasid, wcss->mem_region,
+ 			     wcss->mem_phys, wcss->mem_size,
+-			     &wcss->mem_reloc);
++			     NULL);
+ }
+ 
+ static unsigned long q6_wcss_panic(struct rproc *rproc)
+@@ -465,26 +468,15 @@ static int q6_alloc_memory_region(struct
+ 	struct device_node *node;
+ 	struct device *dev = wcss->dev;
+ 
+-	if (wcss->version == Q6_IPQ) {
+-		node = of_parse_phandle(dev->of_node, "memory-region", 0);
+-		if (node)
+-			rmem = of_reserved_mem_lookup(node);
+-
+-		of_node_put(node);
+-
+-		if (!rmem) {
+-			dev_err(dev, "unable to acquire memory-region\n");
+-			return -EINVAL;
+-		}
+-	} else {
+-		struct rproc *rpd_rproc = dev_get_drvdata(dev->parent);
+-		struct q6_wcss *rpd_wcss = rpd_rproc->priv;
+-
+-		wcss->mem_phys = rpd_wcss->mem_phys;
+-		wcss->mem_reloc = rpd_wcss->mem_reloc;
+-		wcss->mem_size = rpd_wcss->mem_size;
+-		wcss->mem_region = rpd_wcss->mem_region;
+-		return 0;
++	node = of_parse_phandle(dev->of_node, "memory-region", 0);
++	if (node)
++		rmem = of_reserved_mem_lookup(node);
++
++	of_node_put(node);
++
++	if (!rmem) {
++		dev_err(dev, "unable to acquire memory-region\n");
++		return -EINVAL;
+ 	}
+ 
+ 	wcss->mem_phys = rmem->base;
+@@ -508,7 +500,7 @@ static int q6_get_inbound_irq(struct qco
+ {
+ 	int ret, irq;
+ 	char *interrupt, *tmp = (char *)int_name;
+-	struct q6_wcss *wcss = q6->rproc->priv;
++	struct userpd *upd = q6->rproc->priv;
+ 
+ 	irq = platform_get_irq(pdev, index);
+ 	if (irq < 0)
+@@ -520,7 +512,7 @@ static int q6_get_inbound_irq(struct qco
+ 	if (!interrupt)
+ 		return -ENOMEM;
+ 
+-	snprintf(interrupt, BUF_SIZE, "q6v5_wcss_userpd%d_%s", wcss->pd_asid, tmp);
++	snprintf(interrupt, BUF_SIZE, "q6v5_wcss_userpd%d_%s", upd->pd_asid, tmp);
+ 
+ 	ret = devm_request_threaded_irq(&pdev->dev, *pirq,
+ 					NULL, handler,
+@@ -561,7 +553,7 @@ static int init_irq(struct qcom_q6v5 *q6
+ 		    void (*handover)(struct qcom_q6v5 *q6))
+ {
+ 	int ret;
+-	struct q6_wcss *wcss = rproc->priv;
++	struct userpd *upd = rproc->priv;
+ 
+ 	q6->rproc = rproc;
+ 	q6->dev = &pdev->dev;
+@@ -581,7 +573,7 @@ static int init_irq(struct qcom_q6v5 *q6
+ 		return ret;
+ 
+ 	/* Get pd_asid to prepare interrupt names */
+-	wcss->pd_asid = qcom_get_pd_asid(rproc);
++	upd->pd_asid = qcom_get_pd_asid(rproc);
+ 
+ 	ret = q6_get_inbound_irq(q6, pdev, "fatal", 0, &q6->fatal_irq,
+ 				 q6v5_fatal_interrupt);
+@@ -619,7 +611,7 @@ static void q6_release_resources(void)
+ static int q6_register_userpd(struct platform_device *pdev,
+ 			      struct device_node *userpd_np)
+ {
+-	struct q6_wcss *wcss;
++	struct userpd *upd;
+ 	struct rproc *rproc = NULL;
+ 	int ret;
+ 	struct platform_device *userpd_pdev;
+@@ -652,21 +644,16 @@ static int q6_register_userpd(struct pla
+ 
+ 	userpd_pdev->dev.driver = pdev->dev.driver;
+ 	rproc = rproc_alloc(&userpd_pdev->dev, userpd_pdev->name, &wcss_ops,
+-			    firmware_name, sizeof(*wcss));
++			    firmware_name, sizeof(*upd));
+ 	if (!rproc) {
+ 		ret = -ENOMEM;
+ 		goto free_rproc;
+ 	}
+ 
+-	wcss = rproc->priv;
+-	wcss->dev = &userpd_pdev->dev;
+-	wcss->version = WCSS_IPQ;
+-
+-	ret = q6_alloc_memory_region(wcss);
+-	if (ret)
+-		goto free_rproc;
++	upd = rproc->priv;
++	upd->dev = &userpd_pdev->dev;
+ 
+-	ret = init_irq(&wcss->q6, userpd_pdev, rproc,
++	ret = init_irq(&upd->q6, userpd_pdev, rproc,
+ 		       WCSS_CRASH_REASON, NULL, NULL);
+ 	if (ret)
+ 		goto free_rproc;
+@@ -678,7 +665,7 @@ static int q6_register_userpd(struct pla
+ 
+ 	list_add(&rproc->node, &upd_rproc_list);
+ 	platform_set_drvdata(userpd_pdev, rproc);
+-	qcom_add_ssr_subdev(rproc, &wcss->ssr_subdev, userpd_pdev->name);
++	qcom_add_ssr_subdev(rproc, &upd->ssr_subdev, userpd_pdev->name);
+ 	return 0;
+ 
+ free_rproc:
+@@ -719,7 +706,6 @@ static int q6_wcss_probe(struct platform
+ 	wcss->dev = &pdev->dev;
+ 	wcss->desc = desc;
+ 	wcss->firmware = firmware;
+-	wcss->version = Q6_IPQ;
+ 
+ 	ret = q6_alloc_memory_region(wcss);
+ 	if (ret)
diff --git a/target/linux/qualcommax/patches-6.6/0807-remoteproc-qcom_q6v5_mpd-fix-incorrent-use-of-rproc-.patch b/target/linux/qualcommax/patches-6.6/0807-remoteproc-qcom_q6v5_mpd-fix-incorrent-use-of-rproc-.patch
new file mode 100644
index 0000000000..59f49ad66e
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0807-remoteproc-qcom_q6v5_mpd-fix-incorrent-use-of-rproc-.patch
@@ -0,0 +1,206 @@
+From 0fa7bdb855247b738d1d227d6f4b3417ebdf21a8 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH 2/2] remoteproc: qcom_q6v5_mpd: fix incorrent use of
+ rproc->node
+
+    1.817524] list_add corruption. next->prev should be prev (ffffffc0814bbfc8), but was ffffffc0814bc358. (next=ffffff8003b56800).
+[    1.822435] WARNING: CPU: 1 PID: 24 at lib/list_debug.c:29 __list_add_valid_or_report+0x8c/0xdc
+[    1.833923] Modules linked in:
+[    1.842425] CPU: 1 PID: 24 Comm: kworker/u4:1 Not tainted 6.6.47 #0
+[    1.845552] Hardware name: Qualcomm MP03 (DT)
+[    1.851716] Workqueue: events_unbound deferred_probe_work_func
+[    1.856229] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
+[    1.861959] pc : __list_add_valid_or_report+0x8c/0xdc
+[    1.868816] lr : __list_add_valid_or_report+0x8c/0xdc
+[    1.874022] sp : ffffffc081603a50
+[    1.879055] x29: ffffffc081603a50 x28: ffffff8000fa2810 x27: ffffff8003cba800
+[    1.882358] x26: ffffff8000fa2800 x25: ffffff8003cbac80 x24: 0000000000000000
+[    1.889476] x23: ffffffc08088b968 x22: ffffffc0814bb000 x21: ffffffc0814bbfc8
+[    1.896593] x20: ffffffc08088b8e8 x19: ffffff8003cba800 x18: 00000000000000b1
+[    1.903713] x17: 3863666262343138 x16: 3063666666666666 x15: ffffffc081416e20
+[    1.910830] x14: 0000000000000213 x13: 00000000000000b1 x12: 00000000ffffffea
+[    1.917948] x11: 00000000ffffefff x10: ffffffc08146ee20 x9 : ffffffc081416dc8
+[    1.925066] x8 : 0000000000017fe8 x7 : c0000000ffffefff x6 : 0000000000057fa8
+[    1.932184] x5 : 0000000000000fff x4 : 0000000000000000 x3 : ffffffc081603850
+[    1.939302] x2 : ffffffc081416d60 x1 : ffffffc081416d60 x0 : 0000000000000075
+[    1.946422] Call trace:
+[    1.953535]  __list_add_valid_or_report+0x8c/0xdc
+[    1.955793]  rproc_add+0x1f4/0x25c
+[    1.960653]  q6_wcss_probe+0x510/0x634
+[    1.963950]  platform_probe+0x68/0xc4
+[    1.967684]  really_probe+0x148/0x2b0
+[    1.971417]  __driver_probe_device+0x78/0x128
+[    1.975063]  driver_probe_device+0x40/0xdc
+[    1.979402]  __device_attach_driver+0xb8/0xf8
+[    1.983397]  bus_for_each_drv+0x70/0xb8
+[    1.987823]  __device_attach+0xa0/0x184
+[    1.991468]  device_initial_probe+0x14/0x20
+[    1.995289]  bus_probe_device+0xac/0xb0
+[    1.999455]  deferred_probe_work_func+0xa4/0xec
+[    2.003275]  process_one_work+0x178/0x2d4
+[    2.007788]  worker_thread+0x2ec/0x4d8
+[    2.011954]  kthread+0xdc/0xe0
+[    2.015600]  ret_from_fork+0x10/0x20
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+---
+ drivers/remoteproc/qcom_q6v5_mpd.c | 53 +++++++++++++++++-------------
+ 1 file changed, 30 insertions(+), 23 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_mpd.c
++++ b/drivers/remoteproc/qcom_q6v5_mpd.c
+@@ -33,6 +33,7 @@
+ 
+ #define BUF_SIZE			35
+ 
++#define MAX_UPD				3
+ #define MAX_FIRMWARE			3
+ 
+ #define RPD_SWID		MPD_WCNSS_PAS_ID
+@@ -43,8 +44,6 @@
+ #define UPD_BOOT_INFO_SMEM_ID		507
+ #define VERSION2			2
+ 
+-static LIST_HEAD(upd_rproc_list);
+-
+ /**
+  * struct userpd_boot_info_header - header of user pd bootinfo
+  * @type:		type of bootinfo passing over smem
+@@ -80,6 +79,7 @@ struct q6_wcss {
+ 	size_t mem_size;
+ 	const struct wcss_data *desc;
+ 	const char **firmware;
++	struct userpd *upd[MAX_UPD];
+ };
+ 
+ struct userpd {
+@@ -270,13 +270,12 @@ static void *q6_wcss_da_to_va(struct rpr
+  */
+ static int share_upd_bootinfo_to_q6(struct rproc *rproc)
+ {
+-	int ret;
++	int i, ret;
+ 	size_t size;
+ 	u16 cnt = 0, version;
+ 	void *ptr;
+ 	struct q6_wcss *wcss = rproc->priv;
+ 	struct userpd *upd;
+-	struct rproc *upd_rproc;
+ 	struct userpd_boot_info upd_bootinfo = {0};
+ 	const struct firmware *fw;
+ 
+@@ -301,16 +300,19 @@ static int share_upd_bootinfo_to_q6(stru
+ 	memcpy_toio(ptr, &version, sizeof(version));
+ 	ptr += sizeof(version);
+ 
+-	list_for_each_entry(upd_rproc, &upd_rproc_list, node)
+-		cnt++;
++	for (i = 0; i < ARRAY_SIZE(wcss->upd); i++)
++		if (wcss->upd[i])
++			cnt++;
+ 
+ 	/* No of elements */
+ 	cnt = (sizeof(upd_bootinfo) * cnt);
+ 	memcpy_toio(ptr, &cnt, sizeof(u16));
+ 	ptr += sizeof(u16);
+ 
+-	list_for_each_entry(upd_rproc, &upd_rproc_list, node) {
+-		upd = upd_rproc->priv;
++	for (i = 0; i < ARRAY_SIZE(wcss->upd); i++) {
++		upd = wcss->upd[i];
++		if (!upd)
++			continue;
+ 
+ 		/* TYPE */
+ 		upd_bootinfo.header.type = UPD_BOOT_INFO_HEADER_TYPE;
+@@ -322,14 +324,14 @@ static int share_upd_bootinfo_to_q6(stru
+ 		/* Process ID */
+ 		upd_bootinfo.pid = upd->pd_asid + 1;
+ 
+-		ret = request_firmware(&fw, upd_rproc->firmware, upd->dev);
++		ret = request_firmware(&fw, upd->q6.rproc->firmware, upd->dev);
+ 		if (ret < 0) {
+ 			dev_err(upd->dev, "request_firmware failed: %d\n",	ret);
+ 			return ret;
+ 		}
+ 
+ 		/* Load address */
+-		upd_bootinfo.bootaddr = rproc_get_boot_addr(upd_rproc, fw);
++		upd_bootinfo.bootaddr = rproc_get_boot_addr(upd->q6.rproc, fw);
+ 
+ 		/* Firmware mem size */
+ 		upd_bootinfo.data_size = qcom_mdt_get_size(fw);
+@@ -597,18 +599,23 @@ static int init_irq(struct qcom_q6v5 *q6
+ 	return 0;
+ }
+ 
+-static void q6_release_resources(void)
++static void q6_release_resources(struct q6_wcss *wcss)
+ {
+-	struct rproc *upd_rproc;
++	struct userpd *upd;
++	int i;
+ 
+ 	/* Release userpd resources */
+-	list_for_each_entry(upd_rproc, &upd_rproc_list, node) {
+-		rproc_del(upd_rproc);
+-		rproc_free(upd_rproc);
++	for (i = 0; i < ARRAY_SIZE(wcss->upd); i++) {
++		upd = wcss->upd[i];
++		if (!upd)
++			continue;
++
++		rproc_del(upd->q6.rproc);
++		rproc_free(upd->q6.rproc);
+ 	}
+ }
+ 
+-static int q6_register_userpd(struct platform_device *pdev,
++static int q6_register_userpd(struct q6_wcss *wcss,
+ 			      struct device_node *userpd_np)
+ {
+ 	struct userpd *upd;
+@@ -633,16 +640,16 @@ static int q6_register_userpd(struct pla
+ 		return ret;
+ 	}
+ 
+-	dev_info(&pdev->dev, "%s node found\n", userpd_np->name);
++	dev_info(wcss->dev, "%s node found\n", userpd_np->name);
+ 
+ 	userpd_pdev = of_platform_device_create(userpd_np, userpd_np->name,
+-						&pdev->dev);
++						wcss->dev);
+ 	if (!userpd_pdev)
+-		return dev_err_probe(&pdev->dev, -ENODEV,
++		return dev_err_probe(wcss->dev, -ENODEV,
+ 				     "failed to create %s platform device\n",
+ 				     userpd_np->name);
+ 
+-	userpd_pdev->dev.driver = pdev->dev.driver;
++	userpd_pdev->dev.driver = wcss->dev->driver;
+ 	rproc = rproc_alloc(&userpd_pdev->dev, userpd_pdev->name, &wcss_ops,
+ 			    firmware_name, sizeof(*upd));
+ 	if (!rproc) {
+@@ -663,7 +670,7 @@ static int q6_register_userpd(struct pla
+ 	if (ret)
+ 		goto free_rproc;
+ 
+-	list_add(&rproc->node, &upd_rproc_list);
++	wcss->upd[upd->pd_asid] = upd;
+ 	platform_set_drvdata(userpd_pdev, rproc);
+ 	qcom_add_ssr_subdev(rproc, &upd->ssr_subdev, userpd_pdev->name);
+ 	return 0;
+@@ -728,10 +735,10 @@ static int q6_wcss_probe(struct platform
+ 
+ 	/* Iterate over userpd child's and register with rproc */
+ 	for_each_available_child_of_node(pdev->dev.of_node, userpd_np) {
+-		ret = q6_register_userpd(pdev, userpd_np);
++		ret = q6_register_userpd(wcss, userpd_np);
+ 		if (ret) {
+ 			/* release resources of successfully allocated userpd rproc's */
+-			q6_release_resources();
++			q6_release_resources(wcss);
+ 			return dev_err_probe(&pdev->dev, ret,
+ 					     "Failed to register userpd(%s)\n",
+ 					     userpd_np->name);
diff --git a/target/linux/qualcommax/patches-6.6/0811-firmware-qcom_scm-support-MPD.patch b/target/linux/qualcommax/patches-6.6/0811-firmware-qcom_scm-support-MPD.patch
new file mode 100644
index 0000000000..afcc15e69f
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0811-firmware-qcom_scm-support-MPD.patch
@@ -0,0 +1,128 @@
+From 6553d598cdb507f7ede020f25da646ba084a23c6 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH] firmware: qcom_scm: support MPD
+
+Add SCM calls to power up / down the SoC's internal WiFi radio and to 
+load PIL segments to support the MPD architecture.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ drivers/firmware/qcom_scm.c            | 79 ++++++++++++++++++++++++++
+ drivers/firmware/qcom_scm.h            |  3 +
+ include/linux/firmware/qcom/qcom_scm.h |  3 +
+ 3 files changed, 85 insertions(+)
+
+--- a/drivers/firmware/qcom_scm.c
++++ b/drivers/firmware/qcom_scm.c
+@@ -713,6 +713,85 @@ bool qcom_scm_pas_supported(u32 peripher
+ EXPORT_SYMBOL_GPL(qcom_scm_pas_supported);
+ 
+ /**
++ * qcom_scm_internal_wifi_powerup() - Bring up internal wifi
++ * @peripheral:	peripheral id
++ *
++ * Return 0 on success.
++ */
++int qcom_scm_internal_wifi_powerup(u32 peripheral)
++{
++	struct qcom_scm_desc desc = {
++		.svc = QCOM_SCM_SVC_PIL,
++		.cmd = QCOM_SCM_INTERNAL_WIFI_POWERUP,
++		.arginfo = QCOM_SCM_ARGS(1),
++		.args[0] = peripheral,
++		.owner = ARM_SMCCC_OWNER_SIP,
++	};
++	struct qcom_scm_res res;
++	int ret;
++
++	ret = qcom_scm_call(__scm->dev, &desc, &res);
++
++	return ret ? : res.result[0];
++}
++EXPORT_SYMBOL(qcom_scm_internal_wifi_powerup);
++
++/**
++ * qcom_scm_internal_wifi_shutdown() - Shut down internal wifi
++ * @peripheral: peripheral id
++ *
++ * Returns 0 on success.
++ */
++int qcom_scm_internal_wifi_shutdown(u32 peripheral)
++{
++	struct qcom_scm_desc desc = {
++		.svc = QCOM_SCM_SVC_PIL,
++		.cmd = QCOM_SCM_INTERNAL_WIFI_SHUTDOWN,
++		.arginfo = QCOM_SCM_ARGS(1),
++		.args[0] = peripheral,
++		.owner = ARM_SMCCC_OWNER_SIP,
++	};
++	struct qcom_scm_res res;
++	int ret;
++
++	ret = qcom_scm_call(__scm->dev, &desc, &res);
++
++	return ret ? : res.result[0];
++}
++EXPORT_SYMBOL(qcom_scm_internal_wifi_shutdown);
++
++/**
++ * qcom_scm_pas_load_segment() - copy userpd PIL segments data to dma blocks
++ * @peripheral:		peripheral id
++ * @segment:		segment id
++ * @dma:		handle of dma region
++ * @seg_cnt:		no of dma blocks
++ *
++ * Returns 0 if trustzone successfully loads userpd PIL segments from dma
++ * blocks to DDR
++ */
++int qcom_scm_pas_load_segment(u32 peripheral, int segment, dma_addr_t dma, int seg_cnt)
++{
++	struct qcom_scm_desc desc = {
++		.svc = QCOM_SCM_SVC_PIL,
++		.cmd = QCOM_SCM_PIL_PAS_LOAD_SEG,
++		.arginfo = QCOM_SCM_ARGS(4, QCOM_SCM_VAL, QCOM_SCM_VAL, QCOM_SCM_RW, QCOM_SCM_VAL),
++		.args[0] = peripheral,
++		.args[1] = segment,
++		.args[2] = dma,
++		.args[3] = seg_cnt,
++		.owner = ARM_SMCCC_OWNER_SIP,
++	};
++	struct qcom_scm_res res;
++	int ret;
++
++	ret = qcom_scm_call(__scm->dev, &desc, &res);
++
++	return ret ? : res.result[0];
++}
++EXPORT_SYMBOL(qcom_scm_pas_load_segment);
++
++/**
+  * qcom_scm_msa_lock() - Lock given peripheral firmware region as MSA
+  *
+  * @peripheral:	peripheral id
+--- a/drivers/firmware/qcom_scm.h
++++ b/drivers/firmware/qcom_scm.h
+@@ -98,6 +98,9 @@ extern int scm_legacy_call(struct device
+ #define QCOM_SCM_PIL_PAS_SHUTDOWN	0x06
+ #define QCOM_SCM_PIL_PAS_IS_SUPPORTED	0x07
+ #define QCOM_SCM_PIL_PAS_MSS_RESET	0x0a
++#define QCOM_SCM_INTERNAL_WIFI_POWERUP	0x17
++#define QCOM_SCM_INTERNAL_WIFI_SHUTDOWN	0x18
++#define QCOM_SCM_PIL_PAS_LOAD_SEG	0x19
+ #define QCOM_SCM_MSA_LOCK		0x24
+ #define QCOM_SCM_MSA_UNLOCK		0x25
+ 
+--- a/include/linux/firmware/qcom/qcom_scm.h
++++ b/include/linux/firmware/qcom/qcom_scm.h
+@@ -81,6 +81,9 @@ extern int qcom_scm_pas_mem_setup(u32 pe
+ extern int qcom_scm_pas_auth_and_reset(u32 peripheral);
+ extern int qcom_scm_pas_shutdown(u32 peripheral);
+ extern bool qcom_scm_pas_supported(u32 peripheral);
++extern int qcom_scm_internal_wifi_powerup(u32 peripheral);
++extern int qcom_scm_internal_wifi_shutdown(u32 peripheral);
++extern int qcom_scm_pas_load_segment(u32 peripheral, int segment, dma_addr_t dma, int seg_cnt);
+ extern int qcom_scm_msa_lock(u32 peripheral);
+ extern int qcom_scm_msa_unlock(u32 peripheral);
+ 
diff --git a/target/linux/qualcommax/patches-6.6/0812-soc-qcom-mdt_loader-support-MPD.patch b/target/linux/qualcommax/patches-6.6/0812-soc-qcom-mdt_loader-support-MPD.patch
new file mode 100644
index 0000000000..935a943858
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0812-soc-qcom-mdt_loader-support-MPD.patch
@@ -0,0 +1,199 @@
+From bf42d84868bc82a9cb334a33930f2d1da24f7070 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH] soc: qcom: mdt_loader: support MPD
+
+Add support for loading user PD specific PIL segments as required by the 
+MPD architecture.
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+ drivers/soc/qcom/mdt_loader.c       | 110 ++++++++++++++++++++++++++--
+ include/linux/soc/qcom/mdt_loader.h |   5 ++
+ 2 files changed, 110 insertions(+), 5 deletions(-)
+
+--- a/drivers/soc/qcom/mdt_loader.c
++++ b/drivers/soc/qcom/mdt_loader.c
+@@ -16,6 +16,16 @@
+ #include <linux/sizes.h>
+ #include <linux/slab.h>
+ #include <linux/soc/qcom/mdt_loader.h>
++#include <linux/dma-mapping.h>
++
++#include "../../remoteproc/qcom_common.h"
++
++#define QCOM_MDT_PF_ASID_MASK	GENMASK(19, 16)
++
++struct segment_load_args {
++	__le64 addr;
++	__le64 blk_size;
++};
+ 
+ static bool mdt_phdr_valid(const struct elf32_phdr *phdr)
+ {
+@@ -69,6 +79,56 @@ static ssize_t mdt_load_split_segment(vo
+ 	return ret;
+ }
+ 
++static int mdt_load_split_segment_dma(int pas_id, unsigned int segment,
++				      const struct elf32_phdr *phdrs,
++				      const char *fw_name,
++				      struct device *dev)
++{
++	const struct elf32_phdr *phdr = &phdrs[segment];
++	struct segment_load_args *args;
++	dma_addr_t *addrs;
++	void *ptr;
++	dma_addr_t dma_args, dma_addrs, dma_ptr;
++	int ret;
++
++	args = dma_alloc_coherent(dev, sizeof(*args) + sizeof(*addrs), &dma_args, GFP_DMA);
++	if (!args) {
++		dev_err(dev, "Error in dma alloc regin: %ld\n", sizeof(*args));
++		return -ENOMEM;
++	}
++
++	addrs = (void *) args + sizeof(*args);
++	dma_addrs = dma_args + sizeof(*args);
++
++	ptr = dma_alloc_coherent(dev, phdr->p_filesz, &dma_ptr, GFP_DMA);
++	if (!ptr) {
++		dev_err(dev, "Error in dma alloc ptr: %d\n", phdr->p_filesz);
++		return -ENOMEM;
++	}
++
++	args->addr = dma_addrs;
++	args->blk_size = phdr->p_filesz;
++
++	addrs[0] = dma_ptr;
++
++	ret = mdt_load_split_segment(ptr, phdrs, segment, fw_name, dev);
++	if (ret < 0) {
++		dev_err(dev, "Error in mdt_load_split_segment: %d\n", ret);
++		return ret;
++	}
++
++	ret = qcom_scm_pas_load_segment(pas_id, segment, dma_args, 1);
++	if (ret < 0) {
++		dev_err(dev, "Error in qcom_scm_pas_load_segment: %d\n", ret);
++		return ret;
++	}
++
++	dma_free_coherent(dev, phdr->p_filesz, ptr, dma_ptr);
++	dma_free_coherent(dev, sizeof(*args) + sizeof(*addrs), args, dma_args);
++
++	return 0;
++}
++
+ /**
+  * qcom_mdt_get_size() - acquire size of the memory region needed to load mdt
+  * @fw:		firmware object for the mdt file
+@@ -295,7 +355,8 @@ static bool qcom_mdt_bins_are_split(cons
+ static int __qcom_mdt_load(struct device *dev, const struct firmware *fw,
+ 			   const char *fw_name, int pas_id, void *mem_region,
+ 			   phys_addr_t mem_phys, size_t mem_size,
+-			   phys_addr_t *reloc_base, bool pas_init)
++			   phys_addr_t *reloc_base, bool pas_init,
++			   bool dma_require, int pd_asid)
+ {
+ 	const struct elf32_phdr *phdrs;
+ 	const struct elf32_phdr *phdr;
+@@ -349,6 +410,14 @@ static int __qcom_mdt_load(struct device
+ 		if (!mdt_phdr_valid(phdr))
+ 			continue;
+ 
++		/*
++		 * While doing PD specific reloading, load only that PD
++		 * specific writeable entries. Skip others
++		 */
++		if (pd_asid && (FIELD_GET(QCOM_MDT_PF_ASID_MASK, phdr->p_flags) != pd_asid ||
++				(phdr->p_flags & PF_W) == 0))
++			continue;
++
+ 		offset = phdr->p_paddr - mem_reloc;
+ 		if (offset < 0 || offset + phdr->p_memsz > mem_size) {
+ 			dev_err(dev, "segment outside memory range\n");
+@@ -366,7 +435,11 @@ static int __qcom_mdt_load(struct device
+ 
+ 		ptr = mem_region + offset;
+ 
+-		if (phdr->p_filesz && !is_split) {
++		if (dma_require && phdr->p_filesz) {
++			ret = mdt_load_split_segment_dma(pas_id, i, phdrs, fw_name, dev);
++			if (ret)
++				break;
++		} else if (phdr->p_filesz && !is_split) {
+ 			/* Firmware is large enough to be non-split */
+ 			if (phdr->p_offset + phdr->p_filesz > fw->size) {
+ 				dev_err(dev, "file %s segment %d would be truncated\n",
+@@ -383,7 +456,7 @@ static int __qcom_mdt_load(struct device
+ 				break;
+ 		}
+ 
+-		if (phdr->p_memsz > phdr->p_filesz)
++		if (!dma_require && phdr->p_memsz > phdr->p_filesz)
+ 			memset(ptr + phdr->p_filesz, 0, phdr->p_memsz - phdr->p_filesz);
+ 	}
+ 
+@@ -418,7 +491,7 @@ int qcom_mdt_load(struct device *dev, co
+ 		return ret;
+ 
+ 	return __qcom_mdt_load(dev, fw, firmware, pas_id, mem_region, mem_phys,
+-			       mem_size, reloc_base, true);
++			       mem_size, reloc_base, true, false, 0);
+ }
+ EXPORT_SYMBOL_GPL(qcom_mdt_load);
+ 
+@@ -441,9 +514,36 @@ int qcom_mdt_load_no_init(struct device
+ 			  size_t mem_size, phys_addr_t *reloc_base)
+ {
+ 	return __qcom_mdt_load(dev, fw, firmware, pas_id, mem_region, mem_phys,
+-			       mem_size, reloc_base, false);
++			       mem_size, reloc_base, false, false, 0);
+ }
+ EXPORT_SYMBOL_GPL(qcom_mdt_load_no_init);
+ 
++/**
++ * qcom_mdt_load_pd_seg() - load userpd specific PIL segements
++ * @dev:	device handle to associate resources with
++ * @fw:		firmware object for the mdt file
++ * @firmware:	name of the firmware, for construction of segment file names
++ * @pas_id:	PAS identifier
++ * @mem_region:	allocated memory region to load firmware into
++ * @mem_phys:	physical address of allocated memory region
++ * @mem_size:	size of the allocated memory region
++ * @reloc_base:	adjusted physical address after relocation
++ *
++ * Here userpd PIL segements are stitched with rootpd firmware.
++ * This function reloads userpd specific PIL segments during SSR
++ * of userpd.
++ *
++ * Returns 0 on success, negative errno otherwise.
++ */
++int qcom_mdt_load_pd_seg(struct device *dev, const struct firmware *fw,
++			 const char *firmware, int pas_id, int pd_asid, void *mem_region,
++			 phys_addr_t mem_phys, size_t mem_size,
++			 phys_addr_t *reloc_base)
++{
++	return __qcom_mdt_load(dev, fw, firmware, pas_id, mem_region, mem_phys,
++			       mem_size, reloc_base, false, true, pd_asid);
++}
++EXPORT_SYMBOL_GPL(qcom_mdt_load_pd_seg);
++
+ MODULE_DESCRIPTION("Firmware parser for Qualcomm MDT format");
+ MODULE_LICENSE("GPL v2");
+--- a/include/linux/soc/qcom/mdt_loader.h
++++ b/include/linux/soc/qcom/mdt_loader.h
+@@ -30,6 +30,11 @@ int qcom_mdt_load_no_init(struct device
+ void *qcom_mdt_read_metadata(const struct firmware *fw, size_t *data_len,
+ 			     const char *fw_name, struct device *dev);
+ 
++int qcom_mdt_load_pd_seg(struct device *dev, const struct firmware *fw,
++			 const char *firmware, int pas_id, int pd_asid, void *mem_region,
++			 phys_addr_t mem_phys, size_t mem_size,
++			 phys_addr_t *reloc_base);
++
+ #else /* !IS_ENABLED(CONFIG_QCOM_MDT_LOADER) */
+ 
+ static inline ssize_t qcom_mdt_get_size(const struct firmware *fw)
diff --git a/target/linux/qualcommax/patches-6.6/0813-remoteproc-qcom_q6v5_mpd-enable-clocks.patch b/target/linux/qualcommax/patches-6.6/0813-remoteproc-qcom_q6v5_mpd-enable-clocks.patch
new file mode 100644
index 0000000000..f549580f3d
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0813-remoteproc-qcom_q6v5_mpd-enable-clocks.patch
@@ -0,0 +1,38 @@
+From e83215d5d22946885fa388d375b12f1b991a43c1 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH 3/5] remoteproc: qcom_q6v5_mpd: enable clocks
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+---
+ drivers/remoteproc/qcom_q6v5_mpd.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/drivers/remoteproc/qcom_q6v5_mpd.c
++++ b/drivers/remoteproc/qcom_q6v5_mpd.c
+@@ -77,6 +77,8 @@ struct q6_wcss {
+ 	phys_addr_t mem_reloc;
+ 	void *mem_region;
+ 	size_t mem_size;
++	struct clk_bulk_data *clks;
++	int num_clks;
+ 	const struct wcss_data *desc;
+ 	const char **firmware;
+ 	struct userpd *upd[MAX_UPD];
+@@ -718,6 +720,16 @@ static int q6_wcss_probe(struct platform
+ 	if (ret)
+ 		goto free_rproc;
+ 
++	wcss->num_clks = devm_clk_bulk_get_all(wcss->dev, &wcss->clks);
++	if (wcss->num_clks < 0)
++		return dev_err_probe(wcss->dev, wcss->num_clks,
++				     "failed to acquire clocks\n");
++
++	ret = clk_bulk_prepare_enable(wcss->num_clks, wcss->clks);
++	if (ret)
++		return dev_err_probe(wcss->dev, ret,
++				     "failed to enable clocks\n");
++
+ 	ret = qcom_q6v5_init(&wcss->q6, pdev, rproc,
+ 			     WCSS_CRASH_REASON, NULL, NULL);
+ 	if (ret)
diff --git a/target/linux/qualcommax/patches-6.6/0814-remoteproc-qcom_q6v5_mpd-support-ipq5018.patch b/target/linux/qualcommax/patches-6.6/0814-remoteproc-qcom_q6v5_mpd-support-ipq5018.patch
new file mode 100644
index 0000000000..9316458cbd
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0814-remoteproc-qcom_q6v5_mpd-support-ipq5018.patch
@@ -0,0 +1,111 @@
+From 4ae334127f073aa5f7c9209c9f0a17fd9e331db1 Mon Sep 17 00:00:00 2001
+From: Ziyang Huang <hzyitc@outlook.com>
+Date: Sun, 8 Sep 2024 16:40:12 +0800
+Subject: [PATCH] remoteproc: qcom_q6v5_mpd: support ipq5018
+
+Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
+---
+ drivers/remoteproc/qcom_q6v5_mpd.c | 37 +++++++++++++++++++++++++++---
+ 1 file changed, 34 insertions(+), 3 deletions(-)
+
+--- a/drivers/remoteproc/qcom_q6v5_mpd.c
++++ b/drivers/remoteproc/qcom_q6v5_mpd.c
+@@ -155,6 +155,8 @@ static int q6_wcss_spawn_pd(struct rproc
+ static int wcss_pd_start(struct rproc *rproc)
+ {
+ 	struct userpd *upd = rproc->priv;
++	struct rproc *rpd_rproc = dev_get_drvdata(upd->dev->parent);
++	struct q6_wcss *wcss = rpd_rproc->priv;
+ 	u32 pasid = (upd->pd_asid << 8) | UPD_SWID;
+ 	int ret;
+ 
+@@ -170,6 +172,14 @@ static int wcss_pd_start(struct rproc *r
+ 			return ret;
+ 	}
+ 
++	if (upd->pd_asid == 1) {
++		ret = qcom_scm_internal_wifi_powerup(wcss->desc->pasid);
++		if (ret) {
++			dev_err(upd->dev, "failed to power up internal radio\n");
++			return ret;
++		}
++	}
++
+ 	return ret;
+ }
+ 
+@@ -179,6 +189,12 @@ static int q6_wcss_stop(struct rproc *rp
+ 	const struct wcss_data *desc = wcss->desc;
+ 	int ret;
+ 
++	ret = qcom_q6v5_request_stop(&wcss->q6, NULL);
++	if (ret) {
++		dev_err(wcss->dev, "pd not stopped\n");
++		return ret;
++	}
++
+ 	ret = qcom_scm_pas_shutdown(desc->pasid);
+ 	if (ret) {
+ 		dev_err(wcss->dev, "not able to shutdown\n");
+@@ -218,6 +234,7 @@ static int wcss_pd_stop(struct rproc *rp
+ {
+ 	struct userpd *upd = rproc->priv;
+ 	struct rproc *rpd_rproc = dev_get_drvdata(upd->dev->parent);
++	struct q6_wcss *wcss = rpd_rproc->priv;
+ 	u32 pasid = (upd->pd_asid << 8) | UPD_SWID;
+ 	int ret;
+ 
+@@ -229,6 +246,14 @@ static int wcss_pd_stop(struct rproc *rp
+ 		}
+ 	}
+ 
++	if (upd->pd_asid == 1) {
++		ret = qcom_scm_internal_wifi_shutdown(wcss->desc->pasid);
++		if (ret) {
++			dev_err(upd->dev, "failed to power down internal radio\n");
++			return ret;
++		}
++	}
++
+ 	ret = qcom_scm_msa_unlock(pasid);
+ 	if (ret) {
+ 		dev_err(upd->dev, "failed to power down pd\n");
+@@ -430,15 +455,14 @@ static int wcss_pd_load(struct rproc *rp
+ 	struct userpd *upd = rproc->priv;
+ 	struct rproc *rpd_rproc = dev_get_drvdata(upd->dev->parent);
+ 	struct q6_wcss *wcss = rpd_rproc->priv;
+-	u32 pasid = (upd->pd_asid << 8) | UPD_SWID;
+ 	int ret;
+ 
+ 	ret = rproc_boot(rpd_rproc);
+ 	if (ret)
+ 		return ret;
+ 
+-	return qcom_mdt_load(upd->dev, fw, rproc->firmware,
+-			     pasid, wcss->mem_region,
++	return qcom_mdt_load_pd_seg(upd->dev, fw, rproc->firmware,
++			     wcss->desc->pasid, upd->pd_asid, wcss->mem_region,
+ 			     wcss->mem_phys, wcss->mem_size,
+ 			     NULL);
+ }
+@@ -777,6 +801,12 @@ static int q6_wcss_remove(struct platfor
+ 	return 0;
+ }
+ 
++static const struct wcss_data q6_ipq5018_res_init = {
++	.pasid = MPD_WCNSS_PAS_ID,
++	// .share_upd_info_to_q6 = true, /* Version 1 */
++	// .mdt_load_sec = qcom_mdt_load_pd_seg,
++};
++
+ static const struct wcss_data q6_ipq5332_res_init = {
+ 	.pasid = MPD_WCNSS_PAS_ID,
+ 	.share_upd_info_to_q6 = true,
+@@ -787,6 +817,7 @@ static const struct wcss_data q6_ipq9574
+ };
+ 
+ static const struct of_device_id q6_wcss_of_match[] = {
++	{ .compatible = "qcom,ipq5018-q6-mpd", .data = &q6_ipq5018_res_init },
+ 	{ .compatible = "qcom,ipq5332-q6-mpd", .data = &q6_ipq5332_res_init },
+ 	{ .compatible = "qcom,ipq9574-q6-mpd", .data = &q6_ipq9574_res_init },
+ 	{ },
diff --git a/target/linux/qualcommax/patches-6.6/0815-remoteproc-qcom_q6v5_mpd-add-support-for-passing-v1-bootargs.patch b/target/linux/qualcommax/patches-6.6/0815-remoteproc-qcom_q6v5_mpd-add-support-for-passing-v1-bootargs.patch
new file mode 100644
index 0000000000..fdc2879f03
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0815-remoteproc-qcom_q6v5_mpd-add-support-for-passing-v1-bootargs.patch
@@ -0,0 +1,163 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Mon, 09 Dec 2024 09:59:38 +0400
+Subject: [PATCH] remoteproc: qcom_q6v5_mpd: add support for passing v1 bootargs
+
+On multi-PD platforms such as IPQ5018, boot args are passed to the root PD
+run on the Q6 processor which in turn boots the user PDs for internal 
+(IPQ5018) and external wifi radios (such as QCN6122). These boot args 
+let the user PD process know details like what PCIE index, user PD ID, and
+reset GPIO is used. These are otherwise hardcoded in the firmware.
+
+Below is the structure expected of the version 1 boot args including the 
+default values hardcoded in the firmware for IPQ5018:
+
++------------+------+--------------+--------------+
+| Argument   | type | def val UPD2 | def val UPD3 |
++------------+------+--------------+--------------+
+| PCIE Index | u32  | 0x02 (PCIE1) | 0x01 (PCIE0) |
+| Length     | u32  | 0x04         | 0x04         |
+| User PD ID | u32  | 0x02         | 0x03         |
+| Reset GPIO | u32  | 0x12         | 0x0f         |
+| Reserved 1 | u32  | 0x00         | 0x00         |
+| Reserved 2 | u32  | 0x00         | 0x00         |
++------------+------+--------------+--------------+
+
+On IPQ5018/QCN6122 boards, the default mapping is as follows:
+
+          +-> UPD1 ----> IPQ5018 Internal 2.4G Radio
+         / 
+        /
+Root PD +---> UPD2 ----> QCN6122 6G Radio on PCIE1 (if available)
+        \
+         \
+          +-> UPD3 ----> QCN6102 5G Radio on PCIE0
+
+To support (future) boards with other mappings or control what UPD ID is 
+used, let's add support for passing boot args for more flexibility.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/drivers/remoteproc/qcom_q6v5_mpd.c
++++ b/drivers/remoteproc/qcom_q6v5_mpd.c
+@@ -42,7 +42,11 @@
+ #define UPD_BOOT_INFO_SMEM_SIZE		4096
+ #define UPD_BOOT_INFO_HEADER_TYPE	0x2
+ #define UPD_BOOT_INFO_SMEM_ID		507
+-#define VERSION2			2
++
++enum q6_bootargs_version {
++	VERSION1 = 1,
++	VERSION2,
++};
+ 
+ /**
+  * struct userpd_boot_info_header - header of user pd bootinfo
+@@ -94,6 +98,7 @@ struct userpd {
+ struct wcss_data {
+ 	u32 pasid;
+ 	bool share_upd_info_to_q6;
++	u8 bootargs_version;
+ };
+ 
+ /**
+@@ -298,10 +303,13 @@ static void *q6_wcss_da_to_va(struct rpr
+ static int share_upd_bootinfo_to_q6(struct rproc *rproc)
+ {
+ 	int i, ret;
++	u32 rd_val;
+ 	size_t size;
+ 	u16 cnt = 0, version;
+ 	void *ptr;
++	u8 *bootargs_arr;
+ 	struct q6_wcss *wcss = rproc->priv;
++	struct device_node *np = wcss->dev->of_node;
+ 	struct userpd *upd;
+ 	struct userpd_boot_info upd_bootinfo = {0};
+ 	const struct firmware *fw;
+@@ -323,10 +331,47 @@ static int share_upd_bootinfo_to_q6(stru
+ 	}
+ 
+ 	/*Version*/
+-	version = VERSION2;
++	version = (wcss->desc->bootargs_version) ? wcss->desc->bootargs_version : VERSION2;
+ 	memcpy_toio(ptr, &version, sizeof(version));
+ 	ptr += sizeof(version);
+ 
++	cnt = ret = of_property_count_u32_elems(np, "boot-args");
++	if (ret < 0) {
++		if (ret == -ENODATA) {
++			dev_err(wcss->dev, "failed to read boot args ret:%d\n", ret);
++			return ret;
++		}
++		cnt = 0;
++	}
++
++	/* No of elements */
++	memcpy_toio(ptr, &cnt, sizeof(u16));
++	ptr += sizeof(u16);
++
++	bootargs_arr = kzalloc(cnt, GFP_KERNEL);
++	if (!bootargs_arr) {
++		dev_err(wcss->dev, "failed to allocate memory\n");
++		return PTR_ERR(bootargs_arr);
++	}
++
++	for (i = 0; i < cnt; i++) {
++		ret = of_property_read_u32_index(np, "boot-args", i, &rd_val);
++		if (ret) {
++			dev_err(wcss->dev, "failed to read boot args\n");
++			kfree(bootargs_arr);
++			return ret;
++		}
++		bootargs_arr[i] = (u8)rd_val;
++	}
++
++	/* Copy bootargs */
++	memcpy_toio(ptr, bootargs_arr, cnt);
++	ptr += (cnt);
++
++	of_node_put(np);
++	kfree(bootargs_arr);
++	cnt = 0;
++
+ 	for (i = 0; i < ARRAY_SIZE(wcss->upd); i++)
+ 		if (wcss->upd[i])
+ 			cnt++;
+@@ -382,12 +427,14 @@ static int q6_wcss_load(struct rproc *rp
+ 
+ 	/* Share user pd boot info to Q6 remote processor */
+ 	if (desc->share_upd_info_to_q6) {
+-		ret = share_upd_bootinfo_to_q6(rproc);
+-		if (ret) {
+-			dev_err(wcss->dev,
+-				"user pd boot info sharing with q6 failed %d\n",
+-				ret);
+-			return ret;
++		if (of_property_present(wcss->dev->of_node, "boot-args")) {
++			ret = share_upd_bootinfo_to_q6(rproc);
++			if (ret) {
++				dev_err(wcss->dev,
++					"user pd boot info sharing with q6 failed %d\n",
++					ret);
++				return ret;
++			}
+ 		}
+ 	}
+ 
+@@ -803,13 +850,15 @@ static int q6_wcss_remove(struct platfor
+ 
+ static const struct wcss_data q6_ipq5018_res_init = {
+ 	.pasid = MPD_WCNSS_PAS_ID,
+-	// .share_upd_info_to_q6 = true, /* Version 1 */
++	.share_upd_info_to_q6 = true,
++	.bootargs_version = VERSION1,
+ 	// .mdt_load_sec = qcom_mdt_load_pd_seg,
+ };
+ 
+ static const struct wcss_data q6_ipq5332_res_init = {
+ 	.pasid = MPD_WCNSS_PAS_ID,
+ 	.share_upd_info_to_q6 = true,
++	.bootargs_version = VERSION2,
+ };
+ 
+ static const struct wcss_data q6_ipq9574_res_init = {
diff --git a/target/linux/qualcommax/patches-6.6/0816-arm64-dts-qcom-ipq5018-add-wifi-support.patch b/target/linux/qualcommax/patches-6.6/0816-arm64-dts-qcom-ipq5018-add-wifi-support.patch
new file mode 100644
index 0000000000..786345f640
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0816-arm64-dts-qcom-ipq5018-add-wifi-support.patch
@@ -0,0 +1,241 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Wed, 27 Oct 2024 16:34:11 +0400
+Subject: [PATCH] arm64: dts: qcom: ipq5018: add wifi support
+
+The IPQ5018 SoC comes with an internal 2x2 2.4Ghz wifi radio.
+QCN6122 is a PCIe based wifi solution specific to the IPQ5018 platform which 
+comes optinally packed with 1 or 2 QCN6122 chips or with an external 
+PCIe based wifi solution (such as QCN9074) for 5/6 Ghz support.
+
+As such, add wifi nodes for both IPQ5018 and QCN6122.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -692,6 +692,225 @@
+ 			};
+ 		};
+ 
++		wifi0: wifi@c000000 {
++			compatible = "qcom,ipq5018-wifi";
++			reg = <0xc000000 0x1000000>;
++
++			interrupts = <GIC_SPI 288 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 289 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 290 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 291 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 292 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 293 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 294 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 295 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 296 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 297 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 298 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 299 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 300 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 301 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 302 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 303 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 304 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 305 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 306 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 307 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 308 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 309 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 310 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 311 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 312 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 313 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 314 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 315 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 316 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 317 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 318 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 319 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 320 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 321 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 322 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 323 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 324 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 325 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 326 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 327 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 328 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 329 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 330 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 331 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 332 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 333 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 334 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 335 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 336 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 337 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 338 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 339 IRQ_TYPE_EDGE_RISING>;
++
++			interrupt-names = "misc-pulse1",
++					  "misc-latch",
++					  "sw-exception",
++					  "watchdog",
++					  "ce0",
++					  "ce1",
++					  "ce2",
++					  "ce3",
++					  "ce4",
++					  "ce5",
++					  "ce6",
++					  "ce7",
++					  "ce8",
++					  "ce9",
++					  "ce10",
++					  "ce11",
++					  "host2wbm-desc-feed",
++					  "host2reo-re-injection",
++					  "host2reo-command",
++					  "host2rxdma-monitor-ring3",
++					  "host2rxdma-monitor-ring2",
++					  "host2rxdma-monitor-ring1",
++					  "reo2ost-exception",
++					  "wbm2host-rx-release",
++					  "reo2host-status",
++					  "reo2host-destination-ring4",
++					  "reo2host-destination-ring3",
++					  "reo2host-destination-ring2",
++					  "reo2host-destination-ring1",
++					  "rxdma2host-monitor-destination-mac3",
++					  "rxdma2host-monitor-destination-mac2",
++					  "rxdma2host-monitor-destination-mac1",
++					  "ppdu-end-interrupts-mac3",
++					  "ppdu-end-interrupts-mac2",
++					  "ppdu-end-interrupts-mac1",
++					  "rxdma2host-monitor-status-ring-mac3",
++					  "rxdma2host-monitor-status-ring-mac2",
++					  "rxdma2host-monitor-status-ring-mac1",
++					  "host2rxdma-host-buf-ring-mac3",
++					  "host2rxdma-host-buf-ring-mac2",
++					  "host2rxdma-host-buf-ring-mac1",
++					  "rxdma2host-destination-ring-mac3",
++					  "rxdma2host-destination-ring-mac2",
++					  "rxdma2host-destination-ring-mac1",
++					  "host2tcl-input-ring4",
++					  "host2tcl-input-ring3",
++					  "host2tcl-input-ring2",
++					  "host2tcl-input-ring1",
++					  "wbm2host-tx-completions-ring3",
++					  "wbm2host-tx-completions-ring2",
++					  "wbm2host-tx-completions-ring1",
++					  "tcl2host-status-ring";
++
++			status = "disabled";
++		};
++
++		//QCN6102 5G
++		wifi1: wifi1@c000000 {
++			reg = <0x0b00a040 0x0>;
++			compatible = "qcom,qcn6122-wifi";
++			interrupts = <GIC_SPI 416 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 417 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 418 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 419 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 420 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 421 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 422 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 423 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 424 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 425 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 426 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 427 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 428 IRQ_TYPE_EDGE_RISING>;
++			status = "disabled";
++		};
++
++		//QCN6122 5G/6G
++		wifi2: wifi2@c000000 {
++			reg = <0x0b00a040 0x0>;
++			compatible = "qcom,qcn6122-wifi";
++			interrupts = <GIC_SPI 448 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 449 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 450 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 451 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 452 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 453 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 454 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 455 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 456 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 457 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 458 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 459 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 460 IRQ_TYPE_EDGE_RISING>;
++			status = "disabled";
++		};
++
++		q6v5_wcss: remoteproc@cd00000 {
++			compatible = "qcom,ipq5018-q6-mpd";
++			reg = <0x0cd00000 0x4040>;
++			#address-cells = <1>;
++			#size-cells = <1>;
++			ranges;
++
++			clocks = <&gcc GCC_XO_CLK>,
++				 <&gcc GCC_SLEEP_CLK_SRC>,
++				 <&gcc GCC_SYS_NOC_WCSS_AHB_CLK>;
++
++			interrupts-extended = <&intc GIC_SPI 291 IRQ_TYPE_EDGE_RISING>,
++					      <&wcss_smp2p_in 0 IRQ_TYPE_NONE>,
++					      <&wcss_smp2p_in 1 IRQ_TYPE_NONE>,
++					      <&wcss_smp2p_in 2 IRQ_TYPE_NONE>,
++					      <&wcss_smp2p_in 3 IRQ_TYPE_NONE>;
++			interrupt-names = "wdog",
++					  "fatal",
++					  "ready",
++					  "handover",
++					  "stop-ack";
++
++			qcom,smem-states = <&wcss_smp2p_out 0>,
++					   <&wcss_smp2p_out 1>;
++			qcom,smem-state-names = "shutdown",
++						"stop";
++
++			status = "disabled";
++
++			glink-edge {
++				interrupts = <GIC_SPI 179 IRQ_TYPE_EDGE_RISING>;
++				label = "rtr";
++				qcom,remote-pid = <1>;
++				mboxes = <&apcs_glb 8>;
++
++				qrtr_requests {
++					qcom,glink-channels = "IPCRTR";
++				};
++			};
++		};
++
++		wcss: smp2p-wcss {
++			compatible = "qcom,smp2p";
++			qcom,smem = <435>, <428>;
++
++			interrupt-parent = <&intc>;
++			interrupts = <GIC_SPI 177 IRQ_TYPE_EDGE_RISING>;
++
++			mboxes = <&apcs_glb 9>;
++
++			qcom,local-pid = <0>;
++			qcom,remote-pid = <1>;
++
++			wcss_smp2p_out: master-kernel {
++				qcom,entry-name = "master-kernel";
++				qcom,smp2p-feature-ssr-ack;
++				#qcom,smem-state-cells = <1>;
++			};
++
++			wcss_smp2p_in: slave-kernel {
++				qcom,entry-name = "slave-kernel";
++				interrupt-controller;
++				#interrupt-cells = <2>;
++			};
++		};
++
+ 		pcie1: pcie@80000000 {
+ 			compatible = "qcom,pcie-ipq5018";
+ 			reg = <0x80000000 0xf1d>,
diff --git a/target/linux/qualcommax/patches-6.6/0817-arm64-dts-qcom-ipq5018-add-tz_apps-reserved-memory-region.patch b/target/linux/qualcommax/patches-6.6/0817-arm64-dts-qcom-ipq5018-add-tz_apps-reserved-memory-region.patch
new file mode 100644
index 0000000000..03a9c1c981
--- /dev/null
+++ b/target/linux/qualcommax/patches-6.6/0817-arm64-dts-qcom-ipq5018-add-tz_apps-reserved-memory-region.patch
@@ -0,0 +1,22 @@
+From: George Moussalem <george.moussalem@outlook.com>
+Date: Wed, 05 Feb 2025 12:12:47 +0400
+Subject: [PATCH] arm64: dts: qcom: ipq5018: add tz_apps reserved memory region
+
+Add tz_apps memory region needed for wifi to work.
+
+Signed-off-by: George Moussalem <george.moussalem@outlook.com>
+---
+--- a/arch/arm64/boot/dts/qcom/ipq5018.dtsi
++++ b/arch/arm64/boot/dts/qcom/ipq5018.dtsi
+@@ -113,6 +113,11 @@
+ 		#size-cells = <2>;
+ 		ranges;
+ 
++		tz_apps@4a400000 {
++			reg = <0x0 0x4a400000 0x0 0x400000>;
++			no-map;
++		};
++
+ 		bootloader@4a800000 {
+ 			reg = <0x0 0x4a800000 0x0 0x200000>;
+ 			no-map;
diff --git a/target/linux/qualcommax/patches-6.6/0906-arm64-dts-qcom-ipq6018-add-wifi-node.patch b/target/linux/qualcommax/patches-6.6/0906-arm64-dts-qcom-ipq6018-add-wifi-node.patch
index d41244d65a..25e5d2f62d 100644
--- a/target/linux/qualcommax/patches-6.6/0906-arm64-dts-qcom-ipq6018-add-wifi-node.patch
+++ b/target/linux/qualcommax/patches-6.6/0906-arm64-dts-qcom-ipq6018-add-wifi-node.patch
@@ -15,7 +15,7 @@ Signed-off-by: Mantas Pucka <mantas@8devices.com>
 
 --- a/arch/arm64/boot/dts/qcom/ipq6018.dtsi
 +++ b/arch/arm64/boot/dts/qcom/ipq6018.dtsi
-@@ -814,6 +814,102 @@
+@@ -827,6 +827,102 @@
  			};
  		};
  
diff --git a/target/linux/qualcommax/patches-6.6/0907-soc-qcom-fix-smp2p-ack-on-ipq6018.patch b/target/linux/qualcommax/patches-6.6/0907-soc-qcom-fix-smp2p-ack-on-ipq6018.patch
index 5154aad531..981ee03105 100644
--- a/target/linux/qualcommax/patches-6.6/0907-soc-qcom-fix-smp2p-ack-on-ipq6018.patch
+++ b/target/linux/qualcommax/patches-6.6/0907-soc-qcom-fix-smp2p-ack-on-ipq6018.patch
@@ -15,7 +15,7 @@ Signed-off-by: Mantas Pucka <mantas@8devices.com>
 
 --- a/arch/arm64/boot/dts/qcom/ipq6018.dtsi
 +++ b/arch/arm64/boot/dts/qcom/ipq6018.dtsi
-@@ -1162,6 +1162,7 @@
+@@ -1175,6 +1175,7 @@
  
  		wcss_smp2p_out: master-kernel {
  			qcom,entry-name = "master-kernel";
diff --git a/target/linux/qualcommax/patches-6.6/0909-arm64-dts-qcom-ipq6018-assign-QDSS_AT-clock-to-wifi-.patch b/target/linux/qualcommax/patches-6.6/0909-arm64-dts-qcom-ipq6018-assign-QDSS_AT-clock-to-wifi-.patch
index 993d60870b..150e06f301 100644
--- a/target/linux/qualcommax/patches-6.6/0909-arm64-dts-qcom-ipq6018-assign-QDSS_AT-clock-to-wifi-.patch
+++ b/target/linux/qualcommax/patches-6.6/0909-arm64-dts-qcom-ipq6018-assign-QDSS_AT-clock-to-wifi-.patch
@@ -13,7 +13,7 @@ Signed-off-by: Mantas Pucka <mantas@8devices.com>
 
 --- a/arch/arm64/boot/dts/qcom/ipq6018.dtsi
 +++ b/arch/arm64/boot/dts/qcom/ipq6018.dtsi
-@@ -935,8 +935,8 @@
+@@ -948,8 +948,8 @@
  				      "wcss_reset",
  				      "wcss_q6_reset";
  
diff --git a/target/linux/ramips/files/drivers/dma/mediatek/hsdma-mt7621.c b/target/linux/ramips/files/drivers/dma/mediatek/hsdma-mt7621.c
index a3a9a7f4ae..b99b4a920f 100644
--- a/target/linux/ramips/files/drivers/dma/mediatek/hsdma-mt7621.c
+++ b/target/linux/ramips/files/drivers/dma/mediatek/hsdma-mt7621.c
@@ -733,7 +733,7 @@ err_uninit_hsdma:
 	return ret;
 }
 
-static int mtk_hsdma_remove(struct platform_device *pdev)
+static void mtk_hsdma_remove(struct platform_device *pdev)
 {
 	struct mtk_hsdam_engine *hsdma = platform_get_drvdata(pdev);
 
@@ -741,13 +741,11 @@ static int mtk_hsdma_remove(struct platform_device *pdev)
 
 	of_dma_controller_free(pdev->dev.of_node);
 	dma_async_device_unregister(&hsdma->ddev);
-
-	return 0;
 }
 
 static struct platform_driver mtk_hsdma_driver = {
 	.probe = mtk_hsdma_probe,
-	.remove = mtk_hsdma_remove,
+	.remove_new = mtk_hsdma_remove,
 	.driver = {
 		.name = KBUILD_MODNAME,
 		.of_match_table = mtk_hsdma_of_match,
diff --git a/target/linux/ramips/files/drivers/dma/ralink-gdma.c b/target/linux/ramips/files/drivers/dma/ralink-gdma.c
index e510a05ebb..41220d83dd 100644
--- a/target/linux/ramips/files/drivers/dma/ralink-gdma.c
+++ b/target/linux/ramips/files/drivers/dma/ralink-gdma.c
@@ -890,20 +890,18 @@ err_unregister:
 	return ret;
 }
 
-static int gdma_dma_remove(struct platform_device *pdev)
+static void gdma_dma_remove(struct platform_device *pdev)
 {
 	struct gdma_dma_dev *dma_dev = platform_get_drvdata(pdev);
 
 	tasklet_kill(&dma_dev->task);
 	of_dma_controller_free(pdev->dev.of_node);
 	dma_async_device_unregister(&dma_dev->ddev);
-
-	return 0;
 }
 
 static struct platform_driver gdma_dma_driver = {
 	.probe = gdma_dma_probe,
-	.remove = gdma_dma_remove,
+	.remove_new = gdma_dma_remove,
 	.driver = {
 		.name = "gdma-rt2880",
 		.of_match_table = gdma_of_match_table,
diff --git a/target/linux/ramips/files/drivers/mmc/host/mtk-mmc/sd.c b/target/linux/ramips/files/drivers/mmc/host/mtk-mmc/sd.c
index a9c242bfd3..fc89fa5f8b 100644
--- a/target/linux/ramips/files/drivers/mmc/host/mtk-mmc/sd.c
+++ b/target/linux/ramips/files/drivers/mmc/host/mtk-mmc/sd.c
@@ -2346,7 +2346,7 @@ host_free:
 }
 
 /* 4 device share one driver, using "drvdata" to show difference */
-static int msdc_drv_remove(struct platform_device *pdev)
+static void msdc_drv_remove(struct platform_device *pdev)
 {
 	struct mmc_host *mmc;
 	struct msdc_host *host;
@@ -2371,8 +2371,6 @@ static int msdc_drv_remove(struct platform_device *pdev)
 			  host->dma.bd,  host->dma.bd_addr);
 
 	mmc_free_host(host->mmc);
-
-	return 0;
 }
 
 /* Fix me: Power Flow */
@@ -2412,7 +2410,7 @@ MODULE_DEVICE_TABLE(of, mt7620_sdhci_match);
 
 static struct platform_driver mt_msdc_driver = {
 	.probe   = msdc_drv_probe,
-	.remove  = msdc_drv_remove,
+	.remove_new  = msdc_drv_remove,
 #ifdef CONFIG_PM
 	.suspend = msdc_drv_suspend,
 	.resume  = msdc_drv_resume,
diff --git a/target/linux/ramips/files/drivers/mtd/nand/raw/mt7621_nand.c b/target/linux/ramips/files/drivers/mtd/nand/raw/mt7621_nand.c
index 0ac191ea66..bd071c9ec3 100644
--- a/target/linux/ramips/files/drivers/mtd/nand/raw/mt7621_nand.c
+++ b/target/linux/ramips/files/drivers/mtd/nand/raw/mt7621_nand.c
@@ -1312,7 +1312,7 @@ static int mt7621_nfc_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int mt7621_nfc_remove(struct platform_device *pdev)
+static void mt7621_nfc_remove(struct platform_device *pdev)
 {
 	struct mt7621_nfc *nfc = platform_get_drvdata(pdev);
 	struct nand_chip *nand = &nfc->nand;
@@ -1321,8 +1321,6 @@ static int mt7621_nfc_remove(struct platform_device *pdev)
 	mtk_bmt_detach(mtd);
 	mtd_device_unregister(mtd);
 	nand_cleanup(nand);
-
-	return 0;
 }
 
 static const struct of_device_id mt7621_nfc_id_table[] = {
@@ -1333,7 +1331,7 @@ MODULE_DEVICE_TABLE(of, match);
 
 static struct platform_driver mt7621_nfc_driver = {
 	.probe = mt7621_nfc_probe,
-	.remove = mt7621_nfc_remove,
+	.remove_new = mt7621_nfc_remove,
 	.driver = {
 		.name = MT7621_NFC_NAME,
 		.of_match_table = mt7621_nfc_id_table,
diff --git a/target/linux/ramips/files/drivers/net/ethernet/ralink/esw_rt3050.c b/target/linux/ramips/files/drivers/net/ethernet/ralink/esw_rt3050.c
index bbb52d74b2..9cd6fc456c 100644
--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/esw_rt3050.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/esw_rt3050.c
@@ -19,6 +19,7 @@
 #include <asm/mach-ralink/ralink_regs.h>
 #include <linux/of_device.h>
 #include <linux/of_irq.h>
+#include <linux/of_platform.h>
 
 #include <linux/switch.h>
 #include <linux/reset.h>
@@ -1437,7 +1438,7 @@ static int esw_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int esw_remove(struct platform_device *pdev)
+static void esw_remove(struct platform_device *pdev)
 {
 	struct rt305x_esw *esw = platform_get_drvdata(pdev);
 
@@ -1445,8 +1446,6 @@ static int esw_remove(struct platform_device *pdev)
 		esw_w32(esw, ~0, RT305X_ESW_REG_IMR);
 		platform_set_drvdata(pdev, NULL);
 	}
-
-	return 0;
 }
 
 static const struct of_device_id ralink_esw_match[] = {
@@ -1522,7 +1521,7 @@ int rt3050_esw_init(struct fe_priv *priv)
 
 static struct platform_driver esw_driver = {
 	.probe = esw_probe,
-	.remove = esw_remove,
+	.remove_new = esw_remove,
 	.driver = {
 		.name = "rt3050-esw",
 		.of_match_table = ralink_esw_match,
diff --git a/target/linux/ramips/files/drivers/net/ethernet/ralink/ethtool.c b/target/linux/ramips/files/drivers/net/ethernet/ralink/ethtool.c
index 5d4cebb089..63d904e4bf 100644
--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/ethtool.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/ethtool.c
@@ -13,6 +13,7 @@
  */
 
 #include "mtk_eth_soc.h"
+#include "ethtool.h"
 
 static const char fe_gdma_str[][ETH_GSTRING_LEN] = {
 #define _FE(x...)	# x,
@@ -70,9 +71,9 @@ static void fe_get_drvinfo(struct net_device *dev,
 	struct fe_priv *priv = netdev_priv(dev);
 	struct fe_soc_data *soc = priv->soc;
 
-	strlcpy(info->driver, priv->dev->driver->name, sizeof(info->driver));
-	strlcpy(info->version, MTK_FE_DRV_VERSION, sizeof(info->version));
-	strlcpy(info->bus_info, dev_name(priv->dev), sizeof(info->bus_info));
+	strscpy(info->driver, priv->dev->driver->name, sizeof(info->driver));
+	strscpy(info->version, MTK_FE_DRV_VERSION, sizeof(info->version));
+	strscpy(info->bus_info, dev_name(priv->dev), sizeof(info->bus_info));
 
 	if (soc->reg_table[FE_REG_FE_COUNTER_BASE])
 		info->n_stats = ARRAY_SIZE(fe_gdma_str);
diff --git a/target/linux/ramips/files/drivers/net/ethernet/ralink/gsw_mt7620.c b/target/linux/ramips/files/drivers/net/ethernet/ralink/gsw_mt7620.c
index 154983494e..ad0b2007af 100644
--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/gsw_mt7620.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/gsw_mt7620.c
@@ -19,6 +19,7 @@
 #include <linux/platform_device.h>
 #include <linux/of_device.h>
 #include <linux/of_irq.h>
+#include <linux/of_platform.h>
 
 #include <ralink_regs.h>
 
@@ -284,16 +285,14 @@ static int mt7620_gsw_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int mt7620_gsw_remove(struct platform_device *pdev)
+static void mt7620_gsw_remove(struct platform_device *pdev)
 {
 	platform_set_drvdata(pdev, NULL);
-
-	return 0;
 }
 
 static struct platform_driver gsw_driver = {
 	.probe = mt7620_gsw_probe,
-	.remove = mt7620_gsw_remove,
+	.remove_new = mt7620_gsw_remove,
 	.driver = {
 		.name = "mt7620-gsw",
 		.of_match_table = mediatek_gsw_match,
diff --git a/target/linux/ramips/files/drivers/net/ethernet/ralink/mt7530.c b/target/linux/ramips/files/drivers/net/ethernet/ralink/mt7530.c
index b4632d3990..9d40dfb520 100644
--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/mt7530.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mt7530.c
@@ -31,6 +31,7 @@
 #include <linux/lockdep.h>
 #include <linux/workqueue.h>
 #include <linux/of_device.h>
+#include <linux/of.h>
 #include <asm/byteorder.h>
 
 #include "mt7530.h"
@@ -209,7 +210,7 @@ struct mt7530_mapping {
 	},
 };
 
-struct mt7530_mapping*
+static struct mt7530_mapping*
 mt7530_find_mapping(struct device_node *np)
 {
 	const char *map;
diff --git a/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_eth_soc.c b/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_eth_soc.c
index 4dff1340d7..5a8e92ab12 100644
--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_eth_soc.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_eth_soc.c
@@ -1638,7 +1638,7 @@ static int fe_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int fe_remove(struct platform_device *pdev)
+static void fe_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
 	struct fe_priv *priv = netdev_priv(dev);
@@ -1648,13 +1648,11 @@ static int fe_remove(struct platform_device *pdev)
 	cancel_work_sync(&priv->pending_work);
 
 	platform_set_drvdata(pdev, NULL);
-
-	return 0;
 }
 
 static struct platform_driver fe_driver = {
 	.probe = fe_probe,
-	.remove = fe_remove,
+	.remove_new = fe_remove,
 	.driver = {
 		.name = "mtk_soc_eth",
 		.of_match_table = of_fe_match,
diff --git a/target/linux/ramips/patches-6.6/835-asoc-add-mt7620-support.patch b/target/linux/ramips/patches-6.6/835-asoc-add-mt7620-support.patch
index 4a7ad8f6fa..e53725d435 100644
--- a/target/linux/ramips/patches-6.6/835-asoc-add-mt7620-support.patch
+++ b/target/linux/ramips/patches-6.6/835-asoc-add-mt7620-support.patch
@@ -59,7 +59,7 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +obj-$(CONFIG_SND_RALINK_SOC_I2S) += snd-soc-ralink-i2s.o
 --- /dev/null
 +++ b/sound/soc/ralink/ralink-i2s.c
-@@ -0,0 +1,941 @@
+@@ -0,0 +1,921 @@
 +/*
 + *  Copyright (C) 2010, Lars-Peter Clausen <lars@metafoo.de>
 + *  Copyright (C) 2016 Michael Lee <igvtee@gmail.com>
@@ -200,7 +200,6 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +	struct snd_dmaengine_dai_dma_data capture_dma_data;
 +
 +	struct dentry *dbg_dir;
-+        struct dentry *dbg_stats;
 +	struct ralink_i2s_stats txstats;
 +	struct ralink_i2s_stats rxstats;
 +};
@@ -221,7 +220,7 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +}
 +
 +static int ralink_i2s_set_sysclk(struct snd_soc_dai *dai,
-+                              int clk_id, unsigned int freq, int dir)
++			int clk_id, unsigned int freq, int dir)
 +{
 +	return 0;
 +}
@@ -677,7 +676,7 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +#if IS_ENABLED(CONFIG_DEBUG_FS)
 +static int ralink_i2s_stats_show(struct seq_file *s, void *unused)
 +{
-+        struct ralink_i2s *i2s = s->private;
++	struct ralink_i2s *i2s = s->private;
 +
 +	seq_printf(s, "tx stats\n");
 +	seq_printf(s, "\tbelow threshold\t%u\n", i2s->txstats.belowthres);
@@ -696,37 +695,20 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +	return 0;
 +}
 +
-+static int ralink_i2s_stats_open(struct inode *inode, struct file *file)
++static inline int ralink_i2s_debugfs_create(struct ralink_i2s *i2s)
 +{
-+        return single_open(file, ralink_i2s_stats_show, inode->i_private);
-+}
++	i2s->dbg_dir = debugfs_create_dir(dev_name(i2s->dev), NULL);
++	if (!i2s->dbg_dir)
++		return -ENOMEM;
 +
-+static const struct file_operations ralink_i2s_stats_ops = {
-+        .open = ralink_i2s_stats_open,
-+        .read = seq_read,
-+        .llseek = seq_lseek,
-+        .release = single_release,
-+};
++	debugfs_create_devm_seqfile(i2s->dev, "stats", i2s->dbg_dir,
++				    &ralink_i2s_stats_show);
 +
-+static inline int ralink_i2s_debugfs_create(struct ralink_i2s *i2s)
-+{
-+        i2s->dbg_dir = debugfs_create_dir(dev_name(i2s->dev), NULL);
-+        if (!i2s->dbg_dir)
-+                return -ENOMEM;
-+
-+        i2s->dbg_stats = debugfs_create_file("stats", S_IRUGO,
-+                        i2s->dbg_dir, i2s, &ralink_i2s_stats_ops);
-+        if (!i2s->dbg_stats) {
-+                debugfs_remove(i2s->dbg_dir);
-+                return -ENOMEM;
-+        }
-+
-+        return 0;
++	return 0;
 +}
 +
 +static inline void ralink_i2s_debugfs_remove(struct ralink_i2s *i2s)
 +{
-+	debugfs_remove(i2s->dbg_stats);
 +	debugfs_remove(i2s->dbg_dir);
 +}
 +#else
@@ -912,11 +894,11 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +	if (IS_ERR(i2s->regmap))
 +		return dev_err_probe(dev, PTR_ERR(i2s->regmap), "regmap init failed");
 +
-+        irq = platform_get_irq(pdev, 0);
-+        if (irq < 0) {
-+                dev_err(dev, "failed to get irq\n");
-+                return -EINVAL;
-+        }
++	irq = platform_get_irq(pdev, 0);
++	if (irq < 0) {
++		dev_err(dev, "failed to get irq\n");
++		return -EINVAL;
++	}
 +
 +#if (RALINK_I2S_INT_EN)
 +	ret = devm_request_irq(dev, irq, ralink_i2s_irq,
@@ -978,18 +960,16 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +	return ralink_i2s_debugfs_create(i2s);
 +}
 +
-+static int ralink_i2s_remove(struct platform_device *pdev)
++static void ralink_i2s_remove(struct platform_device *pdev)
 +{
 +	struct ralink_i2s *i2s = platform_get_drvdata(pdev);
 +
 +	ralink_i2s_debugfs_remove(i2s);
-+
-+	return 0;
 +}
 +
 +static struct platform_driver ralink_i2s_driver = {
 +	.probe = ralink_i2s_probe,
-+	.remove = ralink_i2s_remove,
++	.remove_new = ralink_i2s_remove,
 +	.driver = {
 +		.name = DRV_NAME,
 +		.of_match_table = ralink_i2s_match_table,
diff --git a/target/linux/ramips/patches-6.6/845-pwm-add-mediatek-support.patch b/target/linux/ramips/patches-6.6/845-pwm-add-mediatek-support.patch
index e7d11a0429..57e87e978c 100644
--- a/target/linux/ramips/patches-6.6/845-pwm-add-mediatek-support.patch
+++ b/target/linux/ramips/patches-6.6/845-pwm-add-mediatek-support.patch
@@ -41,7 +41,7 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
  obj-$(CONFIG_PWM_MXS)		+= pwm-mxs.o
 --- /dev/null
 +++ b/drivers/pwm/pwm-mediatek-ramips.c
-@@ -0,0 +1,187 @@
+@@ -0,0 +1,185 @@
 +/*
 + * Mediatek Pulse Width Modulator driver
 + *
@@ -197,15 +197,13 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +	return devm_pwmchip_add(&pdev->dev, &pc->chip);
 +}
 +
-+static int mtk_pwm_remove(struct platform_device *pdev)
++static void mtk_pwm_remove(struct platform_device *pdev)
 +{
 +	struct mtk_pwm_chip *pc = platform_get_drvdata(pdev);
 +	int i;
 +
 +	for (i = 0; i < NUM_PWM; i++)
 +		pwm_disable(&pc->chip.pwms[i]);
-+
-+	return 0;
 +}
 +
 +static const struct of_device_id mtk_pwm_of_match[] = {
@@ -221,7 +219,7 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 +		.of_match_table = mtk_pwm_of_match,
 +	},
 +	.probe = mtk_pwm_probe,
-+	.remove = mtk_pwm_remove,
++	.remove_new = mtk_pwm_remove,
 +};
 +
 +module_platform_driver(mtk_pwm_driver);
diff --git a/target/linux/ramips/patches-6.6/860-ramips-add-eip93-driver.patch b/target/linux/ramips/patches-6.6/860-ramips-add-eip93-driver.patch
index de7e37817c..2307b42bde 100644
--- a/target/linux/ramips/patches-6.6/860-ramips-add-eip93-driver.patch
+++ b/target/linux/ramips/patches-6.6/860-ramips-add-eip93-driver.patch
@@ -2256,7 +2256,7 @@
 +#endif /* _EIP93_DES_H_ */
 --- /dev/null
 +++ b/drivers/crypto/mtk-eip93/eip93-main.c
-@@ -0,0 +1,465 @@
+@@ -0,0 +1,463 @@
 +// SPDX-License-Identifier: GPL-2.0
 +/*
 + * Copyright (C) 2019 - 2021
@@ -2689,15 +2689,13 @@
 +	return 0;
 +}
 +
-+static int mtk_crypto_remove(struct platform_device *pdev)
++static void mtk_crypto_remove(struct platform_device *pdev)
 +{
 +	struct mtk_device *mtk = platform_get_drvdata(pdev);
 +
 +	mtk_unregister_algs(ARRAY_SIZE(mtk_algs));
 +	mtk_cleanup(mtk);
 +	dev_info(mtk->dev, "EIP93 removed.\n");
-+
-+	return 0;
 +}
 +
 +#if defined(CONFIG_OF)
@@ -2710,7 +2708,7 @@
 +
 +static struct platform_driver mtk_crypto_driver = {
 +	.probe = mtk_crypto_probe,
-+	.remove = mtk_crypto_remove,
++	.remove_new = mtk_crypto_remove,
 +	.driver = {
 +		.name = "mtk-eip93",
 +		.of_match_table = of_match_ptr(mtk_crypto_of_match),
diff --git a/target/linux/realtek/patches-6.6/720-add-rtl-phy.patch b/target/linux/realtek/patches-6.6/720-add-rtl-phy.patch
index 4d6866db24..c7078cea4e 100644
--- a/target/linux/realtek/patches-6.6/720-add-rtl-phy.patch
+++ b/target/linux/realtek/patches-6.6/720-add-rtl-phy.patch
@@ -14,9 +14,9 @@ Submitted-by: Birger Koblitz <mail@birger-koblitz.de>
 
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -407,6 +407,12 @@ config QSEMI_PHY
+@@ -409,6 +409,12 @@ source "drivers/net/phy/realtek/Kconfig"
  
- source "drivers/net/phy/realtek/Kconfig"
+ source "drivers/net/phy/rtl8261n/Kconfig"
  
 +config REALTEK_SOC_PHY
 +	tristate "Realtek SoC PHYs"
@@ -29,11 +29,11 @@ Submitted-by: Birger Koblitz <mail@birger-koblitz.de>
  	help
 --- a/drivers/net/phy/Makefile
 +++ b/drivers/net/phy/Makefile
-@@ -100,6 +100,7 @@ obj-$(CONFIG_NXP_TJA11XX_PHY)	+= nxp-tja
- obj-y				+= qcom/
+@@ -101,6 +101,7 @@ obj-y				+= qcom/
  obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
  obj-$(CONFIG_REALTEK_PHY)	+= realtek/
-+obj-$(CONFIG_REALTEK_SOC_PHY)   += rtl83xx-phy.o
+ obj-y				+= rtl8261n/
++obj-$(CONFIG_REALTEK_SOC_PHY)	+= rtl83xx-phy.o
  obj-$(CONFIG_RENESAS_PHY)	+= uPD60620.o
  obj-$(CONFIG_ROCKCHIP_PHY)	+= rockchip.o
  obj-$(CONFIG_SMSC_PHY)		+= smsc.o
-- 
2.43.0

